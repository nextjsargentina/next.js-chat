{"docstore/data":{"297d0a46-6d0e-4cde-b627-fd67b85a4102":{"indexId":"297d0a46-6d0e-4cde-b627-fd67b85a4102","nodesDict":{"451ed0c2-cc92-497e-8685-5d8be86213c0":{"id_":"451ed0c2-cc92-497e-8685-5d8be86213c0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Wmd7vsqiqCtKalR1Ik7wgmSdjcectGzyaTHATbzHyd8=","metadata":{},"hash":"8PJsMVr6iA52s9IDBrCMhizfDZGPzRa8MqvWjt6aiAc="}},"hash":"BEgXLAb4a0b+0HWPmCuwcUqfrds2jQZrZ2wS/XZuHKE=","text":"Next.js v14\r\nDocumentation\r\nDate: 2023-12-27","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f7bda12e-734d-4a47-9460-16fd07fbf9d4":{"id_":"f7bda12e-734d-4a47-9460-16fd07fbf9d4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1rckTv0UzPvlYszsGUEawoJKg+FUNHzj9jMmwPnQNy0=","metadata":{},"hash":"wUrBby7tN86bSwRX7b+0Pfd4leOeS8V1o+C4rY0WZDg="}},"hash":"3Tj24J+xx3U4NmD6y9rrGpts+oXElLsaN0LVJMDw/6c=","text":"Table of Contents\r\n1 - Introduction\r\n2 - Getting Started\r\n     2.1 - Installation\r\n     2.2 - Next.js Project Structure\r\n3 - App Router\r\n     3.1 - Building Your Application\r\n          3.1.1 - Routing Fundamentals\r\n               3.1.1.1 - Defining Routes\r\n               3.1.1.2 - Pages and Layouts\r\n               3.1.1.3 - Linking and Navigating\r\n               3.1.1.4 - Route Groups\r\n               3.1.1.5 - Dynamic Routes\r\n               3.1.1.6 - Loading UI and Streaming\r\n               3.1.1.7 - Error Handling\r\n               3.1.1.8 - Parallel Routes\r\n               3.1.1.9 - Intercepting Routes\r\n               3.1.1.10 - Route Handlers\r\n               3.1.1.11 - Middleware\r\n               3.1.1.12 - Project Organization and File Colocation\r\n               3.1.1.13 - Internationalization\r\n          3.1.2 - Data Fetching\r\n               3.1.2.1 - Data Fetching, Caching, and Revalidating\r\n               3.1.2.2 - Server Actions and Mutations\r\n               3.1.2.3 - Patterns and Best Practices\r\n          3.1.3 - Rendering\r\n               3.1.3.1 - Server Components\r\n               3.1.3.2 - Client Components\r\n               3.1.3.3 - Server and Client Composition Patterns\r\n               3.1.3.4 - Edge and Node.js Runtimes\r\n          3.1.4 - Caching in Next.js\r\n          3.1.5 - Styling\r\n               3.1.5.1 - CSS Modules\r\n               3.1.5.2 - Tailwind CSS\r\n               3.1.5.3 - CSS-in-JS\r\n               3.1.5.4 - Sass\r\n          3.1.6 - Optimizations\r\n               3.1.6.1 - Image Optimization\r\n               3.1.6.2 - Font Optimization\r\n               3.1.6.3 - Script Optimization\r\n               3.1.6.4 - Metadata\r\n               3.1.6.5 - Static Assets\r\n               3.1.6.6 - Lazy Loading\r\n               3.1.6.7 - Analytics\r\n               3.1.6.8 - OpenTelemetry\r\n               3.1.6.9 - Instrumentation\r\n               3.1.6.10 - Third Party Libraries\r\n          3.1.7 - Configuring\r\n               3.1.7.1 - TypeScript\r\n               3.1.7.2 - ESLint\r\n               3.1.7.3 - Environment Variables\r\n               3.1.7.4 - Absolute Imports and Module Path Aliases\r\n               3.1.7.5 - Markdown and MDX\r\n               3.1.7.6 - src Directory\r\n               3.1.7.7 - Draft Mode\r\n               3.1.7.8 - Content Security Policy\r\n          3.1.8 - Testing\r\n               3.1.8.1 - Setting up Vitest with Next.js\r\n               3.1.8.2 - Setting up Jest with Next.js\r\n               3.1.8.3 - Setting up Playwright with Next.js\r\n               3.1.8.4 - Setting up Cypress with Next.js\r\n          3.1.9 - Deploying\r\n               3.1.9.1 - Static Exports","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e5b1333b-55b3-415e-8c5d-0fbd5d2ef0f7":{"id_":"e5b1333b-55b3-415e-8c5d-0fbd5d2ef0f7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Oh21k4HKZd8qFy2BQ4WPex8buq+ki3M2A42cOmfWYcw=","metadata":{},"hash":"lqZKV62AFTSUS2mJIgLxysTuhiWxQpcHUCjsdmI7twQ="}},"hash":"a4ePLWBqXqXMIVST9ZbUZ1YLazYqpv4fO7tsR6ZDQEY=","text":"3.1.10 - Upgrade Guide\r\n               3.1.10.1 - Codemods\r\n               3.1.10.2 - App Router Incremental Adoption Guide\r\n               3.1.10.3 - Version 14\r\n               3.1.10.4 - Migrating from Vite\r\n     3.2 - API Reference\r\n          3.2.1 - Components\r\n               3.2.1.1 - Font Module\r\n               3.2.1.2 - <Image>\r\n               3.2.1.3 - <Link>\r\n               3.2.1.4 - <Script>\r\n          3.2.2 - File Conventions\r\n               3.2.2.1 - Metadata Files API Reference\r\n                    3.2.2.1.1 - favicon, icon, and apple-icon\r\n                    3.2.2.1.2 - manifest.json\r\n                    3.2.2.1.3 - opengraph-image and twitter-image\r\n                    3.2.2.1.4 - robots.txt\r\n                    3.2.2.1.5 - sitemap.xml\r\n               3.2.2.2 - default.js\r\n               3.2.2.3 - error.js\r\n               3.2.2.4 - layout.js\r\n               3.2.2.5 - loading.js\r\n               3.2.2.6 - not-found.js\r\n               3.2.2.7 - page.js\r\n               3.2.2.8 - Route Segment Config\r\n               3.2.2.9 - route.js\r\n               3.2.2.10 - template.js\r\n          3.2.3 - Functions\r\n               3.2.3.1 - cookies\r\n               3.2.3.2 - draftMode\r\n               3.2.3.3 - fetch\r\n               3.2.3.4 - generateImageMetadata\r\n               3.2.3.5 - Metadata Object and generateMetadata Options\r\n               3.2.3.6 - generateSitemaps\r\n               3.2.3.7 - generateStaticParams\r\n               3.2.3.8 - generateViewport\r\n               3.2.3.9 - headers\r\n               3.2.3.10 - ImageResponse\r\n               3.2.3.11 - NextRequest\r\n               3.2.3.12 - NextResponse\r\n               3.2.3.13 - notFound\r\n               3.2.3.14 - permanentRedirect\r\n               3.2.3.15 - redirect\r\n               3.2.3.16 - revalidatePath\r\n               3.2.3.17 - revalidateTag\r\n               3.2.3.18 - unstable_cache\r\n               3.2.3.19 - unstable_noStore\r\n               3.2.3.20 - useParams\r\n               3.2.3.21 - usePathname\r\n               3.2.3.22 - useReportWebVitals\r\n               3.2.3.23 - useRouter\r\n               3.2.3.24 - useSearchParams\r\n               3.2.3.25 - useSelectedLayoutSegment\r\n               3.2.3.26 - useSelectedLayoutSegments\r\n               3.2.3.27 - userAgent\r\n          3.2.4 - next.config.js Options\r\n               3.2.4.1 - appDir\r\n               3.2.4.2 - assetPrefix\r\n               3.2.4.3 - basePath\r\n               3.2.4.4 - compress\r\n               3.2.4.5 - devIndicators\r\n               3.2.4.6 - distDir\r\n               3.2.4.7 - env\r\n               3.2.4.8 - eslint\r\n               3.2.4.9 - exportPathMap (Deprecated)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"af9893af-20c2-4c1f-9605-e720e36e08d5":{"id_":"af9893af-20c2-4c1f-9605-e720e36e08d5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ojyg9K1ufQwvvx0wKImzaRQl3QtR7PlRO5nOQDtmN8U=","metadata":{},"hash":"+EK2GAU1E0BUMTKdOEhwT9cj4IvVk7qwzIKvpOr6TjQ="}},"hash":"o2OtcbrOwJ2TLFAFjAN1+3iDfHX6U4z41iW0iPmsZjQ=","text":"3.2.4.10 - generateBuildId\r\n               3.2.4.11 - generateEtags\r\n               3.2.4.12 - headers\r\n               3.2.4.13 - httpAgentOptions\r\n               3.2.4.14 - images\r\n               3.2.4.15 - incrementalCacheHandlerPath\r\n               3.2.4.16 - logging\r\n               3.2.4.17 - mdxRs\r\n               3.2.4.18 - onDemandEntries\r\n               3.2.4.19 - optimizePackageImports\r\n               3.2.4.20 - output\r\n               3.2.4.21 - pageExtensions\r\n               3.2.4.22 - Partial Prerendering (experimental)\r\n               3.2.4.23 - poweredByHeader\r\n               3.2.4.24 - productionBrowserSourceMaps\r\n               3.2.4.25 - reactStrictMode\r\n               3.2.4.26 - redirects\r\n               3.2.4.27 - rewrites\r\n               3.2.4.28 - serverActions\r\n               3.2.4.29 - serverComponentsExternalPackages\r\n               3.2.4.30 - trailingSlash\r\n               3.2.4.31 - transpilePackages\r\n               3.2.4.32 - turbo (Experimental)\r\n               3.2.4.33 - typedRoutes (experimental)\r\n               3.2.4.34 - typescript\r\n               3.2.4.35 - urlImports\r\n               3.2.4.36 - webVitalsAttribution\r\n               3.2.4.37 - Custom Webpack Config\r\n          3.2.5 - create-next-app\r\n          3.2.6 - Edge Runtime\r\n          3.2.7 - Next.js CLI\r\n4 - Pages Router\r\n     4.1 - Building Your Application\r\n          4.1.1 - Routing\r\n               4.1.1.1 - Pages and Layouts\r\n               4.1.1.2 - Dynamic Routes\r\n               4.1.1.3 - Linking and Navigating\r\n               4.1.1.4 - Custom App\r\n               4.1.1.5 - Custom Document\r\n               4.1.1.6 - Custom Errors\r\n               4.1.1.7 - API Routes\r\n               4.1.1.8 - Internationalization (i18n) Routing\r\n               4.1.1.9 - Authenticating\r\n               4.1.1.10 - Middleware\r\n          4.1.2 - Rendering\r\n               4.1.2.1 - Server-side Rendering (SSR)\r\n               4.1.2.2 - Static Site Generation (SSG)\r\n               4.1.2.3 - Automatic Static Optimization\r\n               4.1.2.4 - Client-side Rendering (CSR)\r\n               4.1.2.5 - Edge and Node.js Runtimes\r\n          4.1.3 - Data Fetching\r\n               4.1.3.1 - getStaticProps\r\n               4.1.3.2 - getStaticPaths\r\n               4.1.3.3 - Forms and Mutations\r\n               4.1.3.4 - getServerSideProps\r\n               4.1.3.5 - Incremental Static Regeneration\r\n               4.1.3.6 - Client-side Fetching\r\n          4.1.4 - Styling\r\n               4.1.4.1 - CSS Modules\r\n               4.1.4.2 - Tailwind CSS\r\n               4.1.4.3 - CSS-in-JS\r\n               4.1.4.4 - Sass\r\n          4.1.5 - Optimizations\r\n               4.1.5.1 - Image Optimization\r\n               4.1.5.2 - Font Optimization","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"156c7fba-d6d7-4dd0-94cb-d61dac637cce":{"id_":"156c7fba-d6d7-4dd0-94cb-d61dac637cce","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aLSaue0ogrYGquYjFZL9LvpCAVGhdWp5NBGCK6WcW+Y=","metadata":{},"hash":"KnqW1HxmFUq/yzpkLOCCKpSIZA96Et/gMZFI6Cjwiqs="}},"hash":"WF/jXU3podQ+mpUWOkLAvmWRYm/e3H6U180hveUH5OQ=","text":"4.1.5.3 - Script Optimization\r\n               4.1.5.4 - Static Assets\r\n               4.1.5.5 - Lazy Loading\r\n               4.1.5.6 - Analytics\r\n               4.1.5.7 - OpenTelemetry\r\n               4.1.5.8 - Instrumentation\r\n               4.1.5.9 - Third Party Libraries\r\n          4.1.6 - Configuring\r\n               4.1.6.1 - TypeScript\r\n               4.1.6.2 - ESLint\r\n               4.1.6.3 - Environment Variables\r\n               4.1.6.4 - Absolute Imports and Module Path Aliases\r\n               4.1.6.5 - src Directory\r\n               4.1.6.6 - Markdown and MDX\r\n               4.1.6.7 - AMP\r\n               4.1.6.8 - Babel\r\n               4.1.6.9 - PostCSS\r\n               4.1.6.10 - Custom Server\r\n               4.1.6.11 - Draft Mode\r\n               4.1.6.12 - Error Handling\r\n               4.1.6.13 - Debugging\r\n               4.1.6.14 - Preview Mode\r\n               4.1.6.15 - Content Security Policy\r\n          4.1.7 - Testing\r\n               4.1.7.1 - Setting up Vitest with Next.js\r\n               4.1.7.2 - Setting up Jest with Next.js\r\n               4.1.7.3 - Setting up Playwright with Next.js\r\n               4.1.7.4 - Setting up Cypress with Next.js\r\n          4.1.8 - Deploying\r\n               4.1.8.1 - Going to Production\r\n               4.1.8.2 - Static Exports\r\n               4.1.8.3 - Multi Zones\r\n               4.1.8.4 - Continuous Integration (CI) Build Caching\r\n          4.1.9 - Upgrading\r\n               4.1.9.1 - Codemods\r\n               4.1.9.2 - From Pages to App\r\n               4.1.9.3 - Version 14\r\n               4.1.9.4 - Version 13\r\n               4.1.9.5 - Version 12\r\n               4.1.9.6 - Version 11\r\n               4.1.9.7 - Version 10\r\n               4.1.9.8 - Upgrading to Version 9\r\n     4.2 - API Reference\r\n          4.2.1 - Components\r\n               4.2.1.1 - Font Module\r\n               4.2.1.2 - <Head>\r\n               4.2.1.3 - <Image> (Legacy)\r\n               4.2.1.4 - <Image>\r\n               4.2.1.5 - <Link>\r\n               4.2.1.6 - <Script>\r\n          4.2.2 - Functions\r\n               4.2.2.1 - getInitialProps\r\n               4.2.2.2 - getServerSideProps\r\n               4.2.2.3 - getStaticPaths\r\n               4.2.2.4 - getStaticProps\r\n               4.2.2.5 - NextRequest\r\n               4.2.2.6 - NextResponse\r\n               4.2.2.7 - useAmp\r\n               4.2.2.8 - useReportWebVitals\r\n               4.2.2.9 - useRouter\r\n               4.2.2.10 - userAgent\r\n          4.2.3 - next.config.js Options\r\n               4.2.3.1 - assetPrefix\r\n               4.2.3.2 - basePath\r\n               4.2.3.3 - compress","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6a985e30-8418-4e36-b8c5-641931360e26":{"id_":"6a985e30-8418-4e36-b8c5-641931360e26","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cPMvKC8vmMnvbcMeAdPH6SPFc/1/KKxNED4jt2PGX1E=","metadata":{},"hash":"NrX78PsIwdaPcEaR/5SLYwjWTKNlmQnbWF6rMJE+Vqw="}},"hash":"QUQw/rJyEULCh3rAp6QD/YutCcvPgjwWp+WEd2vX/hA=","text":"4.2.3.4 - devIndicators\r\n               4.2.3.5 - distDir\r\n               4.2.3.6 - env\r\n               4.2.3.7 - eslint\r\n               4.2.3.8 - exportPathMap\r\n               4.2.3.9 - generateBuildId\r\n               4.2.3.10 - generateEtags\r\n               4.2.3.11 - headers\r\n               4.2.3.12 - httpAgentOptions\r\n               4.2.3.13 - images\r\n               4.2.3.14 - onDemandEntries\r\n               4.2.3.15 - output\r\n               4.2.3.16 - pageExtensions\r\n               4.2.3.17 - poweredByHeader\r\n               4.2.3.18 - productionBrowserSourceMaps\r\n               4.2.3.19 - reactStrictMode\r\n               4.2.3.20 - redirects\r\n               4.2.3.21 - rewrites\r\n               4.2.3.22 - Runtime Config\r\n               4.2.3.23 - trailingSlash\r\n               4.2.3.24 - transpilePackages\r\n               4.2.3.25 - turbo (experimental)\r\n               4.2.3.26 - typescript\r\n               4.2.3.27 - urlImports\r\n               4.2.3.28 - webVitalsAttribution\r\n               4.2.3.29 - Custom Webpack Config\r\n          4.2.4 - create-next-app\r\n          4.2.5 - Next.js CLI\r\n          4.2.6 - Edge Runtime\r\n5 - Architecture\r\n     5.1 - Accessibility\r\n     5.2 - Fast Refresh\r\n     5.3 - Next.js Compiler\r\n     5.4 - Supported Browsers\r\n     5.5 - Turbopack\r\n6 - Next.js Community\r\n     6.1 - Docs Contribution Guide","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"faddf8e1-e62c-4549-a22e-bc0afc7c4b1d":{"id_":"faddf8e1-e62c-4549-a22e-bc0afc7c4b1d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dpykyN1KGwxvnMiQYtpSZY+iS+Bv1m/Nxn+Zq1rnFaA=","metadata":{},"hash":"RILWalrwPOguyEQYuzpMUlClXvvLFNApYcDkZgXyCAU="},"NEXT":{"nodeId":"0331de49-6540-4cc7-943c-ba6f6fae3858","metadata":{},"hash":"lFQA0pf4lIQG3Rn/8pubhwQ7SGgHhVExFdf0LNJv5gw="}},"hash":"g37i9OTheuB87dq7lJRqaiZfX607OuvPsZtOYzoWTeQ=","text":"1 - Introduction\r\nDocumentation path: /index\r\nDescription: Welcome to the Next.js Documentation. Welcome to the Next.js documentation! What is Next.js? Next.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js\r\nfor additional features and optimizations. Under the hood, Next.js also abstracts and automatically configures tooling needed for React, like bundling, compiling, and more. This\r\nallows you to focus on building your application instead of spending time with configuration. Whether you’re an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React\r\napplications. Main Features\r\nSome of the main Next.js features include:\r\nFeatureDescription\r\nRoutingA file-system based router built on top of Server Components that supports layouts, nested routing, loading states,error handling, and more. RenderingClient-side and Server-side Rendering with Client and Server Components. Further optimized with Static and DynamicRendering on the server with Next.js. Streaming on Edge and Node.js runtimes. Data FetchingSimplified data fetching with async/await in Server Components, and an extended \r\nfetch API for request\r\nmemoization, data caching and revalidation. StylingSupport for your preferred styling methods, including CSS Modules, Tailwind CSS, and CSS-in-JS\r\nOptimizationsImage, Fonts, and Script Optimizations to improve your application’s Core Web Vitals and User Experience. TypeScriptImproved support for TypeScript, with better type checking and more efficient compilation, as well as customTypeScript Plugin and type checker. How to Use These Docs\r\nOn the left side of the screen, you’ll find the docs navbar. The pages of the docs are organized sequentially, from basic to advanced, so\r\nyou can follow them step-by-step when building your application. However, you can read them in any order or skip to the pages that\r\napply to your use case. On the right side of the screen, you’ll see a table of contents that makes it easier to navigate between sections of a page. If you need to\r\nquickly find a page, you can use the search bar at the top, or the search shortcut (Ctrl+K or Cmd+K). To get started, checkout the Installation guide. App Router vs Pages Router\r\nNext.js has two different routers: the App Router and the Pages Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0331de49-6540-4cc7-943c-ba6f6fae3858":{"id_":"0331de49-6540-4cc7-943c-ba6f6fae3858","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dpykyN1KGwxvnMiQYtpSZY+iS+Bv1m/Nxn+Zq1rnFaA=","metadata":{},"hash":"RILWalrwPOguyEQYuzpMUlClXvvLFNApYcDkZgXyCAU="},"PREVIOUS":{"nodeId":"faddf8e1-e62c-4549-a22e-bc0afc7c4b1d","metadata":{},"hash":"g37i9OTheuB87dq7lJRqaiZfX607OuvPsZtOYzoWTeQ="}},"hash":"lFQA0pf4lIQG3Rn/8pubhwQ7SGgHhVExFdf0LNJv5gw=","text":"The App Router is a newer router that allows you to use React’s\r\nlatest features, such as Server Components and Streaming. The Pages Router is the original Next.js router, which allowed you to build\r\nserver-rendered React applications and continues to be supported for older Next.js applications. At the top of the sidebar, you’ll notice a dropdown menu that allows you to switch between the App Router and the Pages Router\r\nfeatures. Since there are features that are unique to each directory, it’s important to keep track of which tab is selected. The breadcrumbs at the top of the page will also indicate whether you’re viewing App Router docs or Pages Router docs. Pre-Requisite Knowledge\r\nAlthough our docs are designed to be beginner-friendly, we need to establish a baseline so that the docs can stay focused on Next.js\r\nfunctionality. We’ll make sure to provide links to relevant documentation whenever we introduce a new concept. To get the most out of our docs, it’s recommended that you have a basic understanding of HTML, CSS, and React. If you need to brush\r\nup on your React skills, check out our React Foundations Course, which will introduce you to the fundamentals. Then, learn more about","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ce6b4e21-3b1f-496f-81d7-0d1e988ac21c":{"id_":"ce6b4e21-3b1f-496f-81d7-0d1e988ac21c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MTe7gvIzuR5Tq8vJXgxrjZ3wKhLTgQFDssLRNQ4SPoQ=","metadata":{},"hash":"vV/mmSKW9wQ0CjR/iLmxOgA9MjsWT6r1ftUSA9e/fKY="}},"hash":"ZKfVqA40pgCYMm3e4Khkjno7ySqzJHzYW0gOWX1IUmA=","text":"Next.js by building a dashboard application. Accessibility\r\nFor optimal accessibility when using a screen reader while reading the docs, we recommend using Firefox and NVDA, or Safari and\r\nVoiceOver. Join our Community\r\nIf you have questions about anything related to Next.js, you’re always welcome to ask our community on GitHub Discussions, Discord,\r\nTwitter, and Reddit.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"45442648-49de-44a0-9719-55b18821a7ca":{"id_":"45442648-49de-44a0-9719-55b18821a7ca","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ER0LbogzOwoPcT5F6pxwhnQ+c/h7v0YZnhNXEZa+pjg=","metadata":{},"hash":"l5ezNyDJqR+BvTHZHWiWgUi2sojyZ25KIx881hEqryY="}},"hash":"XgbW+yBJNSNVEFMWIoE2oMpZ0w1Sgf0fTu04rFKt+bQ=","text":"2 - Getting Started\r\nDocumentation path: /01-getting-started/index\r\nDescription: Learn how to create full-stack web applications with Next.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"15138a80-f6eb-44e1-9f4a-b8125b47b887":{"id_":"15138a80-f6eb-44e1-9f4a-b8125b47b887","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"VPMVsf+G8SvqAvoo5TauP7I5wUsUk/vvj+jIk00Bz7o=","metadata":{},"hash":"NP3lyu5YGmQxTZNaT8zs3VzPsDC8H+vafsw96Tw40nc="}},"hash":"Yhkj4u+Uks0C0oRo37xIFrkC0vbz4a4vwspeyRsVJY8=","text":"2.1 - Installation\r\nDocumentation path: /01-getting-started/01-installation\r\nDescription: Create a new Next.js application with `create-next-app`. Set up TypeScript, styles, and configure your `next.config.js` file. Related:\r\nTitle: Next Steps\r\nRelated Description: Learn about the files and folders in your Next.js project. Links:\r\ngetting-started/project-structure\r\nSystem Requirements:\r\nNode.js 18.17 or later. macOS, Windows (including WSL), and Linux are supported. Automatic Installation\r\nWe recommend starting a new Next.js app using create-next-app, which sets up everything automatically for you. To create a\r\nproject, run:\r\nTerminal (bash)npx create-next-app@latest\r\nOn installation, you’ll see the following prompts:\r\nTerminal (txt)What is your project named? my-app\r\nWould you like to use TypeScript? No / Yes\r\nWould you like to use ESLint? No / Yes\r\nWould you like to use Tailwind CSS? No / Yes\r\nWould you like to use `src/` directory? No / Yes\r\nWould you like to use App Router? (recommended) No / Yes\r\nWould you like to customize the default import alias (@/*)? No / Yes\r\nWhat import alias would you like configured? @/*\r\nAfter the prompts, create-next-app will create a folder with your project name and install the required dependencies. Good to know:\r\nNext.js now ships with TypeScript, ESLint, and Tailwind CSS configuration by default. You can optionally use a src directory in the root of your project to separate your application’s code from configuration\r\nfiles. Manual Installation\r\nTo manually create a new Next.js app, install the required packages:\r\nTerminal (bash)npm install next@latest react@latest react-dom@latest\r\nOpen your package.json file and add the following scripts:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"next lint\"\r\n  }\r\n}\r\nThese scripts refer to the different stages of developing an application:\r\ndev: runs next dev to start Next.js in development mode. build: runs next build to build the application for production usage.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"165df495-af2b-4a94-acd3-446a64f0d68c":{"id_":"165df495-af2b-4a94-acd3-446a64f0d68c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pbrfnK5GH+6nrgVEt5hyRcT8bJYSqbA9Xscuhrl2/oo=","metadata":{},"hash":"TnfcM1uD2JSG1m8SEeZY7jvsr17aAphkg/81m+BZ8z0="}},"hash":"aK3JrDzH1uv3qQnuG5xBiMZPhNt/DMSSKTiOgU9G79Y=","text":"start: runs next start to start a Next.js production server. lint: runs next lint to set up Next.js’ built-in ESLint configuration. Creating directories\r\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files. The appapp directory\r\nFor new applications, we recommend using the App Router. This router allows you to use React’s latest features and is an evolution of\r\nthe Pages Router based on community feedback. Create an app/ folder, then add a layout.tsx and page.tsx file. These will be rendered when the user visits the root of your\r\napplication (/). Create a root layout inside app/layout.tsx with the required <html> and <body> tags:\r\napp/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nFinally, create a home page app/page.tsx with some initial content:\r\napp/page.tsx (tsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\napp/page.js (jsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\nGood to know: If you forget to create layout.tsx, Next.js will automatically create this file when running the development\r\nserver with next dev. Learn more about using the App Router. The pagespages directory (optional)\r\nIf you prefer to use the Pages Router instead of the App Router, you can create a pages/ directory at the root of your project. Then, add an index.tsx file inside your pages folder. This will be your home page (/):","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"923e8d9a-3a02-49d4-b805-9927a8a671b1":{"id_":"923e8d9a-3a02-49d4-b805-9927a8a671b1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mMLge29xy5t4kK7JyTrPbyD4N7pnDJe607PJAymV38Q=","metadata":{},"hash":"yztXnlj9FVvC1TckVrvxP8JTlxzYvipiAi1OwrZSAgc="}},"hash":"TT6O5emU+7jmkCmuZJ2ptIqFcahXdkYahhzZm1aTd5c=","text":"pages/index.tsx (tsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\nNext, add an _app.tsx file inside pages/ to define the global layout. Learn more about the custom App file. pages/_app.tsx (tsx)import type { AppProps } from 'next/app'\r\nexport default function App({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}\r\npages/_app.js (jsx)export default function App({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}\r\nFinally, add a _document.tsx file inside pages/ to control the initial response from the server. Learn more about the custom\r\nDocument file. pages/_document.tsx (tsx)import { Html, Head, Main, NextScript } from 'next/document'\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}\r\nLearn more about using the Pages Router. Good to know: Although you can use both routers in the same project, routes in app will be prioritized over pages. We\r\nrecommend using only one router in your new project to avoid confusion. The publicpublic folder (optional)\r\nCreate a public folder to store static assets such as images, fonts, etc. Files inside public directory can then be referenced by your\r\ncode starting from the base URL (/). Run the Development Server\r\n1. Run npm run dev to start the development server. 2. Visit http://localhost:3000 to view your application. 3. Edit app/page.tsx (or pages/index.tsx) file and save it to see the updated result in your browser.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2702ca00-b3e1-49bd-b80e-fe708c8466e5":{"id_":"2702ca00-b3e1-49bd-b80e-fe708c8466e5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"en7CLu8CchfSw2zweaoo3+o0ZbMz7X6eB5i3w8S0pg0=","metadata":{},"hash":"0Iu1f+5UB61Hfv0/XvhRNhZgVtaGMVsDdvlhBNLk8gE="}},"hash":"Yy5IoMVU+R7kXrouMHyG5naGB3J3LMtCo4zfnqk1L18=","text":"2.2 - Next.js Project Structure\r\nDocumentation path: /01-getting-started/02-project-structure\r\nDescription: A list of folders and files conventions in a Next.js project\r\nThis page provides an overview of the file and folder structure of a Next.js project. It covers top-level files and folders, configuration\r\nfiles, and routing conventions within the app and pages directories. Top-level folders\r\nappApp Router\r\npagesPages Router\r\npublicStatic assets to be served\r\nsrcOptional application source folder\r\nTop-level files\r\nNext.js\r\nnext.config.jsConfiguration file for Next.js\r\npackage.jsonProject dependencies and scripts\r\ninstrumentation.tsOpenTelemetry and Instrumentation file\r\nmiddleware.tsNext.js request middleware\r\n.envEnvironment variables\r\n.env.localLocal environment variables\r\n.env.productionProduction environment variables\r\n.env.developmentDevelopment environment variables\r\n.eslintrc.jsonConfiguration file for ESLint\r\n.gitignoreGit files and folders to ignore\r\nnext-env.d.tsTypeScript declaration file for Next.js\r\ntsconfig.jsonConfiguration file for TypeScript\r\njsconfig.jsonConfiguration file for JavaScript\r\nappapp Routing Conventions\r\nRouting Files\r\nlayout.js .jsx .tsxLayout\r\npage.js .jsx .tsxPage\r\nloading.js .jsx .tsxLoading UI\r\nnot-found.js .jsx .tsxNot found UI\r\nerror.js .jsx .tsxError UI\r\nglobal-error.js .jsx .tsxGlobal error UI\r\nroute.js .tsAPI endpoint","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b1c84cc-f685-4515-aa2b-96f4472f9a01":{"id_":"7b1c84cc-f685-4515-aa2b-96f4472f9a01","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"K+HEFA/MEjOyQqqJH9vQcjHBpzaZBah9MDmw5ALyg0c=","metadata":{},"hash":"xflfQydiwF30bgoc6YwafA3MRSK9wkLJ2Fdk8ZGMQ9A="}},"hash":"ZPihzzL4mXz2FxAAoxwYG22/D/4CRzkIbN02v+YWNWs=","text":"template.js .jsx .tsxRe-rendered layout\r\ndefault.js .jsx .tsxParallel route fallback page\r\nNested Routes\r\nfolderRoute segment\r\nfolder/folderNested route segment\r\nDynamic Routes\r\n[folder]Dynamic route segment\r\n[...folder]Catch-all route segment\r\n[[...folder]]Optional catch-all route segment\r\nRoute Groups and Private Folders\r\n(folder)Group routes without affecting routing\r\n_folderOpt folder and all child segments out of routing\r\nParallel and Intercepted Routes\r\n@folderNamed slot\r\n(.)folderIntercept same level\r\n(..)folderIntercept one level above\r\n(..)(..)folderIntercept two levels above\r\n(...)folderIntercept from root\r\nMetadata File Conventions\r\nApp Icons\r\nfavicon.icoFavicon file\r\nicon.ico .jpg .jpeg .png .svgApp Icon file\r\nicon.js .ts .tsxGenerated App Icon\r\napple-icon.jpg .jpeg, .pngApple App Icon file\r\napple-icon.js .ts .tsxGenerated Apple App Icon\r\nOpen Graph and Twitter Images\r\nopengraph-image.jpg .jpeg .png .gifOpen Graph image file\r\nopengraph-image.js .ts .tsxGenerated Open Graph image\r\ntwitter-image.jpg .jpeg .png .gifTwitter image file","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"883b54ee-de4d-4de4-9ef1-3132260ff0fa":{"id_":"883b54ee-de4d-4de4-9ef1-3132260ff0fa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DDsfEdTWhjVZOsmEXwRimCnq2CE3b4YTS8vlqRqu/BQ=","metadata":{},"hash":"xe8ea1fOM3V0HeHX8jCEb5nVi8rRSn94kXOpRzOd0Fk="}},"hash":"MfMwOHdFL6V02BzwUbcrJH6P8F8o4j7f1MD7ZnQvv5g=","text":"twitter-image.js .ts .tsxGenerated Twitter image\r\nSEO\r\nsitemap.xmlSitemap file\r\nsitemap.js .tsGenerated Sitemap\r\nrobots.txtRobots file\r\nrobots.js .tsGenerated Robots file\r\npagespages Routing Conventions\r\nSpecial Files\r\n_app.js .jsx .tsxCustom App\r\n_document.js .jsx .tsxCustom Document\r\n_error.js .jsx .tsxCustom Error Page\r\n404.js .jsx .tsx404 Error Page\r\n500.js .jsx .tsx500 Error Page\r\nRoutes\r\nFolder convention\r\nindex.js .jsx .tsxHome page\r\nfolder/index.js .jsx .tsxNested page\r\nFile convention\r\nindex.js .jsx .tsxHome page\r\nfile.js .jsx .tsxNested page\r\nDynamic Routes\r\nFolder convention\r\n[folder]/index.js .jsx .tsxDynamic route segment\r\n[...folder]/index.js .jsx .tsxCatch-all route segment\r\n[[...folder]]/index.js .jsx .tsxOptional catch-all route segment\r\nFile convention\r\n[file].js .jsx .tsxDynamic route segment\r\n[...file].js .jsx .tsxCatch-all route segment\r\n[[...file]].js .jsx .tsxOptional catch-all route segment","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9822ddec-8c88-4125-93a8-5cb0a2596f9b":{"id_":"9822ddec-8c88-4125-93a8-5cb0a2596f9b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c4oA7ZGt3gRQHt6bK/y/c4/dEWXMD6QLwLwsFqiuVo0=","metadata":{},"hash":"EspFedfGpkovNVmgP33KKSFo1JWOzESCrqQLvcdAOpw="},"NEXT":{"nodeId":"52e347f3-6ca0-4cdc-aa3d-2c731c0e97ee","metadata":{},"hash":"JwRT1ZRjxo4m4eqlkz4y1OXl5rCXl5s/5UQRWdZaVnI="}},"hash":"dcfYDM/gYL6S+eHle2Upf8z/1liYHoG9J9Pncz/ByG4=","text":"3 - App Router\r\nDocumentation path: /02-app/index\r\nDescription: Use the new App Router with Next.js' and React's latest features, including Layouts, Server Components, Suspense, and\r\nmore. The Next.js App Router is a new paradigm for building applications using React’s latest features. If you’re already familiar with Next.js,\r\nyou’ll find that the App Router is a natural evolution of the existing file-system based router in the Pages Router. For new applications, we recommend using the App Router. For existing applications, you can incrementally adopt the App Router. It’s also possible to use both routers in the same application. Frequently Asked Questions\r\nHow can I access the request object in a layout? You intentionally cannot access the raw request object. However, you can access headers and cookies through server-only functions. You can also set cookies. Layouts do not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By\r\nrestricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within\r\nthe layout, which could negatively impact performance. This design also enforces consistent and predictable behavior for layouts across different pages, which simplifies development and\r\ndebugging. Depending on the UI pattern you’re building, Parallel Routes allow you to render multiple pages in the same layout, and pages have\r\naccess to the route segments as well as the URL search params. How can I access the URL on a page? By default, pages are Server Components. You can access the route segments through the params prop and the URL search params\r\nthrough the searchParams prop for a given page. If you are using Client Components, you can use usePathname, useSelectedLayoutSegment, and useSelectedLayoutSegments for\r\nmore complex routes. Further, depending on the UI pattern you’re building, Parallel Routes allow you to render multiple pages in the same layout, and pages\r\nhave access to the route segments as well as the URL search params. How can I redirect from a Server Component? You can use redirect to redirect from a page to a relative or absolute URL. redirect is a temporary (307) redirect, while\r\npermanentRedirect is a permanent (308) redirect. When these functions are used while streaming UI, they will insert a meta tag to\r\nemit the redirect on the client side.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"52e347f3-6ca0-4cdc-aa3d-2c731c0e97ee":{"id_":"52e347f3-6ca0-4cdc-aa3d-2c731c0e97ee","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c4oA7ZGt3gRQHt6bK/y/c4/dEWXMD6QLwLwsFqiuVo0=","metadata":{},"hash":"EspFedfGpkovNVmgP33KKSFo1JWOzESCrqQLvcdAOpw="},"PREVIOUS":{"nodeId":"9822ddec-8c88-4125-93a8-5cb0a2596f9b","metadata":{},"hash":"dcfYDM/gYL6S+eHle2Upf8z/1liYHoG9J9Pncz/ByG4="}},"hash":"JwRT1ZRjxo4m4eqlkz4y1OXl5rCXl5s/5UQRWdZaVnI=","text":"How can I handle authentication with the App Router? Here are some common authentication solutions that support the App Router:\r\nNextAuth.js\r\nClerk\r\nAuth0\r\nStytch\r\nKinde\r\nOr manually handling sessions or JWTs\r\nHow can I set cookies? You can set cookies in Server Actions or Route Handlers using the cookies function. Since HTTP does not allow setting cookies after streaming starts, you cannot set cookies from a page or layout directly. You can also set\r\ncookies from Middleware. How can I build multi-tenant apps? If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our\r\nrecommended architecture.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"edcbfec9-aae4-47f5-8a64-874068e67f49":{"id_":"edcbfec9-aae4-47f5-8a64-874068e67f49","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"m3YHqq9jhXPRIS8MuNfLVx+zB9nfig2FvHUsU56l1Dc=","metadata":{},"hash":"UsY7HYbs+b3fixo/tclryXCgbD14Icsdersv4qC8PFg="}},"hash":"FnXXsmL1kUQe7bXCBRG9IrPQeIa8j4kFiq9TTJLUdIc=","text":"How can I invalidate the App Router cache? There are multiple layers of caching in Next.js, and thus, multiple ways to invalidate different parts of the cache. Learn more about\r\ncaching. Are there any comprehensive, open-source applications built on the App Router? Yes. You can view Next.js Commerce or the Platforms Starter Kit for two larger examples of using the App Router that are open-source. Learn More\r\nRouting Fundamentals\r\nData Fetching, Caching, and Revalidating\r\nForms and Mutations\r\nCaching\r\nRendering Fundamentals\r\nServer Components\r\nClient Components","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f5f4142c-65d8-49e4-a1cd-f5b95adf06e4":{"id_":"f5f4142c-65d8-49e4-a1cd-f5b95adf06e4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ITFt5E8wIbdhYqvwBoYvt2xzkiEWf530GSITx5iE8DA=","metadata":{},"hash":"a5QM2vFLVb/mqZ8bCF3HR8NGPKH/ez/emKKLruEwrP0="}},"hash":"WECU3m7kfQ+PlPoxT+1Gd/E2b6BFg3jaj9w1PSAkmqM=","text":"3.1 - Building Your Application\r\nDocumentation path: /02-app/01-building-your-application/index\r\nDescription: Learn how to use Next.js features to build your application. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js provides the building blocks to create flexible, full-stack web applications. The guides in Building Your Application explain\r\nhow to use these features and how to customize your application’s behavior. The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your\r\nNext.js application. However, you can read them in any order or skip to the pages that apply to your use case. If you’re new to Next.js, we recommend starting with the Routing, Rendering, Data Fetching and Styling sections, as they introduce the\r\nfundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such as Optimizing\r\nand Configuring. Finally, once you’re ready, checkout the Deploying and Upgrading sections. If you’re new to Next.js, we recommend starting with the Routing, Rendering, Data Fetching and Styling sections, as they introduce the\r\nfundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such as Optimizing\r\nand Configuring. Finally, once you’re ready, checkout the Deploying and Upgrading sections.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8bdf737a-8c5c-448e-a8aa-3093ca98c4ca":{"id_":"8bdf737a-8c5c-448e-a8aa-3093ca98c4ca","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wnhjCdFQTWvUyVmQdgTof5dKH60vP7IY2zOZJNnE1Gw=","metadata":{},"hash":"YMD2d06G9bz9/dXaFby0K+GuiRUy4Ve3bMFPfSKA2gM="}},"hash":"lBYJl5nojEcrDIORHV8ooycCeCa1D6mRob/26JYDGfE=","text":"3.1.1 - Routing Fundamentals\r\nDocumentation path: /02-app/01-building-your-application/01-routing/index\r\nDescription: Learn the fundamentals of routing for front-end applications. The skeleton of every application is routing. This page will introduce you to the fundamental concepts of routing for the web and how\r\nto handle routing in Next.js. Terminology\r\nFirst, you will see these terms being used throughout the documentation. Here’s a quick reference:\r\nTree: A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a\r\nfolder structure, etc. Subtree: Part of a tree, starting at a new root (first) and ending at the leaves (last). Root: The first node in a tree or subtree, such as a root layout. Leaf: Nodes in a subtree that have no children, such as the last segment in a URL path. URL Segment: Part of the URL path delimited by slashes. URL Path: Part of the URL that comes after the domain (composed of segments). The appapp Router\r\nIn version 13, Next.js introduced a new App Router built on React Server Components, which supports shared layouts, nested routing,\r\nloading states, error handling, and more. The App Router works in a new directory named app. The app directory works alongside the pages directory to allow for incremental\r\nadoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the pages\r\ndirectory for previous behavior. If your application uses the pages directory, please also see the Pages Router documentation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3bbc57f3-394a-43f8-9f7b-886d13fffede":{"id_":"3bbc57f3-394a-43f8-9f7b-886d13fffede","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3UKZxircE1jTH4GxCOUDfP6tgdcibnoRf6mM5rNM0bA=","metadata":{},"hash":"JYWp+17/o1KtEql6xMIToHrX6t0Wvr93RZkOGAd2DzY="}},"hash":"PK4HhvznTHJY+3KIgdgvEu0IeTEVR1qsiC/+LRb4w1w=","text":"Good to know: The App Router takes priority over the Pages Router. Routes across directories should not resolve to the same\r\nURL path and will cause a build-time error to prevent a conflict. By default, components inside app are React Server Components. This is a performance optimization and allows you to easily adopt\r\nthem, and you can also use Client Components. Recommendation: Check out the Server page if you’re new to Server Components. Roles of Folders and Files\r\nNext.js uses a file-system based router where:\r\nFolders are used to define routes. A route is a single path of nested folders, following the file-system hierarchy from the root\r\nfolder down to a final leaf folder that includes a page.js file. See Defining Routes. Files are used to create UI that is shown for a route segment. See special files. Route Segments\r\nEach folder in a route represents a route segment. Each route segment is mapped to a corresponding segment in a URL path. Nested Routes\r\nTo create a nested route, you can nest folders inside each other. For example, you can add a new /dashboard/settings route by\r\nnesting two new folders in the app directory. The /dashboard/settings route is composed of three segments:\r\n/ (Root segment)\r\ndashboard (Segment)\r\nsettings (Leaf segment)\r\nFile Conventions\r\nNext.js provides a set of special files to create UI with specific behavior in nested routes:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5216bf77-75d8-4fce-8514-5889027af632":{"id_":"5216bf77-75d8-4fce-8514-5889027af632","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PP94LKz5RSv1uO6s8T4LFazYEizCzzHQq2m8ZEMNs8I=","metadata":{},"hash":"MsPIlqjGdFWZXhxxF0elkOG1htjO7hjkJniz6qwbN/c="}},"hash":"O9AwQPu5kGIyvdFD1OuoVSHVnzRIKTh1rXh8NiBayAA=","text":"layout\r\nShared UI for a segment and its children\r\npageUnique UI of a route and make routes publicly accessible\r\nloadingLoading UI for a segment and its children\r\nnot-foundNot found UI for a segment and its children\r\nerrorError UI for a segment and its children\r\nglobal-errorGlobal Error UI\r\nrouteServer-side API endpoint\r\ntemplateSpecialized re-rendered Layout UI\r\ndefaultFallback UI for Parallel Routes\r\nGood to know: .js, .jsx, or .tsx file extensions can be used for special files. Component Hierarchy\r\nThe React components defined in special files of a route segment are rendered in a specific hierarchy:\r\nlayout.js\r\ntemplate.js\r\nerror.js (React error boundary)\r\nloading.js (React suspense boundary)\r\nnot-found.js (React error boundary)\r\npage.js or nested layout.js\r\nIn a nested route, the components of a segment will be nested inside the components of its parent segment.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9a2ae1c9-b30a-42d8-914a-2743a6d2cc29":{"id_":"9a2ae1c9-b30a-42d8-914a-2743a6d2cc29","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wKlLwpQTPsPW0aqqOoknMYMDp6R0576XUQbRhQrrADA=","metadata":{},"hash":"cMaW2RRve1a+kMeY+lPH9iiXqYGMSU41F/XemigdSuA="}},"hash":"Ac3QrZJzyi7c/8axsplxlshwaxXLVQQzFinkYEEfa5k=","text":"Colocation\r\nIn addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc) inside folders in the app\r\ndirectory. This is because while folders define routes, only the contents returned by page.js or route.js are publicly addressable. Learn more about Project Organization and Colocation. Advanced Routing Patterns\r\nThe App Router also provides a set of conventions to help you implement more advanced routing patterns. These include:\r\nParallel Routes: Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c102be81-ec32-4a49-9e8c-d82657706630":{"id_":"c102be81-ec32-4a49-9e8c-d82657706630","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"5XGvSnodqXD1JWOoN3iCU3REcqgEXUCU48u7ZG8MLd4=","metadata":{},"hash":"NM2uMJykXnoHI87QujHGU9ahcZwG2B+8PjjdPEdqCJ4="}},"hash":"1vDT/AT5eRemwEUPS27pe9DmZT+CSLoLVvFG7Y/BTvA=","text":"can use them for split views that have their own sub-navigation. E.g. Dashboards. Intercepting Routes: Allow you to intercept a route and show it in the context of another route. You can use these when keeping the\r\ncontext for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed. These patterns allow you to build richer and more complex UIs, democratizing features that were historically complex for small teams\r\nand individual developers to implement. Next Steps\r\nNow that you understand the fundamentals of routing in Next.js, follow the links below to create your first routes:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f6ae3526-ef1d-4aee-ad9a-5f12dc0ec5c1":{"id_":"f6ae3526-ef1d-4aee-ad9a-5f12dc0ec5c1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RwDusD4WphaiId7H7jTDpvbFuj6b6tEnCen+kB0t+rk=","metadata":{},"hash":"roICXKbgmlfnLDPLFohRxx9wB31Lhn3mxoPFM9As5Vw="}},"hash":"PqWga4dcJ97oSn+5jSDRaeoQ7lDoyMSWbI0/7/LB8M0=","text":"3.1.1.1 - Defining Routes\r\nDocumentation path: /02-app/01-building-your-application/01-routing/01-defining-routes\r\nDescription: Learn how to create your first route in Next.js. Related:\r\nTitle: Related\r\nRelated Description: Learn more about creating pages and layouts. Links:\r\napp/building-your-application/routing/pages-and-layouts\r\nWe recommend reading the Routing Fundamentals page before continuing. This page will guide you through how to define and organize routes in your Next.js application. Creating Routes\r\nNext.js uses a file-system based router where folders are used to define routes. Each folder represents a route segment that maps to a URL segment. To create a nested route, you can nest folders inside each other. A special page.js file is used to make route segments publicly accessible. In this example, the /dashboard/analytics URL path is not publicly accessible because it does not have a corresponding page.js\r\nfile. This folder could be used to store components, stylesheets, images, or other colocated files. Good to know: .js, .jsx, or .tsx file extensions can be used for special files. Creating UI","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2edb23ba-a6d5-41a5-a9ba-ac5cdf3e4543":{"id_":"2edb23ba-a6d5-41a5-a9ba-ac5cdf3e4543","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eIUHqv+aG9GeMu3ItLSDALNTYWB+8LK+qnmRXPmtnY4=","metadata":{},"hash":"ZwPNoB1F9zMst3c74TNFOlIfkAD63SfmWJzWNmOuSx0="}},"hash":"kFsKvvCvHzmhZA2CmnZ/f18bUlz21p5NhVmYvVFRzf0=","text":"Special file conventions are used to create UI for each route segment. The most common are pages to show UI unique to a route, and\r\nlayouts to show UI that is shared across multiple routes. For example, to create your first page, add a page.js file inside the app directory and export a React component:\r\napp/page.tsx (tsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\napp/page.js (jsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"39757185-05e6-4ba9-919c-393720e7f4a0":{"id_":"39757185-05e6-4ba9-919c-393720e7f4a0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1mJA6rX+HaB1CW/I5B7Y80z4bIbeeoJOHSgH2PM5a1E=","metadata":{},"hash":"zQNcGH34/+T3lyvXyodZuALfwsglkV13ihA6ww1SC5k="}},"hash":"Mgq/hfoDClBzyemDXvL4jL+GwgrOf6WLu0mjXgp1MK4=","text":"3.1.1.2 - Pages and Layouts\r\nDocumentation path: /02-app/01-building-your-application/01-routing/02-pages-and-layouts\r\nDescription: Create your first page and shared layout with the App Router. We recommend reading the Routing Fundamentals and Defining Routes pages before continuing. The App Router inside Next.js 13 introduced new file conventions to easily create pages, shared layouts, and templates. This page will\r\nguide you through how to use these special files in your Next.js application. Pages\r\nA page is UI that is unique to a route. You can define pages by exporting a component from a page.js file. Use nested folders to\r\ndefine a route and a page.js file to make the route publicly accessible. Create your first page by adding a page.js file inside the app directory:\r\napp/page.tsx (tsx)// `app/page.tsx` is the UI for the `/` URL\r\nexport default function Page() {\r\n  return <h1>Hello, Home page!</h1>\r\n}\r\napp/page.js (jsx)// `app/page.js` is the UI for the `/` URL\r\nexport default function Page() {\r\n  return <h1>Hello, Home page!</h1>\r\n}\r\napp/dashboard/page.tsx (tsx)// `app/dashboard/page.tsx` is the UI for the `/dashboard` URL\r\nexport default function Page() {\r\n  return <h1>Hello, Dashboard Page!</h1>\r\n}\r\napp/dashboard/page.js (jsx)// `app/dashboard/page.js` is the UI for the `/dashboard` URL\r\nexport default function Page() {\r\n  return <h1>Hello, Dashboard Page!</h1>\r\n}\r\nGood to know:\r\nA page is always the leaf of the route subtree..js\r\n, .jsx, or .tsx file extensions can be used for Pages. A page.js file is required to make a route segment publicly accessible. Pages are Server Components by default but can be set to a Client Component. Pages can fetch data. View the Data Fetching section for more information. Layouts\r\nA layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dcc2f3c2-2e69-4b81-950c-3515f8b0d885":{"id_":"dcc2f3c2-2e69-4b81-950c-3515f8b0d885","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hVa2RSbs4gqZEgc8mavrP2Oitd4NP6xEyrqv363lnkc=","metadata":{},"hash":"qkifeAHRBK+sk+wm1ieiL5hZfcoio5Fp0tliA4ewvCM="}},"hash":"cnjz155+sys9q5qpNO+nXykyjT0p16KpLDEu4WFpqF8=","text":"You can define a layout by default exporting a React component from a layout.js file. The component should accept a children\r\nprop that will be populated with a child layout (if it exists) or a child page during rendering. app/dashboard/layout.tsx (tsx)export default function DashboardLayout({\r\n  children, // will be a page or nested layout\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <section>\r\n      {/* Include shared UI here e.g. a header or sidebar */}\r\n      <nav></nav>\r\n      {children}\r\n    </section>\r\n  )\r\n}\r\napp/dashboard/layout.js (jsx)export default function DashboardLayout({\r\n  children, // will be a page or nested layout\r\n}) {\r\n  return (\r\n    <section>\r\n      {/* Include shared UI here e.g. a header or sidebar */}\r\n      <nav></nav>\r\n      {children}\r\n    </section>\r\n  )\r\n}\r\nGood to know:\r\nThe top-most layout is called the Root Layout. This required layout is shared across all pages in an application. Root\r\nlayouts must contain html and body tags. Any route segment can optionally define its own Layout. These layouts will be shared across all pages in that segment. Layouts in a route are nested by default. Each parent layout wraps child layouts below it using the React children prop. You can use Route Groups to opt specific route segments in and out of shared layouts. Layouts are Server Components by default but can be set to a Client Component. Layouts can fetch data. View the Data Fetching section for more information. Passing data between a parent layout and its children is not possible. However, you can fetch the same data in a route more\r\nthan once, and React will automatically dedupe the requests without affecting performance. Layouts do not have access to the route segments below itself. To access all route segments, you can useuseSelectedLayoutSegment\r\n or useSelectedLayoutSegments in a Client Component. .js, .jsx, or .tsx file extensions can be used for Layouts. A layout.js and page.js file can be defined in the same folder. The layout will wrap the page. Root Layout (Required)\r\nThe root layout is defined at the top level of the app directory and applies to all routes. This layout enables you to modify the initial","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c1604aa3-be96-4eb8-b0eb-e36fdc16fb4f":{"id_":"c1604aa3-be96-4eb8-b0eb-e36fdc16fb4f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"FhgtxYASmCqmfgZEAARVbr/HamdqCYpQveQ9h1rhwJ8=","metadata":{},"hash":"NykDZVbJ7C6L6akl6vfRXBylKRJHw/tB+vEwQQMfjwM="}},"hash":"9IgY2THzUoUt3jyyFz71QK695CfSsY6O/u4mRiJkNRo=","text":"HTML returned from the server. app/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nGood to know:\r\nThe app directory must include a root layout. The root layout must define <html> and <body> tags since Next.js does not automatically create them. You can use the built-in SEO support to manage <head> HTML elements, for example, the <title> element. You can use route groups to create multiple root layouts. See an example here. The root layout is a Server Component by default and can not be set to a Client Component. Migrating from the pagespages directory: The root layout replaces the _app.js and _document.js files. View the migration\r\nguide. Nesting Layouts\r\nLayouts defined inside a folder (e.g. app/dashboard/layout.js) apply to specific route segments (e.g. acme.com/dashboard) and\r\nrender when those segments are active. By default, layouts in the file hierarchy are nested, which means they wrap child layouts via\r\ntheir children prop. app/dashboard/layout.tsx (tsx)export default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <section>{children}</section>\r\n}\r\napp/dashboard/layout.js (jsx)export default function DashboardLayout({ children }) {\r\n  return <section>{children}</section>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"735157f0-2bb0-4b08-871b-dc844940034c":{"id_":"735157f0-2bb0-4b08-871b-dc844940034c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aLmda6umqMHKJ2iy4eIwYNw5FDfY2kemflCFeqSCpzw=","metadata":{},"hash":"rv6f+VLahw6YpE4LSbN4z4boddjRklKPSFLEolxDULI="}},"hash":"e9DTTxxa4HcUOz1YZ0isOXOKVQpWOQhmIWOF7ZPBue0=","text":"}\r\nGood to know:\r\nOnly the root layout can contain <html> and <body> tags. If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the dashboard layout\r\n(app/dashboard/layout.js), which would wrap route segments inside app/dashboard/*. The two layouts would be nested as such:\r\nYou can use Route Groups to opt specific route segments in and out of shared layouts. Templates\r\nTemplates are similar to layouts in that they wrap each child layout or page. Unlike layouts that persist across routes and maintain\r\nstate, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes\r\nthat share a template, a new instance of the component is mounted, DOM elements are recreated, state is not preserved, and effects\r\nare re-synchronized. There may be cases where you need those specific behaviors, and templates would be a more suitable option than layouts. For\r\nexample:\r\nFeatures that rely on useEffect (e.g logging page views) and useState (e.g a per-page feedback form). To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time\r\nthe Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation. A template can be defined by exporting a default React component from a template.js file. The component should accept a\r\nchildren prop.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b6edc737-e087-4782-933c-ca06f123f3cc":{"id_":"b6edc737-e087-4782-933c-ca06f123f3cc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Epp9jxo3UFOU2M5uU90oAkqreaXXywYIPJMLFkcVUCo=","metadata":{},"hash":"Kypky4jct9aZ9QIz73xk4ld9c5kFtHYjDAk1vR2mi2s="}},"hash":"1R/Pa9ROdnWBbzIw9iuzby9kT+W+9tEawEXqUa+IGy4=","text":"app/template.tsx (tsx)export default function Template({ children }: { children: React.ReactNode }) {\r\n  return <div>{children}</div>\r\n}\r\napp/template.js (jsx)export default function Template({ children }) {\r\n  return <div>{children}</div>\r\n}\r\nIn terms of nesting, template.js is rendered between a layout and its children. Here’s a simplified output:\r\nOutput (jsx)<Layout>\r\n  {/* Note that the template is given a unique key. */}\r\n  <Template key={routeParam}>{children}</Template>\r\n</Layout>\r\nModifying <head><head>\r\nIn the app directory, you can modify the <head> HTML elements such as title and meta using the built-in SEO support. Metadata can be defined by exporting a metadata object or generateMetadata function in a layout.js or page.js file. app/page.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'Next.js',\r\n}\r\nexport default function Page() {\r\n  return '... '\r\n}\r\napp/page.js (jsx)export const metadata = {\r\n  title: 'Next.js',\r\n}\r\nexport default function Page() {\r\n  return '... '\r\n}\r\nGood to know: You should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, you should\r\nuse the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating <head>\r\nelements. Learn more about available metadata options in the API reference.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0832edc1-c034-4530-9fad-fa59c8941ffd":{"id_":"0832edc1-c034-4530-9fad-fa59c8941ffd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"krWKqFE+J7KRqXiHeAKx94i02AA02yl5U6GdU85kU/E=","metadata":{},"hash":"/ZvbTsz9h5/eXFNgiZJldzJ61/5c8YEknHFDxhPeJt4="}},"hash":"9LmWzZqtJcgg7GDEQcGAge06UGFu1IpBa19u0G1w9r8=","text":"3.1.1.3 - Linking and Navigating\r\nDocumentation path: /02-app/01-building-your-application/01-routing/03-linking-and-navigating\r\nDescription: Learn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/building-your-application/caching\r\napp/building-your-application/configuring/typescript\r\nThere are two ways to navigate between routes in Next.js:\r\nUsing the <Link> Component\r\nUsing the useRouter Hook\r\nThis page will go through how to use <Link>, useRouter(), and dive deeper into how navigation works.<Link><Link>\r\n Component\r\n<Link> is a built-in component that extends the HTML <a> tag to provide prefetching and client-side navigation between routes. It is\r\nthe primary way to navigate between routes in Next.js. You can use it by importing it from next/link, and passing a href prop to the component:\r\napp/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}\r\nThere are other optional props you can pass to <Link>. See the API reference for more. Examples\r\nLinking to Dynamic Segments\r\nWhen linking to dynamic segments, you can use template literals and interpolation to generate a list of links. For example, to generate\r\na list of blog posts:\r\napp/blog/PostList.js (jsx)import Link from 'next/link'\r\nexport default function PostList({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nChecking Active Links\r\nYou can use usePathname() to determine if a link is active. For example, to add a class to the active link, you can check if the current","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"85521004-c447-4656-a333-8ac7b192e845":{"id_":"85521004-c447-4656-a333-8ac7b192e845","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6hMtYOyvDAZexuLU/3YC7q5vaiz5gWgk2zse2cn0NkM=","metadata":{},"hash":"/QbqVNDJosKwyBQQmFUsSyLQV5VZzs7iafOT/e9q+bU="}},"hash":"x65eZ5GN8B+HTAjwVbDgDBIdvXT9cU0Wy/JpSxls/UM=","text":"pathname matches the href of the link:\r\napp/components/links.tsx (tsx)'use client'\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\nexport function Links() {\r\n  const pathname = usePathname()\r\n  return (\r\n    <nav>\r\n      <ul>\r\n        <li>\r\n          <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n            Home\r\n          </Link>\r\n        </li>\r\n        <li>\r\n          <Link\r\n            className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n            href=\"/about\"\r\n          >\r\n            About\r\n          </Link>\r\n        </li>\r\n      </ul>\r\n    </nav>\r\n  )\r\n}\r\napp/components/links.js (jsx)'use client'\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\nexport function Links() {\r\n  const pathname = usePathname()\r\n  return (\r\n    <nav>\r\n      <ul>\r\n        <li>\r\n          <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n            Home\r\n          </Link>\r\n        </li>\r\n        <li>\r\n          <Link\r\n            className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n            href=\"/about\"\r\n          >\r\n            About\r\n          </Link>\r\n        </li>\r\n      </ul>\r\n    </nav>\r\n  )\r\n}\r\nScrolling to an idid\r\nThe default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and\r\nforwards navigation. If you’d like to scroll to a specific id on navigation, you can append your URL with a # hash link or just pass a hash link to the href\r\nprop. This is possible since <Link> renders to an <a> element. <Link href=\"/dashboard#settings\">Settings</Link>\r\n// Output\r\n<a href=\"/dashboard#settings\">Settings</a>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7a83dd56-4255-4017-8bed-1410ada1f93a":{"id_":"7a83dd56-4255-4017-8bed-1410ada1f93a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a03p2/B/igPauIVtx56XaGae6u1CmIg8pyhsAo16N7w=","metadata":{},"hash":"U4tYuU6GMvkTnKp+laUhHFouv68TY7M46bfbOhENW8M="},"NEXT":{"nodeId":"59989fe5-82bf-4102-a618-288ea80992db","metadata":{},"hash":"B6rXga2z+pvfMwXP0/eTeB4zEHxqoCBX3FsaW93dCF4="}},"hash":"CiEAfMG3BX2UBEFuDOywvRZyghc1VVnjsD7Q5Yi74DQ=","text":"Disabling scroll restoration\r\nThe default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and\r\nforwards navigation. If you’d like to disable this behavior, you can pass scroll={false} to the <Link> component, or scroll:\r\nfalse to router.push() or router.replace(). // next/link\r\n<Link href=\"/dashboard\" scroll={false}>\r\n  Dashboard\r\n</Link>\r\n// useRouter\r\nimport { useRouter } from 'next/navigation'\r\nconst router = useRouter()\r\nrouter.push('/dashboard', { scroll: false })\r\nuseRouter()useRouter() Hook\r\nThe useRouter hook allows you to programmatically change routes. This hook can only be used inside Client Components and is imported from next/navigation. app/page.js (jsx)'use client'\r\nimport { useRouter } from 'next/navigation'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}\r\nFor a full list of useRouter methods, see the API reference. Recommendation: Use the <Link> component to navigate between routes unless you have a specific requirement for usinguseRouter\r\n. How Routing and Navigation Works\r\nThe App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by\r\nroute segments. And on the client, Next.js prefetches and caches the route segments. This means, when a user navigates to a new\r\nroute, the browser doesn’t reload the page, and only the route segments that change re-render - improving the navigation experience\r\nand performance. 1. Prefetching\r\nPrefetching is a way to preload a route in the background before the user visits it. There are two ways routes are prefetched in Next.js:\r\n<Link><Link> component: Routes are automatically prefetched as they become visible in the user’s viewport. Prefetching happens when\r\nthe page first loads or when it comes into view through scrolling.router.prefetch()router.prefetch()\r\n: The useRouter hook can be used to prefetch routes programmatically. The<Link>’s prefetching behavior is different for static and dynamic routes:\r\nStatic Routes: prefetch defaults to true. The entire route is prefetched and cached. Dynamic Routes: prefetch default to automatic.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"59989fe5-82bf-4102-a618-288ea80992db":{"id_":"59989fe5-82bf-4102-a618-288ea80992db","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a03p2/B/igPauIVtx56XaGae6u1CmIg8pyhsAo16N7w=","metadata":{},"hash":"U4tYuU6GMvkTnKp+laUhHFouv68TY7M46bfbOhENW8M="},"PREVIOUS":{"nodeId":"7a83dd56-4255-4017-8bed-1410ada1f93a","metadata":{},"hash":"CiEAfMG3BX2UBEFuDOywvRZyghc1VVnjsD7Q5Yi74DQ="}},"hash":"B6rXga2z+pvfMwXP0/eTeB4zEHxqoCBX3FsaW93dCF4=","text":"The entire route is prefetched and cached. Dynamic Routes: prefetch default to automatic. Only the shared layout down until the first loading.js file is prefetched and\r\ncached for 30s. This reduces the cost of fetching an entire dynamic route, and it means you can show an instant loading state for\r\nbetter visual feedback to users. You can disable prefetching by setting the prefetch prop to false.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c68f3da3-86f6-4d4c-b5d5-a8e559e7a2ab":{"id_":"c68f3da3-86f6-4d4c-b5d5-a8e559e7a2ab","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DZxILSKdcZSz4+74PUq3/1aEJQuB6jIDr7hw13FRJzw=","metadata":{},"hash":"Sbskn8Wch8lEn12W2DeKrGdBOCvhtCkyj3FgW524dRo="}},"hash":"0e2IMbTgq+fO4doZUkcLtzo/LSog8HNT6OHNMzwu6Zw=","text":"See the <Link> API reference for more information. Good to know:\r\nPrefetching is not enabled in development, only in production. 2. Caching\r\nNext.js has an in-memory client-side cache called the Router Cache. As users navigate around the app, the React Server Component\r\nPayload of prefetched route segments and visited routes are stored in the cache. This means on navigation, the cache is reused as much as possible, instead of making a new request to the server - improving\r\nperformance by reducing the number of requests and data transferred. Learn more about how the Router Cache works and how to configure it. 3. Partial Rendering\r\nPartial rendering means only the route segments that change on navigation re-render on the client, and any shared segments are\r\npreserved. For example, when navigating between two sibling routes, /dashboard/settings and /dashboard/analytics, the settings and\r\nanalytics pages will be rendered, and the shared dashboard layout will be preserved. Without partial rendering, each navigation would cause the full page to re-render on the server. Rendering only the segment that\r\nchanges reduces the amount of data transferred and execution time, leading to improved performance. 4. Soft Navigation\r\nBy default, the browser performs a hard navigation between pages. This means the browser reloads the page and resets React state\r\nsuch as useState hooks in your app and browser state such as the user’s scroll position or focused element. However, in Next.js, the\r\nApp Router uses soft navigation. This means React only renders the segments that have changed while preserving React and browser\r\nstate, and there is no full page reload. 5. Back and Forward Navigation\r\nBy default, Next.js will maintain the scroll position for backwards and forwards navigation, and re-use route segments in the Router\r\nCache.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d2b66e15-b04e-48a6-a0b5-bd3a37a1000e":{"id_":"d2b66e15-b04e-48a6-a0b5-bd3a37a1000e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AP3Pw+5ZGH2PInJinxO4FWS7NluZZdPTVlQ4cYwiRmA=","metadata":{},"hash":"jQWy4oHJUD7j3IARPNUuBbqAPpfCNuXCz5xyT8c/mAM="}},"hash":"wf0FmgpK0cwflmHEnOpLfBPvjtF2pM0CBHYyK4fYppg=","text":"3.1.1.4 - Route Groups\r\nDocumentation path: /02-app/01-building-your-application/01-routing/04-route-groups\r\nDescription: Route Groups can be used to partition your Next.js application into different sections. In the app directory, nested folders are normally mapped to URL paths. However, you can mark a folder as a Route Group to prevent\r\nthe folder from being included in the route’s URL path. This allows you to organize your route segments and project files into logical groups without affecting the URL path structure. Route groups are useful for:\r\nOrganizing routes into groups e.g. by site section, intent, or team. Enabling nested layouts in the same route segment level:\r\nCreating multiple nested layouts in the same segment, including multiple root layouts\r\nAdding a layout to a subset of routes in a common segment\r\nConvention\r\nA route group can be created by wrapping a folder’s name in parenthesis: (folderName)\r\nExamples\r\nOrganize routes without affecting the URL path\r\nTo organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted\r\nfrom the URL (e.g. (marketing) or (shop)). Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by\r\nadding a layout.js file inside their folders.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7e0857c8-b14c-479e-9921-3c93149c1e91":{"id_":"7e0857c8-b14c-479e-9921-3c93149c1e91","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cmNG3sIxbd4CBbcqiR1DRE6QeZw+cgvcyFyoiFEBzHI=","metadata":{},"hash":"o2ZkPmMFFkUSH4910Fj8O7SjWLlkUtSB8FHgYDIBnXo="}},"hash":"4shghKbRu1jUj0KpG3vuih8PUlClC5w/EzYZrmrD9II=","text":"Opting specific segments into a layout\r\nTo opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the\r\ngroup (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout). Creating multiple root layouts\r\nTo create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route groups. This is useful\r\nfor partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be\r\nadded to each root layout.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"93399848-7320-47f8-b868-7cd8b97199b6":{"id_":"93399848-7320-47f8-b868-7cd8b97199b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Xk5i0got7vEZE3HNuYXByKyRB+DVbow4lVrtV2KQ8Wc=","metadata":{},"hash":"sjy4v7C8O4352PmaVCozVbVBbkOEgBnKfHsfVoLb9Nw="}},"hash":"k9dg9fcfI85Usd07rygpyKn6Ug/L3T/rYgMZ3QREUF4=","text":"In the example above, both (marketing) and (shop) have their own root layout. Good to know:\r\nThe naming of route groups has no special significance other than for organization. They do not affect the URL path. Routes that include a route group should not resolve to the same URL path as other routes. For example, since route\r\ngroups don’t affect URL structure, (marketing)/about/page.js and (shop)/about/page.js would both resolve to\r\n/about and cause an error. If you use multiple root layouts without a top-level layout.js file, your home page.js file should be defined in one of the\r\nroute groups, For example: app/(marketing)/page.js. Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example,\r\nnavigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js will cause a\r\nfull page load. This only applies to multiple root layouts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"44724502-e62a-4e37-a024-b96a689c580d":{"id_":"44724502-e62a-4e37-a024-b96a689c580d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"z+7bl8SgPtBkIAEOkTUNcoxdiMDdtGyzkviYycFxnLI=","metadata":{},"hash":"0GuwrYVun/F7IFdGiceIJfIjUgRBFh4X11/sSBFFszY="},"NEXT":{"nodeId":"442cbba7-47a5-46fe-b999-15f49fa06b30","metadata":{},"hash":"jdvc77Vjg19TyX13EQSoR4/QLKLgNaLGbCXfDW9fq50="}},"hash":"k5bm5U0DRgPo7eXudU6R2u2Wz+LHgpf1SpZkcM/tr/M=","text":"3.1.1.5 - Dynamic Routes\r\nDocumentation path: /02-app/01-building-your-application/01-routing/05-dynamic-routes\r\nDescription: Dynamic Routes can be used to programmatically generate route segments from dynamic data. Related:\r\nTitle: Next Steps\r\nRelated Description: For more information on what to do next, we recommend the following sections\r\nLinks:\r\napp/building-your-application/routing/linking-and-navigating\r\napp/api-reference/functions/generate-static-params\r\nWhen you don’t know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic\r\nSegments that are filled in at request time or prerendered at build time. Convention\r\nA Dynamic Segment can be created by wrapping a folder’s name in square brackets: [folderName]. For example, [id] or [slug]. Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions. Example\r\nFor example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog\r\nposts. app/blog/[slug]/page.tsx (tsx)export default function Page({ params }: { params: { slug: string } }) {\r\n  return <div>My Post: {params.slug}</div>\r\n}\r\napp/blog/[slug]/page.js (jsx)export default function Page({ params }) {\r\n  return <div>My Post: {params.slug}</div>\r\n}\r\nRouteExample URLparamsparams\r\napp/blog/[slug]/page.js/blog/a{ slug: 'a' }\r\napp/blog/[slug]/page.js/blog/b{ slug: 'b' }\r\napp/blog/[slug]/page.js/blog/c{ slug: 'c' }\r\nSee the generateStaticParams() page to learn how to generate the params for the segment. Good to know: Dynamic Segments are equivalent to Dynamic Routes in the pages directory. Generating Static Params\r\nThe generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build\r\ntime instead of on-demand at request time.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"442cbba7-47a5-46fe-b999-15f49fa06b30":{"id_":"442cbba7-47a5-46fe-b999-15f49fa06b30","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"z+7bl8SgPtBkIAEOkTUNcoxdiMDdtGyzkviYycFxnLI=","metadata":{},"hash":"0GuwrYVun/F7IFdGiceIJfIjUgRBFh4X11/sSBFFszY="},"PREVIOUS":{"nodeId":"44724502-e62a-4e37-a024-b96a689c580d","metadata":{},"hash":"k5bm5U0DRgPo7eXudU6R2u2Wz+LHgpf1SpZkcM/tr/M="}},"hash":"jdvc77Vjg19TyX13EQSoR4/QLKLgNaLGbCXfDW9fq50=","text":"app/blog/[slug]/page.tsx (tsx)export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\napp/blog/[slug]/page.js (jsx)export async function generateStaticParams() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0dfbed2a-d790-48c0-858d-0ad34abdde28":{"id_":"0dfbed2a-d790-48c0-858d-0ad34abdde28","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sIQaRYAvjRIcmF0uFX6mV1P6F1+UrngA6tTsIafnsV0=","metadata":{},"hash":"o0LFjTy9oKnrh04gFiwXfymHX2dU2wU5omJdJJxQjjQ="},"NEXT":{"nodeId":"eb888739-38a3-4f8f-988e-0ca8f00d1239","metadata":{},"hash":"mdiUWI6fpmhBEouV7JPc/joFOLQQ3IP0yFvoQNwg28M="}},"hash":"ZJzcSQFHt4M534H5vt4ncyTp8L7kO9yL4U9k9IrAcGE=","text":"const posts = await fetch('https://.../posts').then((res) => res.json())\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\nThe primary benefit of the generateStaticParams function is its smart retrieval of data. If content is fetched within the\r\ngenerateStaticParams function using a fetch request, the requests are automatically memoized. This means a fetch request with\r\nthe same arguments across multiple generateStaticParams, Layouts, and Pages will only be made once, which decreases build\r\ntimes. Use the migration guide if you are migrating from the pages directory. See generateStaticParams server function documentation for more information and advanced use cases. Catch-all Segments\r\nDynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName]. For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops,\r\n/shop/clothes/tops/t-shirts, and so on. RouteExample URLparamsparams\r\napp/shop/[...slug]/page.js/shop/a{ slug: ['a'] }\r\napp/shop/[...slug]/page.js/shop/a/b{ slug: ['a', 'b'] }\r\napp/shop/[...slug]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] }\r\nOptional Catch-all Segments\r\nCatch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]]. For example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops,\r\n/shop/clothes/tops/t-shirts. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also\r\nmatched (/shop in the example above). RouteExample URLparamsparams\r\napp/shop/[[...slug]]/page.js/shop{}\r\napp/shop/[[...slug]]/page.js/shop/a{ slug: ['a'] }\r\napp/shop/[[...slug]]/page.js/shop/a/b{ slug: ['a', 'b'] }\r\napp/shop/[[...slug]]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] }\r\nTypeScript\r\nWhen using TypeScript, you can add types for params depending on your configured route segment.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"eb888739-38a3-4f8f-988e-0ca8f00d1239":{"id_":"eb888739-38a3-4f8f-988e-0ca8f00d1239","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sIQaRYAvjRIcmF0uFX6mV1P6F1+UrngA6tTsIafnsV0=","metadata":{},"hash":"o0LFjTy9oKnrh04gFiwXfymHX2dU2wU5omJdJJxQjjQ="},"PREVIOUS":{"nodeId":"0dfbed2a-d790-48c0-858d-0ad34abdde28","metadata":{},"hash":"ZJzcSQFHt4M534H5vt4ncyTp8L7kO9yL4U9k9IrAcGE="}},"hash":"mdiUWI6fpmhBEouV7JPc/joFOLQQ3IP0yFvoQNwg28M=","text":"app/blog/[slug]/page.tsx (tsx)export default function Page({ params }: { params: { slug: string } }) {\r\n  return <h1>My Page</h1>\r\n}\r\napp/blog/[slug]/page.js (jsx)export default function Page({ params }) {\r\n  return <h1>My Page</h1>\r\n}\r\nRouteparamsparams Type Definition\r\napp/blog/[slug]/page.js{ slug: string }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c8675217-414a-4f62-97aa-9e382d23ba56":{"id_":"c8675217-414a-4f62-97aa-9e382d23ba56","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"utXEne9yozybxmUd0v+0iI8S8WZh1yZhtX52N4eYD3I=","metadata":{},"hash":"VMVae5NxuVmIgssPc8PMoIzh9y9XdACYvSzNvbz7264="}},"hash":"OgUuq9BfK6JV50cmuG29b/RT2F2Iz4VzcL1a11s9ibw=","text":"app/shop/[...slug]/page.js{ slug: string[] }\r\napp/[categoryId]/[itemId]/page.js{ categoryId: string, itemId: string }\r\nRouteparamsparams Type Definition\r\nGood to know: This may be done automatically by the TypeScript plugin in the future.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f9f90cf3-5715-4427-9f42-c9ccc12a7d53":{"id_":"f9f90cf3-5715-4427-9f42-c9ccc12a7d53","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/hEXHOKmo99zp42XufjQjEAv66CFdxGcHvKzLMCNorc=","metadata":{},"hash":"fdeKB7fjKozlnOlIQ5I2fhTNGMrXj0evz3GIAISRqp8="}},"hash":"kmeLJwiidhlcqFFtO8mDoe9SvO6PwnDEccSL74h/z+o=","text":"3.1.1.6 - Loading UI and Streaming\r\nDocumentation path: /02-app/01-building-your-application/01-routing/06-loading-ui-and-streaming\r\nDescription: Built on top of Suspense, Loading UI allows you to create a fallback for specific route segments, and automatically stream\r\ncontent as it becomes ready. The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an\r\ninstant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once\r\nrendering is complete. Instant Loading States\r\nAn instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as\r\nskeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand\r\nthe app is responding and provides a better user experience. Create a loading state by adding a loading.js file inside a folder. app/dashboard/loading.tsx (tsx)export default function Loading() {\r\n  // You can add any UI inside Loading, including a Skeleton. return <LoadingSkeleton />\r\n}\r\napp/dashboard/loading.js (jsx)export default function Loading() {\r\n  // You can add any UI inside Loading, including a Skeleton. return <LoadingSkeleton />\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ca5e8b38-2490-4f92-8874-194c58e68124":{"id_":"ca5e8b38-2490-4f92-8874-194c58e68124","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+ILVNENRxXDWi5VgsKKI7J/LKDum7BrdByFdrsBkvWI=","metadata":{},"hash":"JpSAFIBtPPxLgxR8KoBZ+wcyeUymNXNVsUHJCNzUHZU="}},"hash":"96qVMYiRnkPusiwC+FYhODsKr+540KgT4ZGxT6nrGhg=","text":"In the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in\r\na <Suspense> boundary. Good to know:\r\nNavigation is immediate, even with server-centric routing. Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before\r\nnavigating to another route. Shared layouts remain interactive while new route segments load. Recommendation: Use the loading.js convention for route segments (layouts and pages) as Next.js optimizes this\r\nfunctionality. Streaming with Suspense\r\nIn addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports\r\nstreaming with Suspense for both Node.js and Edge runtimes. What is Streaming? To learn how Streaming works in React and Next.js, it’s helpful to understand Server-Side Rendering (SSR) and its limitations. With SSR, there’s a series of steps that need to be completed before a user can see and interact with a page:\r\n1. First, all data for a given page is fetched on the server. 2. The server then renders the HTML for the page. 3. The HTML, CSS, and JavaScript for the page are sent to the client. 4. A non-interactive user interface is shown using the generated HTML, and CSS. 5. Finally, React hydrates the user interface to make it interactive.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f869c8b6-df52-4fb0-856b-8058b4543972":{"id_":"f869c8b6-df52-4fb0-856b-8058b4543972","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CywOndRE338z7uYKDKOreIeDTimRtIec/DkeYKKZb8Q=","metadata":{},"hash":"y/gTU8RIjMHjbmtn5GpOHCRxRLTX/GACRnQh9+CbBzQ="}},"hash":"dZ0Q/hDLwI1Pa7cRJysi/9pytsmMPPomozgZ0TUvAJw=","text":"These steps are sequential and blocking, meaning the server can only render the HTML for a page once all the data has been fetched. And, on the client, React can only hydrate the UI once the code for all components in the page has been downloaded. SSR with React and Next.js helps improve the perceived loading performance by showing a non-interactive page to the user as soon as\r\npossible. However, it can still be slow as all data fetching on server needs to be completed before the page can be shown to the user. Streaming allows you to break down the page’s HTML into smaller chunks and progressively send those chunks from the server to the\r\nclient.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fb0bec1f-b0d2-4359-8ede-b6d3dd4a36e0":{"id_":"fb0bec1f-b0d2-4359-8ede-b6d3dd4a36e0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"V38WnivuhiRAOrfGLA1MINJ6kjUkR41P2w8T77yLlGQ=","metadata":{},"hash":"6Gsz19mDCLCax1SVeGFdmVa+IlBEzP0p/m3VF8B5lOY="}},"hash":"lDxI6bpA+TSxkkOWs6ci9KFpCyoJ92w44lcYTYiC+l0=","text":"This enables parts of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered. Streaming works well with React’s component model because each component can be considered a chunk. Components that have\r\nhigher priority (e.g. product information) or that don’t rely on data can be sent first (e.g. layout), and React can start hydration earlier. Components that have lower priority (e.g. reviews, related products) can be sent in the same server request after their data has been\r\nfetched. Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can\r\nreduce the Time To First Byte (TTFB) and First Contentful Paint (FCP). It also helps improve Time to Interactive (TTI), especially on slower\r\ndevices. Example\r\n<Suspense> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton,\r\nspinner) while it’s happening, and then swapping in your component once the action completes. app/dashboard/page.tsx (tsx)import { Suspense } from 'react'\r\nimport { PostFeed, Weather } from './Components'\r\nexport default function Posts() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<p>Loading feed...</p>}>\r\n        <PostFeed />\r\n      </Suspense>\r\n      <Suspense fallback={<p>Loading weather...</p>}>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"73fde5e8-e757-4c11-b154-77aaeaa4600e":{"id_":"73fde5e8-e757-4c11-b154-77aaeaa4600e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OvYEX4Z2tJKkie9w+sneAB6i5W08pj/lohHkL88/UMc=","metadata":{},"hash":"MBYrb1jkw/UbwCNOnZsaQ3Onj4EzWunMrP+tyjvk2Ko="}},"hash":"icEkJ5LcME3wLACXBxb63nc4cLmOxVnytkZVDYLVNkg=","text":"<Weather />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}\r\napp/dashboard/page.js (jsx)import { Suspense } from 'react'\r\nimport { PostFeed, Weather } from './Components'\r\nexport default function Posts() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<p>Loading feed...</p>}>\r\n        <PostFeed />\r\n      </Suspense>\r\n      <Suspense fallback={<p>Loading weather...</p>}>\r\n        <Weather />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}\r\nBy using Suspense, you get the benefits of:\r\n1. Streaming Server Rendering - Progressively rendering HTML from the server to the client. 2. Selective Hydration - React prioritizes what components to make interactive first based on user interaction. For more Suspense examples and use cases, please see the React Documentation. SEO\r\nNext.js will wait for data fetching inside generateMetadata to complete before streaming UI to the client. This guarantees the first\r\npart of a streamed response includes <head> tags. Since streaming is server-rendered, it does not impact SEO. You can use the Mobile Friendly Test tool from Google to see how your\r\npage appears to Google’s web crawlers and view the serialized HTML (source). Status Codes\r\nWhen streaming, a 200 status code will be returned to signal that the request was successful. The server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or\r\nnotFound. Since the response headers have already been sent to the client, the status code of the response cannot be updated. This\r\ndoes not affect SEO.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b5333073-0a74-48f4-88a0-4e452c214540":{"id_":"b5333073-0a74-48f4-88a0-4e452c214540","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dUwnE2IeULCMwqA6PgFq9OSpKs+qJU7PTI/bPKaWm7k=","metadata":{},"hash":"Y0xvR4/3dEO+iFdUMhB1YrveN9D3DBhaEH37DEyvnVk="}},"hash":"fLxvc41JsxHHroRULSIeDnc8ls7ga3QIsFmJbsCxiZI=","text":"3.1.1.7 - Error Handling\r\nDocumentation path: /02-app/01-building-your-application/01-routing/07-error-handling\r\nDescription: Handle runtime errors by automatically wrapping route segments and their nested children in a React Error Boundary. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/api-reference/file-conventions/error\r\nThe error.js file convention allows you to gracefully handle unexpected runtime errors in nested routes. Automatically wrap a route segment and its nested children in a React Error Boundary. Create error UI tailored to specific segments using the file-system hierarchy to adjust granularity. Isolate errors to affected segments while keeping the rest of the application functional. Add functionality to attempt to recover from an error without a full page reload. Create error UI by adding an error.js file inside a route segment and exporting a React component:\r\napp/dashboard/error.tsx (tsx)'use client' // Error components must be Client Components\r\nimport { useEffect } from 'react'\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bd6b955d-8520-4199-9916-4bdfa98c9c15":{"id_":"bd6b955d-8520-4199-9916-4bdfa98c9c15","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"x1jUQ/HaI1i1FeZr+WrO5lOkpXbGN3xfKwEyk8h+Y74=","metadata":{},"hash":"yquWjCnXVoWe78I2WNt4hoPanwPMV+o8RKxA3u3R+Xs="}},"hash":"nPVniQwtOrst+zmo+VjEGL5ob7blWigYbjIEG3SslNU=","text":"app/dashboard/error.js (jsx)'use client' // Error components must be Client Components\r\nimport { useEffect } from 'react'\r\nexport default function Error({ error, reset }) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\nHow error.jserror.js Works\r\nerror.js automatically creates a React Error Boundary that wraps a nested child segment or page.js component. The React component exported from the error.js file is used as the fallback component. If an error is thrown within the error boundary, the error is contained, and the fallback component is rendered. When the fallback error component is active, layouts above the error boundary maintain their state and remain interactive, and\r\nthe error component can display functionality to recover from the error. Recovering From Errors\r\nThe cause of an error can sometimes be temporary. In these cases, simply trying again might resolve the issue. An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the\r\nfunction will try to re-render the Error boundary’s contents. If successful, the fallback error component is replaced with the result of the\r\nre-render. app/dashboard/error.tsx (tsx)'use client'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4bfb44c4-b141-444c-bf36-65960226950b":{"id_":"4bfb44c4-b141-444c-bf36-65960226950b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Azcz0EWbdD4PtwfjgHLaJvgx+INsIspye6IHtigbo3k=","metadata":{},"hash":"lRO3CD/D8lBcUJGe4SsHP1OX6BjxTkRietwyD6GB7/k="}},"hash":"EVjGt+D7tg1AqMV6fuFTAbkkTN66fTBjKQLes2F1g+Y=","text":"export default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button onClick={() => reset()}>Try again</button>\r\n    </div>\r\n  )\r\n}\r\napp/dashboard/error.js (jsx)'use client'\r\nexport default function Error({ error, reset }) {\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button onClick={() => reset()}>Try again</button>\r\n    </div>\r\n  )\r\n}\r\nNested Routes\r\nReact components created through special files are rendered in a specific nested hierarchy. For example, a nested route with two segments that both include layout.js and error.js files are rendered in the following\r\nsimplified component hierarchy:\r\nThe nested component hierarchy has implications for the behavior of error.js files across a nested route:\r\nErrors bubble up to the nearest parent error boundary. This means an error.js file will handle errors for all its nested child\r\nsegments. More or less granular error UI can be achieved by placing error.js files at different levels in the nested folders of a\r\nroute. An error.js boundary will not handle errors thrown in a layout.js component in the same segment because the error\r\nboundary is nested inside that layout’s component. Handling Errors in Layouts\r\nerror.js boundaries do not catch errors thrown in layout.js or template.js components of the same segment. This intentional\r\nhierarchy keeps important UI that is shared between sibling routes (such as navigation) visible and functional when an error occurs. To handle errors within a specific layout or template, place an error.js file in the layout’s parent segment. To handle errors within the root layout or template, use a variation of error.js called global-error.js. Handling Errors in Root Layouts","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"eaa883a4-d1fa-4424-9b41-08c233bdcdaa":{"id_":"eaa883a4-d1fa-4424-9b41-08c233bdcdaa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wvGZRbQlJVGBWhLzI1ppOkzwTYEFx8BFzzTKKOq/3zI=","metadata":{},"hash":"VQPtwJLxiNHeWo3hCfNrikT+SqeEagQJuyY3QXkV16g="},"NEXT":{"nodeId":"454b7229-af22-45cb-8010-3d886c12111d","metadata":{},"hash":"yF/3czKmmh1ykHkXIX9Kpk20iWHjAU0Cszkjg46lVSU="}},"hash":"9PhwmseqFWZepKv3vjjBsLc//5azvyJ4GktawusexeA=","text":"The root app/error.js boundary does not catch errors thrown in the root app/layout.js or app/template.js component. To specifically handle errors in these root components, use a variation of error.js called app/global-error.js located in the root\r\napp directory. Unlike the root error.js, the global-error.js error boundary wraps the entire application, and its fallback component replaces\r\nthe root layout when active. Because of this, it is important to note that global-error.js must define its own <html> and <body>\r\ntags. global-error.js is the least granular error UI and can be considered “catch-all” error handling for the whole application. It is unlikely\r\nto be triggered often as root components are typically less dynamic, and other error.js boundaries will catch most errors. Even if a global-error.js is defined, it is still recommended to define a root error.js whose fallback component will be rendered\r\nwithin the root layout, which includes globally shared UI and branding. app/global-error.tsx (tsx)'use client'\r\nexport default function GlobalError({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/global-error.js (jsx)'use client'\r\nexport default function GlobalError({ error, reset }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nHandling Server Errors\r\nIf an error is thrown inside a Server Component, Next.js will forward an Error object (stripped of sensitive error information in\r\nproduction) to the nearest error.js file as the error prop. Securing Sensitive Error Information\r\nDuring production, the Error object forwarded to the client only includes a generic message and digest property. This is a security precaution to avoid leaking potentially sensitive details included in the error to the client. The message property contains a generic message about the error and the digest property contains an automatically generated hash\r\nof the error that can be used to match the corresponding error in server-side logs.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"454b7229-af22-45cb-8010-3d886c12111d":{"id_":"454b7229-af22-45cb-8010-3d886c12111d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wvGZRbQlJVGBWhLzI1ppOkzwTYEFx8BFzzTKKOq/3zI=","metadata":{},"hash":"VQPtwJLxiNHeWo3hCfNrikT+SqeEagQJuyY3QXkV16g="},"PREVIOUS":{"nodeId":"eaa883a4-d1fa-4424-9b41-08c233bdcdaa","metadata":{},"hash":"9PhwmseqFWZepKv3vjjBsLc//5azvyJ4GktawusexeA="}},"hash":"yF/3czKmmh1ykHkXIX9Kpk20iWHjAU0Cszkjg46lVSU=","text":"During development, the Error object forwarded to the client will be serialized and include the message of the original error for easier\r\ndebugging.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"86fd7016-7b17-4e1b-ad92-69b83c5ff3a3":{"id_":"86fd7016-7b17-4e1b-ad92-69b83c5ff3a3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KHbEwX5XTjJzTwwROGC5+r3Ln/Id5y1QuPyi31V++EM=","metadata":{},"hash":"EnH6i/fTipgtydiOKIh0TPAa8T1dY4cA4WE8gVdQ6/4="}},"hash":"6SXUD/rdJ3w/JOiB5djMarA/PW38QYi0T1WU/1rt96Q=","text":"3.1.1.8 - Parallel Routes\r\nDocumentation path: /02-app/01-building-your-application/01-routing/08-parallel-routes\r\nDescription: Simultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly\r\ndynamic applications. Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout. For highly dynamic\r\nsections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns. For example, you can simultaneously render the team and analytics pages. Parallel Routing allows you to define independent error and loading states for each route as they’re being streamed in independently.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a6343bf2-eab9-4a3e-afc7-fe826a056af6":{"id_":"a6343bf2-eab9-4a3e-afc7-fe826a056af6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+acYD9kINpyys0HsD3qXbh+X36oPvyCQcQbtS/zvVPU=","metadata":{},"hash":"dl0n7vAVcBA+3szIjSkV/KKchGlG+Q3MSrPyH7XCrOM="}},"hash":"HZ8vRCtum8f+vevqeYOzoErUiWbDUei+9Mc2Miz7fy4=","text":"Parallel Routing also allows you to conditionally render a slot based on certain conditions, such as authentication state. This enables\r\nfully separated code on the same URL. Convention\r\nParallel routes are created using named slots. Slots are defined with the @folder convention, and are passed to the same-level layout\r\nas props.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"018e84f1-8a44-4ae3-9088-f569c7828cf7":{"id_":"018e84f1-8a44-4ae3-9088-f569c7828cf7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hfH1xi7lA5pY2p8fujN0SFDo1kT1b6IAXpAN05paAgI=","metadata":{},"hash":"sn/6gEXyVeZC/0jC2wBuTkCfHB7dSlv/ibTXNTT0eV4="}},"hash":"WB0AXjJ9buvAmZmxY2+5SmqBgCwyO9/ihLNOvPHEvIs=","text":"Slots are not route segments and do not affect the URL structure. The file path /@team/members would be accessible at\r\n/members. For example, the following file structure defines two explicit slots: @analytics and @team. The folder structure above means that the component in app/layout.js now accepts the @analytics and @team slots props, and\r\ncan render them in parallel alongside the children prop:\r\napp/layout.tsx (tsx)export default function Layout(props: {\r\n  children: React.ReactNode\r\n  analytics: React.ReactNode\r\n  team: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      {props.children}\r\n      {props.team}\r\n      {props.analytics}\r\n    </>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function Layout(props) {\r\n  return (\r\n    <>\r\n      {props.children}\r\n      {props.team}\r\n      {props.analytics}\r\n    </>\r\n  )\r\n}\r\nGood to know: The children prop is an implicit slot that does not need to be mapped to a folder. This means app/page.js is\r\nequivalent to app/@children/page.js. Unmatched Routes\r\nBy default, the content rendered within a slot will match the current URL. In the case of an unmatched slot, the content that Next.js renders differs based on the routing technique and folder structure. default.jsdefault.js\r\nYou can define a default.js file to render as a fallback when Next.js cannot recover a slot’s active state based on the current URL. Consider the following folder structure. The @team slot has a settings directory, but @analytics does not.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ebf776ac-5021-4b41-82f1-735e523b73b0":{"id_":"ebf776ac-5021-4b41-82f1-735e523b73b0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rxVEEVlS1v6QLuykQUq5EoL8RHFgSCtHmlEhe+IUnM0=","metadata":{},"hash":"pKjhEJtYZ+8BhCpncI4ExRBVZd/5GvNqW55Jseh1Xsg="}},"hash":"wRN4vpTPYJz1U4XByLbf4QfrOyizpL+ss2qLPlAitEI=","text":"Navigation\r\nOn navigation, Next.js will render the slot’s previously active state, even if it doesn’t match the current URL. Reload\r\nOn reload, Next.js will first try to render the unmatched slot’s default.js file. If that’s not available, a 404 gets rendered. The 404 for unmatched routes helps ensure that you don’t accidentally render a route that shouldn’t be parallel rendered.useSelectedLayoutSegment(s)useSelectedLayoutSegment(s)\r\nBoth useSelectedLayoutSegment and useSelectedLayoutSegments accept a parallelRoutesKey, which allows you to read the\r\nactive route segment within that slot. app/layout.tsx (tsx)'use client'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\nexport default function Layout(props: {\r\n  //... auth: React.ReactNode\r\n}) {\r\n  const loginSegments = useSelectedLayoutSegment('auth')\r\n  // ... }\r\napp/layout.js (jsx)'use client'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\nexport default function Layout(props) {\r\n  const loginSegments = useSelectedLayoutSegment('auth')\r\n  // ... }\r\nWhen a user navigates to @auth/login, or /login in the URL bar, loginSegments will be equal to the string \"login\". Examples","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a6cd169-4e6e-4fe5-99c0-5b954a118768":{"id_":"2a6cd169-4e6e-4fe5-99c0-5b954a118768","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cupq5CBM0Dr/N6SxqDkswaqP0bNeaMTq7QJ11x7YYF8=","metadata":{},"hash":"7k5wsOVdRBZAZ76Jo0BhdtmVDNZU8ZNHKVAzwVepGVE="}},"hash":"WbRrUgdTg7qzi1TD8G2OUzNZJnrSAndypZTmcVGtbHE=","text":"Modals\r\nParallel Routing can be used to render modals. The @auth slot renders a <Modal> component that can be shown by navigating to a matching route, for example /login. app/layout.tsx (tsx)export default async function Layout(props: {\r\n  // ... auth: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      {/* ... */}\r\n      {props.auth}\r\n    </>\r\n  )\r\n}\r\napp/layout.js (jsx)export default async function Layout(props) {\r\n  return (\r\n    <>\r\n      {/* ... */}\r\n      {props.auth}\r\n    </>\r\n  )\r\n}\r\napp/@auth/login/page.tsx (tsx)import { Modal } from 'components/modal'\r\nexport default function Login() {\r\n  return (\r\n    <Modal>\r\n      <h1>Login</h1>\r\n      {/* ... */}\r\n    </Modal>\r\n  )\r\n}\r\napp/@auth/login/page.js (jsx)import { Modal } from 'components/modal'\r\nexport default function Login() {\r\n  return (\r\n    <Modal>\r\n      <h1>Login</h1>\r\n      {/* ... */}\r\n    </Modal>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3e872307-0178-4923-9869-d3b0cfa2cd7d":{"id_":"3e872307-0178-4923-9869-d3b0cfa2cd7d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"t9+3oFNX6Yo0bJEmPf/ewKUM9TTXd7BTeLtwSRa2jeo=","metadata":{},"hash":"nJr7mqJJ67pT2iLBxqyRiXajLNq/9VfNUpXfK5v+mgA="}},"hash":"kmhQ6zX4PhkCzLOEN2YxunnQ/2d9aY8PFwLlKHTmFvU=","text":"To ensure that the contents of the modal don’t get rendered when it’s not active, you can create a default.js file that returns null. app/@auth/default.tsx (tsx)export default function Default() {\r\n  return null\r\n}\r\napp/@auth/default.js (jsx)export default function Default() {\r\n  return null\r\n}\r\nDismissing a modal\r\nIf a modal was initiated through client navigation, e.g. by using <Link href=\"/login\">, you can dismiss the modal by calling\r\nrouter.back() or by using a Link component. ```tsx filename=”app/@auth/login/page.tsx” highlight=”5” switcher ‘use client’ import { useRouter } from ‘next/navigation’ import { Modal\r\n} from ‘components/modal’\r\nexport default function Login() { const router = useRouter() return ( router.back()}>Close modalLogin\r\n... ) }\r\n```jsx filename=\"app/@auth/login/page.js\" highlight=\"5\" switcher\r\n'use client'\r\nimport { useRouter } from 'next/navigation'\r\nimport { Modal } from 'components/modal'\r\nexport default function Login() {\r\n  const router = useRouter()\r\n  return (\r\n    <Modal>\r\n      <span onClick={() => router.back()}>Close modal</span>\r\n      <h1>Login</h1>\r\n      ... </Modal>\r\n  )\r\n}\r\nMore information on modals is covered in the Intercepting Routes section. If you want to navigate elsewhere and dismiss a modal, you can also use a catch-all route. app/@auth/[...catchAll]/page.tsx (tsx)export default function CatchAll() {\r\n  return null\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cc860a6b-fcf6-4dfe-8a3b-be6cdcb745ec":{"id_":"cc860a6b-fcf6-4dfe-8a3b-be6cdcb745ec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pfGrIyWWL0uyitGRehP5IP/mx7ouN3KHznkRIH8xiQk=","metadata":{},"hash":"o2/FKXmhq4LoWq8XIsHvHmJME2S41/p3T88WgAoiIAs="}},"hash":"bgWXuv0gXqG4CuVXL8C8L+H3vjFHf5Qeiw7rE/S7CJw=","text":"app/@auth/[...catchAll]/page.js (jsx)export default function CatchAll() {\r\n  return null\r\n}\r\nCatch-all routes take precedence over default.js. Conditional Routes\r\nParallel Routes can be used to implement conditional routing. For example, you can render a @dashboard or @login route depending\r\non the authentication state. app/layout.tsx (tsx)import { getUser } from '@/lib/auth'\r\nexport default function Layout({\r\n  dashboard,\r\n  login,\r\n}: {\r\n  dashboard: React.ReactNode\r\n  login: React.ReactNode\r\n}) {\r\n  const isLoggedIn = getUser()\r\n  return isLoggedIn ? dashboard : login\r\n}\r\napp/layout.js (jsx)import { getUser } from '@/lib/auth'\r\nexport default function Layout({ dashboard, login }) {\r\n  const isLoggedIn = getUser()\r\n  return isLoggedIn ? dashboard : login\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"37b54a92-efc6-4a69-a648-41843435be9e":{"id_":"37b54a92-efc6-4a69-a648-41843435be9e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DBRA/CR1N8VzmxUg+a8z5m/bp31cqG02cpq3Cuy62XM=","metadata":{},"hash":"RGj6Gt6DVFQsSLscAhGaNikq+ID4i+xySk58nDLVFkM="}},"hash":"Nw+gom3AQNB3GQ/aMeEgmGgLwR2w2WHYxiLdB+lQZsU=","text":"3.1.1.9 - Intercepting Routes\r\nDocumentation path: /02-app/01-building-your-application/01-routing/09-intercepting-routes\r\nDescription: Use intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced\r\nrouting patterns such as modals. Related:\r\nTitle: Next Steps\r\nRelated Description: Learn how to use modals with Intercepted and Parallel Routes. Links:\r\napp/building-your-application/routing/parallel-routes\r\nIntercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm\r\ncan be useful when you want to display the content of a route without the user switching to a different context. For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js\r\nintercepts the /photo/123 route, masks the URL, and overlays it over /feed. However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render\r\ninstead of the modal. No route interception should occur. Convention\r\nIntercepting routes can be defined with the (.. ) convention, which is similar to relative path convention ../ but for segments. You can use:\r\n(. ) to match segments on the same level\r\n(.. ) to match segments one level above\r\n(..)(.. ) to match segments two levels above","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"da46b5fe-b0a7-4b43-87ab-40e5451c1e55":{"id_":"da46b5fe-b0a7-4b43-87ab-40e5451c1e55","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DRTpYvPkZzmtBZDQRS+ejGu+ahkNpcYOsuYTo2iiGOg=","metadata":{},"hash":"ZIVTICjZ1vBsSwztr0CpdvDzNcWC3uxoEXxUNP81Vfs="}},"hash":"VbhQ+mqdfLmUKG4eQiXw5wGKWWIhdObT4PR2m8o1QK4=","text":"(... ) to match segments from the root app directory\r\nFor example, you can intercept the photo segment from within the feed segment by creating a (..)photo directory. Note that the (.. ) convention is based on route segments, not the file-system. Examples\r\nModals\r\nIntercepting Routes can be used together with Parallel Routes to create modals. Using this pattern to create modals overcomes some common challenges when working with modals, by allowing you to:\r\nMake the modal content shareable through a URL\r\nPreserve context when the page is refreshed, instead of closing the modal\r\nClose the modal on backwards navigation rather than going to the previous route\r\nReopen the modal on forwards navigation","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f3a38eb8-3563-43fd-bf0c-85786ffb9ecc":{"id_":"f3a38eb8-3563-43fd-bf0c-85786ffb9ecc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gypj9c5mRtm5G5IAFpk3p+WrPRZe8WVv/o3sqvgwX7A=","metadata":{},"hash":"L1sx9gmSIgye6f4lcqoN65I2RSCpZt2I12ll5gXig2Q="}},"hash":"jPBNWREUh/9DfqnWxzoB99tp/styTi7NdtcgCg2elaY=","text":"In the above example, the path to the photo segment can use the (.. ) matcher since @modal is a slot and not a segment. This\r\nmeans that the photo route is only one segment level higher, despite being two file-system levels higher. Other examples could include opening a login modal in a top navbar while also having a dedicated /login page, or opening a shopping\r\ncart in a side modal. View an example of modals with Intercepted and Parallel Routes.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a4a400b-138e-476e-bdd0-b9787e38a277":{"id_":"2a4a400b-138e-476e-bdd0-b9787e38a277","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Rg6A9jk7Kf7AqSAuqWjkDOcw9p90nGQYai/D0iAC3Cs=","metadata":{},"hash":"b8NF2HuhG4kR1zAXQTnI+wLuC1g5zCu7y0T7sT1lE2g="}},"hash":"YN9pyJBhStU8A5i0+h1GAaSpQMTe3m3y5vjd4tpImLk=","text":"3.1.1.10 - Route Handlers\r\nDocumentation path: /02-app/01-building-your-application/01-routing/10-route-handlers\r\nDescription: Create custom request handlers for a given route using the Web's Request and Response APIs. Related:\r\nTitle: API Reference\r\nRelated Description: Learn more about the route.js file. Links:\r\napp/api-reference/file-conventions/route\r\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. Good to know: Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside thepages\r\n directory meaning you do not need to use API Routes and Route Handlers together. Convention\r\nRoute Handlers are defined in a route.js|ts file inside the app directory:\r\napp/api/route.ts (ts)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET(request: Request) {}\r\napp/api/route.js (js)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET(request) {}\r\nRoute Handlers can be nested inside the app directory, similar to page.js and layout.js. But there cannot be a route.js file at the\r\nsame route segment level as page.js. Supported HTTP Methods\r\nThe following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called,\r\nNext.js will return a 405 Method Not Allowed response. Extended NextRequestNextRequest and NextResponseNextResponse APIs\r\nIn addition to supporting native Request and Response. Next.js extends them with NextRequest and NextResponse to provide\r\nconvenient helpers for advanced use cases. Behavior\r\nCaching\r\nRoute Handlers are cached by default when using the GET method with the Response object. app/items/route.ts (ts)export async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    headers: {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2b83a982-3467-4ab9-9069-88dd6b282ac5":{"id_":"2b83a982-3467-4ab9-9069-88dd6b282ac5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ip3rsuEYqJb7w7fKAkzMxpEO6FF/8bm4kmF7y+oq74U=","metadata":{},"hash":"C+Gy0Rk/KDoQZwyGF8HakH/H/hXvCPoZS1a9Qr/jhGQ="}},"hash":"+T+MtnrkBkNcT4Vq4s3lzns9w7Cs726iOL3DgG2X90s=","text":"'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n  })\r\n  const data = await res.json()\r\n  return Response.json({ data })\r\n}\r\napp/items/route.js (js)export async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n  })\r\n  const data = await res.json()\r\n  return Response.json({ data })\r\n}\r\nTypeScript Warning: Response.json() is only valid from TypeScript 5.2. If you use a lower TypeScript version, you can useNextResponse.json()\r\n for typed responses instead. Opting out of caching\r\nYou can opt out of caching by:\r\nUsing the Request object with the GET method. Using any of the other HTTP methods. Using Dynamic Functions like cookies and headers. The Segment Config Options manually specifies dynamic mode. For example:\r\napp/products/api/route.ts (ts)export async function GET(request: Request) {\r\n  const { searchParams } = new URL(request.url)\r\n  const id = searchParams.get('id')\r\n  const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY!,\r\n    },\r\n  })\r\n  const product = await res.json()\r\n  return Response.json({ product })\r\n}\r\napp/products/api/route.js (js)export async function GET(request) {\r\n  const { searchParams } = new URL(request.url)\r\n  const id = searchParams.get('id')\r\n  const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n  })\r\n  const product = await res.json()\r\n  return Response.json({ product })\r\n}\r\nSimilarly, the POST method will cause the Route Handler to be evaluated dynamically. app/items/route.ts (ts)export async function POST() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    method: 'POST',\r\n    headers: {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cc9e6f64-16dc-4769-897f-da72daff19cd":{"id_":"cc9e6f64-16dc-4769-897f-da72daff19cd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cc3clS+nFD+KzkLQv1mRYO402onpxFF1/lFX1QIcaYM=","metadata":{},"hash":"WSjQRATXIt0kJW49xuEi6z/4I9fcqt1DwW3Czl2O6DY="}},"hash":"C3o9MMRbZwujdwI0Ors9U11IhPnzLS/kzhP348QIP2I=","text":"'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY!,\r\n    },\r\n    body: JSON.stringify({ time: new Date().toISOString() }),\r\n  })\r\n  const data = await res.json()\r\n  return Response.json(data)\r\n}\r\napp/items/route.js (js)export async function POST() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n    body: JSON.stringify({ time: new Date().toISOString() }),\r\n  })\r\n  const data = await res.json()\r\n  return Response.json(data)\r\n}\r\nGood to know: Like API Routes, Route Handlers can be used for cases like handling form submissions. A new abstraction for\r\nhandling forms and mutations that integrates deeply with React is being worked on. Route Resolution\r\nYou can consider a route the lowest level routing primitive. They do not participate in layouts or client-side navigations like page. There cannot be a route.js file at the same route as page.js. PageRouteResult\r\napp/page.jsapp/route.jsConflict\r\napp/page.jsapp/api/route.jsValid\r\napp/[user]/page.jsapp/api/route.jsValid\r\nEach route.js or page.js file takes over all HTTP verbs for that route. app/page.js (jsx)export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\n// \u0000 Conflict\r\n// `app/route.js`\r\nexport async function POST(request) {}\r\nExamples\r\nThe following examples show how to combine Route Handlers with other Next.js APIs and features. Revalidating Cached Data\r\nYou can revalidate cached data using the next.revalidate option:\r\napp/items/route.ts (ts)export async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    next: { revalidate: 60 }, // Revalidate every 60 seconds\r\n  })\r\n  const data = await res.json()","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a72229b6-9c63-4032-9a1d-e0e14e7c4b53":{"id_":"a72229b6-9c63-4032-9a1d-e0e14e7c4b53","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HhVzcmz6Ik2Y/EznnLvezS7P6ATGHzxO7LSBhtOVxh0=","metadata":{},"hash":"kHQa62l+dFiCu95FQbZHSLCPDKB1Z1yjmJN1GC8QqUg="}},"hash":"KaEMbx5f8pW8LrBbJ47Gbug5g4vSfOnPh4xC96YUoL8=","text":"return Response.json(data)\r\n}\r\napp/items/route.js (js)export async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    next: { revalidate: 60 }, // Revalidate every 60 seconds\r\n  })\r\n  const data = await res.json()\r\n  return Response.json(data)\r\n}\r\nAlternatively, you can use the revalidate segment config option:\r\nexport const revalidate = 60\r\nDynamic Functions\r\nRoute Handlers can be used with dynamic functions from Next.js, like cookies and headers. Cookies\r\nYou can read or set cookies with cookies from next/headers. This server function can be called directly in a Route Handler, or\r\nnested inside of another function. Alternatively, you can return a new Response using the Set-Cookie header. app/api/route.ts (ts)import { cookies } from 'next/headers'\r\nexport async function GET(request: Request) {\r\n  const cookieStore = cookies()\r\n  const token = cookieStore.get('token')\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { 'Set-Cookie': `token=${token.value}` },\r\n  })\r\n}\r\napp/api/route.js (js)import { cookies } from 'next/headers'\r\nexport async function GET(request) {\r\n  const cookieStore = cookies()\r\n  const token = cookieStore.get('token')\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { 'Set-Cookie': `token=${token}` },\r\n  })\r\n}\r\nYou can also use the underlying Web APIs to read cookies from the request (NextRequest):\r\napp/api/route.ts (ts)import { type NextRequest } from 'next/server'\r\nexport async function GET(request: NextRequest) {\r\n  const token = request.cookies.get('token')\r\n}\r\napp/api/route.js (js)export async function GET(request) {\r\n  const token = request.cookies.get('token')\r\n}\r\nHeaders\r\nYou can read headers with headers from next/headers. This server function can be called directly in a Route Handler, or nested\r\ninside of another function.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"676c45fd-578d-472d-ad47-9898e9a0b417":{"id_":"676c45fd-578d-472d-ad47-9898e9a0b417","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"s8t7t/qukGCh6HdnBz8RjgYAyaL0h8Px8R+dumxikFI=","metadata":{},"hash":"Q8fKAKnF0KgQGePmDLkjfHT6ytulY9RZJEdEXAGeuMk="}},"hash":"ybmIxWnok/fQ2MKri2vJ2wfJXXnoXRb/XPHgU8UU1gU=","text":"This headers instance is read-only. To set headers, you need to return a new Response with new headers. app/api/route.ts (ts)import { headers } from 'next/headers'\r\nexport async function GET(request: Request) {\r\n  const headersList = headers()\r\n  const referer = headersList.get('referer')\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { referer: referer },\r\n  })\r\n}\r\napp/api/route.js (js)import { headers } from 'next/headers'\r\nexport async function GET(request) {\r\n  const headersList = headers()\r\n  const referer = headersList.get('referer')\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { referer: referer },\r\n  })\r\n}\r\nYou can also use the underlying Web APIs to read headers from the request (NextRequest):\r\napp/api/route.ts (ts)import { type NextRequest } from 'next/server'\r\nexport async function GET(request: NextRequest) {\r\n  const requestHeaders = new Headers(request.headers)\r\n}\r\napp/api/route.js (js)export async function GET(request) {\r\n  const requestHeaders = new Headers(request.headers)\r\n}\r\nRedirects\r\napp/api/route.ts (ts)import { redirect } from 'next/navigation'\r\nexport async function GET(request: Request) {\r\n  redirect('https://nextjs.org/')\r\n}\r\napp/api/route.js (js)import { redirect } from 'next/navigation'\r\nexport async function GET(request) {\r\n  redirect('https://nextjs.org/')\r\n}\r\nDynamic Route Segments\r\nWe recommend reading the Defining Routes page before continuing. Route Handlers can use Dynamic Segments to create request handlers from dynamic data. app/items/[slug]/route.ts (ts)export async function GET(\r\n  request: Request,\r\n  { params }: { params: { slug: string } }\r\n) {\r\n  const slug = params.slug // 'a', 'b', or 'c'\r\n}\r\napp/items/[slug]/route.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"320df056-47d6-461d-b77c-d29569d41bcd":{"id_":"320df056-47d6-461d-b77c-d29569d41bcd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JJARLOxaySBqllezK0tJ9OdN4gVbZlYCzfSUR0K+xWk=","metadata":{},"hash":"IFAPyYZUkM9YF0lqH9ds0R4FjvGyaiYRdKydM0ljax8="}},"hash":"MMgvp0mDjtMp6h98mPAugm4UBPgajkKjDYySmV7hCZk=","text":"export async function GET(request, { params }) {\r\n  const slug = params.slug // 'a', 'b', or 'c'\r\n}\r\nRouteExample URLparamsparams\r\napp/items/[slug]/route.js/items/a{ slug: 'a' }\r\napp/items/[slug]/route.js/items/b{ slug: 'b' }\r\napp/items/[slug]/route.js/items/c{ slug: 'c' }\r\nURL Query Parameters\r\nThe request object passed to the Route Handler is a NextRequest instance, which has some additional convenience methods,\r\nincluding for more easily handling query parameters. app/api/search/route.ts (ts)import { type NextRequest } from 'next/server'\r\nexport function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const query = searchParams.get('query')\r\n  // query is \"hello\" for /api/search?query=hello\r\n}\r\napp/api/search/route.js (js)export function GET(request) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const query = searchParams.get('query')\r\n  // query is \"hello\" for /api/search?query=hello\r\n}\r\nStreaming\r\nStreaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more\r\nabout the AI SDK. app/api/chat/route.ts (ts)import OpenAI from 'openai'\r\nimport { OpenAIStream, StreamingTextResponse } from 'ai'\r\nconst openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n})\r\nexport const runtime = 'edge'\r\nexport async function POST(req: Request) {\r\n  const { messages } = await req.json()\r\n  const response = await openai.chat.completions.create({\r\n    model: 'gpt-3.5-turbo',\r\n    stream: true,\r\n    messages,\r\n  })\r\n  const stream = OpenAIStream(response)\r\n  return new StreamingTextResponse(stream)\r\n}\r\napp/api/chat/route.js (js)import OpenAI from 'openai'\r\nimport { OpenAIStream, StreamingTextResponse } from 'ai'\r\nconst openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n})\r\nexport const runtime = 'edge'\r\nexport async function POST(req) {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"75e6365b-bf7f-4f6c-b985-19b965c33dea":{"id_":"75e6365b-bf7f-4f6c-b985-19b965c33dea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pKV0EOW/+gaScoi5cnvk47d2L7nyp+oPJZbLcvzBEP0=","metadata":{},"hash":"GgOHkFWYbknBuzihYiqRJFV6GhuzouxrMNodvFU6H5I="}},"hash":"eQG0rDb1GukZs3P2YbV3St23mAv+ZXwsil/M4EAIGOg=","text":"const { messages } = await req.json()\r\n  const response = await openai.chat.completions.create({\r\n    model: 'gpt-3.5-turbo',\r\n    stream: true,\r\n    messages,\r\n  })\r\n  const stream = OpenAIStream(response)\r\n  return new StreamingTextResponse(stream)\r\n}\r\nThese abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly. app/api/route.ts (ts)// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\r\nfunction iteratorToStream(iterator: any) {\r\n  return new ReadableStream({\r\n    async pull(controller) {\r\n      const { value, done } = await iterator.next()\r\n      if (done) {\r\n        controller.close()\r\n      } else {\r\n        controller.enqueue(value)\r\n      }\r\n    },\r\n  })\r\n}\r\nfunction sleep(time: number) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\nconst encoder = new TextEncoder()\r\nasync function* makeIterator() {\r\n  yield encoder.encode('<p>One</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Two</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Three</p>')\r\n}\r\nexport async function GET() {\r\n  const iterator = makeIterator()\r\n  const stream = iteratorToStream(iterator)\r\n  return new Response(stream)\r\n}\r\napp/api/route.js (js)// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\r\nfunction iteratorToStream(iterator) {\r\n  return new ReadableStream({\r\n    async pull(controller) {\r\n      const { value, done } = await iterator.next()\r\n      if (done) {\r\n        controller.close()\r\n      } else {\r\n        controller.enqueue(value)\r\n      }\r\n    },\r\n  })\r\n}\r\nfunction sleep(time) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\nconst encoder = new TextEncoder()","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"df317275-1b34-44e5-992d-46917bef9f9b":{"id_":"df317275-1b34-44e5-992d-46917bef9f9b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J1ueuL3203vBGBEIhu1enLhRXw1H1NxZeFg6aWiS3bg=","metadata":{},"hash":"W5CZFk9QDoxVvGcF23LEL0zpHI/tni7UvsODLF7r1gQ="}},"hash":"vhYeRZVSGUdSgEot5peosuXiPJMSm9qURHI8SkF9zEg=","text":"async function* makeIterator() {\r\n  yield encoder.encode('<p>One</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Two</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Three</p>')\r\n}\r\nexport async function GET() {\r\n  const iterator = makeIterator()\r\n  const stream = iteratorToStream(iterator)\r\n  return new Response(stream)\r\n}\r\nRequest Body\r\nYou can read the Request body using the standard Web API methods:\r\napp/items/route.ts (ts)export async function POST(request: Request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}\r\napp/items/route.js (js)export async function POST(request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}\r\nRequest Body FormData\r\nYou can read the FormData using the request.formData() function:\r\napp/items/route.ts (ts)export async function POST(request: Request) {\r\n  const formData = await request.formData()\r\n  const name = formData.get('name')\r\n  const email = formData.get('email')\r\n  return Response.json({ name, email })\r\n}\r\napp/items/route.js (js)export async function POST(request) {\r\n  const formData = await request.formData()\r\n  const name = formData.get('name')\r\n  const email = formData.get('email')\r\n  return Response.json({ name, email })\r\n}\r\nSince formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you\r\nprefer (e.g. number). CORS\r\nYou can set CORS headers on a Response using the standard Web API methods:\r\napp/api/route.ts (ts)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET(request: Request) {\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n    },\r\n  })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cb880238-47a2-4be9-b821-e1192389ec8e":{"id_":"cb880238-47a2-4be9-b821-e1192389ec8e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/wOF54KaeS2244XxoUKwiKoBC48fx0usZyiQIc7aEuo=","metadata":{},"hash":"bbH5S4u1yPrOZvu/F1lJg5Mn0XvodrjQo5MpZBjgUO0="},"NEXT":{"nodeId":"7b0502d8-f31f-427a-99f1-7d6e19db1737","metadata":{},"hash":"huL9+NoggFHKW8a2dKCD3KxB9hIxsW+zmwUjQ2hUYE8="}},"hash":"UR2A70RNx6jCIv0BD9bcW9uaPTAqy975VN1HnGbOsVo=","text":"app/api/route.js (js)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET(request) {\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n    },\r\n  })\r\n}\r\nEdge and Node.js Runtimes\r\nRoute Handlers have an isomorphic Web API to support both Edge and Node.js runtimes seamlessly, including support for streaming. Since Route Handlers use the same route segment configuration as Pages and Layouts, they support long-awaited features like general-\r\npurpose statically regenerated Route Handlers. You can use the runtime segment config option to specify the runtime:\r\nexport const runtime = 'edge' // 'nodejs' is the default\r\nNon-UI Responses\r\nYou can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all\r\nhave built-in support. app/rss.xml/route.ts (ts)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET() {\r\n  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n<channel>\r\n  <title>Next.js Documentation</title>\r\n  <link>https://nextjs.org/docs</link>\r\n  <description>The React Framework for the Web</description>\r\n</channel>\r\n</rss>`)\r\n}\r\napp/rss.xml/route.js (js)export const dynamic = 'force-dynamic' // defaults to auto\r\nexport async function GET() {\r\n  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n<channel>\r\n  <title>Next.js Documentation</title>\r\n  <link>https://nextjs.org/docs</link>\r\n  <description>The React Framework for the Web</description>\r\n</channel>\r\n</rss>`)\r\n}\r\nSegment Config Options\r\nRoute Handlers use the same route segment configuration as pages and layouts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b0502d8-f31f-427a-99f1-7d6e19db1737":{"id_":"7b0502d8-f31f-427a-99f1-7d6e19db1737","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/wOF54KaeS2244XxoUKwiKoBC48fx0usZyiQIc7aEuo=","metadata":{},"hash":"bbH5S4u1yPrOZvu/F1lJg5Mn0XvodrjQo5MpZBjgUO0="},"PREVIOUS":{"nodeId":"cb880238-47a2-4be9-b821-e1192389ec8e","metadata":{},"hash":"UR2A70RNx6jCIv0BD9bcW9uaPTAqy975VN1HnGbOsVo="}},"hash":"huL9+NoggFHKW8a2dKCD3KxB9hIxsW+zmwUjQ2hUYE8=","text":"app/items/route.ts (ts)export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'\r\napp/items/route.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1686fdad-d6d9-430e-8247-2ea26619a2cd":{"id_":"1686fdad-d6d9-430e-8247-2ea26619a2cd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MqExIRpRkgSMwoJo+aodukuF+TWWhrwRRgyI01Gp464=","metadata":{},"hash":"gHpqBgWV4iV3S57Wpa7Ymr+1zLiTJIsYklbjj4zMnDs="}},"hash":"WR7wx6QzGajcEqQ5iVFJcPDLvfVB4bAG/ETpLk1fcsA=","text":"export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'\r\nSee the API reference for more details.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e27ba7ef-596e-4dbe-bcc4-852e0a00689f":{"id_":"e27ba7ef-596e-4dbe-bcc4-852e0a00689f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ldnn/DrAGzKTgB1w/5gWk/23Bw0DUnrAwncCejNxNyk=","metadata":{},"hash":"O/zpkKFXraWwraqpdrwUu+RREe9OIvyu2bgddGgm1Z8="},"NEXT":{"nodeId":"bd56a259-1089-42c7-a224-e35d302d4412","metadata":{},"hash":"jhSvvLI5IToPp57UkgW2J2Q3Ok4suLXopcerw/wOqvg="}},"hash":"Z+03IJ0WZtEWhCsqsn7JsjtX0xJhEfayeMPKva8YQ+Y=","text":"3.1.1.11 - Middleware\r\nDocumentation path: /02-app/01-building-your-application/01-routing/11-middleware\r\nDescription: Learn how to use Middleware to run code before a request is completed. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nMiddleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response\r\nby rewriting, redirecting, modifying the request or response headers, or responding directly. Middleware runs before cached content and routes are matched. See Matching Paths for more details. Convention\r\nUse the file middleware.ts (or .js) in the root of your project to define Middleware. For example, at the same level as pages or app,\r\nor inside src if applicable. Example\r\nmiddleware.ts (ts)import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n// This function can be marked `async` if using `await` inside\r\nexport function middleware(request: NextRequest) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n// See \"Matching Paths\" below to learn more\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}\r\nmiddleware.js (js)import { NextResponse } from 'next/server'\r\n// This function can be marked `async` if using `await` inside\r\nexport function middleware(request) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n// See \"Matching Paths\" below to learn more\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}\r\nMatching Paths\r\nMiddleware will be invoked for every route in your project. The following is the execution order:\r\n1. headers from next.config.js\r\n2. redirects from next.config.js\r\n3. Middleware (rewrites, redirects, etc. )\r\n4. beforeFiles (rewrites) from next.config.js\r\n5. Filesystem routes (public/, _next/static/, pages/, app/, etc. )\r\n6. afterFiles (rewrites) from next.config.js\r\n7. Dynamic Routes (/blog/[slug])\r\n8.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bd56a259-1089-42c7-a224-e35d302d4412":{"id_":"bd56a259-1089-42c7-a224-e35d302d4412","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ldnn/DrAGzKTgB1w/5gWk/23Bw0DUnrAwncCejNxNyk=","metadata":{},"hash":"O/zpkKFXraWwraqpdrwUu+RREe9OIvyu2bgddGgm1Z8="},"PREVIOUS":{"nodeId":"e27ba7ef-596e-4dbe-bcc4-852e0a00689f","metadata":{},"hash":"Z+03IJ0WZtEWhCsqsn7JsjtX0xJhEfayeMPKva8YQ+Y="}},"hash":"jhSvvLI5IToPp57UkgW2J2Q3Ok4suLXopcerw/wOqvg=","text":"Dynamic Routes (/blog/[slug])\r\n8. fallback (rewrites) from next.config.js\r\nThere are two ways to define which paths Middleware will run on:\r\n1. Custom matcher config\r\n2. Conditional statements\r\nMatcher","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6141c6a2-5c00-4dce-a069-476bab82c28c":{"id_":"6141c6a2-5c00-4dce-a069-476bab82c28c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/z77yEi5+wj6YiXzpu9MEPN+Qt6tDflgpTzE+uDZdyc=","metadata":{},"hash":"KTnedKMNHbxTIvRUKVYk9qZYOO//+RR/MIfiWuJWMY8="},"NEXT":{"nodeId":"4b63e94c-315b-4815-9ced-bb0c0145e982","metadata":{},"hash":"gUYRS8u8gNT7RX9d1Bf8uo7H+dbgcZLhphxt+JHg4/4="}},"hash":"qhLGQfAIcMgHgsfAIweyfWBQGB9bkHVpmxBTmci/pZY=","text":"matcher allows you to filter Middleware to run on specific paths. middleware.js (js)export const config = {\r\n  matcher: '/about/:path*',\r\n}\r\nYou can match a single path or multiple paths with an array syntax:\r\nmiddleware.js (js)export const config = {\r\n  matcher: ['/about/:path*', '/dashboard/:path*'],\r\n}\r\nThe matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a\r\nnegative lookahead to match all except specific paths can be seen here:\r\nmiddleware.js (js)export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n  ],\r\n}\r\nYou can also ignore prefetches (from next/link) that don’t need to go through the Middleware using the missing array:\r\nmiddleware.js (js)export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    {\r\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n  ],\r\n}\r\nGood to know: The matcher values need to be constants so they can be statically analyzed at build-time. Dynamic values such\r\nas variables will be ignored. Configured matchers:\r\n1. MUST start with /\r\n2. Can include named parameters: /about/:path matches /about/a and /about/b but not /about/a/c\r\n3. Can have modifiers on named parameters (starting with :): /about/:path* matches /about/a/b/c because * is zero or more. ? is\r\nzero or one and + one or more\r\n4.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4b63e94c-315b-4815-9ced-bb0c0145e982":{"id_":"4b63e94c-315b-4815-9ced-bb0c0145e982","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/z77yEi5+wj6YiXzpu9MEPN+Qt6tDflgpTzE+uDZdyc=","metadata":{},"hash":"KTnedKMNHbxTIvRUKVYk9qZYOO//+RR/MIfiWuJWMY8="},"PREVIOUS":{"nodeId":"6141c6a2-5c00-4dce-a069-476bab82c28c","metadata":{},"hash":"qhLGQfAIcMgHgsfAIweyfWBQGB9bkHVpmxBTmci/pZY="}},"hash":"gUYRS8u8gNT7RX9d1Bf8uo7H+dbgcZLhphxt+JHg4/4=","text":"? is\r\nzero or one and + one or more\r\n4. Can use regular expression enclosed in parenthesis: /about/(.*) is the same as /about/:path*\r\nRead more details on path-to-regexp documentation. Good to know: For backward compatibility, Next.js always considers /public as /public/index. Therefore, a matcher of/public/:path\r\n will match. Conditional Statements\r\nmiddleware.ts (ts)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"268f29f0-0e2e-429a-b0e0-5e718ae5750f":{"id_":"268f29f0-0e2e-429a-b0e0-5e718ae5750f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jcD2J+w4IfJWcea8MQxIuPVLIcmdgQOWIWQVIjFFits=","metadata":{},"hash":"LqUt1D3h/7lwLO/6hDcdiZ35lNsm1uOuFABeaM/mO3k="},"NEXT":{"nodeId":"b0832163-f9b4-4903-9852-bb57a0d4dc02","metadata":{},"hash":"3jdOB2dArFvg/1LAtIBg45ihrBr2EbDM6HVlTb1VWKE="}},"hash":"hp7MWhUny5Do+jS4VWCEd0LELEKkwc9nK29J8XMyDIk=","text":"import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nexport function middleware(request: NextRequest) {\r\n  if (request.nextUrl.pathname.startsWith('/about')) {\r\n    return NextResponse.rewrite(new URL('/about-2', request.url))\r\n  }\r\n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\r\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\r\n  }\r\n}\r\nmiddleware.js (js)import { NextResponse } from 'next/server'\r\nexport function middleware(request) {\r\n  if (request.nextUrl.pathname.startsWith('/about')) {\r\n    return NextResponse.rewrite(new URL('/about-2', request.url))\r\n  }\r\n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\r\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\r\n  }\r\n}\r\nNextResponse\r\nThe NextResponse API allows you to:\r\nredirect the incoming request to a different URL\r\nrewrite the response by displaying a given URL\r\nSet request headers for API Routes, getServerSideProps, and rewrite destinations\r\nSet response cookies\r\nSet response headers\r\nTo produce a response from Middleware, you can:\r\n1. rewrite to a route (Page or Route Handler) that produces a response\r\n2. return a NextResponse directly. See Producing a Response\r\nTo produce a response from Middleware, you can:\r\n1. rewrite to a route (Page or Edge API Route) that produces a response\r\n2. return a NextResponse directly. See Producing a Response\r\nUsing Cookies\r\nCookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and\r\nNextResponse. 1. For incoming requests, cookies comes with the following methods: get, getAll, set, and delete cookies. You can check for the\r\nexistence of a cookie with has or remove all cookies with clear. 2. For outgoing responses, cookies have the following methods get, getAll, set, and delete.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b0832163-f9b4-4903-9852-bb57a0d4dc02":{"id_":"b0832163-f9b4-4903-9852-bb57a0d4dc02","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jcD2J+w4IfJWcea8MQxIuPVLIcmdgQOWIWQVIjFFits=","metadata":{},"hash":"LqUt1D3h/7lwLO/6hDcdiZ35lNsm1uOuFABeaM/mO3k="},"PREVIOUS":{"nodeId":"268f29f0-0e2e-429a-b0e0-5e718ae5750f","metadata":{},"hash":"hp7MWhUny5Do+jS4VWCEd0LELEKkwc9nK29J8XMyDIk="}},"hash":"3jdOB2dArFvg/1LAtIBg45ihrBr2EbDM6HVlTb1VWKE=","text":"For outgoing responses, cookies have the following methods get, getAll, set, and delete. middleware.ts (ts)import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nexport function middleware(request: NextRequest) {\r\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\r\n  // Getting cookies from the request using the `RequestCookies` API\r\n  let cookie = request.cookies.get('nextjs')\r\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\r\n  const allCookies = request.cookies.getAll()\r\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\r\n  request.cookies.has('nextjs') // => true","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"86ed672f-b83e-4a5f-97fb-c6a3ee2a50b5":{"id_":"86ed672f-b83e-4a5f-97fb-c6a3ee2a50b5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"66FBXkx9x6zCU+lsOKchAOfrFHx8qF8lta+8fKwB7VM=","metadata":{},"hash":"Sn8sjGq/tr/G/rheiR+v5U8k1gk0bE1Xfqt9/CWeOIc="},"NEXT":{"nodeId":"c029522c-2758-4e6a-bad4-8cdb4de2a581","metadata":{},"hash":"e0w6ZdodBZdwrOFrXiYjifpG23PLDZDpUHQAN2g6ABI="}},"hash":"kjOpv39BWSns23jZssjimC5X/yrVd6lFx++sSPG39T8=","text":"request.cookies.delete('nextjs')\r\n  request.cookies.has('nextjs') // => false\r\n  // Setting cookies on the response using the `ResponseCookies` API\r\n  const response = NextResponse.next()\r\n  response.cookies.set('vercel', 'fast')\r\n  response.cookies.set({\r\n    name: 'vercel',\r\n    value: 'fast',\r\n    path: '/',\r\n  })\r\n  cookie = response.cookies.get('vercel')\r\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\r\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header. return response\r\n}\r\nmiddleware.js (js)import { NextResponse } from 'next/server'\r\nexport function middleware(request) {\r\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\r\n  // Getting cookies from the request using the `RequestCookies` API\r\n  let cookie = request.cookies.get('nextjs')\r\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\r\n  const allCookies = request.cookies.getAll()\r\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\r\n  request.cookies.has('nextjs') // => true\r\n  request.cookies.delete('nextjs')\r\n  request.cookies.has('nextjs') // => false\r\n  // Setting cookies on the response using the `ResponseCookies` API\r\n  const response = NextResponse.next()\r\n  response.cookies.set('vercel', 'fast')\r\n  response.cookies.set({\r\n    name: 'vercel',\r\n    value: 'fast',\r\n    path: '/',\r\n  })\r\n  cookie = response.cookies.get('vercel')\r\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\r\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header. return response\r\n}\r\nSetting Headers\r\nYou can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c029522c-2758-4e6a-bad4-8cdb4de2a581":{"id_":"c029522c-2758-4e6a-bad4-8cdb4de2a581","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"66FBXkx9x6zCU+lsOKchAOfrFHx8qF8lta+8fKwB7VM=","metadata":{},"hash":"Sn8sjGq/tr/G/rheiR+v5U8k1gk0bE1Xfqt9/CWeOIc="},"PREVIOUS":{"nodeId":"86ed672f-b83e-4a5f-97fb-c6a3ee2a50b5","metadata":{},"hash":"kjOpv39BWSns23jZssjimC5X/yrVd6lFx++sSPG39T8="}},"hash":"e0w6ZdodBZdwrOFrXiYjifpG23PLDZDpUHQAN2g6ABI=","text":"middleware.ts (ts)import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nexport function middleware(request: NextRequest) {\r\n  // Clone the request headers and set a new header `x-hello-from-middleware1`\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-hello-from-middleware1', 'hello')\r\n  // You can also set request headers in NextResponse.rewrite\r\n  const response = NextResponse.next({\r\n    request: {\r\n      // New request headers\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  // Set a new response header `x-hello-from-middleware2`\r\n  response.headers.set('x-hello-from-middleware2', 'hello')\r\n  return response\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f86ff1dd-5a36-4817-a730-4bb2d2ede4ee":{"id_":"f86ff1dd-5a36-4817-a730-4bb2d2ede4ee","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"giM9KM30DODskYvtP9dirmQaPCUKRBQ0SkZxb7fEhDI=","metadata":{},"hash":"quqpsQ205xzH9bteKdDylvGkBuAS3WBkRHJUm45OMe8="}},"hash":"4pCP9tFAkRb3sf2TKyfKzo5as2GYSHAbAOJFjGt5eFg=","text":"middleware.js (js)import { NextResponse } from 'next/server'\r\nexport function middleware(request) {\r\n  // Clone the request headers and set a new header `x-hello-from-middleware1`\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-hello-from-middleware1', 'hello')\r\n  // You can also set request headers in NextResponse.rewrite\r\n  const response = NextResponse.next({\r\n    request: {\r\n      // New request headers\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  // Set a new response header `x-hello-from-middleware2`\r\n  response.headers.set('x-hello-from-middleware2', 'hello')\r\n  return response\r\n}\r\nGood to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your\r\nbackend web server configuration. Producing a Response\r\nYou can respond from Middleware directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0)\r\nmiddleware.ts (ts)import { NextRequest } from 'next/server'\r\nimport { isAuthenticated } from '@lib/auth'\r\n// Limit the middleware to paths starting with `/api/`\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\nexport function middleware(request: NextRequest) {\r\n  // Call our authentication function to check the request\r\n  if (!isAuthenticated(request)) {\r\n    // Respond with JSON indicating an error message\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}\r\nmiddleware.js (js)import { isAuthenticated } from '@lib/auth'\r\n// Limit the middleware to paths starting with `/api/`\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\nexport function middleware(request) {\r\n  // Call our authentication function to check the request\r\n  if (!isAuthenticated(request)) {\r\n    // Respond with JSON indicating an error message\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}\r\nwaitUntilwaitUntil and NextFetchEventNextFetchEvent\r\nThe NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method. The waitUntil() method takes a promise as an argument, and extends the lifetime of the Middleware until the promise settles. This is\r\nuseful for performing work in the background.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4ca99b4e-9283-495e-9ce5-4b319726c7b2":{"id_":"4ca99b4e-9283-495e-9ce5-4b319726c7b2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jlWNH3K+7SGjYHCN7Qgja0wXMTJ4EmP//EnAWNTvVO0=","metadata":{},"hash":"/24k2pViZl1VMKtXm7oKwMHz/Se7EtT3ViZugJfqD3k="}},"hash":"0RlCgF+rhICJbTo2HzWSMoqddk6JQKTtKudOToTzwE8=","text":"middleware.ts (ts)import { NextResponse } from 'next/server'\r\nimport type { NextFetchEvent, NextRequest } from 'next/server'\r\nexport function middleware(req: NextRequest, event: NextFetchEvent) {\r\n  event.waitUntil(\r\n    fetch('https://my-analytics-platform.com', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ pathname: req.nextUrl.pathname }),\r\n    })\r\n  )\r\n  return NextResponse.next()\r\n}\r\nAdvanced Middleware Flags\r\nIn v13.1 of Next.js two additional flags were introduced for middleware, skipMiddlewareUrlNormalize and\r\nskipTrailingSlashRedirect to handle advanced use cases. skipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside\r\nmiddleware to maintain the trailing slash for some paths but not others, which can make incremental migrations easier. next.config.js (js)module.exports = {\r\n  skipTrailingSlashRedirect: true,\r\n}\r\nmiddleware.js (js)const legacyPrefixes = ['/docs', '/blog']\r\nexport default async function middleware(req) {\r\n  const { pathname } = req.nextUrl\r\n  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {\r\n    return NextResponse.next()\r\n  }\r\n  // apply trailing slash handling\r\n  if (\r\n    !pathname.endsWith('/') &&\r\n    !pathname.match(/((?!\\.well-known(?:\\/.*)?)(?:[^/]+\\/)*[^/]+\\.\\w+)/)\r\n  ) {\r\n    req.nextUrl.pathname += '/'\r\n    return NextResponse.redirect(req.nextUrl)\r\n  }\r\n}\r\nskipMiddlewareUrlNormalize allows disabling the URL normalizing Next.js does to make handling direct visits and client-transitions\r\nthe same. There are some advanced cases where you need full control using the original URL which this unlocks. next.config.js (js)module.exports = {\r\n  skipMiddlewareUrlNormalize: true,\r\n}\r\nmiddleware.js (js)export default async function middleware(req) {\r\n  const { pathname } = req.nextUrl\r\n  // GET /_next/data/build-id/hello.json\r\n  console.log(pathname)\r\n  // with the flag this now /_next/data/build-id/hello.json\r\n  // without the flag this would be normalized to /hello\r\n}\r\nRuntime\r\nMiddleware currently only supports the Edge runtime. The Node.js runtime can not be used.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"abf018ae-3962-4ed3-a6cd-413391d18e07":{"id_":"abf018ae-3962-4ed3-a6cd-413391d18e07","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DU/aF67TQGFnmwSv8pwOv0NZrKyNQUmUXMogtOlzHlU=","metadata":{},"hash":"s43+cKRWBQDDoCgaE3ntxpPzutChA9RKKU+QXxXg+7U="}},"hash":"wPa3C4QsOB793/1JxRVjL8dcLfY1W4bxYqn4+d10i+k=","text":"Version History\r\nVersionChanges\r\nv13.1.0Advanced Middleware flags added\r\nv13.0.0Middleware can modify request headers, response headers, and send responses\r\nv12.2.0Middleware is stable, please see the upgrade guide\r\nv12.0.9Enforce absolute URLs in Edge Runtime (PR)\r\nv12.0.0Middleware (Beta) added","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"661b8199-fc6c-4315-aa4c-c0404c877a8a":{"id_":"661b8199-fc6c-4315-aa4c-c0404c877a8a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EIKpXCKEayEVK5IXMPfdRlLJDn6urmdBqkwGOYNi/1o=","metadata":{},"hash":"isJuGydAI9qtoRRQTlvYK6ii2j6z9Lz8yCyckAp/o50="}},"hash":"Z6BWrCQh26LNP+kNuzQSR0yxe7o9xTMaO0COqo19EVE=","text":"3.1.1.12 - Project Organization and File Colocation\r\nDocumentation path: /02-app/01-building-your-application/01-routing/12-colocation\r\nDescription: Learn how to organize your Next.js project and colocate files. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/building-your-application/routing/defining-routes\r\napp/building-your-application/routing/route-groups\r\napp/building-your-application/configuring/src-directory\r\napp/building-your-application/configuring/absolute-imports-and-module-aliases\r\nApart from routing folder and file conventions, Next.js is unopinionated about how you organize and colocate your project files. This page shares default behavior and features you can use to organize your project. Safe colocation by default\r\nProject organization features\r\nProject organization strategies\r\nSafe colocation by default\r\nIn the app directory, nested folder hierarchy defines route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path. However, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file\r\nis added to a route segment. And, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client. This means that project files can be safely colocated inside route segments in the app directory without accidentally being routable.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"774fcbc8-1674-4740-b8c1-7929dca7ba51":{"id_":"774fcbc8-1674-4740-b8c1-7929dca7ba51","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fprBoklm0MaYqWizb7qZFLMIAnQMVJJkS/7r9C9mkbI=","metadata":{},"hash":"+XZHBemIIgX7vdcIhZHxXbOKsym9EsrfsjaxSKOy8C0="}},"hash":"nF1wWD3FUSUifdNMyn5kQ3wTjZ7qpH6ZZkXsqcP43sA=","text":"Good to know:\r\nThis is different from the pages directory, where any file in pages is considered a route. While you can colocate your project files in app you don’t have to. If you prefer, you can keep them outside the app\r\ndirectory. Project organization features\r\nNext.js provides several features to help you organize your project. Private Folders\r\nPrivate folders can be created by prefixing a folder with an underscore: _folderName\r\nThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the\r\nfolder and all its subfolders out of routing.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5a69e09f-c1c2-472d-a34f-f0c16021e511":{"id_":"5a69e09f-c1c2-472d-a34f-f0c16021e511","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/HnSWNWhXFYd6XQdhQlIuKicMGEFCVT91uRnBcbF8Cs=","metadata":{},"hash":"AaCYqcfMNScwV+QdazSTOsfvLaGzW6LQ0uBaNFYYqe8="}},"hash":"fM0aN3get9p5fJU1TvahLFqUajo/U4WTEfgJqnCOOg4=","text":"Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be\r\nuseful for:\r\nSeparating UI logic from routing logic. Consistently organizing internal files across a project and the Next.js ecosystem. Sorting and grouping files in code editors. Avoiding potential naming conflicts with future Next.js file conventions. Good to know\r\nWhile not a framework convention, you might also consider marking files outside private folders as “private” using the same\r\nunderscore pattern. You can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of\r\nan underscore): %5FfolderName. If you don’t use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming\r\nconflicts. Route Groups\r\nRoute groups can be created by wrapping a folder in parenthesis: (folderName)\r\nThis indicates the folder is for organizational purposes and should not be included in the route’s URL path.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4d6e8c33-efe5-45c1-9bce-b7f88df0834a":{"id_":"4d6e8c33-efe5-45c1-9bce-b7f88df0834a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"FpZXu8k5FRMHHtF8PcM3NGb8b/itTD5hfhbKn2fJFWs=","metadata":{},"hash":"kGBGc7YGetQLMcUiOjHoN2XfrBQpV7JE1xZbmAXN0bs="}},"hash":"tAaFT00YmnBdGUKcZxL9VkZr1+VW61kFg/tH0UyEWNc=","text":"Route groups are useful for:\r\nOrganizing routes into groups e.g. by site section, intent, or team. Enabling nested layouts in the same route segment level:\r\nCreating multiple nested layouts in the same segment, including multiple root layouts\r\nAdding a layout to a subset of routes in a common segment\r\nsrcsrc Directory\r\nNext.js supports storing application code (including app) inside an optional src directory. This separates application code from project\r\nconfiguration files which mostly live in the root of a project. Module Path Aliases\r\nNext.js supports Module Path Aliases which make it easier to read and maintain imports across deeply nested project files. app/dashboard/settings/analytics/page.js (jsx)// before\r\nimport { Button } from '../../../components/button'\r\n// after\r\nimport { Button } from '@/components/button'\r\nProject organization strategies","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7e05843e-48ae-4f6d-9969-cb52f7f0ead2":{"id_":"7e05843e-48ae-4f6d-9969-cb52f7f0ead2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PcWBYGRcq5KdYa9Myyt4BvfSHJ5S6sbZJoez3KsnlbM=","metadata":{},"hash":"lOg1JB5p7b8YYLlD1O3zpDcMOxLvjMmFsjc52LMBZLw="}},"hash":"ppwkkbsyrjiWLTfIWzEWvL4RlTx6VO5koXdGxdxGasA=","text":"There is no “right” or “wrong” way when it comes to organizing your own files and folders in a Next.js project. The following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works\r\nfor you and your team and be consistent across the project. Good to know: In our examples below, we’re using components and lib folders as generalized placeholders, their naming has\r\nno special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc. Store project files outside of appapp\r\nThis strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing\r\npurposes. Store project files in top-level folders inside of appapp\r\nThis strategy stores all application code in shared folders in the root of the appapp directory. Split project files by feature or route\r\nThis strategy stores globally shared application code in the root app directory and splits more specific application code into the route","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a358b764-721d-4dca-a2b7-c0ed3e157e86":{"id_":"a358b764-721d-4dca-a2b7-c0ed3e157e86","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GueiMvdt7DNvIyin/cOwNwb5BJnZ89OoVr6lBeZC+6Y=","metadata":{},"hash":"RoPis1qjqCPsmoTsRDeUQU08RZQ3kgAF6MO27mfQHb4="}},"hash":"cVpyk4Z7mBohmaeate0EsMWFgWIiaJXlTaJZvH6Jd/U=","text":"segments that use them.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"80f3256b-8d07-406c-adc1-6cf30d520a2c":{"id_":"80f3256b-8d07-406c-adc1-6cf30d520a2c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zFzgPR0EIzPw+aB3eD/Hahb+EXZaU2KHcl9UTQvVvxE=","metadata":{},"hash":"ey6iGuGPCvrCI/jMpzYg8v6UGZCc+OZwjIAlbWngghA="},"NEXT":{"nodeId":"5048a17f-dc8c-4c82-be1b-b757f9d8d3d9","metadata":{},"hash":"ShyBkBbkRS9d0ou/PTL5NccFonPa9P3i4v0zcvi7oj0="}},"hash":"eVLsM+jjQxKPFA7Tl8JPghWz5cAJml6fkSEcmnl0pxg=","text":"3.1.1.13 - Internationalization\r\nDocumentation path: /02-app/01-building-your-application/01-routing/13-internationalization\r\nDescription: Add support for multiple languages with internationalized routing and localized content. Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to\r\ndifferent locales includes translated content (localization) and internationalized routes. Terminology\r\nLocale: An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and\r\npossibly their geographic region.en-US\r\n: English as spoken in the United States\r\nnl-NL: Dutch as spoken in the Netherlands\r\nnl: Dutch, no specific region\r\nRouting Overview\r\nIt’s recommended to use the user’s language preferences in the browser to select which locale to use. Changing your preferred\r\nlanguage will modify the incoming Accept-Language header to your application. For example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the\r\nHeaders, locales you plan to support, and the default locale. middleware.js (js)import { match } from '@formatjs/intl-localematcher'\r\nimport Negotiator from 'negotiator'\r\nlet headers = { 'accept-language': 'en-US,en;q=0.5' }\r\nlet languages = new Negotiator({ headers }).languages()\r\nlet locales = ['en-US', 'nl-NL', 'nl']\r\nlet defaultLocale = 'en-US'\r\nmatch(languages, locales, defaultLocale) // -> 'en-US'\r\nRouting can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information,\r\nyou can now redirect the user based on the locale inside Middleware. middleware.js (js)let locales = ['en-US', 'nl-NL', 'nl']\r\n// Get the preferred locale, similar to the above or using a library\r\nfunction getLocale(request) { ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5048a17f-dc8c-4c82-be1b-b757f9d8d3d9":{"id_":"5048a17f-dc8c-4c82-be1b-b757f9d8d3d9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zFzgPR0EIzPw+aB3eD/Hahb+EXZaU2KHcl9UTQvVvxE=","metadata":{},"hash":"ey6iGuGPCvrCI/jMpzYg8v6UGZCc+OZwjIAlbWngghA="},"PREVIOUS":{"nodeId":"80f3256b-8d07-406c-adc1-6cf30d520a2c","metadata":{},"hash":"eVLsM+jjQxKPFA7Tl8JPghWz5cAJml6fkSEcmnl0pxg="}},"hash":"ShyBkBbkRS9d0ou/PTL5NccFonPa9P3i4v0zcvi7oj0=","text":"}\r\nexport function middleware(request) {\r\n  // Check if there is any supported locale in the pathname\r\n  const { pathname } = request.nextUrl\r\n  const pathnameHasLocale = locales.some(\r\n    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`\r\n  )\r\n  if (pathnameHasLocale) return\r\n  // Redirect if there is no locale\r\n  const locale = getLocale(request)\r\n  request.nextUrl.pathname = `/${locale}${pathname}`\r\n  // e.g. incoming request is /products\r\n  // The new URL is now /en-US/products\r\n  return Response.redirect(request.nextUrl)\r\n}\r\nexport const config = {\r\n  matcher: [\r\n    // Skip all internal paths (_next)\r\n    '/((?!_next).*)',\r\n    // Optional: only run on root (/) URL\r\n    // '/'\r\n  ],\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"39342ae8-f8c6-4b9d-b56b-f3a09620c78c":{"id_":"39342ae8-f8c6-4b9d-b56b-f3a09620c78c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i3BUH6GM2pywLhMmJw1e/pGiDxjw4JX7/8qAP0yyxxg=","metadata":{},"hash":"oU2onHX5Wy2ZbyrMN8sUkvE9NVj1PV6BxGp53P+ykMo="},"NEXT":{"nodeId":"10aa0516-c5cd-4234-9cd0-ff88e3f17286","metadata":{},"hash":"To3qTbwMsY243/GEN+EirC8NWohRF48SjWQryu2LtKE="}},"hash":"G7WQkZB1M418zOG/bIO2HuwXyPRzpo/A7kuWy4tvArU=","text":"Finally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle\r\ndifferent locales in the route, and forward the lang parameter to every layout and page. For example:\r\napp/[lang]/page.js (jsx)// You now have access to the current locale\r\n// e.g. /en-US/products -> `lang` is \"en-US\"\r\nexport default async function Page({ params: { lang } }) {\r\n  return ... }\r\nThe root layout can also be nested in the new folder (e.g. app/[lang]/layout.js). Localization\r\nChanging displayed content based on the user’s preferred locale, or localization, is not something specific to Next.js. The patterns\r\ndescribed below would work the same with any web application. Let’s assume we want to support both English and Dutch content inside our application. We might maintain two different “dictionaries”,\r\nwhich are objects that give us a mapping from some key to a localized string. For example:\r\ndictionaries/en.json (json){\r\n  \"products\": {\r\n    \"cart\": \"Add to Cart\"\r\n  }\r\n}\r\ndictionaries/nl.json (json){\r\n  \"products\": {\r\n    \"cart\": \"Toevoegen aan Winkelwagen\"\r\n  }\r\n}\r\nWe can then create a getDictionary function to load the translations for the requested locale:\r\napp/[lang]/dictionaries.js (jsx)import 'server-only'\r\nconst dictionaries = {\r\n  en: () => import('./dictionaries/en.json').then((module) => module.default),\r\n  nl: () => import('./dictionaries/nl.json').then((module) => module.default),\r\n}\r\nexport const getDictionary = async (locale) => dictionaries[locale]()\r\nGiven the currently selected language, we can fetch the dictionary inside of a layout or page. app/[lang]/page.js (jsx)import { getDictionary } from './dictionaries'\r\nexport default async function Page({ params: { lang } }) {\r\n  const dict = await getDictionary(lang) // en\r\n  return <button>{dict.products.cart}</button> // Add to Cart\r\n}\r\nBecause all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the\r\ntranslation files affecting our client-side JavaScript bundle size. This code will only run on the server, and only the resulting HTML will\r\nbe sent to the browser.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"10aa0516-c5cd-4234-9cd0-ff88e3f17286":{"id_":"10aa0516-c5cd-4234-9cd0-ff88e3f17286","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i3BUH6GM2pywLhMmJw1e/pGiDxjw4JX7/8qAP0yyxxg=","metadata":{},"hash":"oU2onHX5Wy2ZbyrMN8sUkvE9NVj1PV6BxGp53P+ykMo="},"PREVIOUS":{"nodeId":"39342ae8-f8c6-4b9d-b56b-f3a09620c78c","metadata":{},"hash":"G7WQkZB1M418zOG/bIO2HuwXyPRzpo/A7kuWy4tvArU="}},"hash":"To3qTbwMsY243/GEN+EirC8NWohRF48SjWQryu2LtKE=","text":"Static Generation\r\nTo generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for\r\nexample, in the root layout:\r\napp/[lang]/layout.js (jsx)export async function generateStaticParams() {\r\n  return [{ lang: 'en-US' }, { lang: 'de' }]\r\n}\r\nexport default function Root({ children, params }) {\r\n  return (","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cbe44fa9-cc59-4afd-a350-64e352006107":{"id_":"cbe44fa9-cc59-4afd-a350-64e352006107","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AwtowjgAnwWDKpN/xux0Ah54hzLAOBxHLxYxHQCWhHQ=","metadata":{},"hash":"2lKk8ZeNsx4Fp+Ay2mWpKIQaqjlDrAvDrJCeU3bFt48="}},"hash":"6vrVQAvS6WANHKhnoR4skP4TeUkwgygCP/PsxTvXfwk=","text":"<html lang={params.lang}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nResources\r\nMinimal i18n routing and translationsnext-intl\r\nnext-international\r\nnext-i18n-router","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"35357d82-9128-48a0-b5e2-7306ac2d702d":{"id_":"35357d82-9128-48a0-b5e2-7306ac2d702d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gXbjTeRdeWGoW0IoSONsd5KQwKzmZJ4rOib9E4TSkIo=","metadata":{},"hash":"5JBagmY3WVirdeVHvVtlp6aPuyXutfnv1OpKWAoMmj4="}},"hash":"5OpCx/m82q5wRfQL9EtVa+9yKgqSxDtBdai8dZmIOfE=","text":"3.1.2 - Data Fetching\r\nDocumentation path: /02-app/01-building-your-application/02-data-fetching/index\r\nDescription: Learn how to fetch, cache, revalidate, and mutate data with Next.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a6b2b7d9-d38a-4bf2-b03c-47e2e2a5bdcc":{"id_":"a6b2b7d9-d38a-4bf2-b03c-47e2e2a5bdcc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sQ03U5dfY2vleaZvxMUZ98Gn43mG3fOhDNIkfjpxiL8=","metadata":{},"hash":"1+qIkZ/+S+IXjBrb2u/ozL2RG+NEZhyWlLKFZCK9a4I="},"NEXT":{"nodeId":"14073f5e-dba6-4e28-be63-dcfffc63a26a","metadata":{},"hash":"jtgP+eFYUwfcU4u3b8ZL+qroZMgv/dszd/EnNDMZe+w="}},"hash":"zTE9C4el7F6t+Hf1ERoYGU/YtRfQrKokAYApJhk1wbE=","text":"3.1.2.1 - Data Fetching, Caching, and Revalidating\r\nDocumentation path: /02-app/01-building-your-application/02-data-fetching/01-fetching-caching-and-revalidating\r\nDescription: Learn how to fetch, cache, and revalidate data in your Next.js application. Data fetching is a core part of any application. This page goes through how you can fetch, cache, and revalidate data in React and\r\nNext.js. There are four ways you can fetch data:\r\n1. On the server, with fetch\r\n2. On the server, with third-party libraries\r\n3. On the client, via a Route Handler\r\n4. On the client, with third-party libraries. Fetching Data on the Server with fetchfetch\r\nNext.js extends the native fetch Web API to allow you to configure the caching and revalidating behavior for each fetch request on the\r\nserver. React extends fetch to automatically memoize fetch requests while rendering a React component tree. You can use fetch with async/await in Server Components, in Route Handlers, and in Server Actions. For example:\r\napp/page.tsx (tsx)async function getData() {\r\n  const res = await fetch('https://api.example.com/... ')\r\n  // The return value is *not* serialized\r\n  // You can return Date, Map, Set, etc. if (!res.ok) {\r\n    // This will activate the closest `error.js` Error Boundary\r\n    throw new Error('Failed to fetch data')\r\n  }\r\n  return res.json()\r\n}\r\nexport default async function Page() {\r\n  const data = await getData()\r\n  return <main></main>\r\n}\r\napp/page.js (jsx)async function getData() {\r\n  const res = await fetch('https://api.example.com/... ')\r\n  // The return value is *not* serialized\r\n  // You can return Date, Map, Set, etc. if (!res.ok) {\r\n    // This will activate the closest `error.js` Error Boundary\r\n    throw new Error('Failed to fetch data')\r\n  }\r\n  return res.json()\r\n}\r\nexport default async function Page() {\r\n  const data = await getData()\r\n  return <main></main>\r\n}\r\nGood to know:\r\nNext.js provides helpful functions you may need when fetching data in Server Components such as cookies and headers. These will cause the route to be dynamically rendered as they rely on request time information.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"14073f5e-dba6-4e28-be63-dcfffc63a26a":{"id_":"14073f5e-dba6-4e28-be63-dcfffc63a26a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sQ03U5dfY2vleaZvxMUZ98Gn43mG3fOhDNIkfjpxiL8=","metadata":{},"hash":"1+qIkZ/+S+IXjBrb2u/ozL2RG+NEZhyWlLKFZCK9a4I="},"PREVIOUS":{"nodeId":"a6b2b7d9-d38a-4bf2-b03c-47e2e2a5bdcc","metadata":{},"hash":"zTE9C4el7F6t+Hf1ERoYGU/YtRfQrKokAYApJhk1wbE="}},"hash":"jtgP+eFYUwfcU4u3b8ZL+qroZMgv/dszd/EnNDMZe+w=","text":"These will cause the route to be dynamically rendered as they rely on request time information. In Route handlers, fetch requests are not memoized as Route Handlers are not part of the React component tree. To use async/await in a Server Component with TypeScript, you’ll need to use TypeScript 5.1.3 or higher and","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0e3fd93a-fafb-423d-950a-b64eb7a059a1":{"id_":"0e3fd93a-fafb-423d-950a-b64eb7a059a1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KC/t5KU428gIGfLpSmAxDxlsEuO8zqjvh48O07bZXiU=","metadata":{},"hash":"6gVryT1VNom4vyRqK90E0qwnsC2R7+M0SdkF9jQQBK8="},"NEXT":{"nodeId":"63b71cbf-c494-4c39-9ef1-92dec1c68c8d","metadata":{},"hash":"qgjnj9ecWvGBX9Gk6RONeorBWf1hrwUr/8ML4wNPUIg="}},"hash":"kJijpp1pMuqKTYqsOInMQuvtjdb56eh2G6bgJ9lWFLg=","text":"@types/react 18.2.8 or higher. Caching Data\r\nCaching stores data so it doesn’t need to be re-fetched from your data source on every request. By default, Next.js automatically caches the returned values of fetch in the Data Cache on the server. This means that the data can be\r\nfetched at build time or request time, cached, and reused on each data request. // 'force-cache' is the default, and can be omitted\r\nfetch('https://...', { cache: 'force-cache' })\r\nfetch requests that use the POST method are also automatically cached. Unless it’s inside a Route Handler that uses the POST method,\r\nthen it will not be cached. What is the Data Cache? The Data Cache is a persistent HTTP cache. Depending on your platform, the cache can scale automatically and be shared\r\nacross multiple regions. Learn more about the Data Cache. Revalidating Data\r\nRevalidation is the process of purging the Data Cache and re-fetching the latest data. This is useful when your data changes and you\r\nwant to ensure you show the latest information. Cached data can be revalidated in two ways:\r\nTime-based revalidation: Automatically revalidate data after a certain amount of time has passed. This is useful for data that\r\nchanges infrequently and freshness is not as critical. On-demand revalidation: Manually revalidate data based on an event (e.g. form submission). On-demand revalidation can use a\r\ntag-based or path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is\r\nshown as soon as possible (e.g. when content from your headless CMS is updated). Time-based Revalidation\r\nTo revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in\r\nseconds). fetch('https://...', { next: { revalidate: 3600 } })\r\nAlternatively, to revalidate all fetch requests in a route segment, you can use the Segment Config Options. layout.js | page.js (jsx)export const revalidate = 3600 // revalidate at most every hour\r\nIf you have multiple fetch requests in a statically rendered route, and each has a different revalidation frequency. The lowest time will\r\nbe used for all requests.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"63b71cbf-c494-4c39-9ef1-92dec1c68c8d":{"id_":"63b71cbf-c494-4c39-9ef1-92dec1c68c8d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KC/t5KU428gIGfLpSmAxDxlsEuO8zqjvh48O07bZXiU=","metadata":{},"hash":"6gVryT1VNom4vyRqK90E0qwnsC2R7+M0SdkF9jQQBK8="},"PREVIOUS":{"nodeId":"0e3fd93a-fafb-423d-950a-b64eb7a059a1","metadata":{},"hash":"kJijpp1pMuqKTYqsOInMQuvtjdb56eh2G6bgJ9lWFLg="}},"hash":"qgjnj9ecWvGBX9Gk6RONeorBWf1hrwUr/8ML4wNPUIg=","text":"The lowest time will\r\nbe used for all requests. For dynamically rendered routes, each fetch request will be revalidated independently. Learn more about time-based revalidation. On-demand Revalidation\r\nData can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag) inside a Server Action or Route\r\nHandler. Next.js has a cache tagging system for invalidating fetch requests across routes. 1. When using fetch, you have the option to tag cache entries with one or more tags. 2. Then, you can call revalidateTag to revalidate all entries associated with that tag. For example, the following fetch request adds the cache tag collection:\r\napp/page.tsx (tsx)export default async function Page() {\r\n  const res = await fetch('https://...', { next: { tags: ['collection'] } })\r\n  const data = await res.json()\r\n  // ... }\r\napp/page.js (jsx)export default async function Page() {\r\n  const res = await fetch('https://...', { next: { tags: ['collection'] } })","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"782b4348-e92a-488a-af1e-5fd4740fb63a":{"id_":"782b4348-e92a-488a-af1e-5fd4740fb63a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vUP2+CFb5keFOuedplV+OKaU0mZ+lPXVcmuWjnoJHQU=","metadata":{},"hash":"oCiMoshHlxlwMRptGFS4aGtyzEMirn6+hrWYrRZspu4="},"NEXT":{"nodeId":"7c66ad8b-7758-4626-8bb4-85f1bede241f","metadata":{},"hash":"AtCJ0T9VIt+i2l96K/Kl9k+m7LUBSMlvXhF7HBhamyo="}},"hash":"bOahgR2RXjNFuYJ3/pjuSJMt7t6i9I/ZBPx/v+xsVMc=","text":"const data = await res.json()\r\n  // ... }\r\nYou can then revalidate this fetch call tagged with collection by calling revalidateTag in a Server Action:\r\napp/actions.ts (ts)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport default async function action() {\r\n  revalidateTag('collection')\r\n}\r\napp/actions.js (js)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport default async function action() {\r\n  revalidateTag('collection')\r\n}\r\nLearn more about on-demand revalidation. Error handling and revalidation\r\nIf an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data. Opting out of Data Caching\r\nfetch requests are not cached if:\r\nThe cache: 'no-store' is added to fetch requests. The revalidate: 0 option is added to individual fetch requests. The fetch request is inside a Router Handler that uses the POST method. The fetch request comes after the usage of headers or cookies. The const dynamic = 'force-dynamic' route segment option is used. The fetchCache route segment option is configured to skip cache by default. The fetch request uses Authorization or Cookie headers and there’s an uncached request above it in the component tree. Individual fetchfetch Requests\r\nTo opt out of caching for individual fetch requests, you can set the cache option in fetch to 'no-store'. This will fetch data\r\ndynamically, on every request. layout.js | page.js (js)fetch('https://...', { cache: 'no-store' })\r\nView all the available cache options in the fetch API reference. Multiple fetchfetch Requests\r\nIf you have multiple fetch requests in a route segment (e.g. a Layout or Page), you can configure the caching behavior of all data\r\nrequests in the segment using the Segment Config Options. However, we recommend configuring the caching behavior of each fetch request individually. This gives you more granular control\r\nover the caching behavior. Fetching data on the Server with third-party libraries\r\nIn cases where you’re using a third-party library that doesn’t support or expose fetch (for example, a database, CMS, or ORM client),\r\nyou can configure the caching and revalidating behavior of those requests using the Route Segment Config Option and React’s cache\r\nfunction.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7c66ad8b-7758-4626-8bb4-85f1bede241f":{"id_":"7c66ad8b-7758-4626-8bb4-85f1bede241f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vUP2+CFb5keFOuedplV+OKaU0mZ+lPXVcmuWjnoJHQU=","metadata":{},"hash":"oCiMoshHlxlwMRptGFS4aGtyzEMirn6+hrWYrRZspu4="},"PREVIOUS":{"nodeId":"782b4348-e92a-488a-af1e-5fd4740fb63a","metadata":{},"hash":"bOahgR2RXjNFuYJ3/pjuSJMt7t6i9I/ZBPx/v+xsVMc="}},"hash":"AtCJ0T9VIt+i2l96K/Kl9k+m7LUBSMlvXhF7HBhamyo=","text":"Whether the data is cached or not will depend on whether the route segment is statically or dynamically rendered. If the segment is\r\nstatic (default), the output of the request will be cached and revalidated as part of the route segment. If the segment is dynamic, the","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c67484af-8d59-4b43-a4d7-1ce3eb2095ae":{"id_":"c67484af-8d59-4b43-a4d7-1ce3eb2095ae","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4kMdHoEJwGsC7KBt1aD1b3hBE3GxZeIC6FU1sJiY2OA=","metadata":{},"hash":"+87pFGdSc7aCoQbv5qbXAqVOqevh0QI6H4tMLL3th4E="}},"hash":"TJkaC0dv/c7WsG0HjNYpthvi443UKTcDDfNzj9ULWPE=","text":"output of the request will not be cached and will be re-fetched on every request when the segment is rendered. You can also use the experimental unstable_cache API. Example\r\nIn the example below:\r\nThe React cache function is used to memoize data requests. The revalidate option is set to 3600 in the Layout and Page segments, meaning the data will be cached and revalidated at most\r\nevery hour. app/utils.ts (ts)import { cache } from 'react'\r\nexport const getItem = cache(async (id: string) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})\r\napp/utils.js (js)import { cache } from 'react'\r\nexport const getItem = cache(async (id) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})\r\nAlthough the getItem function is called twice, only one query will be made to the database. app/item/[id]/layout.tsx (tsx)import { getItem } from '@/utils/get-item'\r\nexport const revalidate = 3600 // revalidate the data at most every hour\r\nexport default async function Layout({\r\n  params: { id },\r\n}: {\r\n  params: { id: string }\r\n}) {\r\n  const item = await getItem(id)\r\n  // ... }\r\napp/item/[id]/layout.js (jsx)import { getItem } from '@/utils/get-item'\r\nexport const revalidate = 3600 // revalidate the data at most every hour\r\nexport default async function Layout({ params: { id } }) {\r\n  const item = await getItem(id)\r\n  // ... }\r\napp/item/[id]/page.tsx (tsx)import { getItem } from '@/utils/get-item'\r\nexport const revalidate = 3600 // revalidate the data at most every hour\r\nexport default async function Page({\r\n  params: { id },\r\n}: {\r\n  params: { id: string }\r\n}) {\r\n  const item = await getItem(id)\r\n  // ... }\r\napp/item/[id]/page.js (jsx)import { getItem } from '@/utils/get-item'\r\nexport const revalidate = 3600 // revalidate the data at most every hour","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dc4166d0-3a19-4bcc-9ee4-877b57b48112":{"id_":"dc4166d0-3a19-4bcc-9ee4-877b57b48112","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UQ5O7sFIwBQDkXTCzE696zRyl3bHCS2ujDk9/pbOWvU=","metadata":{},"hash":"Ub0cFZB4v6iGGo/Hr3MClgm2uTVxvECWmQK08AEykqc="}},"hash":"e4LCC0FPd5zwWtXBwdK6JNkl1GdyGJZGcmnRqSH50v8=","text":"export default async function Page({ params: { id } }) {\r\n  const item = await getItem(id)\r\n  // ... }\r\nFetching Data on the Client with Route Handlers\r\nIf you need to fetch data in a client component, you can call a Route Handler from the client. Route Handlers execute on the server and\r\nreturn the data to the client. This is useful when you don’t want to expose sensitive information to the client, such as API tokens. See the Route Handler documentation for examples. Server Components and Route Handlers\r\nSince Server Components render on the server, you don’t need to call a Route Handler from a Server Component to fetch data. Instead, you can fetch the data directly inside the Server Component. Fetching Data on the Client with third-party libraries\r\nYou can also fetch data on the client using a third-party library such as SWR or TanStack Query. These libraries provide their own APIs\r\nfor memoizing requests, caching, revalidating, and mutating data. Future APIs:\r\nuse is a React function that accepts and handles a promise returned by a function. Wrapping fetch in use is currently not\r\nrecommended in Client Components and may trigger multiple re-renders. Learn more about use in the React docs.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6233aa28-7a08-493f-95b2-17d599dd85f7":{"id_":"6233aa28-7a08-493f-95b2-17d599dd85f7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dSAjGvW0u8VRy93hPl3dY5zq3xQzTeMw+ZbkL4qCK4Q=","metadata":{},"hash":"7H6Cx2Vp8+SquHZM7uY75u6rb0m3z9kmu8wJiGGuruw="}},"hash":"Pb7bjNxGWhEaUMEU+IWA1CZZd21m+j36wg5DH7lzJA8=","text":"3.1.2.2 - Server Actions and Mutations\r\nDocumentation path: /02-app/01-building-your-application/02-data-fetching/02-server-actions-and-mutations\r\nDescription: Learn how to handle form submissions and data mutations with Next.js. Related:\r\nTitle: Related\r\nRelated Description: Learn how to configure Server Actions in Next.js\r\nLinks:\r\napp/api-reference/next-config-js/serverActions\r\nServer Actions are asynchronous functions that are executed on the server. They can be used in Server and Client Components to\r\nhandle form submissions and data mutations in Next.js applications. \u0000 Watch: Learn more about forms and mutations with Server Actions → YouTube (10 minutes). Convention\r\nA Server Action can be defined with the React \"use server\" directive. You can place the directive at the top of an async function to\r\nmark the function as a Server Action, or at the top of a separate file to mark all exports of that file as Server Actions. Server Components\r\nServer Components can use the inline function level or module level \"use server\" directive. To inline a Server Action, add \"use\r\nserver\" to the top of the function body:\r\napp/page.tsx (tsx)// Server Component\r\nexport default function Page() {\r\n  // Server Action\r\n  async function create() {\r\n    'use server'\r\n    // ... }\r\n  return (\r\n    // ... )\r\n}\r\napp/page.jsx (jsx)// Server Component\r\nexport default function Page() {\r\n  // Server Action\r\n  async function create() {\r\n    'use server'\r\n    // ... }\r\n  return (\r\n    // ... )\r\n}\r\nClient Components\r\nClient Components can only import actions that use the module-level \"use server\" directive. To call a Server Action in a Client Component, create a new file and add the \"use server\" directive at the top of it. All functions\r\nwithin the file will be marked as Server Actions that can be reused in both Client and Server Components:\r\napp/actions.ts (tsx)'use server'\r\nexport async function create() {\r\n  // ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d1c1d34d-2e8d-463f-b064-3e0d7548c4a2":{"id_":"d1c1d34d-2e8d-463f-b064-3e0d7548c4a2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"l8Vh/gdTGWgQIoOTlcz5nbjFxKsTBuhWletd4B1rfEo=","metadata":{},"hash":"jhI2/1w5BcPS1WuYKBZny+m0k7UtoPrI+otVpbj3Fuc="}},"hash":"u7oD0a7RPPhR0repuA2zF1YlIruTgmcbasdCqHbNy50=","text":"}\r\napp/actions.js (js)'use server'\r\nexport async function create() {\r\n  // ... }\r\napp/ui/button.tsx (tsx)import { create } from '@/app/actions'\r\nexport function Button() {\r\n  return (\r\n    // ... )\r\n}\r\napp/ui/button.js (jsx)import { create } from '@/app/actions'\r\nexport function Button() {\r\n  return (\r\n    // ... )\r\n}\r\nYou can also pass a Server Action to a Client Component as a prop:\r\n<ClientComponent updateItem={updateItem} />\r\napp/client-component.jsx (jsx)'use client'\r\nexport default function ClientComponent({ updateItem }) {\r\n  return <form action={updateItem}>{/* ... */}</form>\r\n}\r\nBehavior\r\nServer actions can be invoked using the action attribute in a <form> element:\r\nServer Components support progressive enhancement by default, meaning the form will be submitted even if JavaScript hasn’t\r\nloaded yet or is disabled. In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn’t loaded yet, prioritizing client\r\nhydration. After hydration, the browser does not refresh on form submission. Server Actions are not limited to <form> and can be invoked from event handlers, useEffect, third-party libraries, and other form\r\nelements like <button>. Server Actions integrate with the Next.js caching and revalidation architecture. When an action is invoked, Next.js can return both\r\nthe updated UI and new data in a single server roundtrip. Behind the scenes, actions use the POST method, and only this HTTP method can invoke them. The arguments and return value of Server Actions must be serializable by React. See the React docs for a list of serializable\r\narguments and values. Server Actions are functions. This means they can be reused anywhere in your application. Server Actions inherit the runtime from the page or layout they are used on. Examples\r\nForms\r\nReact extends the HTML <form> element to allow Server Actions to be invoked with the action prop. When invoked in a form, the action automatically receives the FormData object. You don’t need to use React useState to manage\r\nfields, instead, you can extract the data using the native FormData methods:\r\napp/invoices/page.tsx (tsx)export default function Page() {\r\n  async function createInvoice(formData: FormData) {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bec9ed0f-06e5-4051-8a63-7917ad9bc9b3":{"id_":"bec9ed0f-06e5-4051-8a63-7917ad9bc9b3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jGL0OFFHO7KDUMQhWF+3++GZKKV2eZnLOIGlWdbCH3o=","metadata":{},"hash":"nXOvsDuXPr9v/ACpbzqrpEku+S9n41k4yDHt00jWbIE="}},"hash":"p3i0JlIOhKjpLCVmWGaEV7Xfdxe3K02LPponpaaTnLQ=","text":"'use server'\r\n    const rawFormData = {\r\n      customerId: formData.get('customerId'),\r\n      amount: formData.get('amount'),\r\n      status: formData.get('status'),\r\n    }\r\n    // mutate data\r\n    // revalidate cache\r\n  }\r\n  return <form action={createInvoice}>...</form>\r\n}\r\napp/invoices/page.jsx (jsx)export default function Page() {\r\n  async function createInvoice(formData) {\r\n    'use server'\r\n    const rawFormData = {\r\n      customerId: formData.get('customerId'),\r\n      amount: formData.get('amount'),\r\n      status: formData.get('status'),\r\n    }\r\n    // mutate data\r\n    // revalidate cache\r\n  }\r\n  return <form action={createInvoice}>...</form>\r\n}\r\nGood to know:\r\nExample: Form with Loading & Error States\r\nWhen working with forms that have many fields, you may want to consider using the entries() method with JavaScript’s\r\nObject.fromEntries(). For example: const rawFormData = Object.fromEntries(formData.entries())\r\nSee React <form> documentation to learn more. Passing Additional Arguments\r\nYou can pass additional arguments to a Server Action using the JavaScript bind method. ```tsx filename=”app/client-component.tsx” highlight={6} switcher ‘use client’\r\nimport { updateUser } from ‘./actions’\r\nexport function UserProfile({ userId }: { userId: string }) { const updateUserWithId = updateUser.bind(null, userId)\r\nreturn (\r\n Update User Name\r\n) }\r\n```jsx filename=\"app/client-component.js\" highlight={6} switcher\r\n'use client'\r\nimport { updateUser } from './actions'\r\nexport function UserProfile({ userId }) {\r\n  const updateUserWithId = updateUser.bind(null, userId)\r\n  return (\r\n    <form action={updateUserWithId}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Update User Name</button>\r\n    </form>\r\n  )\r\n}\r\nThe Server Action will receive the userId argument, in addition to the form data:\r\napp/actions.js (js)'use server'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fc4e7091-57ff-4530-b09e-16c3ebfd1fa5":{"id_":"fc4e7091-57ff-4530-b09e-16c3ebfd1fa5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xTZsXezzJClM7SPJVZey+xi7EkETBdmWuvzNBBs+wec=","metadata":{},"hash":"h1GQS42sfYD+SI1Lg06kY2gKb+k5p6FVZuXolVQrz6c="}},"hash":"GHX3sf3itFwMWGscRatzxfPAA1i2qahmCdCq1lrhF1s=","text":"export async function updateUser(userId, formData) {\r\n  // ... }\r\nGood to know:\r\nAn alternative is to pass arguments as hidden input fields in the form (e.g. <input type=\"hidden\" name=\"userId\"\r\nvalue={userId} />). However, the value will be part of the rendered HTML and will not be encoded. .bind works in both Server and Client Components. It also supports progressive enhancement. Pending states\r\nYou can use the React useFormStatus hook to show a pending state while the form is being submitted. useFormStatus returns the status for a specific <form>, so it must be defined as a child of the <form><form> element. useFormStatus is a React hook and therefore must be used in a Client Component. app/submit-button.tsx (tsx)'use client'\r\nimport { useFormStatus } from 'react-dom'\r\nexport function SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n  return (\r\n    <button type=\"submit\" aria-disabled={pending}>\r\n      Add\r\n    </button>\r\n  )\r\n}\r\napp/submit-button.jsx (jsx)'use client'\r\nimport { useFormStatus } from 'react-dom'\r\nexport function SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n  return (\r\n    <button type=\"submit\" aria-disabled={pending}>\r\n      Add\r\n    </button>\r\n  )\r\n}\r\n<SubmitButton /> can then be nested in any form:\r\napp/page.tsx (tsx)import { SubmitButton } from '@/app/submit-button'\r\nimport { createItem } from '@/app/actions'\r\n// Server Component\r\nexport default async function Home() {\r\n  return (\r\n    <form action={createItem}>\r\n      <input type=\"text\" name=\"field-name\" />\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\napp/page.jsx (jsx)import { SubmitButton } from '@/app/submit-button'\r\nimport { createItem } from '@/app/actions'\r\n// Server Component\r\nexport default async function Home() {\r\n  return (\r\n    <form action={createItem}>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"36f4fefc-ea8c-4b05-b385-c2fa262698c3":{"id_":"36f4fefc-ea8c-4b05-b385-c2fa262698c3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CJ+Ej6jcCybOR+c5y6e9j7SFc93KX1Vf/o8YRhcyFuM=","metadata":{},"hash":"JCVxj14sOzlILODoNLvURaM924hgm/ffcFSMbyWTAHw="}},"hash":"J0gjZsepyYCy2Yjz8yfCtDyGHc7OSaAFhfFwz6KLmec=","text":"<input type=\"text\" name=\"field-name\" />\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\nServer-side validation and error handling\r\nWe recommend using HTML validation like required and type=\"email\" for basic client-side form validation. For more advanced server-side validation, you can use a library like zod to validate the form fields before mutating the data:\r\napp/actions.ts (tsx)'use server'\r\nimport { z } from 'zod'\r\nconst schema = z.object({\r\n  email: z.string({\r\n    invalid_type_error: 'Invalid Email',\r\n  }),\r\n})\r\nexport default async function createUser(formData: FormData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n  // Return early if the form data is invalid\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n  // Mutate data\r\n}\r\napp/actions.js (jsx)'use server'\r\nimport { z } from 'zod'\r\nconst schema = z.object({\r\n  email: z.string({\r\n    invalid_type_error: 'Invalid Email',\r\n  }),\r\n})\r\nexport default async function createsUser(formData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n  // Return early if the form data is invalid\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n  // Mutate data\r\n}\r\nOnce the fields have been validated on the server, you can return a serializable object in your action and use the React useFormState\r\nhook to show a message to the user. By passing the action to useFormState, the action’s function signature changes to receive a new prevState or initialState\r\nparameter as its first argument.useFormState\r\n is a React hook and therefore must be used in a Client Component. app/actions.ts (tsx)'use server'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d7dda120-9429-48f7-8552-a651b8104bb7":{"id_":"d7dda120-9429-48f7-8552-a651b8104bb7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"90n0ySGDWoDDCry1GLc0oEKoOejhfoAjK7muUY+o2Qk=","metadata":{},"hash":"zWs8osz9tvPB0VuqcpSWLtgtsvGCikWTRUEZIJQUgC0="}},"hash":"V4tcplyHTOBBi3FEq6lg9aEEQ9RhN4D+3J1fMFOrXFM=","text":"export async function createUser(prevState: any, formData: FormData) {\r\n  // ... return {\r\n    message: 'Please enter a valid email',\r\n  }\r\n}\r\napp/actions.js (jsx)'use server'\r\nexport async function createUser(prevState, formData) {\r\n  // ... return {\r\n    message: 'Please enter a valid email',\r\n  }\r\n}\r\nThen, you can pass your action to the useFormState hook and use the returned state to display an error message. app/ui/signup.tsx (tsx)'use client'\r\nimport { useFormState } from 'react-dom'\r\nimport { createUser } from '@/app/actions'\r\nconst initialState = {\r\n  message: null,\r\n}\r\nexport function Signup() {\r\n  const [state, formAction] = useFormState(createUser, initialState)\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"email\">Email</label>\r\n      <input type=\"text\" id=\"email\" name=\"email\" required />\r\n      {/* ... */}\r\n      <p aria-live=\"polite\" className=\"sr-only\">\r\n        {state?.message}\r\n      </p>\r\n      <button>Sign up</button>\r\n    </form>\r\n  )\r\n}\r\napp/ui/signup.js (jsx)'use client'\r\nimport { useFormState } from 'react-dom'\r\nimport { createUser } from '@/app/actions'\r\nconst initialState = {\r\n  message: null,\r\n}\r\nexport function Signup() {\r\n  const [state, formAction] = useFormState(createUser, initialState)\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"email\">Email</label>\r\n      <input type=\"text\" id=\"email\" name=\"email\" required />\r\n      {/* ... */}\r\n      <p aria-live=\"polite\" className=\"sr-only\">\r\n        {state?.message}\r\n      </p>\r\n      <button>Sign up</button>\r\n    </form>\r\n  )\r\n}\r\nGood to know:\r\nBefore mutating data, you should always ensure a user is also authorized to perform the action. See Authentication and","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fb63e085-8de0-42f5-99dd-85a406948a3e":{"id_":"fb63e085-8de0-42f5-99dd-85a406948a3e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9z6cGR4SWjHRDVsBk0N+cWpP0LT56nr6+xRyxsP/HK0=","metadata":{},"hash":"YGckNj1C++x/TLB8Xrlor/oeQRYgBf1EMn2LEDIVavI="}},"hash":"WhJosdyU//3meMLOxfG1aaUEojrIiR1+hWvEyKVJa4Y=","text":"Authorization. Optimistic updates\r\nYou can use the React useOptimistic hook to optimistically update the UI before the Server Action finishes, rather than waiting for\r\nthe response:\r\napp/page.tsx (tsx)'use client'\r\nimport { useOptimistic } from 'react'\r\nimport { send } from './actions'\r\ntype Message = {\r\n  message: string\r\n}\r\nexport function Thread({ messages }: { messages: Message[] }) {\r\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic<Message[]>(\r\n    messages,\r\n    (state: Message[], newMessage: string) => [\r\n      ...state,\r\n      { message: newMessage },\r\n    ]\r\n  )\r\n  return (\r\n    <div>\r\n      {optimisticMessages.map((m, k) => (\r\n        <div key={k}>{m.message}</div>\r\n      ))}\r\n      <form\r\n        action={async (formData: FormData) => {\r\n          const message = formData.get('message')\r\n          addOptimisticMessage(message)\r\n          await send(message)\r\n        }}\r\n      >\r\n        <input type=\"text\" name=\"message\" />\r\n        <button type=\"submit\">Send</button>\r\n      </form>\r\n    </div>\r\n  )\r\n}\r\napp/page.jsx (jsx)'use client'\r\nimport { useOptimistic } from 'react'\r\nimport { send } from './actions'\r\nexport function Thread({ messages }) {\r\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\r\n    messages,\r\n    (state, newMessage) => [...state, { message: newMessage }]\r\n  )\r\n  return (\r\n    <div>\r\n      {optimisticMessages.map((m) => (\r\n        <div>{m.message}</div>\r\n      ))}\r\n      <form\r\n        action={async (formData) => {\r\n          const message = formData.get('message')\r\n          addOptimisticMessage(message)\r\n          await send(message)\r\n        }}\r\n      >\r\n        <input type=\"text\" name=\"message\" />\r\n        <button type=\"submit\">Send</button>\r\n      </form>\r\n    </div>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"85124ab9-9a74-43dc-9516-45fafc4122aa":{"id_":"85124ab9-9a74-43dc-9516-45fafc4122aa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CG0GeUtILSq6YclCNbZgA3gU7O+h62qt6C2EZ1L0jog=","metadata":{},"hash":"9ENqdxnYphwY/wgmxzd29Mp+OV7W0H13eav+gVUP0t8="}},"hash":"DS0zLQfzPG6PQ/Mj0PRnh/ZqTfvEbmRFjbSj/BFXy8M=","text":"Nested elements\r\nYou can invoke a Server Action in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input\r\ntype=\"image\">. These elements accept the formAction prop or event handlers. This is useful in cases where you want to call multiple server actions within a form. For example, you can create a specific <button>\r\nelement for saving a post draft in addition to publishing it. See the React <form> docs for more information. Non-form Elements\r\nWhile it’s common to use Server Actions within <form> elements, they can also be invoked from other parts of your code such as event\r\nhandlers and useEffect. Event Handlers\r\nYou can invoke a Server Action from event handlers such as onClick. For example, to increment a like count:\r\napp/actions.js (js)'use server'\r\nexport async function incrementLike() {\r\n  // Mutate database\r\n  // Return updated data\r\n}\r\napp/like-button.tsx (tsx)'use client'\r\nimport { incrementLike } from './actions'\r\nimport { useState } from 'react'\r\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\r\n  const [likes, setLikes] = useState(initialLikes)\r\n  return (\r\n    <>\r\n      <p>Total Likes: {likes}</p>\r\n      <button\r\n        onClick={async () => {\r\n          const updatedLikes = await incrementLike()\r\n          setLikes(updatedLikes)\r\n        }}\r\n      >\r\n        Like\r\n      </button>\r\n    </>\r\n  )\r\n}\r\nTo improve the user experience, we recommend using other React APIs like useOptimistic and useTransition to update the UI\r\nbefore the Server Action finishes executing on the server, or to show a pending state. You can also add event handlers to form elements, for example, to save a form field onChange:\r\napp/ui/edit-post.tsx (tsx)'use client'\r\nimport { publishPost, saveDraft } from './actions'\r\nexport default function EditPost() {\r\n  return (\r\n    <form action={publishPost}>\r\n      <textarea\r\n        name=\"content\"\r\n        onChange={async (e) => {\r\n          await saveDraft(e.target.value)\r\n        }}\r\n      />\r\n      <button type=\"submit\">Publish</button>\r\n    </form>\r\n  )\r\n}\r\nFor cases like this, where multiple events might be fired in quick succession, we recommend debouncing to prevent unnecessary","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9662fb53-17ca-4bd1-9640-6a13ab384d44":{"id_":"9662fb53-17ca-4bd1-9640-6a13ab384d44","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"A/ptH7O+U3tDKtNn+JozKyIMDAHnVZBxbHs2/w9JDt4=","metadata":{},"hash":"T/pcpK45z6CruaQD3S4AOf2g9kDEA3sVmZaTmvrJb4M="}},"hash":"+g3DweKCAMB5UJYY8QcbFKJEje+5j0saV3lyYoHasx0=","text":"Server Action invocations. useEffectuseEffect\r\nYou can use the React useEffect hook to invoke a Server Action when the component mounts or a dependency changes. This is useful\r\nfor mutations that depend on global events or need to be triggered automatically. For example, onKeyDown for app shortcuts, an\r\nintersection observer hook for infinite scrolling, or when the component mounts to update a view count:\r\napp/view-count.tsx (tsx)'use client'\r\nimport { incrementViews } from './actions'\r\nimport { useState, useEffect } from 'react'\r\nexport default function ViewCount({ initialViews }: { initialViews: number }) {\r\n  const [views, setViews] = useState(initialViews)\r\n  useEffect(() => {\r\n    const updateViews = async () => {\r\n      const updatedViews = await incrementViews()\r\n      setViews(updatedViews)\r\n    }\r\n    updateViews()\r\n  }, [])\r\n  return <p>Total Views: {views}</p>\r\n}\r\nRemember to consider the behavior and caveats of useEffect. Error Handling\r\nWhen an error is thrown, it’ll be caught by the nearest error.js or <Suspense> boundary on the client. We recommend using\r\ntry/catch to return errors to be handled by your UI. For example, your Server Action might handle errors from creating a new item by returning a message:\r\napp/actions.ts (ts)'use server'\r\nexport async function createTodo(prevState: any, formData: FormData) {\r\n  try {\r\n    // Mutate data\r\n  } catch (e) {\r\n    throw new Error('Failed to create task')\r\n  }\r\n}\r\napp/actions.js (js)'use server'\r\nexport async function createTodo(prevState, formData) {\r\n  try {\r\n    //  Mutate data\r\n  } catch (e) {\r\n    throw new Error('Failed to create task')\r\n  }\r\n}\r\nGood to know:\r\nAside from throwing the error, you can also return an object to be handled by useFormStatus. See Server-side validation\r\nand error handling. Revalidating data\r\nYou can revalidate the Next.js Cache inside your Server Actions with the revalidatePath API:\r\napp/actions.ts (ts)'use server'\r\nimport { revalidatePath } from 'next/cache'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a2d8865a-f2f1-4a81-a3d2-4478c8cae8f1":{"id_":"a2d8865a-f2f1-4a81-a3d2-4478c8cae8f1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"s8lJEScou8/wK5AfIHHKp7AGbud7fi0Ft9uqi6v/D9o=","metadata":{},"hash":"JC6VQNvzoB1n+40BqFRXppwHXydgagm0oNI54gn0W98="}},"hash":"YuxV87v1vXUwL5sMG2gUpo62fWFx/O6m/B6KRlzMF2Q=","text":"export async function createPost() {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ... }\r\n  revalidatePath('/posts')\r\n}\r\napp/actions.js (js)'use server'\r\nimport { revalidatePath } from 'next/cache'\r\nexport async function createPost() {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ... }\r\n  revalidatePath('/posts')\r\n}\r\nOr invalidate a specific data fetch with a cache tag using revalidateTag:\r\napp/actions.ts (ts)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport async function createPost() {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ... }\r\n  revalidateTag('posts')\r\n}\r\napp/actions.js (js)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport async function createPost() {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ... }\r\n  revalidateTag('posts')\r\n}\r\nRedirecting\r\nIf you would like to redirect the user to a different route after the completion of a Server Action, you can use redirect API. redirect\r\nneeds to be called outside of the try/catch block:\r\napp/actions.ts (ts)'use server'\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidateTag } from 'next/cache'\r\nexport async function createPost(id: string) {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cee40628-bc37-4a8a-a3c4-0d6db38442e4":{"id_":"cee40628-bc37-4a8a-a3c4-0d6db38442e4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bZ1AtolEuNi23pZPluawIW09a1DApDaNThmhdAx7qHk=","metadata":{},"hash":"H1aKiLLxElHePxpck8Dokj20KjGifq/++lAHcmPlNe0="}},"hash":"UTyqVj/bQWe/QO/AbP15zuAOySaIfMa8kZfWkVzwYgU=","text":"}\r\n  revalidateTag('posts') // Update cached posts\r\n  redirect(`/post/${id}`) // Navigate to the new post page\r\n}\r\napp/actions.js (js)'use server'\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidateTag } from 'next/cache'\r\nexport async function createPost(id) {\r\n  try {\r\n    // ... } catch (error) {\r\n    // ... }\r\n  revalidateTag('posts') // Update cached posts\r\n  redirect(`/post/${id}`) // Navigate to the new post page\r\n}\r\nCookies\r\nYou can get, set, and delete cookies inside a Server Action using the cookies API:\r\napp/actions.ts (ts)'use server'\r\nimport { cookies } from 'next/headers'\r\nexport async function exampleAction() {\r\n  // Get cookie\r\n  const value = cookies().get('name')?.value\r\n  // Set cookie\r\n  cookies().set('name', 'Delba')\r\n  // Delete cookie\r\n  cookies().delete('name')\r\n}\r\napp/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nexport async function exampleAction() {\r\n  // Get cookie\r\n  const value = cookies().get('name')?.value\r\n  // Set cookie\r\n  cookies().set('name', 'Delba')\r\n  // Delete cookie\r\n  cookies().delete('name')\r\n}\r\nSee additional examples for deleting cookies from Server Actions. Security\r\nAuthentication and authorization\r\nYou should treat Server Actions as you would public-facing API endpoints, and ensure that the user is authorized to perform the action. For example:\r\napp/actions.ts (tsx)'use server'\r\nimport { auth } from './lib'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b03446e-704f-4103-9c0a-7ee3a0b737df":{"id_":"7b03446e-704f-4103-9c0a-7ee3a0b737df","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+uz/Gp6Pdsq2Bd3s8dpyLkie1E4Dpv8VjI1ZOYqRnAE=","metadata":{},"hash":"j47J23UvwDj6FLOFnXzUh+I1n7gM6bLSW2QkKkiPk6o="},"NEXT":{"nodeId":"00ec1394-709a-4817-b430-f1923378bb34","metadata":{},"hash":"1UFGaFZ+47kqhsF+44ggizlggdXEQcTKXluukUmMtvA="}},"hash":"JCSCCFjc8QgmWIAXjIopaSU3Li+5uyflryAnxuKZ3d8=","text":"export function addItem() {\r\n  const { user } = auth()\r\n  if (!user) {\r\n    throw new Error('You must be signed in to perform this action')\r\n  }\r\n  // ... }\r\nClosures and encryption\r\nDefining a Server Action inside a component creates a closure where the action has access to the outer function’s scope. For example,\r\nthe publish action has access to the publishVersion variable:\r\napp/page.tsx (tsx)export default function Page() {\r\n  const publishVersion = await getLatestVersion();\r\n  async function publish(formData: FormData) {\r\n    \"use server\";\r\n    if (publishVersion !== await getLatestVersion()) {\r\n      throw new Error('The version has changed since pressing publish');\r\n    }\r\n    ... }\r\n  return <button action={publish}>Publish</button>;\r\n}\r\napp/page.js (jsx)export default function Page() {\r\n  const publishVersion = await getLatestVersion();\r\n  async function publish() {\r\n    \"use server\";\r\n    if (publishVersion !== await getLatestVersion()) {\r\n      throw new Error('The version has changed since pressing publish');\r\n    }\r\n    ... }\r\n  return <button action={publish}>Publish</button>;\r\n}\r\nClosures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used\r\nlater when the action is invoked. However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent\r\nsensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated\r\nfor each action every time a Next.js application is built. This means actions can only be invoked for a specific build. Good to know: We don’t recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use the React taint APIs to proactively prevent specific data from being sent to the client. Overwriting encryption keys (advanced)\r\nWhen self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key,\r\nleading to potential inconsistencies. To mitigate this, you can overwrite the encryption key using the process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY\r\nenvironment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances\r\nuse the same key.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"00ec1394-709a-4817-b430-f1923378bb34":{"id_":"00ec1394-709a-4817-b430-f1923378bb34","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+uz/Gp6Pdsq2Bd3s8dpyLkie1E4Dpv8VjI1ZOYqRnAE=","metadata":{},"hash":"j47J23UvwDj6FLOFnXzUh+I1n7gM6bLSW2QkKkiPk6o="},"PREVIOUS":{"nodeId":"7b03446e-704f-4103-9c0a-7ee3a0b737df","metadata":{},"hash":"JCSCCFjc8QgmWIAXjIopaSU3Li+5uyflryAnxuKZ3d8="}},"hash":"1UFGaFZ+47kqhsF+44ggizlggdXEQcTKXluukUmMtvA=","text":"This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You\r\nshould consider standard security practices such key rotation and signing. Good to know: Next.js applications deployed to Vercel automatically handle this. Allowed origins (advanced)\r\nSince Server Actions can be invoked in a <form> element, this opens them up to CSRF attacks. Behind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF\r\nvulnerabilities in modern browsers, particularly with SameSite cookies being the default.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4bc0b090-1bee-482a-b967-61feb00aaa59":{"id_":"4bc0b090-1bee-482a-b967-61feb00aaa59","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"e6XFZMZZcGFmxddo01IBC4E+pV5e3chkifg/ky8ZS20=","metadata":{},"hash":"4VaXF8+e6has2v1M0LuELirlDO4BDY+bQzhUhIqsQmc="}},"hash":"n7mui7igXGdZHU3jxUSDJBsSMHduMVslcbVTAWI+ogg=","text":"As an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If\r\nthese don’t match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that\r\nhosts it. For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production\r\ndomain), it’s recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings. next.config.js (js)/** @type {import('next').NextConfig} */\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\r\n    },\r\n  },\r\n}\r\nLearn more about Security and Server Actions. Additional resources\r\nFor more information on Server Actions, check out the following React docs:\r\n\"use server\"\r\n<form>\r\nuseFormStatus\r\nuseFormState\r\nuseOptimistic","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"735044b6-4064-42f6-932b-34eefa7905fb":{"id_":"735044b6-4064-42f6-932b-34eefa7905fb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZM2dDKPIeJpeKX5fjNHRRMMb0XqkbNL6OEHVpvVtbEw=","metadata":{},"hash":"D027eKAJq6vGZqj7eNyLHWPwGNnToB6pdcB/n4p0uZA="}},"hash":"7Ofqqeor8GUCkWm5tXhQCiPv4IFjP47vDqcqg8Wa4yE=","text":"3.1.2.3 - Patterns and Best Practices\r\nDocumentation path: /02-app/01-building-your-application/02-data-fetching/03-patterns\r\nDescription: Learn about common data fetching patterns in React and Next.js. There are a few recommended patterns and best practices for fetching data in React and Next.js. This page will go over some of the\r\nmost common patterns and how to use them. Fetching Data on the Server\r\nWhenever possible, we recommend fetching data on the server with Server Components. This allows you to:\r\nHave direct access to backend data resources (e.g. databases). Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to\r\nthe client. Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as\r\nwell as the work on the main thread on the client. Perform multiple data fetches with single round-trip instead of multiple individual requests on the client. Reduce client-server waterfalls. Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance. Then, you can mutate or update data with Server Actions. Fetching Data Where It’s Needed\r\nIf you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor\r\nforward props between components. Instead, you can use fetch or React cache in the component that needs the data without\r\nworrying about the performance implications of making multiple requests for the same data. This is possible because fetch requests are automatically memoized. Learn more about request memoization\r\nGood to know: This also applies to layouts, since it’s not possible to pass data between a parent layout and its children. Streaming\r\nStreaming and Suspense are React features that allow you to progressively render and incrementally stream rendered units of the UI to\r\nthe client. With Server Components and nested layouts, you’re able to instantly render parts of the page that do not specifically require data, and\r\nshow a loading state for parts of the page that are fetching data. This means the user does not have to wait for the entire page to load\r\nbefore they can start interacting with it. To learn more about Streaming and Suspense, see the Loading UI and Streaming and Suspense pages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"251b24b4-aaad-4843-bbcf-b75032fc1a4e":{"id_":"251b24b4-aaad-4843-bbcf-b75032fc1a4e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OXCz7DORx93txUhMYrim8rZu4UYYc0yG18ysZ1CvU58=","metadata":{},"hash":"OWfrhVjW/UWgFr8MbDICDTor2USOvMTKCBWNq4MtceM="}},"hash":"9ST/9FIV6hBcAADbJ+FC4YtRKhkYqstaJjcW6UncC44=","text":"Parallel and Sequential Data Fetching\r\nWhen fetching data inside React components, you need to be aware of two data fetching patterns: Parallel and Sequential. With sequential data fetching, requests in a route are dependent on each other and therefore create waterfalls. There may be\r\ncases where you want this pattern because one fetch depends on the result of the other, or you want a condition to be satisfied\r\nbefore the next fetch to save resources. However, this behavior can also be unintentional and lead to longer loading times. With parallel data fetching, requests in a route are eagerly initiated and will load data at the same time. This reduces client-server\r\nwaterfalls and the total time it takes to load data. Sequential Data Fetching\r\nIf you have nested components, and each component fetches its own data, then data fetching will happen sequentially if those data\r\nrequests are different (this doesn’t apply to requests for the same data as they are automatically memoized). For example, the Playlists component will only start fetching data once the Artist component has finished fetching data because\r\nPlaylists depends on the artistID prop:\r\napp/artist/[username]/page.tsx (tsx)// ... async function Playlists({ artistID }: { artistID: string }) {\r\n  // Wait for the playlists\r\n  const playlists = await getArtistPlaylists(artistID)\r\n  return (\r\n    <ul>\r\n      {playlists.map((playlist) => (\r\n        <li key={playlist.id}>{playlist.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nexport default async function Page({\r\n  params: { username },\r\n}: {\r\n  params: { username: string }\r\n}) {\r\n  // Wait for the artist\r\n  const artist = await getArtist(username)\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <Playlists artistID={artist.id} />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\napp/artist/[username]/page.js (jsx)// ... async function Playlists({ artistID }) {\r\n  // Wait for the playlists\r\n  const playlists = await getArtistPlaylists(artistID)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0962d79a-aa3e-4daa-abb7-a7675666d19d":{"id_":"0962d79a-aa3e-4daa-abb7-a7675666d19d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DlogDoGUGw+65sTdd2VM/vVao023S7B1Aem/2Gj270k=","metadata":{},"hash":"vTmwvA/f3nn3s9VztXMp66ZMY8BLGA3tHYSkbxE8w1E="},"NEXT":{"nodeId":"ba9df7ed-83fe-4e6d-a969-60e112bff137","metadata":{},"hash":"GvDxMoGELKUZUqIeLv1HNM2SL4k2Smm30m3cT/+Wc30="}},"hash":"mN7eglmtSO7Vy0RVAcD60DCS6Zy9+bqP1ixgeNnb5+8=","text":"return (\r\n    <ul>\r\n      {playlists.map((playlist) => (\r\n        <li key={playlist.id}>{playlist.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nexport default async function Page({ params: { username } }) {\r\n  // Wait for the artist\r\n  const artist = await getArtist(username)\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <Playlists artistID={artist.id} />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\nIn cases like this, you can use loading.js (for route segments) or React <Suspense> (for nested components) to show an instant\r\nloading state while React streams in the result. This will prevent the whole route from being blocked by data fetching, and the user will be able to interact with the parts of the page\r\nthat are not blocked. Blocking Data Requests:\r\nAn alternative approach to prevent waterfalls is to fetch data globally, at the root of your application, but this will block\r\nrendering for all route segments beneath it until the data has finished loading. This can be described as “all or nothing” data\r\nfetching. Either you have the entire data for your page or application, or none. Any fetch requests with await will block rendering and data fetching for the entire tree beneath it, unless they are wrapped in a\r\n<Suspense> boundary or loading.js is used. Another alternative is to use parallel data fetching or the preload pattern. Parallel Data Fetching\r\nTo fetch data in parallel, you can eagerly initiate requests by defining them outside the components that use the data, then calling them\r\nfrom inside the component. This saves time by initiating both requests in parallel, however, the user won’t see the rendered result until\r\nboth promises are resolved.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ba9df7ed-83fe-4e6d-a969-60e112bff137":{"id_":"ba9df7ed-83fe-4e6d-a969-60e112bff137","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DlogDoGUGw+65sTdd2VM/vVao023S7B1Aem/2Gj270k=","metadata":{},"hash":"vTmwvA/f3nn3s9VztXMp66ZMY8BLGA3tHYSkbxE8w1E="},"PREVIOUS":{"nodeId":"0962d79a-aa3e-4daa-abb7-a7675666d19d","metadata":{},"hash":"mN7eglmtSO7Vy0RVAcD60DCS6Zy9+bqP1ixgeNnb5+8="}},"hash":"GvDxMoGELKUZUqIeLv1HNM2SL4k2Smm30m3cT/+Wc30=","text":"In the example below, the getArtist and getArtistAlbums functions are defined outside the Page component, then called inside\r\nthe component, and we wait for both promises to resolve:\r\napp/artist/[username]/page.tsx (tsx)import Albums from './albums'\r\nasync function getArtist(username: string) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}`)\r\n  return res.json()\r\n}\r\nasync function getArtistAlbums(username: string) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\r\n  return res.json()\r\n}\r\nexport default async function Page({\r\n  params: { username },\r\n}: {\r\n  params: { username: string }\r\n}) {\r\n  // Initiate both requests in parallel\r\n  const artistData = getArtist(username)\r\n  const albumsData = getArtistAlbums(username)\r\n  // Wait for the promises to resolve\r\n  const [artist, albums] = await Promise.all([artistData, albumsData])\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e7e16c82-fcf9-4819-b020-4f01d3523756":{"id_":"e7e16c82-fcf9-4819-b020-4f01d3523756","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6MiBcY5V9054VkTSUi+WCoLfXGd9ueaT+wmrJrmbIP0=","metadata":{},"hash":"hVOsBNW8IZTBoOxQJZhMDKkfWtuvyL0H2/KetYOA78U="}},"hash":"yNHTw4vJDWAZYer2jP3Bk21kuyUpyI9DT1kGET7pfCI=","text":"<Albums list={albums}></Albums>\r\n    </>\r\n  )\r\n}\r\napp/artist/[username]/page.js (jsx)import Albums from './albums'\r\nasync function getArtist(username) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}`)\r\n  return res.json()\r\n}\r\nasync function getArtistAlbums(username) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\r\n  return res.json()\r\n}\r\nexport default async function Page({ params: { username } }) {\r\n  // Initiate both requests in parallel\r\n  const artistData = getArtist(username)\r\n  const albumsData = getArtistAlbums(username)\r\n  // Wait for the promises to resolve\r\n  const [artist, albums] = await Promise.all([artistData, albumsData])\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      <Albums list={albums}></Albums>\r\n    </>\r\n  )\r\n}\r\nTo improve the user experience, you can add a Suspense Boundary to break up the rendering work and show part of the result as soon\r\nas possible. Preloading Data\r\nAnother way to prevent waterfalls is to use the preload pattern. You can optionally create a preload function to further optimize\r\nparallel data fetching. With this approach, you don’t have to pass promises down as props. The preload function can also have any\r\nname as it’s a pattern, not an API. components/Item.tsx (tsx)import { getItem } from '@/utils/get-item'\r\nexport const preload = (id: string) => {\r\n  // void evaluates the given expression and returns undefined\r\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\r\n  void getItem(id)\r\n}\r\nexport default async function Item({ id }: { id: string }) {\r\n  const result = await getItem(id)\r\n  // ... }\r\ncomponents/Item.js (jsx)import { getItem } from '@/utils/get-item'\r\nexport const preload = (id) => {\r\n  // void evaluates the given expression and returns undefined\r\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\r\n  void getItem(id)\r\n}\r\nexport default async function Item({ id }) {\r\n  const result = await getItem(id)\r\n  // ... }\r\napp/item/[id]/page.tsx (tsx)import Item, { preload, checkIsAvailable } from '@/components/Item'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8ed8e8c1-52cf-4297-ac61-bfd5f2255e34":{"id_":"8ed8e8c1-52cf-4297-ac61-bfd5f2255e34","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YeWqiDgXwKV3/vSlZHPAkWBAtjUnPuF4ChvkgyAzVgM=","metadata":{},"hash":"lqeNNHYhmHeKifTZ/UNBm5Iy+yPt20XgC+VRJcKdf2Q="}},"hash":"N0PlbVM+rnraf/DVfdF4NJmlpADOTRRzCBaWaxjV/Kk=","text":"export default async function Page({\r\n  params: { id },\r\n}: {\r\n  params: { id: string }\r\n}) {\r\n  // starting loading item data\r\n  preload(id)\r\n  // perform another asynchronous task\r\n  const isAvailable = await checkIsAvailable()\r\n  return isAvailable ? <Item id={id} /> : null\r\n}\r\napp/item/[id]/page.js (jsx)import Item, { preload, checkIsAvailable } from '@/components/Item'\r\nexport default async function Page({ params: { id } }) {\r\n  // starting loading item data\r\n  preload(id)\r\n  // perform another asynchronous task\r\n  const isAvailable = await checkIsAvailable()\r\n  return isAvailable ? <Item id={id} /> : null\r\n}\r\nUsing React cachecache, server-onlyserver-only, and the Preload Pattern\r\nYou can combine the cache function, the preload pattern, and the server-only package to create a data fetching utility that can be\r\nused throughout your app. utils/get-item.ts (ts)import { cache } from 'react'\r\nimport 'server-only'\r\nexport const preload = (id: string) => {\r\n  void getItem(id)\r\n}\r\nexport const getItem = cache(async (id: string) => {\r\n  // ... })\r\nutils/get-item.js (js)import { cache } from 'react'\r\nimport 'server-only'\r\nexport const preload = (id) => {\r\n  void getItem(id)\r\n}\r\nexport const getItem = cache(async (id) => {\r\n  // ... })\r\nWith this approach, you can eagerly fetch data, cache responses, and guarantee that this data fetching only happens on the server. The utils/get-item exports can be used by Layouts, Pages, or other components to give them control over when an item’s data is\r\nfetched. Good to know:\r\nWe recommend using the server-only package to make sure server data fetching functions are never used on the client. Preventing sensitive data from being exposed to the client\r\nWe recommend using React’s taint APIs, taintObjectReference and taintUniqueValue, to prevent whole object instances or\r\nsensitive values from being passed to the client. To enable tainting in your application, set the Next.js Config experimental.taint option to true:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fa0c1afb-f81a-425e-9d1b-6257e2f3743f":{"id_":"fa0c1afb-f81a-425e-9d1b-6257e2f3743f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7yrIeCxbJ4FEBqHn27ee2Z+gE8dtPA5pDSRn85siQAw=","metadata":{},"hash":"9jHY/xlPyhRVhRo5eHwtUB6y6GW+yKtuXyjgnUhdOgM="}},"hash":"TfwkdKirVh9XIDiVI/m375aD7IXNEqgVWY8tvnvUTP8=","text":"taint: true,\r\n  },\r\n}\r\nThen pass the object or value you want to taint to the experimental_taintObjectReference or\r\nexperimental_taintUniqueValue functions:\r\napp/utils.ts (ts)import { queryDataFromDB } from './api'\r\nimport {\r\n  experimental_taintObjectReference,\r\n  experimental_taintUniqueValue,\r\n} from 'react'\r\nexport async function getUserData() {\r\n  const data = await queryDataFromDB()\r\n  experimental_taintObjectReference(\r\n    'Do not pass the whole user object to the client',\r\n    data\r\n  )\r\n  experimental_taintUniqueValue(\r\n    \"Do not pass the user's phone number to the client\",\r\n    data,\r\n    data.phoneNumber\r\n  )\r\n  return data\r\n}\r\napp/utils.js (js)import { queryDataFromDB } from './api'\r\nimport {\r\n  experimental_taintObjectReference,\r\n  experimental_taintUniqueValue,\r\n} from 'react'\r\nexport async function getUserData() {\r\n  const data = await queryDataFromDB()\r\n  experimental_taintObjectReference(\r\n    'Do not pass the whole user object to the client',\r\n    data\r\n  )\r\n  experimental_taintUniqueValue(\r\n    \"Do not pass the user's phone number to the client\",\r\n    data,\r\n    data.phoneNumber\r\n  )\r\n  return data\r\n}\r\napp/page.tsx (tsx)import { getUserData } from './data'\r\nexport async function Page() {\r\n  const userData = getUserData()\r\n  return (\r\n    <ClientComponent\r\n      user={userData} // this will cause an error because of taintObjectReference\r\n      phoneNumber={userData.phoneNumber} // this will cause an error because of taintUniqueValue\r\n    />\r\n  )\r\n}\r\napp/page.js (jsx)import { getUserData } from './data'\r\nexport async function Page() {\r\n  const userData = getUserData()\r\n  return (\r\n    <ClientComponent\r\n      user={userData} // this will cause an error because of taintObjectReference\r\n      phoneNumber={userData.phoneNumber} // this will cause an error because of taintUniqueValue\r\n    />\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c81c92cc-64d4-4f2c-bb75-2756855d3043":{"id_":"c81c92cc-64d4-4f2c-bb75-2756855d3043","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DtfkggNSGH3n5dBdugSdm5pc/lCOInbpIZ/WeSR05W4=","metadata":{},"hash":"g/xjBEZe5g+hYvQYMHz1TArL5WVNDXN7i+aWTdCAJOs="}},"hash":"XGQEqE5wGchyiep35V+TUkCV0jV/1GNdZ6ADtuQtdyo=","text":"Learn more about Security and Server Actions.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"730b80b6-9d8a-41de-86ce-ebc7889cccb4":{"id_":"730b80b6-9d8a-41de-86ce-ebc7889cccb4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yvs7yfeAJsxgTYYVaCqyMhJaIMV+slW99+CYs73narE=","metadata":{},"hash":"lLt2L7939TWygKLAc7XVF727mzKgFSwXfwSNLHa9yNQ="},"NEXT":{"nodeId":"93cde329-0641-4dc1-b8fa-0b8af7195518","metadata":{},"hash":"abbTQqrt8i7Y6iKnUGRRivFAIfps8rnseIrGpVpwxy8="}},"hash":"COqOQ5j3LRe1GuE8RkWO7agKmeAOmFctRdqMREh8/MY=","text":"3.1.3 - Rendering\r\nDocumentation path: /02-app/01-building-your-application/03-rendering/index\r\nDescription: Learn the differences between Next.js rendering environments, strategies, and runtimes. Rendering converts the code you write into user interfaces. React and Next.js allow you to create hybrid web applications where parts\r\nof your code can be rendered on the server or the client. This section will help you understand the differences between these rendering\r\nenvironments, strategies, and runtimes. Fundamentals\r\nTo start, it’s helpful to be familiar with three foundational web concepts:\r\nThe Environments your application code can be executed in: the server and the client. The Request-Response Lifecycle that’s initiated when a user visits or interacts with your application. The Network Boundary that separates server and client code. Rendering Environments\r\nThere are two environments where web applications can be rendered: the client and the server. The client refers to the browser on a user’s device that sends a request to a server for your application code. It then turns the\r\nresponse from the server into a user interface. The server refers to the computer in a data center that stores your application code, receives requests from a client, and sends\r\nback an appropriate response. Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the\r\nclient. With React, developers can use the same language (JavaScript), and the same framework (e.g. Next.js or your framework of\r\nchoice). This flexibility allows you to seamlessly write code for both environments without context switching. However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is\r\nnot always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment\r\nover the other. Understanding these differences is key to effectively using React and Next.js. We’ll cover the differences and use cases in more detail on\r\nthe Server and Client Components pages, for now, let’s continue building on our foundation. Request-Response Lifecycle\r\nBroadly speaking, all websites follow the same Request-Response Lifecycle:\r\n1. User Action: The user interacts with a web application. This could be clicking a link, submitting a form, or typing a URL directly into\r\nthe browser’s address bar. 2.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"93cde329-0641-4dc1-b8fa-0b8af7195518":{"id_":"93cde329-0641-4dc1-b8fa-0b8af7195518","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yvs7yfeAJsxgTYYVaCqyMhJaIMV+slW99+CYs73narE=","metadata":{},"hash":"lLt2L7939TWygKLAc7XVF727mzKgFSwXfwSNLHa9yNQ="},"PREVIOUS":{"nodeId":"730b80b6-9d8a-41de-86ce-ebc7889cccb4","metadata":{},"hash":"COqOQ5j3LRe1GuE8RkWO7agKmeAOmFctRdqMREh8/MY="}},"hash":"abbTQqrt8i7Y6iKnUGRRivFAIfps8rnseIrGpVpwxy8=","text":"2. HTTP Request: The client sends an HTTP request to the server that contains necessary information about what resources are being\r\nrequested, what method is being used (e.g. GET, POST), and additional data if necessary. 3. Server: The server processes the request and responds with the appropriate resources. This process may take a couple of steps like\r\nrouting, fetching data, etc. 4. HTTP Response: After processing the request, the server sends an HTTP response back to the client. This response contains a","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1129e1af-3184-485f-984e-340843e40a10":{"id_":"1129e1af-3184-485f-984e-340843e40a10","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"efzFShsyi9+3ubqzBKiknVR3OvJpK93jNrL7ejwgvZM=","metadata":{},"hash":"v2UBFZR/TescdpPnl7gW5T56/sr//PIULxSHCZi2gDY="},"NEXT":{"nodeId":"dd7650f5-9765-413e-94ab-8a9aa4502f0c","metadata":{},"hash":"h20Td4JAm6aVU1+djKOxb4MU/me9EaH6X6NxgMl9uUo="}},"hash":"6p/NBVa95gOryot9NPDNjM+SEQCtOrUiVNggmoiiaBg=","text":"status code (which tells the client whether the request was successful or not) and requested resources (e.g. HTML, CSS, JavaScript,\r\nstatic assets, etc). 5. Client: The client parses the resources to render the user interface. 6. User Action: Once the user interface is rendered, the user can interact with it, and the whole process starts again. A major part of building a hybrid web application is deciding how to split the work in the lifecycle, and where to place the Network\r\nBoundary. Network Boundary\r\nIn web development, the Network Boundary is a conceptual line that separates the different environments. For example, the client\r\nand the server, or the server and the data store. {/ Diagram: Network Boundary /}\r\nIn React, you choose where to place the client-server network boundary wherever it makes the most sense. Behind the scenes, the work is split into two parts: the client module graph and the server module graph. The server module graph\r\ncontains all the components that are rendered on the server, and the client module graph contains all components that are rendered\r\non the client. {/ Diagram: Client and Server Module Graphs /}\r\nIt may be helpful to think about module graphs as a visual representation of how files in your application depend on each other. {/ For example, if you have a file called Page.jsx that imports a file called Button.jsx on the server, the module graph would look\r\nsomething like this: - Diagram - /}\r\nYou can use the React \"use client\" convention to define the boundary. There’s also a \"use server\" convention, which tells React\r\nto do some computational work on the server. Building Hybrid Applications\r\nWhen working in these environments, it’s helpful to think of the flow of the code in your application as unidirectional. In other words,\r\nduring a response, your application code flows in one direction: from the server to the client. {/ Diagram: Response flow /}\r\nIf you need to access the server from the client, you send a new request to the server rather than re-use the same request. This makes\r\nit easier to understand where to render your components and where to place the Network Boundary. In practice, this model encourages developers to think about what they want to execute on the server first, before sending the result to\r\nthe client and making the application interactive.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dd7650f5-9765-413e-94ab-8a9aa4502f0c":{"id_":"dd7650f5-9765-413e-94ab-8a9aa4502f0c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"efzFShsyi9+3ubqzBKiknVR3OvJpK93jNrL7ejwgvZM=","metadata":{},"hash":"v2UBFZR/TescdpPnl7gW5T56/sr//PIULxSHCZi2gDY="},"PREVIOUS":{"nodeId":"1129e1af-3184-485f-984e-340843e40a10","metadata":{},"hash":"6p/NBVa95gOryot9NPDNjM+SEQCtOrUiVNggmoiiaBg="}},"hash":"h20Td4JAm6aVU1+djKOxb4MU/me9EaH6X6NxgMl9uUo=","text":"This concept will become clearer when we look at how you can interleave client and server components in the same component tree.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6181e742-b9f9-4962-a299-b41e489dc709":{"id_":"6181e742-b9f9-4962-a299-b41e489dc709","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+AIJSgWZ3fFGp8gv3mQ2cj2iA8lbI0CfmBfw3hQweA8=","metadata":{},"hash":"8zc2hgUgQFxMdg333q4ZDkcikg+8vkw2B8bMZvcxqKE="},"NEXT":{"nodeId":"c5dcdeb3-b0cf-4967-a9aa-ffa7234e18d8","metadata":{},"hash":"Exoq5EdXRbEJSzXmfyydMe3quXcsqVqZkbbJzHTQ4sA="}},"hash":"dO7odM9t089ekZZgrtMoNxRsjvSxA0wxwoMttY22K7Q=","text":"3.1.3.1 - Server Components\r\nDocumentation path: /02-app/01-building-your-application/03-rendering/01-server-components\r\nDescription: Learn how you can use React Server Components to render parts of your application on the server. Related:\r\nTitle: Related\r\nRelated Description: Learn how Next.js caches data and the result of static rendering. Links:\r\napp/building-your-application/caching\r\nReact Server Components allow you to write UI that can be rendered and optionally cached on the server. In Next.js, the rendering\r\nwork is further split by route segments to enable streaming and partial rendering, and there are three different server rendering\r\nstrategies:\r\nStatic Rendering\r\nDynamic Rendering\r\nStreaming\r\nThis page will go through how Server Components work, when you might use them, and the different server rendering strategies. Benefits of Server Rendering\r\nThere are a couple of benefits to doing the rendering work on the server, including:\r\nData Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve\r\nperformance by reducing time it takes to fetch data needed for rendering, and the amount of requests the client needs to make. Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk\r\nof exposing them to the client. Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can\r\nimprove performance and reduce cost by reducing the amount of rendering and data fetching done on each request. Bundle Sizes: Server Components allow you to keep large dependencies that previously would impact the client JavaScript bundle\r\nsize on the server. This is beneficial for users with slower internet or less powerful devices, as the client does not have to download,\r\nparse and execute any JavaScript for Server Components. Initial Page Load and First Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page\r\nimmediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page. Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index\r\nyour pages and social network bots to generate social card previews for your pages. Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become\r\nready.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c5dcdeb3-b0cf-4967-a9aa-ffa7234e18d8":{"id_":"c5dcdeb3-b0cf-4967-a9aa-ffa7234e18d8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+AIJSgWZ3fFGp8gv3mQ2cj2iA8lbI0CfmBfw3hQweA8=","metadata":{},"hash":"8zc2hgUgQFxMdg333q4ZDkcikg+8vkw2B8bMZvcxqKE="},"PREVIOUS":{"nodeId":"6181e742-b9f9-4962-a299-b41e489dc709","metadata":{},"hash":"dO7odM9t089ekZZgrtMoNxRsjvSxA0wxwoMttY22K7Q="}},"hash":"Exoq5EdXRbEJSzXmfyydMe3quXcsqVqZkbbJzHTQ4sA=","text":"This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server. Using Server Components in Next.js\r\nBy default, Next.js uses Server Components. This allows you to automatically implement server rendering with no additional\r\nconfiguration, and you can opt into using Client Components when needed, see Client Components. How are Server Components rendered? On the server, Next.js uses React’s APIs to orchestrate rendering. The rendering work is split into chunks: by individual route segments\r\nand Suspense Boundaries. Each chunk is rendered in two steps:\r\n1. React renders Server Components into a special data format called the React Server Component Payload (RSC Payload). 2. Next.js uses the RSC Payload and Client Component JavaScript instructions to render HTML on the server. {/ Rendering Diagram /}\r\nThen, on the client:\r\n1. The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only. 2. The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM. 3. The JavaScript instructions are used to hydrate Client Components and make the application interactive. What is the React Server Component Payload (RSC)?","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d18c135b-5842-4301-ac32-45a3d00e1222":{"id_":"d18c135b-5842-4301-ac32-45a3d00e1222","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QoHY1RnfAygGwVxwttxr0jtpdDp54nd+uvoszKyWFY0=","metadata":{},"hash":"VEgIfiLUkvOs1zXa/tikUx3IVxjff+PS+UKBx1gTeV8="},"NEXT":{"nodeId":"68126f86-cd01-4119-bdc3-3a9aa5a51bb4","metadata":{},"hash":"l0uvJuqSfPspDfCEMw3krNR2ZmPCKO+tdeuPU6L/G7E="}},"hash":"YV/cqoBzjVzMu+nfuZHwvUmM1Odc7CiPbwBrNjMpRW4=","text":"The RSC Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the\r\nclient to update the browser’s DOM. The RSC Payload contains:\r\nThe rendered result of Server Components\r\nPlaceholders for where Client Components should be rendered and references to their JavaScript files\r\nAny props passed from a Server Component to a Client Component\r\nServer Rendering Strategies\r\nThere are three subsets of server rendering: Static, Dynamic, and Streaming. Static Rendering (Default)\r\n{/ Static Rendering Diagram /}\r\nWith Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be\r\npushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and\r\nserver requests. Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static\r\nblog post or a product page. Dynamic Rendering\r\n{/ Dynamic Rendering Diagram /}\r\nWith Dynamic Rendering, routes are rendered for each user at request time. Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at\r\nrequest time, such as cookies or the URL’s search params. Dynamic Routes with Cached Data\r\nIn most websites, routes are not fully static or fully dynamic - it’s a spectrum. For example, you can have an e-commerce page\r\nthat uses cached product data that’s revalidated at an interval, but also has uncached, personalized customer data. In Next.js, you can have dynamically rendered routes that have both cached and uncached data. This is because the RSC\r\nPayload and data are cached separately. This allows you to opt into dynamic rendering without worrying about the\r\nperformance impact of fetching all the data at request time. Learn more about the full-route cache and Data Cache. Switching to Dynamic Rendering\r\nDuring rendering, if a dynamic function or uncached data request is discovered, Next.js will switch to dynamically rendering the whole\r\nroute. This table summarizes how dynamic functions and data caching affect whether a route is statically or dynamically rendered:\r\nDynamic FunctionsDataRoute\r\nNoCachedStatically Rendered\r\nYesCachedDynamically Rendered\r\nNoNot CachedDynamically Rendered\r\nYesNot CachedDynamically Rendered\r\nIn the table above, for a route to be fully static, all data must be cached.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"68126f86-cd01-4119-bdc3-3a9aa5a51bb4":{"id_":"68126f86-cd01-4119-bdc3-3a9aa5a51bb4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QoHY1RnfAygGwVxwttxr0jtpdDp54nd+uvoszKyWFY0=","metadata":{},"hash":"VEgIfiLUkvOs1zXa/tikUx3IVxjff+PS+UKBx1gTeV8="},"PREVIOUS":{"nodeId":"d18c135b-5842-4301-ac32-45a3d00e1222","metadata":{},"hash":"YV/cqoBzjVzMu+nfuZHwvUmM1Odc7CiPbwBrNjMpRW4="}},"hash":"l0uvJuqSfPspDfCEMw3krNR2ZmPCKO+tdeuPU6L/G7E=","text":"However, you can have a dynamically rendered route that uses\r\nboth cached and uncached data fetches. As a developer, you do not need to choose between static and dynamic rendering as Next.js will automatically choose the best\r\nrendering strategy for each route based on the features and APIs used. Instead, you choose when to cache or revalidate specific data,\r\nand you may choose to stream parts of your UI. Dynamic Functions\r\nDynamic functions rely on information that can only be known at request time such as a user’s cookies, current requests headers, or\r\nthe URL’s search params. In Next.js, these dynamic functions are:\r\ncookies()cookies() and headers()headers(): Using these in a Server Component will opt the whole route into dynamic rendering at request time. useSearchParams()useSearchParams():\r\nIn Client Components, it’ll skip static rendering and instead render all Client Components up to the nearest parent Suspense\r\nboundary on the client. We recommend wrapping the Client Component that uses useSearchParams() in a <Suspense/> boundary. This will allow any","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e8c79bad-c02b-420f-9c6d-7cbee8574e63":{"id_":"e8c79bad-c02b-420f-9c6d-7cbee8574e63","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QRkkZeBpxbqnRh+bIm9c8mOwAwdQebsewUc3XcmKjBA=","metadata":{},"hash":"HlWBGXoq7wmeF10wb223ixuKkQSb93j1h8PKLH030Bo="}},"hash":"IrVD7VaSdM5oEFo6jD8r3/L26NJLpkHpSD4ZP+Dxw84=","text":"Client Components above it to be statically rendered. Example.searchParamssearchParams\r\n: Using the Pages prop will opt the page into dynamic rendering at request time. Using any of these functions will opt the whole route into dynamic rendering at request time. Streaming\r\nStreaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes\r\nready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. Streaming is built into the Next.js App Router by default. This helps improve both the initial page loading performance, as well as UI\r\nthat depends on slower data fetches that would block rendering the whole route. For example, reviews on a product page. You can start streaming route segments using loading.js and UI components with React Suspense. See the Loading UI and Streaming\r\nsection for more information.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6feed4f1-5a0d-4331-9dc7-655461d7a97a":{"id_":"6feed4f1-5a0d-4331-9dc7-655461d7a97a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p5Pkb2Diatc0169o+iWkGRREdCWNN6hOIyvdIDYPrHg=","metadata":{},"hash":"i+4zl9uEQZcLw/GSlFmhSJQcShGZfekriKa+yiVoQBU="},"NEXT":{"nodeId":"c9f5a61d-1181-40f5-a12b-450acc1a163b","metadata":{},"hash":"8/exEjAjSdrf40NXHiuvrwVlOBHMfDp2R6EGuq2PKRE="}},"hash":"uNSnQW22mwJ6n5z2AiTNrjddEMaAhqW7WRCY+gCXD+g=","text":"3.1.3.2 - Client Components\r\nDocumentation path: /02-app/01-building-your-application/03-rendering/02-client-components\r\nDescription: Learn how to use Client Components to render parts of your application on the client. Client Components allows you to write interactive UI that can be rendered on the client at request time. In Next.js, client rendering is\r\nopt-in, meaning you have to explicitly decide what components React should render on the client. This page will go through how Client Components work, how they’re rendered, and when you might use them. Benefits of Client Rendering\r\nThere are a couple of benefits to doing the rendering work on the client, including:\r\nInteractivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the\r\nuser and update the UI. Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage, allowing you to build UI for\r\nspecific use cases. Using Client Components in Next.js\r\nTo use Client Components, you can add the React \"use client\" directive at the top of a file, above your imports. \"use client\" is used to declare a boundary between a Server and Client Component modules. This means that by defining a \"use\r\nclient\" in a file, all other modules imported into it, including child components, are considered part of the client bundle. ```tsx filename=”app/counter.tsx” highlight={1} switcher ‘use client’\r\nimport { useState } from ‘react’\r\nexport default function Counter() { const [count, setCount] = useState(0)\r\nreturn (\r\nYou clicked {count} times\r\nsetCount(count + 1)}>Click me) }\r\n```jsx filename=\"app/counter.js\" highlight={1} switcher\r\n'use client'\r\nimport { useState } from 'react'\r\nexport default function Counter() {\r\n  const [count, setCount] = useState(0)\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  )\r\n}\r\nThe diagram below shows that using onClick and useState in a nested component (toggle.js) will cause an error if the \"use\r\nclient\" directive is not defined. This is because, by default, the components are rendered on the server where these APIs are not\r\navailable.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c9f5a61d-1181-40f5-a12b-450acc1a163b":{"id_":"c9f5a61d-1181-40f5-a12b-450acc1a163b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p5Pkb2Diatc0169o+iWkGRREdCWNN6hOIyvdIDYPrHg=","metadata":{},"hash":"i+4zl9uEQZcLw/GSlFmhSJQcShGZfekriKa+yiVoQBU="},"PREVIOUS":{"nodeId":"6feed4f1-5a0d-4331-9dc7-655461d7a97a","metadata":{},"hash":"uNSnQW22mwJ6n5z2AiTNrjddEMaAhqW7WRCY+gCXD+g="}},"hash":"8/exEjAjSdrf40NXHiuvrwVlOBHMfDp2R6EGuq2PKRE=","text":"By defining the \"use client\" directive in toggle.js, you can tell React to render the component and its children on the\r\nclient, where the APIs are available.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"745378d6-4f9b-4539-92c7-3c8327052de2":{"id_":"745378d6-4f9b-4539-92c7-3c8327052de2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AYTkxdPW/ULxJgWUTbrzfmuqkSPMmYLsiyu7Tyi6k80=","metadata":{},"hash":"WosKqBHil42oeC+d64041VFi2SzHl63dfRHeCDEwxkw="}},"hash":"EjwpugrHqPSSfIfLAATD0xLkS2lCXOd/eioPSxbvjtc=","text":"Defining multiple use clientuse client entry points:\r\nYou can define multiple “use client” entry points in your React Component tree. This allows you to split your application into\r\nmultiple client bundles (or branches). However, \"use client\" doesn’t need to be defined in every component that needs to be rendered on the client. Once you\r\ndefine the boundary, all child components and modules imported into it are considered part of the client bundle. How are Client Components Rendered? In Next.js, Client Components are rendered differently depending on whether the request is part of a full page load (an initial visit to\r\nyour application or a page reload triggered by a browser refresh) or a subsequent navigation. Full page load\r\nTo optimize the initial page load, Next.js will use React’s APIs to render a static HTML preview on the server for both Client and Server\r\nComponents. This means, when the user first visits your application, they will see the content of the page immediately, without having\r\nto wait for the client to download, parse, and execute the Client Component JavaScript bundle. On the server:\r\n1. React renders Server Components into a special data format called the React Server Component Payload (RSC Payload), which\r\nincludes references to Client Components. 2. Next.js uses the RSC Payload and Client Component JavaScript instructions to render HTML for the route on the server. Then, on the client:\r\n1. The HTML is used to immediately show a fast non-interactive initial preview of the route. 2. The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM. 3. The JavaScript instructions are used to hydrate Client Components and make their UI interactive. What is hydration?","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1a7cb2cd-f7e8-482d-b54f-b4a37f7161cd":{"id_":"1a7cb2cd-f7e8-482d-b54f-b4a37f7161cd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Rq+aaXdWqWjqazxkBmO4ZUCCg+dV+eXac4MBUaBubAw=","metadata":{},"hash":"B5gHwACqZzN8AsHCxN25BrBATFAhyuTjfhN0Q0VZPeE="}},"hash":"D2RlrP35Re1UEZuZokCHhFttmrToLr5j3nc2cWD9vEE=","text":"Hydration is the process of attaching event listeners to the DOM, to make the static HTML interactive. Behind the scenes,\r\nhydration is done with the hydrateRoot React API. Subsequent Navigations\r\nOn subsequent navigations, Client Components are rendered entirely on the client, without the server-rendered HTML. This means the Client Component JavaScript bundle is downloaded and parsed. Once the bundle is ready, React will use the RSC\r\nPayload to reconcile the Client and Server Component trees, and update the DOM. Going back to the Server Environment\r\nSometimes, after you’ve declared the \"use client\" boundary, you may want to go back to the server environment. For example, you\r\nmay want to reduce the client bundle size, fetch data on the server, or use an API that is only available on the server. You can keep code on the server even though it’s theoretically nested inside Client Components by interleaving Client and Server\r\nComponents and Server Actions. See the Composition Patterns page for more information.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"95d11fb1-bf46-4119-880d-bf148039c346":{"id_":"95d11fb1-bf46-4119-880d-bf148039c346","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nZ/myua2rYvkDvyGc6q+QPWt5f9yUcGrfkcnsB01d+M=","metadata":{},"hash":"Xz5X9Kbb1lVR5u4JH0gv1l9cBiQ2uPwgU40ExJCsfJE="},"NEXT":{"nodeId":"c0c8200f-1187-4022-a84a-a76fdd125ce5","metadata":{},"hash":"Pa6xNjVe2y5z8z7bJ99jQdMRCaUzxV/4EmiaAz/hsow="}},"hash":"7iZ3LwLM1GoSY9hFK+3FmEhy44w20f+A10SSf64G1Zs=","text":"3.1.3.3 - Server and Client Composition Patterns\r\nDocumentation path: /02-app/01-building-your-application/03-rendering/03-composition-patterns\r\nDescription: Recommended patterns for using Server and Client Components. When building React applications, you will need to consider what parts of your application should be rendered on the server or the\r\nclient. This page covers some recommended composition patterns when using Server and Client Components. When to use Server and Client Components? Here’s a quick summary of the different use cases for Server and Client Components:\r\nWhat do you need to do?Server ComponentClient Component\r\nFetch data\r\nAccess backend resources (directly)\r\nKeep sensitive information on the server (access tokens, API keys, etc)\r\nKeep large dependencies on the server / Reduce client-side JavaScript\r\nAdd interactivity and event listeners (onClick(), onChange(), etc)\r\nUse State and Lifecycle Effects (useState(), useReducer(), useEffect(), etc)\r\nUse browser-only APIs\r\nUse custom hooks that depend on state, effects, or browser-only APIs\r\nUse React Class components\r\nServer Component Patterns\r\nBefore opting into client-side rendering, you may wish to do some work on the server like fetching data, or accessing your database or\r\nbackend services. Here are some common patterns when working with Server Components:\r\nSharing data between components\r\nWhen fetching data on the server, there may be cases where you need to share data across different components. For example, you\r\nmay have a layout and a page that depend on the same data. Instead of using React Context (which is not available on the server) or passing data as props, you can use fetch or React’s cache\r\nfunction to fetch the same data in the components that need it, without worrying about making duplicate requests for the same data. This is because React extends fetch to automatically memoize data requests, and the cache function can be used when fetch is not\r\navailable. Learn more about memoization in React. Keeping Server-only Code out of the Client Environment\r\nSince JavaScript modules can be shared between both Server and Client Components modules, it’s possible for code that was only ever\r\nintended to be run on the server to sneak its way into the client.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c0c8200f-1187-4022-a84a-a76fdd125ce5":{"id_":"c0c8200f-1187-4022-a84a-a76fdd125ce5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nZ/myua2rYvkDvyGc6q+QPWt5f9yUcGrfkcnsB01d+M=","metadata":{},"hash":"Xz5X9Kbb1lVR5u4JH0gv1l9cBiQ2uPwgU40ExJCsfJE="},"PREVIOUS":{"nodeId":"95d11fb1-bf46-4119-880d-bf148039c346","metadata":{},"hash":"7iZ3LwLM1GoSY9hFK+3FmEhy44w20f+A10SSf64G1Zs="}},"hash":"Pa6xNjVe2y5z8z7bJ99jQdMRCaUzxV/4EmiaAz/hsow=","text":"For example, take the following data-fetching function:\r\nlib/data.ts (ts)export async function getData() {\r\n  const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n  return res.json()\r\n}\r\nlib/data.js (js)export async function getData() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3c45fa9f-5661-462b-acd7-91b8de30ae07":{"id_":"3c45fa9f-5661-462b-acd7-91b8de30ae07","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GxvCwbsBwMbCKlZ/gyEsW6eingj5QObU2nI/0sxA5XA=","metadata":{},"hash":"zd+G9iH2TphZtn6qBDuJXNfCn9tgPx9eNdjdip+mwsw="},"NEXT":{"nodeId":"356b6b46-6006-4009-b0c0-aa2650b01f67","metadata":{},"hash":"Gt2K5JcUKgTMyqVwpIGVrU/9AmKugTOsjh3CWjOaxtE="}},"hash":"RLWg6Y4hE54ZCbKylda87l0G6ht8zEepD9L26zr4+uQ=","text":"const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n  return res.json()\r\n}\r\nAt first glance, it appears that getData works on both the server and the client. However, this function contains an API_KEY, written\r\nwith the intention that it would only ever be executed on the server. Since the environment variable API_KEY is not prefixed with NEXT_PUBLIC, it’s a private variable that can only be accessed on the\r\nserver. To prevent your environment variables from being leaked to the client, Next.js replaces private environment variables with an\r\nempty string. As a result, even though getData() can be imported and executed on the client, it won’t work as expected. And while making the\r\nvariable public would make the function work on the client, you may not want to expose sensitive information to the client. To prevent this sort of unintended client usage of server code, we can use the server-only package to give other developers a build-\r\ntime error if they ever accidentally import one of these modules into a Client Component. To use server-only, first install the package:\r\nTerminal (bash)npm install server-only\r\nThen import the package into any module that contains server-only code:\r\nlib/data.js (js)import 'server-only'\r\nexport async function getData() {\r\n  const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n  return res.json()\r\n}\r\nNow, any Client Component that imports getData() will receive a build-time error explaining that this module can only be used on the\r\nserver. The corresponding package client-only can be used to mark modules that contain client-only code – for example, code that accesses\r\nthe window object. Using Third-party Packages and Providers\r\nSince Server Components are a new React feature, third-party packages and providers in the ecosystem are just beginning to add the\"use client\"\r\n directive to components that use client-only features like useState, useEffect, and createContext. Today, many components from npm packages that use client-only features do not yet have the directive. These third-party components\r\nwill work as expected within Client Components since they have the \"use client\" directive, but they won’t work within Server\r\nComponents. For example, let’s say you’ve installed the hypothetical acme-carousel package which has a <Carousel /> component.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"356b6b46-6006-4009-b0c0-aa2650b01f67":{"id_":"356b6b46-6006-4009-b0c0-aa2650b01f67","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GxvCwbsBwMbCKlZ/gyEsW6eingj5QObU2nI/0sxA5XA=","metadata":{},"hash":"zd+G9iH2TphZtn6qBDuJXNfCn9tgPx9eNdjdip+mwsw="},"PREVIOUS":{"nodeId":"3c45fa9f-5661-462b-acd7-91b8de30ae07","metadata":{},"hash":"RLWg6Y4hE54ZCbKylda87l0G6ht8zEepD9L26zr4+uQ="}},"hash":"Gt2K5JcUKgTMyqVwpIGVrU/9AmKugTOsjh3CWjOaxtE=","text":"This\r\ncomponent uses useState, but it doesn’t yet have the \"use client\" directive. If you use <Carousel /> within a Client Component, it will work as expected:\r\napp/gallery.tsx (tsx)'use client'\r\nimport { useState } from 'react'\r\nimport { Carousel } from 'acme-carousel'\r\nexport default function Gallery() {\r\n  let [isOpen, setIsOpen] = useState(false)\r\n  return (\r\n    <div>\r\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\r\n      {/* Works, since Carousel is used within a Client Component */}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a47ec14d-64c3-4609-aa52-aad48cf421a2":{"id_":"a47ec14d-64c3-4609-aa52-aad48cf421a2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Fmpm/Lv3YhnB1AQMpAYO3Qp87BHAxDVQpAIi5ZYM7sA=","metadata":{},"hash":"DyTgBA6Cc1iOgY/BM3wFnrcUj9X06N5eKqtA1MdCg8I="}},"hash":"dXdbe+wc+NB1Pf9qr3AjtlLP/Gtisuq+HfwO6+f3654=","text":"{isOpen && <Carousel />}\r\n    </div>\r\n  )\r\n}\r\napp/gallery.js (jsx)'use client'\r\nimport { useState } from 'react'\r\nimport { Carousel } from 'acme-carousel'\r\nexport default function Gallery() {\r\n  let [isOpen, setIsOpen] = useState(false)\r\n  return (\r\n    <div>\r\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\r\n      {/*  Works, since Carousel is used within a Client Component */}\r\n      {isOpen && <Carousel />}\r\n    </div>\r\n  )\r\n}\r\nHowever, if you try to use it directly within a Server Component, you’ll see an error:\r\napp/page.tsx (tsx)import { Carousel } from 'acme-carousel'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/* Error: `useState` can not be used within Server Components */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}\r\napp/page.js (jsx)import { Carousel } from 'acme-carousel'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/*  Error: `useState` can not be used within Server Components */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}\r\nThis is because Next.js doesn’t know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:\r\napp/carousel.tsx (tsx)'use client'\r\nimport { Carousel } from 'acme-carousel'\r\nexport default Carousel\r\napp/carousel.js (jsx)'use client'\r\nimport { Carousel } from 'acme-carousel'\r\nexport default Carousel\r\nNow, you can use <Carousel /> directly within a Server Component:\r\napp/page.tsx (tsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ad843b51-fdee-4665-b5d7-3e5eac39f0e3":{"id_":"ad843b51-fdee-4665-b5d7-3e5eac39f0e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Pp2yuDuNW3/R0BxHEhoxfz6BcmXbramc+X7Dljeo4Lk=","metadata":{},"hash":"Sq7yD6QBCF/crmgcsqjnMG0DEdV6Sv0N7KwC3jyA95I="}},"hash":"udhEows5rA4y6qBwOJriTnysCauhKEWhHLcCwokEkJs=","text":"import Carousel from './carousel'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/*  Works, since Carousel is a Client Component */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}\r\napp/page.js (jsx)import Carousel from './carousel'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/*  Works, since Carousel is a Client Component */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}\r\nWe don’t expect you to need to wrap most third-party components since it’s likely you’ll be using them within Client Components. However, one exception is providers, since they rely on React state and context, and are typically needed at the root of an application. Learn more about third-party context providers below. Using Context Providers\r\nContext providers are typically rendered near the root of an application to share global concerns, like the current theme. Since React\r\ncontext is not supported in Server Components, trying to create a context at the root of your application will cause an error:\r\napp/layout.tsx (tsx)import { createContext } from 'react'\r\n//  createContext is not supported in Server Components\r\nexport const ThemeContext = createContext({})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { createContext } from 'react'\r\n//  createContext is not supported in Server Components\r\nexport const ThemeContext = createContext({})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nTo fix this, create your context and render its provider inside of a Client Component:\r\napp/theme-provider.tsx (tsx)'use client'\r\nimport { createContext } from 'react'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e4280652-87e0-4cc7-a8ed-fd9d6349c73e":{"id_":"e4280652-87e0-4cc7-a8ed-fd9d6349c73e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"D/rFDlWP3PfLzcHiA0sTVzB9SA9wIjdiBGkW1rxjd3w=","metadata":{},"hash":"IyKYvbjyz+hUVfxTxOAxgEqpLNEr75CCBzGOAHFe3I8="}},"hash":"InGTU54rOUPo2k4gliT1ymCX7KluAZJ5ZfIj+iG4f80=","text":"export const ThemeContext = createContext({})\r\nexport default function ThemeProvider({ children }) {\r\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n}\r\napp/theme-provider.js (jsx)'use client'\r\nimport { createContext } from 'react'\r\nexport const ThemeContext = createContext({})\r\nexport default function ThemeProvider({ children }) {\r\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n}\r\nYour Server Component will now be able to directly render your provider since it’s been marked as a Client Component:\r\napp/layout.tsx (tsx)import ThemeProvider from './theme-provider'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeProvider>{children}</ThemeProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import ThemeProvider from './theme-provider'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeProvider>{children}</ThemeProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nWith the provider rendered at the root, all other Client Components throughout your app will be able to consume this context. Good to know: You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps{children}\r\n instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server\r\nComponents. Advice for Library Authors\r\nIn a similar fashion, library authors creating packages to be consumed by other developers can use the \"use client\" directive to\r\nmark client entry points of their package. This allows users of the package to import package components directly into their Server\r\nComponents without having to create a wrapping boundary. You can optimize your package by using ‘use client’ deeper in the tree, allowing the imported modules to be part of the Server\r\nComponent module graph. It’s worth noting some bundlers might strip out \"use client\" directives. You can find an example of how to configure esbuild to\r\ninclude the \"use client\" directive in the React Wrap Balancer and Vercel Analytics repositories. Client Components\r\nMoving Client Components Down the Tree","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f7d00b9e-d378-4b1e-a6cf-beba37028c75":{"id_":"f7d00b9e-d378-4b1e-a6cf-beba37028c75","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8jDActmWx6u/0gsWlU6FcE4GmGtyFnl8Qhl8jMXQmao=","metadata":{},"hash":"+93Oac74d/grwoMZr99tjceE6ozssFpAh2Nw7TF3tkM="},"NEXT":{"nodeId":"3ee1def8-afd3-4176-b32a-fe5946df42e3","metadata":{},"hash":"KYcWp60nBNEEv9fwEDRWE8fRXTp5jBuw54iM2jcSDqg="}},"hash":"wNZ1Vf7rDfJ1OklAgptNOjyAePkS918UE9ghqr2ysl8=","text":"To reduce the Client JavaScript bundle size, we recommend moving Client Components down your component tree. For example, you may have a Layout that has static elements (e.g. logo, links, etc) and an interactive search bar that uses state. Instead of making the whole layout a Client Component, move the interactive logic to a Client Component (e.g. <SearchBar />) and\r\nkeep your layout as a Server Component. This means you don’t have to send all the component Javascript of the layout to the client. app/layout.tsx (tsx)// SearchBar is a Client Component\r\nimport SearchBar from './searchbar'\r\n// Logo is a Server Component\r\nimport Logo from './logo'\r\n// Layout is a Server Component by default\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Logo />\r\n        <SearchBar />\r\n      </nav>\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}\r\napp/layout.js (jsx)// SearchBar is a Client Component\r\nimport SearchBar from './searchbar'\r\n// Logo is a Server Component\r\nimport Logo from './logo'\r\n// Layout is a Server Component by default\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Logo />\r\n        <SearchBar />\r\n      </nav>\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}\r\nPassing props from Server to Client Components (Serialization)\r\nIf you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server\r\nto Client Components need to be serializable by React. If your Client Components depend on data that is not serializable, you can fetch data on the client with a third party library or on the\r\nserver via a Route Handler. Interleaving Server and Client Components\r\nWhen interleaving Client and Server Components, it may be helpful to visualize your UI as a tree of components. Starting with the root\r\nlayout, which is a Server Component, you can then render certain subtrees of components on the client by adding the \"use client\"\r\ndirective. {/ Diagram - interleaving /}\r\nWithin those client subtrees, you can still nest Server Components or call Server Actions, however there are some things to keep in\r\nmind:\r\nDuring a request-response lifecycle, your code moves from the server to the client.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3ee1def8-afd3-4176-b32a-fe5946df42e3":{"id_":"3ee1def8-afd3-4176-b32a-fe5946df42e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8jDActmWx6u/0gsWlU6FcE4GmGtyFnl8Qhl8jMXQmao=","metadata":{},"hash":"+93Oac74d/grwoMZr99tjceE6ozssFpAh2Nw7TF3tkM="},"PREVIOUS":{"nodeId":"f7d00b9e-d378-4b1e-a6cf-beba37028c75","metadata":{},"hash":"wNZ1Vf7rDfJ1OklAgptNOjyAePkS918UE9ghqr2ysl8="}},"hash":"KYcWp60nBNEEv9fwEDRWE8fRXTp5jBuw54iM2jcSDqg=","text":"If you need to access data or resources on the\r\nserver while on the client, you’ll be making a new request to the server - not switching back and forth. When a new request is made to the server, all Server Components are rendered first, including those nested inside Client\r\nComponents. The rendered result (RSC Payload) will contain references to the locations of Client Components. Then, on the client,\r\nReact uses the RSC Payload to reconcile Server and Client Components into a single tree. {/ Diagram /}\r\nSince Client Components are rendered after Server Components, you cannot import a Server Component into a Client Component\r\nmodule (since it would require a new request back to the server). Instead, you can pass a Server Component as props to a Client","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4e8a9014-f229-4d32-b6ce-d22b6849188b":{"id_":"4e8a9014-f229-4d32-b6ce-d22b6849188b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OgtIquqxCh9IcAre45OgbcZfoSoReIWAFMujIoQfsjQ=","metadata":{},"hash":"zSJ+RzAmC0fZmxbKrHujprD5Sq5Ir88bQdnRH08lxhw="},"NEXT":{"nodeId":"f2e9bbb5-9c70-43bd-a414-0af8d55f797e","metadata":{},"hash":"fJNMEvw4Yky9WPMf98ThN5BppjpxVMBKzGAfux4EO4o="}},"hash":"EbtSDbpa5hyeBJiLuFsDvZVG+0nqkCx6w4Q7w4i+fqo=","text":"Component. See the unsupported pattern and supported pattern sections below. Unsupported Pattern: Importing Server Components into Client Components\r\nThe following pattern is not supported. You cannot import a Server Component into a Client Component:\r\n```tsx filename=”app/client-component.tsx” switcher highlight={4,17} ‘use client’\r\n// You cannot import a Server Component into a Client Component. import ServerComponent from ‘./Server-Component’\r\nexport default function ClientComponent({ children, }: { children: React.ReactNode }) { const [count, setCount] = useState(0)\r\nreturn ( <> setCount(count + 1)}>{count}\r\n  <ServerComponent />\r\n) }\r\n```jsx filename=\"app/client-component.js\" switcher highlight={3,13}\r\n'use client'\r\n// You cannot import a Server Component into a Client Component. import ServerComponent from './Server-Component'\r\nexport default function ClientComponent({ children }) {\r\n  const [count, setCount] = useState(0)\r\n  return (\r\n    <>\r\n      <button onClick={() => setCount(count + 1)}>{count}</button>\r\n      <ServerComponent />\r\n    </>\r\n  )\r\n}\r\nSupported Pattern: Passing Server Components to Client Components as Props\r\nThe following pattern is supported. You can pass Server Components as a prop to a Client Component. A common pattern is to use the React children prop to create a “slot” in your Client Component. In the example below, <ClientComponent> accepts a children prop:\r\n```tsx filename=”app/client-component.tsx” switcher highlight={6,15} ‘use client’\r\nimport { useState } from ‘react’\r\nexport default function ClientComponent({ children, }: { children: React.ReactNode }) { const [count, setCount] = useState(0)\r\nreturn ( <> setCount(count + 1)}>{count} {children} \r\n) }\r\n```jsx filename=\"app/client-component.js\" switcher highlight={5,12}\r\n'use client'\r\nimport { useState } from 'react'\r\nexport default function ClientComponent({ children }) {\r\n  const [count, setCount] = useState(0)\r\n  return (\r\n    <>\r\n      <button onClick={() => setCount(count + 1)}>{count}</button>\r\n      {children}\r\n    </>\r\n  )\r\n}\r\n<ClientComponent> doesn’t know that children will eventually be filled in by the result of a Server Component. The only\r\nresponsibility <ClientComponent> has is to decide where children will eventually be placed.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f2e9bbb5-9c70-43bd-a414-0af8d55f797e":{"id_":"f2e9bbb5-9c70-43bd-a414-0af8d55f797e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OgtIquqxCh9IcAre45OgbcZfoSoReIWAFMujIoQfsjQ=","metadata":{},"hash":"zSJ+RzAmC0fZmxbKrHujprD5Sq5Ir88bQdnRH08lxhw="},"PREVIOUS":{"nodeId":"4e8a9014-f229-4d32-b6ce-d22b6849188b","metadata":{},"hash":"EbtSDbpa5hyeBJiLuFsDvZVG+0nqkCx6w4Q7w4i+fqo="}},"hash":"fJNMEvw4Yky9WPMf98ThN5BppjpxVMBKzGAfux4EO4o=","text":"The only\r\nresponsibility <ClientComponent> has is to decide where children will eventually be placed. In a parent Server Component, you can import both the <ClientComponent> and <ServerComponent> and pass\r\n<ServerComponent> as a child of <ClientComponent>:\r\n```tsx filename=”app/page.tsx” highlight={11} switcher // This pattern works: // You can pass a Server Component as a child or prop of a\r\n// Client Component. import ClientComponent from ‘./client-component’ import ServerComponent from ‘./server-component’\r\n// Pages in Next.js are Server Components by default export default function Page() { return ( ) }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e771d8b0-761a-42e2-8e73-27e40c252e93":{"id_":"e771d8b0-761a-42e2-8e73-27e40c252e93","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"erV7xeqs5F2HlpEUrrG6jUB36zTVm84sFuPEuT7bOiU=","metadata":{},"hash":"qwtB0XOD2JMGAPRuhu7mC4IHviL1dVJOKZgSEtgpzRw="}},"hash":"RueXllgvogW7Dew+SwV0j70cDPKmZv/cg5124B22EF8=","text":"```jsx filename=\"app/page.js\" highlight={11} switcher\r\n// This pattern works:\r\n// You can pass a Server Component as a child or prop of a\r\n// Client Component. import ClientComponent from './client-component'\r\nimport ServerComponent from './server-component'\r\n// Pages in Next.js are Server Components by default\r\nexport default function Page() {\r\n  return (\r\n    <ClientComponent>\r\n      <ServerComponent />\r\n    </ClientComponent>\r\n  )\r\n}\r\nWith this approach, <ClientComponent> and <ServerComponent> are decoupled and can be rendered independently. In this case,\r\nthe child <ServerComponent> can be rendered on the server, well before <ClientComponent> is rendered on the client. Good to know:\r\nThe pattern of “lifting content up” has been used to avoid re-rendering a nested child component when a parent component\r\nre-renders. You’re not limited to the children prop. You can use any prop to pass JSX.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b2120cf9-4354-4ca3-9fed-585b39c6787e":{"id_":"b2120cf9-4354-4ca3-9fed-585b39c6787e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gnpUUfNj04UHwfDQUp+aj6yPFpvLBkb6/PYrIxQlS44=","metadata":{},"hash":"n7zJH5NOa+GNq9uueBcKhCD7rhZYrb4MMC22lL9DaZQ="},"NEXT":{"nodeId":"3e5befca-e460-4138-9831-d6c43647f9be","metadata":{},"hash":"lljeCRFckhhhaphqO6QDrxhQH8Bi6DSYgFQMUNh4IXk="}},"hash":"jXLG+Q+GagykYmDCGXwPwe7W+/McNTLffUSHUpt5z4k=","text":"3.1.3.4 - Edge and Node.js Runtimes\r\nDocumentation path: /02-app/01-building-your-application/03-rendering/04-edge-and-nodejs-runtimes\r\nDescription: Learn about the switchable runtimes (Edge and Node.js) in Next.js. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nIn the context of Next.js, runtime refers to the set of libraries, APIs, and general functionality available to your code during execution. On the server, there are two runtimes where parts of your application code can be rendered:\r\nThe Node.js Runtime (default) has access to all Node.js APIs and compatible packages from the ecosystem. The Edge Runtime is based on Web APIs. Runtime Differences\r\nThere are many considerations to make when choosing a runtime. This table shows the major differences at a glance. If you want a\r\nmore in-depth analysis of the differences, check out the sections below. NodeServerlessEdge\r\nCold Boot/NormalLow\r\nHTTP StreamingYesYesYes\r\nIOAllAllfetch\r\nScalability/HighHighest\r\nSecurityNormalHighHigh\r\nLatencyNormalLowLowest\r\nnpm PackagesAllAllA smaller subset\r\nStatic RenderingYesYesNo\r\nDynamic RenderingYesYesYes\r\nData Revalidation w/ fetchYesYesYes\r\nEdge Runtime\r\nIn Next.js, the lightweight Edge Runtime is a subset of available Node.js APIs. The Edge Runtime is ideal if you need to deliver dynamic, personalized content at low latency with small, simple functions. The Edge\r\nRuntime’s speed comes from its minimal use of resources, but that can be limiting in many scenarios. For example, code executed in the Edge Runtime on Vercel cannot exceed between 1 MB and 4 MB, this limit includes imported\r\npackages, fonts and files, and will vary depending on your deployment infrastructure. Node.js Runtime\r\nUsing the Node.js runtime gives you access to all Node.js APIs, and all npm packages that rely on them. However, it’s not as fast to start\r\nup as routes using the Edge runtime. Deploying your Next.js application to a Node.js server will require managing, scaling, and configuring your infrastructure.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3e5befca-e460-4138-9831-d6c43647f9be":{"id_":"3e5befca-e460-4138-9831-d6c43647f9be","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gnpUUfNj04UHwfDQUp+aj6yPFpvLBkb6/PYrIxQlS44=","metadata":{},"hash":"n7zJH5NOa+GNq9uueBcKhCD7rhZYrb4MMC22lL9DaZQ="},"PREVIOUS":{"nodeId":"b2120cf9-4354-4ca3-9fed-585b39c6787e","metadata":{},"hash":"jXLG+Q+GagykYmDCGXwPwe7W+/McNTLffUSHUpt5z4k="}},"hash":"lljeCRFckhhhaphqO6QDrxhQH8Bi6DSYgFQMUNh4IXk=","text":"Alternatively,\r\nyou can consider deploying your Next.js application to a serverless platform like Vercel, which will handle this for you. Serverless Node.js\r\nServerless is ideal if you need a scalable solution that can handle more complex computational loads than the Edge Runtime. With\r\nServerless Functions on Vercel, for example, your overall code size is 50MB including imported packages, fonts, and files. The downside compared to routes using the Edge is that it can take hundreds of milliseconds for Serverless Functions to boot up before\r\nthey begin processing requests. Depending on the amount of traffic your site receives, this could be a frequent occurrence as the\r\nfunctions are not frequently “warm”. Examples","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c06d394c-d05b-45fe-8a8e-f54d1a49e094":{"id_":"c06d394c-d05b-45fe-8a8e-f54d1a49e094","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HZuT/uCA4WuyPYh1PxaPvVSrZCipvt/pC9vxFnZUzCQ=","metadata":{},"hash":"mQNN94ykgZ8SnGjoUW6R7lENRV0A2J6dEyFFy5FN/v0="}},"hash":"n3nDopoQL4lyhBtHDdOERJTBeP6Cw7K7/iVaHWDktGs=","text":"Segment Runtime Option\r\nYou can specify a runtime for individual route segments in your Next.js application. To do so, declare a variable called runtime and\r\nexport it. The variable must be a string, and must have a value of either 'nodejs' or 'edge' runtime. The following example demonstrates a page route segment that exports a runtime with a value of 'edge':\r\napp/page.tsx (tsx)export const runtime = 'edge' // 'nodejs' (default) | 'edge'\r\napp/page.js (jsx)export const runtime = 'edge' // 'nodejs' (default) | 'edge'\r\nYou can also define runtime on a layout level, which will make all routes under the layout run on the edge runtime:\r\napp/layout.tsx (tsx)export const runtime = 'edge' // 'nodejs' (default) | 'edge'\r\napp/layout.js (jsx)export const runtime = 'edge' // 'nodejs' (default) | 'edge'\r\nIf the segment runtime is not set, the default nodejs runtime will be used. You do not need to use the runtime option if you do not\r\nplan to change from the Node.js runtime. Please refer to the Node.js Docs and Edge Docs for the full list of available APIs. Both runtimes can also support streaming\r\ndepending on your deployment infrastructure.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d14ffb01-56d2-4f33-94d6-1a8091496422":{"id_":"d14ffb01-56d2-4f33-94d6-1a8091496422","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cpGOplhO8p/GL2RoEFqRN8YQcEq7O12HfnnLBzWuKW4=","metadata":{},"hash":"/v7hhUS1EI2T/WZaic+dU6++1Ik3kfVf2bay7c1FZG4="}},"hash":"upAJs8IP9Y1uTCsqn4NQHfC1snG7WrUQ9ZdwlES3dog=","text":"3.1.4 - Caching in Next.js\r\nDocumentation path: /02-app/01-building-your-application/04-caching/index\r\nDescription: An overview of caching mechanisms in Next.js. Next.js improves your application’s performance and reduces costs by caching rendering work and data requests. This page provides an\r\nin-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other. Good to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be\r\nproductive with Next.js. Most of Next.js’ caching heuristics are determined by your API usage and have defaults for the best\r\nperformance with zero or minimal configuration. Overview\r\nHere’s a high-level overview of the different caching mechanisms and their purpose:\r\nMechanismWhatWherePurposeDuration\r\nRequest\r\nMemoization\r\nReturn values of\r\nfunctionsServerRe-use data in a React Component treePer-request lifecycle\r\nData CacheDataServerStore data across user requests anddeploymentsPersistent (can berevalidated)\r\nFull Route CacheHTML and RSC payloadServerReduce rendering cost and improveperformancePersistent (can berevalidated)\r\nRouter CacheRSC PayloadClientReduce server requests on navigationUser session or time-based\r\nBy default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered\r\nand data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically\r\nrendered at build time and when a static route is first visited.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3d4ff927-25d5-48d7-b632-9e58c714726b":{"id_":"3d4ff927-25d5-48d7-b632-9e58c714726b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"H0E9WCokn/8holMQqtojma8PXGBRLzAEyQyndC1wydE=","metadata":{},"hash":"2oaJsL+ZeiVVZZJZXrvW7PEWnt2HIgn2QBhu7/2IrgU="}},"hash":"PVy+gcwnN8BWePpLQ2H7hxU3PqiWBV/+W1Id/2DaYYw=","text":"Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and\r\nwhether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching\r\nbehavior for individual routes and data requests. Request Memoization\r\nReact extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch\r\nfunction for the same data in multiple places in a React component tree while only executing it once. For example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to\r\nfetch data at the top of the tree then forward props between components. Instead, you can fetch data in the components that need it\r\nwithout worrying about the performance implications of making multiple requests across the network for the same data. app/example.tsx (tsx)async function getItem() {\r\n  // The `fetch` function is automatically memoized and the result\r\n  // is cached\r\n  const res = await fetch('https://.../item/1')\r\n  return res.json()\r\n}\r\n// This function is called twice, but only executed the first time\r\nconst item = await getItem() // cache MISS\r\n// The second call could be anywhere in your route\r\nconst item = await getItem() // cache HIT\r\napp/example.js (jsx)async function getItem() {\r\n  // The `fetch` function is automatically memoized and the result\r\n  // is cached\r\n  const res = await fetch('https://.../item/1')\r\n  return res.json()\r\n}\r\n// This function is called twice, but only executed the first time\r\nconst item = await getItem() // cache MISS\r\n// The second call could be anywhere in your route\r\nconst item = await getItem() // cache HIT\r\nHow Request Memoization Works","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8b4a61a5-9124-4e0b-ae28-858a41382ca8":{"id_":"8b4a61a5-9124-4e0b-ae28-858a41382ca8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CsBcLpNOFnueXP7KLKow84TY7kDQ1wJAphOz0bmsQr0=","metadata":{},"hash":"AhOiRMwKytx8qIlOY6UyrX1ryRIxG9IvdZ22ztjQCP0="}},"hash":"hiKPV9NK9E+h+5XkNEXRrByuTgYfEFsh8mWXLQ0Kiaw=","text":"While rendering a route, the first time a particular request is called, its result will not be in memory and it’ll be a cache MISS. Therefore, the function will be executed, and the data will be fetched from the external source, and the result will be stored in\r\nmemory. Subsequent function calls of the request in the same render pass will be a cache HIT, and the data will be returned from memory\r\nwithout executing the function. Once the route has been rendered and the rendering pass is complete, memory is “reset” and all request memoization entries are\r\ncleared. Good to know:\r\nRequest memoization is a React feature, not a Next.js feature. It’s included here to show how it interacts with the other\r\ncaching mechanisms. Memoization only applies to the GET method in fetch requests. Memoization only applies to the React Component tree, this means:\r\nIt applies to fetch requests in generateMetadata, generateStaticParams, Layouts, Pages, and other Server\r\nComponents. It doesn’t apply to fetch requests in Route Handlers as they are not a part of the React component tree. For cases where fetch is not suitable (e.g. some database clients, CMS clients, or GraphQL clients), you can use the React\r\ncache function to memoize functions. Duration\r\nThe cache lasts the lifetime of a server request until the React component tree has finished rendering. Revalidating\r\nSince the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it. Opting out\r\nTo opt out of memoization in fetch requests, you can pass an AbortController signal to the request. app/example.js (js)const { signal } = new AbortController()\r\nfetch(url, { signal })\r\nData Cache\r\nNext.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is\r\npossible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics. Good to know: In the browser, the cache option of fetch indicates how a request will interact with the browser’s HTTP cache,\r\nin Next.js, the cache option indicates how a server-side request will interact with the server’s Data Cache.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"05cb9b26-2084-48ec-ba38-afd20c64bca6":{"id_":"05cb9b26-2084-48ec-ba38-afd20c64bca6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"//USf8okCDifiv/Qv3uFxZODkzVQYyQrR/BHi9OEGow=","metadata":{},"hash":"LQWB1FgIUxyJKC4+RNyJ0sJx3ABPTIwTCKmT36Enexw="},"NEXT":{"nodeId":"269bf6f2-619b-463a-98ae-b7e2b6c482f0","metadata":{},"hash":"unyCUsDrNPv/1gE7u/+oSSu3QuRQc5KaSNJQB1Yl81k="}},"hash":"6Z4jrp+D8MK8KvTEqyuDKPlOlkrrQSm80yoyWjfP9CA=","text":"By default, data requests that use fetch are cached. You can use the cache and next.revalidate options of fetch to configure the\r\ncaching behavior. How the Data Cache Works\r\nThe first time a fetch request is called during rendering, Next.js checks the Data Cache for a cached response. If a cached response is found, it’s returned immediately and memoized. If a cached response is not found, the request is made to the data source, the result is stored in the Data Cache, and memoized. For uncached data (e.g. { cache: 'no-store' }), the result is always fetched from the data source, and memoized. Whether the data is cached or uncached, the requests are always memoized to avoid making duplicate requests for the same data\r\nduring a React render pass. Differences between the Data Cache and Request Memoization\r\nWhile both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across\r\nincoming requests and deployments, whereas memoization only lasts the lifetime of a request. With memoization, we reduce the number of duplicate requests in the same render pass that have to cross the network\r\nboundary from the rendering server to the Data Cache server (e.g. a CDN or Edge Network) or data source (e.g. a database or\r\nCMS). With the Data Cache, we reduce the number of requests made to our origin data source. Duration\r\nThe Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out. Revalidating\r\nCached data can be revalidated in two ways, with:\r\nTime-based Revalidation: Revalidate data after a certain amount of time has passed and a new request is made. This is useful for\r\ndata that changes infrequently and freshness is not as critical. On-demand Revalidation: Revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based\r\nor path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is shown as\r\nsoon as possible (e.g. when content from your headless CMS is updated). Time-based Revalidation\r\nTo revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in\r\nseconds).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"269bf6f2-619b-463a-98ae-b7e2b6c482f0":{"id_":"269bf6f2-619b-463a-98ae-b7e2b6c482f0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"//USf8okCDifiv/Qv3uFxZODkzVQYyQrR/BHi9OEGow=","metadata":{},"hash":"LQWB1FgIUxyJKC4+RNyJ0sJx3ABPTIwTCKmT36Enexw="},"PREVIOUS":{"nodeId":"05cb9b26-2084-48ec-ba38-afd20c64bca6","metadata":{},"hash":"6Z4jrp+D8MK8KvTEqyuDKPlOlkrrQSm80yoyWjfP9CA="}},"hash":"unyCUsDrNPv/1gE7u/+oSSu3QuRQc5KaSNJQB1Yl81k=","text":"// Revalidate at most every hour\r\nfetch('https://...', { next: { revalidate: 3600 } })\r\nAlternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you’re not\r\nable to use fetch. How Time-based Revalidation Works","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0e35324a-99f4-4a57-a9c4-4ed19c9f4d36":{"id_":"0e35324a-99f4-4a57-a9c4-4ed19c9f4d36","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tNUITF/cDLTzwRPudYPCRbXauLLlvXKB45dWsNcCN8s=","metadata":{},"hash":"IHXZ6s9lvlhDvOQKcPvBCUkhE7LYFVLtaepXFvu9f2s="}},"hash":"77hYXI6TrVtPvtvLn4EJqgxidy5RVDNfipar1/Ldv0A=","text":"The first time a fetch request with revalidate is called, the data will be fetched from the external data source and stored in the\r\nData Cache. Any requests that are called within the specified timeframe (e.g. 60-seconds) will return the cached data. After the timeframe, the next request will still return the cached (now stale) data. Next.js will trigger a revalidation of the data in the background. Once the data is fetched successfully, Next.js will update the Data Cache with the fresh data. If the background revalidation fails, the previous data will be kept unaltered. This is similar to stale-while-revalidate behavior. On-demand Revalidation\r\nData can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag). How On-Demand Revalidation Works","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f104e1e3-a284-447a-8288-72b5e5c13e55":{"id_":"f104e1e3-a284-447a-8288-72b5e5c13e55","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"5NzATMi9echG1Qnfc04G1Lt7eNzW/DiHcxP2/B8v/7s=","metadata":{},"hash":"0OEgqCu2FkF51LvkfZKbkFnOX+3p3EfdCxE1gVKV2Do="}},"hash":"m0XUs7GK7bO6vf/Lhgz1/EXtzTIAtMxQz0m/CL2J64M=","text":"The first time a fetch request is called, the data will be fetched from the external data source and stored in the Data Cache. When an on-demand revalidation is triggered, the appropriate cache entries will be purged from the cache. This is different from time-based revalidation, which keeps the stale data in the cache until the fresh data is fetched. The next time a request is made, it will be a cache MISS again, and the data will be fetched from the external data source and\r\nstored in the Data Cache. Opting out\r\nFor individual data fetches, you can opt out of caching by setting the cache option to no-store. This means data will be fetched\r\nwhenever fetch is called. // Opt out of caching for an individual `fetch` request\r\nfetch(`https://...`, { cache: 'no-store' })\r\nAlternatively, you can also use the Route Segment Config options to opt out of caching for a specific route segment. This will affect all\r\ndata requests in the route segment, including third-party libraries. // Opt out of caching for all data requests in the route segment\r\nexport const dynamic = 'force-dynamic'\r\nVercel Data Cache\r\nIf your Next.js application is deployed to Vercel, we recommend reading the Vercel Data Cache documentation for a better\r\nunderstanding of Vercel specific features. Full Route Cache\r\nRelated terms:\r\nYou may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used\r\ninterchangeably to refer to the process of rendering and caching routes of your application at build time. Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead\r\nof rendering on the server for every request, resulting in faster page loads. To understand how the Full Route Cache works, it’s helpful to look at how React handles rendering, and how Next.js caches the result:\r\n1. React Rendering on the Server","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"24fa0474-b5bc-4fe9-bbcf-cde548871fb7":{"id_":"24fa0474-b5bc-4fe9-bbcf-cde548871fb7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Miv8jEHVbJ50j55o8Qqpe2i/StZiw/8HEdRR4jGO6PA=","metadata":{},"hash":"7NO4jN04tXvMwDBQs7Us78pivtavYxNxeCUVHLt4afg="}},"hash":"ypptO9v7mMmixJERCqrNslo8wr7zDHECJGlp8VEC4lU=","text":"On the server, Next.js uses React’s APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments\r\nand Suspense boundaries. Each chunk is rendered in two steps:\r\n1. React renders Server Components into a special data format, optimized for streaming, called the React Server Component\r\nPayload. 2. Next.js uses the React Server Component Payload and Client Component JavaScript instructions to render HTML on the server. This means we don’t have to wait for everything to render before caching the work or sending a response. Instead, we can stream a\r\nresponse as work is completed. What is the React Server Component Payload? The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It’s\r\nused by React on the client to update the browser’s DOM. The React Server Component Payload contains:\r\nThe rendered result of Server Components\r\nPlaceholders for where Client Components should be rendered and references to their JavaScript files\r\nAny props passed from a Server Component to a Client Component\r\nTo learn more, see the Server Components documentation. 2. Next.js Caching on the Server (Full Route Cache)\r\nThe default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation. 3. React Hydration and Reconciliation on the Client\r\nAt request time, on the client:\r\n1. The HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components. 2. The React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM. 3. The JavaScript instructions are used to hydrate Client Components and make the application interactive. 4. Next.js Caching on the Client (Router Cache)\r\nThe React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route\r\nsegment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future\r\nroutes. 5. Subsequent Navigations\r\nOn subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5d2b0468-1a0f-44b7-bb93-bd9bcc066908":{"id_":"5d2b0468-1a0f-44b7-bb93-bd9bcc066908","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sP7pbysA966yzqskCx6XpaUFln+y4ziiacgut6lN9L0=","metadata":{},"hash":"gfx5F+Ip5AMEakmYb3BZzZCCUjB0ruU1NwR41zFM38o="}},"hash":"aZkfIs2bZJMJCFL0r8KDTuroObLjE6zEcxbBMRLOZh0=","text":"Cache. If so, it will skip sending a new request to the server. If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the\r\nRouter Cache on the client. Static and Dynamic Rendering\r\nWhether a route is cached or not at build time depends on whether it’s statically or dynamically rendered. Static routes are cached by\r\ndefault, whereas dynamic routes are rendered at request time, and not cached. This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:\r\nLearn more about static and dynamic rendering. Duration\r\nBy default, the Full Route Cache is persistent. This means that the render output is cached across user requests. Invalidation\r\nThere are two ways you can invalidate the Full Route Cache:\r\nRevalidating Data: Revalidating the Data Cache, will in turn invalidate the Router Cache by re-rendering components on the server\r\nand caching the new render output. Redeploying: Unlike the Data Cache, which persists across deployments, the Full Route Cache is cleared on new deployments. Opting out\r\nYou can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:\r\nUsing a Dynamic Function: This will opt the route out from the Full Route Cache and dynamically render it at request time. The\r\nData Cache can still be used. Using the dynamic = 'force-dynamic'dynamic = 'force-dynamic' or revalidate = 0revalidate = 0 route segment config options: This will skip the Full Route","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ea29622f-bc5c-4397-bc69-7ff3372fb31c":{"id_":"ea29622f-bc5c-4397-bc69-7ff3372fb31c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Mg8iGWHFiW11FB6e/jShuYZxvhfYJQSojsmLDbQNUm8=","metadata":{},"hash":"+8JUO4HgyfUUqdevOF71xIylyUppbFp5vrk69OhRCTs="}},"hash":"Mhj4aRAuWueE4baoT45ANZURR94puUIXA/t/oyNwodM=","text":"Cache and the Data Cache. Meaning components will be rendered and data fetched on every incoming request to the server. The\r\nRouter Cache will still apply as it’s a client-side cache. Opting out of the Data Cache: If a route has a fetch request that is not cached, this will opt the route out of the Full Route\r\nCache. The data for the specific fetch request will be fetched for every incoming request. Other fetch requests that do not opt\r\nout of caching will still be cached in the Data Cache. This allows for a hybrid of cached and uncached data. Router Cache\r\nRelated Terms:\r\nYou may see the Router Cache being referred to as Client-side Cache or Prefetch Cache. While Prefetch Cache refers to the\r\nprefetched route segments, Client-side Cache refers to the whole Router cache, which includes both visited and prefetched\r\nsegments. This cache specifically applies to Next.js and Server Components, and is different to the browser’s bfcache, though it\r\nhas a similar result. Next.js has an in-memory client-side cache that stores the React Server Component Payload, split by individual route segments, for the\r\nduration of a user session. This is called the Router Cache. How the Router Cache Works\r\nAs a user navigates between routes, Next.js caches visited route segments and prefetches the routes the user is likely to navigate to\r\n(based on <Link> components in their viewport). This results in an improved navigation experience for the user:\r\nInstant backward/forward navigation because visited routes are cached and fast navigation to new routes because of prefetching\r\nand partial rendering. No full-page reload between navigations, and React state and browser state are preserved. Difference between the Router Cache and Full Route Cache:\r\nThe Router Cache temporarily stores the React Server Component Payload in the browser for the duration of a user session,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f4c60e93-ace7-46f0-96b7-4ce58a99b91e":{"id_":"f4c60e93-ace7-46f0-96b7-4ce58a99b91e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RTgDba7stYmpB0NYsSsgI23h1/jJPEoLQPxRy5ic+Fo=","metadata":{},"hash":"fYLqa8Nsz87CQCbSD5QCrk2eI1j+NbA2ZjZD//pdokI="},"NEXT":{"nodeId":"de338d9b-fb6f-4d15-91c8-44dc054efee6","metadata":{},"hash":"p0KfHK2JXjcn8sLVtQ3PGLWLlpMX1nKWVWmhH4iWamo="}},"hash":"iMUUwzST/jVkVN+KEH2dq1Gsct/rs6x06QGAgPRjK1U=","text":"whereas the Full Route Cache persistently stores the React Server Component Payload and HTML on the server across multiple\r\nuser requests. While the Full Route Cache only caches statically rendered routes, the Router Cache applies to both statically and dynamically\r\nrendered routes. Duration\r\nThe cache is stored in the browser’s temporary memory. Two factors determine how long the router cache lasts:\r\nSession: The cache persists across navigation. However, it’s cleared on page refresh. Automatic Invalidation Period: The cache of an individual segment is automatically invalidated after a specific time. The duration\r\ndepends on whether the route is statically or dynamically rendered:\r\nDynamically Rendered: 30 seconds\r\nStatically Rendered: 5 minutes\r\nWhile a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time\r\nit was last accessed or created. By adding prefetch={true} or calling router.prefetch for a dynamically rendered route, you can opt into caching for 5 minutes. Invalidation\r\nThere are two ways you can invalidate the Router Cache:\r\nIn a Server Action:\r\nRevalidating data on-demand by path with (revalidatePath) or by cache tag with (revalidateTag)\r\nUsing cookies.set or cookies.delete invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication). Calling router.refresh will invalidate the Router Cache and make a new request to the server for the current route. Opting out\r\nIt’s not possible to opt out of the Router Cache. You can opt out of prefetching by setting the prefetch prop of the <Link> component to false. However, this will still temporarily\r\nstore the route segments for 30s to allow instant navigation between nested segments, such as tab bars, or back and forward\r\nnavigation. Visited routes will still be cached. Cache Interactions\r\nWhen configuring the different caching mechanisms, it’s important to understand how they interact with each other:\r\nData Cache and Full Route Cache\r\nRevalidating or opting out of the Data Cache will invalidate the Full Route Cache, as the render output depends on data. Invalidating or opting out of the Full Route Cache does not affect the Data Cache. You can dynamically render a route that has both\r\ncached and uncached data. This is useful when most of your page uses cached data, but you have a few components that rely on\r\ndata that needs to be fetched at request time.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"de338d9b-fb6f-4d15-91c8-44dc054efee6":{"id_":"de338d9b-fb6f-4d15-91c8-44dc054efee6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RTgDba7stYmpB0NYsSsgI23h1/jJPEoLQPxRy5ic+Fo=","metadata":{},"hash":"fYLqa8Nsz87CQCbSD5QCrk2eI1j+NbA2ZjZD//pdokI="},"PREVIOUS":{"nodeId":"f4c60e93-ace7-46f0-96b7-4ce58a99b91e","metadata":{},"hash":"iMUUwzST/jVkVN+KEH2dq1Gsct/rs6x06QGAgPRjK1U="}},"hash":"p0KfHK2JXjcn8sLVtQ3PGLWLlpMX1nKWVWmhH4iWamo=","text":"You can dynamically render without worrying about the performance impact of re-\r\nfetching all the data. Data Cache and Client-side Router cache\r\nRevalidating the Data Cache in a Route Handler will not immediately invalidate the Router Cache as the Route Handler isn’t tied to\r\na specific route. This means Router Cache will continue to serve the previous payload until a hard refresh, or the automatic\r\ninvalidation period has elapsed. To immediately invalidate the Data Cache and Router cache, you can use revalidatePath or revalidateTag in a Server Action. APIs\r\nThe following table provides an overview of how different Next.js APIs affect caching:\r\nAPIRouter CacheFull Route CacheData CacheReact Cache\r\n<Link prefetch>Cache\r\nrouter.prefetchCache","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"de0e9dc1-6d5e-4935-8e5d-94a0dac93b96":{"id_":"de0e9dc1-6d5e-4935-8e5d-94a0dac93b96","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"on8p08OsiRRTmacNztyQLYXo/N+TsAenLTXNuVIGMQU=","metadata":{},"hash":"w1yLMJljgLxp3tCEWn29NznkuSIgiriJDboLNde5fDo="}},"hash":"75zJf56UYApoWVkD5QM8fO+/NIeNNOW1gCfdzUkdlBs=","text":"router.refreshRevalidate\r\nfetchCacheCache\r\nfetch options.cacheCache or Opt out\r\nfetch options.next.revalidateRevalidateRevalidate\r\nfetch options.next.tagsCacheCache\r\nrevalidateTagRevalidate (Server\r\nAction)RevalidateRevalidate\r\nrevalidatePathRevalidate (Server\r\nAction)RevalidateRevalidate\r\nconst revalidateRevalidate or Opt outRevalidate or Opt out\r\nconst dynamicCache or Opt outCache or Opt out\r\ncookiesRevalidate (Server\r\nAction)Opt out\r\nheaders, useSearchParams,\r\nsearchParamsOpt out\r\ngenerateStaticParamsCache\r\nReact.cacheCache\r\nunstable_cache\r\nAPIRouter CacheFull Route CacheData CacheReact Cache\r\n<Link><Link>\r\nBy default, the <Link> component automatically prefetches routes from the Full Route Cache and adds the React Server Component\r\nPayload to the Router Cache. To disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will\r\nstill be cached client-side when the user visits the route. Learn more about the <Link> component. router.prefetchrouter.prefetch\r\nThe prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload\r\nto the Router Cache. See the useRouter hook API reference. router.refreshrouter.refresh\r\nThe refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and\r\nmakes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache. The rendered result will be reconciled on the client while preserving React state and browser state. See the useRouter hook API reference. fetchfetch\r\nData returned from fetch is automatically cached in the Data Cache. // Cached by default. `force-cache` is the default option and can be ommitted. fetch(`https://...`, { cache: 'force-cache' })\r\nSee the fetch API Reference for more options. fetch options.cachefetch options.cache","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bdffd44c-c4a5-4eeb-a8dc-e64fcef9c80b":{"id_":"bdffd44c-c4a5-4eeb-a8dc-e64fcef9c80b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DewfHTE1E2nDFPH0hAwZlRE852iklhIMcqrGkxNKGuE=","metadata":{},"hash":"AeqRBr+7sV2M0lC30kzlk0T4dwRHTGOSeESGUkTF+t4="},"NEXT":{"nodeId":"fecf19bb-dac0-4e6b-80d8-97237ed0c5e9","metadata":{},"hash":"N7UcXV+JCOpNEazfi9H/aKUL581RdezdtqOO8PmoxLI="}},"hash":"4zCah2LWsb4P3LIYr3+KgW5dQWbzo6Rof/GZ8nuupmY=","text":"You can opt out individual fetch requests of data caching by setting the cache option to no-store:\r\n// Opt out of caching\r\nfetch(`https://...`, { cache: 'no-store' })\r\nSince the render output depends on data, using cache: 'no-store' will also skip the Full Route Cache for the route where the fetch\r\nrequest is used. That is, the route will be dynamically rendered every request, but you can still have other cached data requests in the\r\nsame route. See the fetch API Reference for more options. fetch options.next.revalidatefetch options.next.revalidate\r\nYou can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will\r\nrevalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-\r\nrendered on the server. // Revalidate at most after 1 hour\r\nfetch(`https://...`, { next: { revalidate: 3600 } })\r\nSee the fetch API reference for more options. fetch options.next.tagsfetch options.next.tags and revalidateTagrevalidateTag\r\nNext.js has a cache tagging system for fine-grained data caching and revalidation. 1. When using fetch or unstable_cache, you have the option to tag cache entries with one or more tags. 2. Then, you can call revalidateTag to purge the cache entries associated with that tag. For example, you can set a tag when fetching data:\r\n// Cache data with a tag\r\nfetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })\r\nThen, call revalidateTag with a tag to purge the cache entry:\r\n// Revalidate entries with a specific tag\r\nrevalidateTag('a')\r\nThere are two places you can use revalidateTag, depending on what you’re trying to achieve:\r\n1. Route Handlers - to revalidate data in response of a third party event (e.g. webhook). This will not invalidate the Router Cache\r\nimmediately as the Router Handler isn’t tied to a specific route. 2. Server Actions - to revalidate data after a user action (e.g. form submission). This will invalidate the Router Cache for the associated\r\nroute.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fecf19bb-dac0-4e6b-80d8-97237ed0c5e9":{"id_":"fecf19bb-dac0-4e6b-80d8-97237ed0c5e9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DewfHTE1E2nDFPH0hAwZlRE852iklhIMcqrGkxNKGuE=","metadata":{},"hash":"AeqRBr+7sV2M0lC30kzlk0T4dwRHTGOSeESGUkTF+t4="},"PREVIOUS":{"nodeId":"bdffd44c-c4a5-4eeb-a8dc-e64fcef9c80b","metadata":{},"hash":"4zCah2LWsb4P3LIYr3+KgW5dQWbzo6Rof/GZ8nuupmY="}},"hash":"N7UcXV+JCOpNEazfi9H/aKUL581RdezdtqOO8PmoxLI=","text":"form submission). This will invalidate the Router Cache for the associated\r\nroute. revalidatePathrevalidatePath\r\nrevalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache. revalidatePath('/')\r\nThere are two places you can use revalidatePath, depending on what you’re trying to achieve:\r\n1. Route Handlers - to revalidate data in response to a third party event (e.g. webhook). 2. Server Actions - to revalidate data after a user interaction (e.g. form submission, clicking a button). See the revalidatePath API reference for more information. revalidatePathrevalidatePath vs. router.refreshrouter.refresh:\r\nCalling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data\r\nCache or the Full Route Cache. The difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not\r\nchange the Data Cache and Full Route Cache, as it is a client-side API. Dynamic Functions","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"929713fa-c39f-4115-a862-eeef84b971bd":{"id_":"929713fa-c39f-4115-a862-eeef84b971bd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3F89a32hkfHwxoKqUxDSFWOPYo7zptYo96W2YbkhnN8=","metadata":{},"hash":"vL7Ss+nzRSOieJ5Ok0xeFWRCzh3EgP8c+cjfEPFbh+w="},"NEXT":{"nodeId":"a1836cf6-3247-4467-b995-56edd5da5df2","metadata":{},"hash":"pE2TNhkVXI7EI46RvP3NOSDIEsOFCf6Ebag+WYV5Kw0="}},"hash":"7kqsgH2GQFqmBWbmTTh4WZyKjg5gtQaUkXMVg7QIZO8=","text":"cookies, headers, useSearchParams, and searchParams are all dynamic functions that depend on runtime incoming request\r\ninformation. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered. cookiescookies\r\nUsing cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from\r\nbecoming stale (e.g. to reflect authentication changes). See the cookies API reference. Segment Config Options\r\nThe Route Segment Config options can be used to override the route segment defaults or when you’re not able to use the fetch API\r\n(e.g. database client or 3rd party libraries). The following Route Segment Config options will opt out of the Data Cache and Full Route Cache:\r\nconst dynamic = 'force-dynamic'\r\nconst revalidate = 0\r\nSee the Route Segment Config documentation for more options. generateStaticParamsgenerateStaticParams\r\nFor dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route\r\nCache at build time. At request time, Next.js will also cache paths that weren’t known at build time the first time they’re visited. You can disable caching at request time by using export const dynamicParams = false option in a route segment. When this\r\nconfig option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of\r\ncatch-all routes). See the generateStaticParams API reference. React cachecache function\r\nThe React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times\r\nwhile only executing it once. Since fetch requests are automatically memoized, you do not need to wrap it in React cache. However, you can use cache to\r\nmanually memoize data requests for use cases when the fetch API is not suitable. For example, some database clients, CMS clients, or\r\nGraphQL clients.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a1836cf6-3247-4467-b995-56edd5da5df2":{"id_":"a1836cf6-3247-4467-b995-56edd5da5df2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3F89a32hkfHwxoKqUxDSFWOPYo7zptYo96W2YbkhnN8=","metadata":{},"hash":"vL7Ss+nzRSOieJ5Ok0xeFWRCzh3EgP8c+cjfEPFbh+w="},"PREVIOUS":{"nodeId":"929713fa-c39f-4115-a862-eeef84b971bd","metadata":{},"hash":"7kqsgH2GQFqmBWbmTTh4WZyKjg5gtQaUkXMVg7QIZO8="}},"hash":"pE2TNhkVXI7EI46RvP3NOSDIEsOFCf6Ebag+WYV5Kw0=","text":"For example, some database clients, CMS clients, or\r\nGraphQL clients. utils/get-item.ts (tsx)import { cache } from 'react'\r\nimport db from '@/lib/db'\r\nexport const getItem = cache(async (id: string) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})\r\nutils/get-item.js (jsx)import { cache } from 'react'\r\nimport db from '@/lib/db'\r\nexport const getItem = cache(async (id) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"98c8c1c2-8b41-497c-9f71-cd00b0c6c5eb":{"id_":"98c8c1c2-8b41-497c-9f71-cd00b0c6c5eb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zlO94cIX7xS/lzvQxZwFyd4QJwkiJ7OdMmTSpdQYxSY=","metadata":{},"hash":"SkQ1jqH4LPQqdyhgAfEm0Q6DkbRKJA+CndTwgv8WQmM="}},"hash":"V3nILlCM3hdMgBqw+KDv+3I5q6RV4DL4hLtdjF9QYDU=","text":"3.1.5 - Styling\r\nDocumentation path: /02-app/01-building-your-application/05-styling/index\r\nDescription: Learn the different ways you can style your Next.js application. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js supports different ways of styling your application, including:\r\nGlobal CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty\r\nmanaging styles as the application grows. CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability. Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes. Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins. CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling. Learn more about each approach by exploring their respective documentation:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"29123149-c3ca-4397-a735-11da2648783b":{"id_":"29123149-c3ca-4397-a735-11da2648783b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"E4/sXdK4rgUvCztwTvtZEANq9YeY0tIypXoBlTEB1bI=","metadata":{},"hash":"bknHbnrb7PbT7PlvC8QpWXACJ89C6GGwHESbPZVlgw0="}},"hash":"hi3sA+wvLy7FYdbK1v1oPWoNISRVfHYDlT4/CcVcPws=","text":"3.1.5.1 - CSS Modules\r\nDocumentation path: /02-app/01-building-your-application/05-styling/01-css-modules\r\nDescription: Style your Next.js Application with CSS Modules. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\n- [Basic CSS Example](https://github.com/vercel/next.js/tree/canary/examples/basic-css)\r\nNext.js has built-in support for CSS Modules using the .module.css extension. CSS Modules locally scope CSS by automatically creating a unique class name. This allows you to use the same class name in different\r\nfiles without worrying about collisions. This behavior makes CSS Modules the ideal way to include component-level CSS. Example\r\nCSS Modules can be imported into any file inside the app directory:\r\napp/dashboard/layout.tsx (tsx)import styles from './styles.module.css'\r\nexport default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <section className={styles.dashboard}>{children}</section>\r\n}\r\napp/dashboard/layout.js (jsx)import styles from './styles.module.css'\r\nexport default function DashboardLayout({ children }) {\r\n  return <section className={styles.dashboard}>{children}</section>\r\n}\r\napp/dashboard/styles.module.css (css).dashboard {\r\n  padding: 24px;\r\n}\r\nFor example, consider a reusable Button component in the components/ folder:\r\nFirst, create components/Button.module.css with the following content:\r\nButton.module.css (css)/*\r\nYou do not need to worry about .error {} colliding with any other `.css` or\r\n`.module.css` files! */\r\n.error {\r\n  color: white;\r\n  background-color: red;\r\n}\r\nThen, create components/Button.js, importing and using the above CSS file:\r\ncomponents/Button.js (jsx)import styles from './Button.module.css'\r\nexport function Button() {\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      // Note how the \"error\" class is accessed as a property on the imported\r\n      // `styles` object. className={styles.error}\r\n    >\r\n      Destroy\r\n    </button>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0b955c28-b93b-4262-b3ef-d91b633e6dd2":{"id_":"0b955c28-b93b-4262-b3ef-d91b633e6dd2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"V70UXw7M/AoJ96cD7rrjxXMPc67qtobAFcd/NQY3rt0=","metadata":{},"hash":"ik+aTQYdI35CPLgAjS+iyYWZIo8anNn9TD5JIfMiUX4="}},"hash":"if8IR4i8DUdyepQ2l4zaLfV8g1e8vvjDOjjTxKXYiEQ=","text":")\r\n}\r\nCSS Modules are an optional feature and are only enabled for files with the .module.css.module.css extension. Regular <link> stylesheets\r\nand global CSS files are still supported. In production, all CSS Module files will be automatically concatenated into many minified and code-split .css files. These .css files\r\nrepresent hot execution paths in your application, ensuring the minimal amount of CSS is loaded for your application to paint. Global Styles\r\nGlobal styles can be imported into any layout, page, or component inside the app directory. Good to know: This is different from the pages directory, where you can only import global styles inside the _app.js file. For example, consider a stylesheet named app/global.css:\r\nbody {\r\n  padding: 20px 20px 60px;\r\n  max-width: 680px;\r\n  margin: 0 auto;\r\n}\r\nInside the root layout (app/layout.js), import the global.css stylesheet to apply the styles to every route in your application:\r\napp/layout.tsx (tsx)// These styles apply to every route in the application\r\nimport './global.css'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)// These styles apply to every route in the application\r\nimport './global.css'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nTo add a stylesheet to your application, import the CSS file within pages/_app.js. For example, consider the following stylesheet named styles.css:\r\nstyles.css (css)body {\r\n  font-family: 'SF Pro Text', 'SF Pro Icons', 'Helvetica Neue', 'Helvetica',\r\n    'Arial', sans-serif;\r\n  padding: 20px 20px 60px;\r\n  max-width: 680px;\r\n  margin: 0 auto;\r\n}\r\nCreate a pages/_app.js file if not already present. Then, import the styles.css file. pages/_app.js (jsx)import '../styles.css'\r\n// This default export is required in a new `pages/_app.js` file. export default function MyApp({ Component, pageProps }) {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5c863646-87d6-4b87-98c2-53666c4bc763":{"id_":"5c863646-87d6-4b87-98c2-53666c4bc763","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YL84m+ypIM0qgxSiZYGYugpPXazeIxUMjD2m4IYPYjo=","metadata":{},"hash":"Zvhf1D8UuJghnKdPxXNMMDrZmMC7strd5EKsIRlmMho="},"NEXT":{"nodeId":"4b7186a8-0efc-4cba-b1ac-bf8247bd0a9c","metadata":{},"hash":"+/ED9bQpV6g+JDsO1xT8XmLPNJPlZdhizXQsRTrXg9o="}},"hash":"m632tB+Y2V93sseF+VpL96lu+yxvvM657KLQqKNGD6s=","text":"return <Component {...pageProps} />\r\n}\r\nThese styles (styles.css) will apply to all pages and components in your application. Due to the global nature of stylesheets, and to\r\navoid conflicts, you may only import them inside pages/_app.jspages/_app.js. In development, expressing stylesheets this way allows your styles to be hot reloaded as you edit them—meaning you can keep\r\napplication state. In production, all CSS files will be automatically concatenated into a single minified .css file. The order that the CSS is concatenated\r\nwill match the order the CSS is imported into the _app.js file. Pay special attention to imported JS modules that include their own CSS;\r\nthe JS module’s CSS will be concatenated following the same ordering rules as imported CSS files. For example:\r\nimport '../styles.css'\r\n// The CSS in ErrorBoundary depends on the global CSS in styles.css,\r\n// so we import it after styles.css. import ErrorBoundary from '../components/ErrorBoundary'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <ErrorBoundary>\r\n      <Component {...pageProps} />\r\n    </ErrorBoundary>\r\n  )\r\n}\r\nExternal Stylesheets\r\nStylesheets published by external packages can be imported anywhere in the app directory, including colocated components:\r\napp/layout.tsx (tsx)import 'bootstrap/dist/css/bootstrap.css'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className=\"container\">{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import 'bootstrap/dist/css/bootstrap.css'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className=\"container\">{children}</body>\r\n    </html>\r\n  )\r\n}\r\nGood to know: External stylesheets must be directly imported from an npm package or downloaded and colocated with your\r\ncodebase. You cannot use <link rel=\"stylesheet\" />. Next.js allows you to import CSS files from a JavaScript file. This is possible because Next.js extends the concept of import beyond\r\nJavaScript. Import styles from node_modulesnode_modules\r\nSince Next.js 9.5.4, importing a CSS file from node_modules is permitted anywhere in your application. For global stylesheets, like bootstrap or nprogress, you should import the file inside pages/_app.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4b7186a8-0efc-4cba-b1ac-bf8247bd0a9c":{"id_":"4b7186a8-0efc-4cba-b1ac-bf8247bd0a9c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YL84m+ypIM0qgxSiZYGYugpPXazeIxUMjD2m4IYPYjo=","metadata":{},"hash":"Zvhf1D8UuJghnKdPxXNMMDrZmMC7strd5EKsIRlmMho="},"PREVIOUS":{"nodeId":"5c863646-87d6-4b87-98c2-53666c4bc763","metadata":{},"hash":"m632tB+Y2V93sseF+VpL96lu+yxvvM657KLQqKNGD6s="}},"hash":"+/ED9bQpV6g+JDsO1xT8XmLPNJPlZdhizXQsRTrXg9o=","text":"For example:\r\npages/_app.js (jsx)import 'bootstrap/dist/css/bootstrap.css'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"38ff91a6-72db-43b8-95d9-2608a4c15729":{"id_":"38ff91a6-72db-43b8-95d9-2608a4c15729","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/6SS3aYaaS+wnOlL0BHekGYgyTfqjTSZANdXKaOvqQE=","metadata":{},"hash":"mjkplvWVCdQuG6bSocxn1fPDba/a/SkYZkaBtnqcQEs="}},"hash":"6NEPNZ8yOXXLkUjwUmN/VXnP8EMRngPODvX7pAw9R7I=","text":"}\r\nFor importing CSS required by a third-party component, you can do so in your component. For example:\r\ncomponents/example-dialog.js (jsx)import { useState } from 'react'\r\nimport { Dialog } from '@reach/dialog'\r\nimport VisuallyHidden from '@reach/visually-hidden'\r\nimport '@reach/dialog/styles.css'\r\nfunction ExampleDialog(props) {\r\n  const [showDialog, setShowDialog] = useState(false)\r\n  const open = () => setShowDialog(true)\r\n  const close = () => setShowDialog(false)\r\n  return (\r\n    <div>\r\n      <button onClick={open}>Open Dialog</button>\r\n      <Dialog isOpen={showDialog} onDismiss={close}>\r\n        <button className=\"close-button\" onClick={close}>\r\n          <VisuallyHidden>Close</VisuallyHidden>\r\n          <span aria-hidden>×</span>\r\n        </button>\r\n        <p>Hello there. I am a dialog</p>\r\n      </Dialog>\r\n    </div>\r\n  )\r\n}\r\nAdditional Features\r\nNext.js includes additional features to improve the authoring experience of adding styles:\r\nWhen running locally with next dev, local stylesheets (either global or CSS modules) will take advantage of Fast Refresh to\r\ninstantly reflect changes as edits are saved. When building for production with next build, CSS files will be bundled into fewer minified .css files to reduce the number of\r\nnetwork requests needed to retrieve styles. If you disable JavaScript, styles will still be loaded in the production build (next start). However, JavaScript is still required for\r\nnext dev to enable Fast Refresh.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b702cbe4-32e5-4ba7-8bd2-ae321cba1735":{"id_":"b702cbe4-32e5-4ba7-8bd2-ae321cba1735","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"o7vohK/op/cb5r1d9b/H8mLF8ehRqlt6lI7VZ9ukaTA=","metadata":{},"hash":"T71eLoUfkiz7oD3qTpDaOkYMfeT53JbFfJwij9rfXXE="},"NEXT":{"nodeId":"490b2b4c-1328-4d78-be5d-7d3d673dad6f","metadata":{},"hash":"69ykhbVAuElKACjwt39CnoLaes5Xxt66I0VhFMkXkHc="}},"hash":"VPXdGnF0PcTZKSU4chXdzRRH4oP23T9XJF/DIMZFTd0=","text":"3.1.5.2 - Tailwind CSS\r\nDocumentation path: /02-app/01-building-your-application/05-styling/02-tailwind-css\r\nDescription: Style your Next.js Application using Tailwind CSS. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\n- [With Tailwind CSS](https://github.com/vercel/next.js/tree/canary/examples/with-tailwindcss)\r\nTailwind CSS is a utility-first CSS framework that works exceptionally well with Next.js. Installing Tailwind\r\nInstall the Tailwind CSS packages and run the init command to generate both the tailwind.config.js and postcss.config.js\r\nfiles:\r\nTerminal (bash)npm install -D tailwindcss postcss autoprefixer\r\nnpx tailwindcss init -p\r\nConfiguring Tailwind\r\nInside tailwind.config.js, add paths to the files that will use Tailwind CSS class names:\r\ntailwind.config.js (js)/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  content: [\r\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // Note the addition of the `app` directory. './pages/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\r\n    // Or if using `src` directory:\r\n    './src/**/*.{js,ts,jsx,tsx,mdx}',\r\n  ],\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [],\r\n}\r\nYou do not need to modify postcss.config.js. Importing Styles\r\nAdd the Tailwind CSS directives that Tailwind will use to inject its generated styles to a Global Stylesheet in your application, for\r\nexample:\r\napp/globals.css (css)@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\nInside the root layout (app/layout.tsx), import the globals.css stylesheet to apply the styles to every route in your application.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"490b2b4c-1328-4d78-be5d-7d3d673dad6f":{"id_":"490b2b4c-1328-4d78-be5d-7d3d673dad6f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"o7vohK/op/cb5r1d9b/H8mLF8ehRqlt6lI7VZ9ukaTA=","metadata":{},"hash":"T71eLoUfkiz7oD3qTpDaOkYMfeT53JbFfJwij9rfXXE="},"PREVIOUS":{"nodeId":"b702cbe4-32e5-4ba7-8bd2-ae321cba1735","metadata":{},"hash":"VPXdGnF0PcTZKSU4chXdzRRH4oP23T9XJF/DIMZFTd0="}},"hash":"69ykhbVAuElKACjwt39CnoLaes5Xxt66I0VhFMkXkHc=","text":"app/layout.tsx (tsx)import type { Metadata } from 'next'\r\n// These styles apply to every route in the application\r\nimport './globals.css'\r\nexport const metadata: Metadata = {\r\n  title: 'Create Next App',\r\n  description: 'Generated by create next app',\r\n}\r\nexport default function RootLayout({\r\n  children,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"538d2316-faa1-4bdf-8852-08c640ea065a":{"id_":"538d2316-faa1-4bdf-8852-08c640ea065a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hGmR24u0ooj4uM0Z9mJeI9LrUAurVWj/midCiFgnVTA=","metadata":{},"hash":"hMv770RZ5Myo++K+f5F5oh5//hgJgTZMLojRBiLS9zE="}},"hash":"7ljWf+I8v/vxhiQo07+Lhr6B/+4ipOn2NihkUQAqiFA=","text":"}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)// These styles apply to every route in the application\r\nimport './globals.css'\r\nexport const metadata = {\r\n  title: 'Create Next App',\r\n  description: 'Generated by create next app',\r\n}\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nUsing Classes\r\nAfter installing Tailwind CSS and adding the global styles, you can use Tailwind’s utility classes in your application. app/page.tsx (tsx)export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}\r\napp/page.js (jsx)export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}\r\nImporting Styles\r\nAdd the Tailwind CSS directives that Tailwind will use to inject its generated styles to a Global Stylesheet in your application, for\r\nexample:\r\nstyles/globals.css (css)@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\nInside the custom app file (pages/_app.js), import the globals.css stylesheet to apply the styles to every route in your application. pages/_app.tsx (tsx)// These styles apply to every route in the application\r\nimport '@/styles/globals.css'\r\nimport type { AppProps } from 'next/app'\r\nexport default function App({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}\r\npages/_app.js (jsx)// These styles apply to every route in the application\r\nimport '@/styles/globals.css'\r\nexport default function App({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2c47e2e0-5ce6-4081-8138-8143a0121641":{"id_":"2c47e2e0-5ce6-4081-8138-8143a0121641","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xvPvt1NLR/Hn8f94ioB0MUKBRRYaQNmHlhvCct73pOI=","metadata":{},"hash":"xWO6rzqigDlSEompcyPFvTsLndwwxP66+Q8H18vtn7g="}},"hash":"22eiqR4thDVajzfVbjVwdkvBb5yI6ium8NUq0JZfdXg=","text":"Using Classes\r\nAfter installing Tailwind CSS and adding the global styles, you can use Tailwind’s utility classes in your application. pages/index.tsx (tsx)export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}\r\npages/index.js (jsx)export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}\r\nUsage with Turbopack\r\nAs of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"57b9c367-cc9a-497f-b8e7-dbdb42281aad":{"id_":"57b9c367-cc9a-497f-b8e7-dbdb42281aad","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2pIXqApr3bF+e2c90Hho5Lc8xoifAfix/LwBP2ns5VY=","metadata":{},"hash":"zoNjCXMi3o1habWBWbViYsTUeUvndnSvNngUMMOtVjI="},"NEXT":{"nodeId":"4ba14621-820a-4b3f-8aa1-9a9bd3a20852","metadata":{},"hash":"Us7P1UgCGsL80GzhXmZaVASXoIwezjdGOPx2ZvpOCE0="}},"hash":"3kvuAAQwhBSrIc5kpxjwgjRINnLZzOb+RncoOjOvizc=","text":"3.1.5.3 - CSS-in-JS\r\nDocumentation path: /02-app/01-building-your-application/05-styling/03-css-in-js\r\nDescription: Use CSS-in-JS libraries with Next.js\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nWarning: CSS-in-JS libraries which require runtime JavaScript are not currently supported in Server Components. Using CSS-in-\r\nJS with newer React features like Server Components and Streaming requires library authors to support the latest version of\r\nReact, including concurrent rendering. We’re working with the React team on upstream APIs to handle CSS and JavaScript assets with support for React Server\r\nComponents and streaming architecture. The following libraries are supported in Client Components in the app directory (alphabetical):\r\nchakra-ui\r\nkuma-ui\r\n@mui/material\r\npandacss\r\nstyled-jsx\r\nstyled-components\r\nstyle9\r\ntamagui\r\ntss-react\r\nvanilla-extract\r\nThe following are currently working on support:\r\nemotion\r\nGood to know: We’re testing out different CSS-in-JS libraries and we’ll be adding more examples for libraries that support\r\nReact 18 features and/or the app directory. If you want to style Server Components, we recommend using CSS Modules or other solutions that output CSS files, like PostCSS or\r\nTailwind CSS. Configuring CSS-in-JS in appapp\r\nConfiguring CSS-in-JS is a three-step opt-in process that involves:\r\n1. A style registry to collect all CSS rules in a render. 2. The new useServerInsertedHTML hook to inject rules before any content that might use them. 3. A Client Component that wraps your app with the style registry during initial server-side rendering. styled-jsxstyled-jsx\r\nUsing styled-jsx in Client Components requires using v5.1.0.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4ba14621-820a-4b3f-8aa1-9a9bd3a20852":{"id_":"4ba14621-820a-4b3f-8aa1-9a9bd3a20852","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2pIXqApr3bF+e2c90Hho5Lc8xoifAfix/LwBP2ns5VY=","metadata":{},"hash":"zoNjCXMi3o1habWBWbViYsTUeUvndnSvNngUMMOtVjI="},"PREVIOUS":{"nodeId":"57b9c367-cc9a-497f-b8e7-dbdb42281aad","metadata":{},"hash":"3kvuAAQwhBSrIc5kpxjwgjRINnLZzOb+RncoOjOvizc="}},"hash":"Us7P1UgCGsL80GzhXmZaVASXoIwezjdGOPx2ZvpOCE0=","text":"First, create a new registry:\r\napp/registry.tsx (tsx)'use client'\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\r\nexport default function StyledJsxRegistry({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [jsxStyleRegistry] = useState(() => createStyleRegistry())\r\n  useServerInsertedHTML(() => {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c08aae9a-3570-4c42-b816-775ab98b9b96":{"id_":"c08aae9a-3570-4c42-b816-775ab98b9b96","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NWGHj4+sSAvLM1t3iXpSrPi0SgvTIZv/pDyUdtjT9c4=","metadata":{},"hash":"4gPIexkxYEQqr3s8hIYW8qXi5px5W6R2ZvO9ll/SD/U="}},"hash":"aIh9SZjue7shggo54P/Wwd/ZORwiFtVOaalI11iIU+Q=","text":"const styles = jsxStyleRegistry.styles()\r\n    jsxStyleRegistry.flush()\r\n    return <>{styles}</>\r\n  })\r\n  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\r\n}\r\napp/registry.js (jsx)'use client'\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\r\nexport default function StyledJsxRegistry({ children }) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [jsxStyleRegistry] = useState(() => createStyleRegistry())\r\n  useServerInsertedHTML(() => {\r\n    const styles = jsxStyleRegistry.styles()\r\n    jsxStyleRegistry.flush()\r\n    return <>{styles}</>\r\n  })\r\n  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\r\n}\r\nThen, wrap your root layout with the registry:\r\napp/layout.tsx (tsx)import StyledJsxRegistry from './registry'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledJsxRegistry>{children}</StyledJsxRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import StyledJsxRegistry from './registry'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledJsxRegistry>{children}</StyledJsxRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nView an example here. Styled Components\r\nBelow is an example of how to configure styled-components@6 or newer:\r\nFirst, enable styled-components in next.config.js. next.config.js (js)module.exports = {\r\n  compiler: {\r\n    styledComponents: true,\r\n    },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"12b3f688-7b57-4b35-9e87-a7166a7657e1":{"id_":"12b3f688-7b57-4b35-9e87-a7166a7657e1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/SK83gMY1c/HbFGC3A5Qb0VlidYCmEhaIvieH2MEoec=","metadata":{},"hash":"oM82WzSaB8FnD1xs8I2LpBy8peHn4tJvEFNDTnEAt4g="}},"hash":"8seITtKlTVn54kUgF/HfSw3JYxt68QnZdTOnP77ClkM=","text":"},\r\n}\r\nThen, use the styled-components API to create a global registry component to collect all CSS style rules generated during a render,\r\nand a function to return those rules. Then use the useServerInsertedHTML hook to inject the styles collected in the registry into the\r\n<head> HTML tag in the root layout. lib/registry.tsx (tsx)'use client'\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\r\nexport default function StyledComponentsRegistry({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\r\n  useServerInsertedHTML(() => {\r\n    const styles = styledComponentsStyleSheet.getStyleElement()\r\n    styledComponentsStyleSheet.instance.clearTag()\r\n    return <>{styles}</>\r\n  })\r\n  if (typeof window !== 'undefined') return <>{children}</>\r\n  return (\r\n    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\r\n      {children}\r\n    </StyleSheetManager>\r\n  )\r\n}\r\nlib/registry.js (jsx)'use client'\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\r\nexport default function StyledComponentsRegistry({ children }) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\r\n  useServerInsertedHTML(() => {\r\n    const styles = styledComponentsStyleSheet.getStyleElement()\r\n    styledComponentsStyleSheet.instance.clearTag()\r\n    return <>{styles}</>\r\n  })\r\n  if (typeof window !== 'undefined') return <>{children}</>\r\n  return (\r\n    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\r\n      {children}\r\n    </StyleSheetManager>\r\n  )\r\n}\r\nWrap the children of the root layout with the style registry component:\r\napp/layout.tsx (tsx)import StyledComponentsRegistry from './lib/registry'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d25f9187-de53-4423-a41b-1cc724fa5f05":{"id_":"d25f9187-de53-4423-a41b-1cc724fa5f05","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tthSOZzTJrB6NVqY2NogLOJksfxQgUi+XJhu2geKeDw=","metadata":{},"hash":"TR1Qfl8S3ktmWx4+4RXck9tRd5Gu3ZBvf5cR759rUN8="}},"hash":"OiyswaXjCFVFee9iFAMUlCiXCNGOOIV3G3MgPdB5Has=","text":"}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import StyledComponentsRegistry from './lib/registry'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nView an example here. Good to know:\r\nDuring server rendering, styles will be extracted to a global registry and flushed to the <head> of your HTML. This ensures\r\nthe style rules are placed before any content that might use them. In the future, we may use an upcoming React feature to\r\ndetermine where to inject the styles. During streaming, styles from each chunk will be collected and appended to existing styles. After client-side hydration is\r\ncomplete, styled-components will take over as usual and inject any further dynamic styles. We specifically use a Client Component at the top level of the tree for the style registry because it’s more efficient to extract\r\nCSS rules this way. It avoids re-generating styles on subsequent server renders, and prevents them from being sent in the\r\nServer Component payload. For advanced use cases where you need to configure individual properties of styled-components compilation, you can read\r\nour Next.js styled-components API reference to learn more. Examples\r\nIt’s possible to use any existing CSS-in-JS solution.The simplest one is inline styles:\r\nfunction HiThere() {\r\n  return <p style={{ color: 'red' }}>hi there</p>\r\n}\r\nexport default HiThere\r\nWe bundle styled-jsx to provide support for isolated scoped CSS. The aim is to support “shadow CSS” similar to Web Components, which\r\nunfortunately do not support server-rendering and are JS-only. See the above examples for other popular CSS-in-JS solutions (like Styled Components). A component using styled-jsx looks like this:\r\nfunction HelloWorld() {\r\n  return (\r\n    <div>\r\n      Hello world\r\n      <p>scoped!</p>\r\n      <style jsx>{`\r\n        p {\r\n          color: blue;\r\n        }\r\n        div {\r\n          background: red;\r\n        }\r\n        @media (max-width: 600px) {\r\n          div {\r\n            background: blue;\r\n          }\r\n        }\r\n      `}</style>\r\n      <style global jsx>{`\r\n        body {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"98f4578f-a95c-471f-88c0-16327bef9c0f":{"id_":"98f4578f-a95c-471f-88c0-16327bef9c0f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"C8p+lErH7f16togVcsEfHo9by0kfn51YNJ0i5ql+n88=","metadata":{},"hash":"+vjRK4p5HLpIUWWNQxSUMPdGmJpUbkooHkJvnhW1xvI="}},"hash":"+RtZF64yUV3thOJLvNMj+zo5q1/Zr8VD1CQwb1UQTOA=","text":"background: black;\r\n        }\r\n      `}</style>\r\n    </div>\r\n  )\r\n}\r\nexport default HelloWorld\r\nPlease see the styled-jsx documentation for more examples. Disabling JavaScript\r\nYes, if you disable JavaScript the CSS will still be loaded in the production build (next start). During development, we require\r\nJavaScript to be enabled to provide the best developer experience with Fast Refresh.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"38efa6e0-6707-4c3f-9931-91354b380ed8":{"id_":"38efa6e0-6707-4c3f-9931-91354b380ed8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"u+Ev6vnNCgAhiflY9MJMred7c7BxZsWcq7UqLWKO414=","metadata":{},"hash":"Kfwrs032XsUXxABAG6y/3ODHQnasb4yMxgd5mgnc1eE="}},"hash":"YBmvh8h85ljF31E30f/JfQh4IJBA0sjoXNBI8v0hHJc=","text":"3.1.5.4 - Sass\r\nDocumentation path: /02-app/01-building-your-application/05-styling/04-sass\r\nDescription: Style your Next.js application using Sass. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can\r\nuse component-level Sass via CSS Modules and the .module.scssor .module.sass extension. First, install sass:\r\nTerminal (bash)npm install --save-dev sass\r\nGood to know:\r\nSass supports two different syntaxes, each with their own extension. The .scss extension requires you use the SCSS syntax,\r\nwhile the .sass extension requires you use the Indented Syntax (“Sass”). If you’re not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn’t require you learn the\r\nIndented Syntax (“Sass”). Customizing Sass Options\r\nIf you want to configure the Sass compiler, use sassOptions in next.config.js. next.config.js (js)const path = require('path')\r\nmodule.exports = {\r\n  sassOptions: {\r\n    includePaths: [path.join(__dirname, 'styles')],\r\n  },\r\n}\r\nSass Variables\r\nNext.js supports Sass variables exported from CSS Module files. For example, using the exported primaryColor Sass variable:\r\napp/variables.module.scss (scss)$primary-color: #64ff00;\r\n:export {\r\n  primaryColor: $primary-color;\r\n}\r\napp/page.js (jsx)// maps to root `/` URL\r\nimport variables from './variables.module.scss'\r\nexport default function Page() {\r\n  return <h1 style={{ color: variables.primaryColor }}>Hello, Next.js!</h1>\r\n}\r\npages/_app.js (jsx)import variables from '../styles/variables.module.scss'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <Layout color={variables.primaryColor}>\r\n      <Component {...pageProps} />\r\n    </Layout>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a11abbd0-2a3f-4eeb-914a-bba8206054bc":{"id_":"a11abbd0-2a3f-4eeb-914a-bba8206054bc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HA5SQ0a3pJgGCTbMSeeYg79Fatd3/Sej7sjLWeBbIHY=","metadata":{},"hash":"s2qDyEGroBsImXe1TP4O2egAkkHvpJFPdZpMM8BZ8p8="},"NEXT":{"nodeId":"4dc2436e-cf1c-44ef-9c58-a33881c60556","metadata":{},"hash":"k9tH2/89UclIDScdUKBR+sXGuWzkrRjw5uiPsTa0FzA="}},"hash":"2/KX0loW+nJQeEr2BWZOaLcvcZZvOvnUZfy/IKoFVBE=","text":"3.1.6 - Optimizations\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/index\r\nDescription: Optimize your Next.js application for best performance and user experience. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js comes with a variety of built-in optimizations designed to improve your application’s speed and Core Web Vitals. This guide will\r\ncover the optimizations you can leverage to enhance your user experience. Built-in Components\r\nBuilt-in components abstract away the complexity of implementing common UI optimizations. These components are:\r\nImages: Built on the native <img> element. The Image Component optimizes images for performance by lazy loading and\r\nautomatically resizing images based on device size. Link: Built on the native <a> tags. The Link Component prefetches pages in the background, for faster and smoother page\r\ntransitions. Scripts: Built on the native <script> tags. The Script Component gives you control over loading and execution of third-party\r\nscripts. Metadata\r\nMetadata helps search engines understand your content better (which can result in better SEO), and allows you to customize how your\r\ncontent is presented on social media, helping you create a more engaging and consistent user experience across various platforms. The Metadata API in Next.js allows you to modify the <head> element of a page. You can configure metadata in two ways:\r\nConfig-based Metadata: Export a static metadata object or a dynamic generateMetadata function in a layout.js or page.js\r\nfile. File-based Metadata: Add static or dynamically generated special files to route segments. Additionally, you can create dynamic Open Graph Images using JSX and CSS with imageResponse constructor. The Head Component in Next.js allows you to modify the <head> of a page. Learn more in the Head Component documentation. Static Assets\r\nNext.js /public folder can be used to serve static assets like images, fonts, and other files. Files inside /public can also be cached by\r\nCDN providers so that they are delivered efficiently. Analytics and Monitoring\r\nFor large applications, Next.js integrates with popular analytics and monitoring tools to help you understand how your application is\r\nperforming.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4dc2436e-cf1c-44ef-9c58-a33881c60556":{"id_":"4dc2436e-cf1c-44ef-9c58-a33881c60556","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HA5SQ0a3pJgGCTbMSeeYg79Fatd3/Sej7sjLWeBbIHY=","metadata":{},"hash":"s2qDyEGroBsImXe1TP4O2egAkkHvpJFPdZpMM8BZ8p8="},"PREVIOUS":{"nodeId":"a11abbd0-2a3f-4eeb-914a-bba8206054bc","metadata":{},"hash":"2/KX0loW+nJQeEr2BWZOaLcvcZZvOvnUZfy/IKoFVBE="}},"hash":"k9tH2/89UclIDScdUKBR+sXGuWzkrRjw5uiPsTa0FzA=","text":"Learn more in the Analytics, OpenTelemetry, and Instrumentation guides.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6c8f5c01-54df-4f28-ba46-c7244e8aa61f":{"id_":"6c8f5c01-54df-4f28-ba46-c7244e8aa61f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jPT5HTAFVmCaH/8PRXR8JSJYB82UDXmrc2Pqttns+eg=","metadata":{},"hash":"xCw0qPB2HENPzwt+OWONXWbZ9pEoPb7MB51QUQIFCcQ="},"NEXT":{"nodeId":"dda91aa8-8679-43fa-91d2-2581bd383614","metadata":{},"hash":"lpJUtPsuGud72LY6h6A4ak0YVepNaxW9ExGCClgADxg="}},"hash":"Bwg/H5yyBLBe0sUb6M64mEZKyEGi8wY2o0axd7l83N8=","text":"3.1.6.1 - Image Optimization\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/01-images\r\nDescription: Optimize your images with the built-in `next/image` component. Related:\r\nTitle: API Reference\r\nRelated Description: Learn more about the next/image API. Links:\r\napp/api-reference/components/image\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\nAccording to Web Almanac, images account for a huge portion of the typical website’s page weight and can have a sizable impact on\r\nyour website’s LCP performance. The Next.js Image component extends the HTML <img> element with features for automatic image optimization:\r\nSize Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF. Visual Stability: Prevent layout shift automatically when images are loading. Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up\r\nplaceholders. Asset Flexibility: On-demand image resizing, even for images stored on remote servers\r\n\u0000 Watch: Learn more about how to use next/image → YouTube (9 minutes). Usage\r\nimport Image from 'next/image'\r\nYou can then define the src for your image (either local or remote). Local Images\r\nTo use a local image, import your .jpg, .png, or .webp image files. Next.js will automatically determine the width and height of your image based on the imported file. These values are used to prevent\r\nCumulative Layout Shift while your image is loading. app/page.js (jsx)import Image from 'next/image'\r\nimport profilePic from './me.png'\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src={profilePic}\r\n      alt=\"Picture of the author\"\r\n      // width={500} automatically provided\r\n      // height={500} automatically provided\r\n      // blurDataURL=\"data:...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dda91aa8-8679-43fa-91d2-2581bd383614":{"id_":"dda91aa8-8679-43fa-91d2-2581bd383614","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jPT5HTAFVmCaH/8PRXR8JSJYB82UDXmrc2Pqttns+eg=","metadata":{},"hash":"xCw0qPB2HENPzwt+OWONXWbZ9pEoPb7MB51QUQIFCcQ="},"PREVIOUS":{"nodeId":"6c8f5c01-54df-4f28-ba46-c7244e8aa61f","metadata":{},"hash":"Bwg/H5yyBLBe0sUb6M64mEZKyEGi8wY2o0axd7l83N8="}},"hash":"lpJUtPsuGud72LY6h6A4ak0YVepNaxW9ExGCClgADxg=","text":"\" automatically provided\r\n      // placeholder=\"blur\" // Optional blur-up while loading\r\n    />\r\n  )\r\n}\r\npages/index.js (jsx)import Image from 'next/image'\r\nimport profilePic from '../public/me.png'\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src={profilePic}\r\n      alt=\"Picture of the author\"\r\n      // width={500} automatically provided","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5f68bb5b-5bed-4d57-8e73-f732662615e3":{"id_":"5f68bb5b-5bed-4d57-8e73-f732662615e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eW1DpxQ9G17sFVQtEALi8uzkWEkHF++O7CALIKPQX+0=","metadata":{},"hash":"8GZLRsbEPvNrytB/adUEYE5I4+tMVzFGB2QjEDD0n+U="},"NEXT":{"nodeId":"3f446e9c-14ba-4932-88b3-d34709b73589","metadata":{},"hash":"k+vEQv6f3CRKtJtnrOoxxIQR3stR95QDGJ0IgFXm77k="}},"hash":"N9vu0ZYpsaWq72XKR2VTsIcivy/ly8axFfL2B++7p+o=","text":"// height={500} automatically provided\r\n      // blurDataURL=\"data:... \" automatically provided\r\n      // placeholder=\"blur\" // Optional blur-up while loading\r\n    />\r\n  )\r\n}\r\nWarning: Dynamic await import() or require() are not supported. The import must be static so it can be analyzed at\r\nbuild time. Remote Images\r\nTo use a remote image, the src property should be a URL string. Since Next.js does not have access to remote files during the build process, you’ll need to provide the width, height and optional\r\nblurDataURL props manually. The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file. Learn more about Image Sizing. app/page.js (jsx)import Image from 'next/image'\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}\r\nTo safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent\r\nmalicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 's3.amazonaws.com',\r\n        port: '',\r\n        pathname: '/my-bucket/**',\r\n      },\r\n    ],\r\n  },\r\n}\r\nLearn more about remotePatterns configuration. If you want to use relative URLs for the image src, use a loader. Domains\r\nSometimes you may want to optimize a remote image, but still use the built-in Next.js Image Optimization API. To do this, leave theloader\r\n at its default setting and enter an absolute URL for the Image src prop. To protect your application from malicious users, you must define a list of remote hostnames you intend to use with the next/image\r\ncomponent. Learn more about remotePatterns configuration. Loaders\r\nNote that in the example earlier, a partial URL (\"/me.png\") is provided for a local image. This is possible because of the loader\r\narchitecture. A loader is a function that generates the URLs for your image.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3f446e9c-14ba-4932-88b3-d34709b73589":{"id_":"3f446e9c-14ba-4932-88b3-d34709b73589","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eW1DpxQ9G17sFVQtEALi8uzkWEkHF++O7CALIKPQX+0=","metadata":{},"hash":"8GZLRsbEPvNrytB/adUEYE5I4+tMVzFGB2QjEDD0n+U="},"PREVIOUS":{"nodeId":"5f68bb5b-5bed-4d57-8e73-f732662615e3","metadata":{},"hash":"N9vu0ZYpsaWq72XKR2VTsIcivy/ly8axFfL2B++7p+o="}},"hash":"k+vEQv6f3CRKtJtnrOoxxIQR3stR95QDGJ0IgFXm77k=","text":"A loader is a function that generates the URLs for your image. It modifies the provided src, and generates multiple URLs to request the\r\nimage at different sizes. These multiple URLs are used in the automatic srcset generation, so that visitors to your site will be served an\r\nimage that is the right size for their viewport. The default loader for Next.js applications uses the built-in Image Optimization API, which optimizes images from anywhere on the web,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d873dcf9-a862-4a1e-b0f3-262c1ed48705":{"id_":"d873dcf9-a862-4a1e-b0f3-262c1ed48705","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qIPmk1KLoU4tMDEggSHcPeBdJH03b66g/AgAPu+UEL8=","metadata":{},"hash":"XeLcIi3Cm4Aiky8XfVuSZN2s/ygnKwDJulki03MiO5s="},"NEXT":{"nodeId":"70ceef81-f064-4886-828e-e2249ef18f92","metadata":{},"hash":"lWcQAEnCT1KF+VevjtLad873zfMKn7PSEGzRZzI+wcA="}},"hash":"samD3Tig7JGzm8NmFc3idRF5iPKoPb+glrw7AXoGeRk=","text":"and then serves them directly from the Next.js web server. If you would like to serve your images directly from a CDN or image server,\r\nyou can write your own loader function with a few lines of JavaScript. You can define a loader per-image with the loader prop, or at the application level with the loaderFile configuration. Priority\r\nYou should add the priority property to the image that will be the Largest Contentful Paint (LCP) element for each page. Doing so\r\nallows Next.js to specially prioritize the image for loading (e.g. through preload tags or priority hints), leading to a meaningful boost in\r\nLCP. The LCP element is typically the largest image or text block visible within the viewport of the page. When you run next dev, you’ll see\r\na console warning if the LCP element is an <Image> without the priority property. Once you’ve identified the LCP image, you can add the property like this:\r\napp/page.js (jsx)import Image from 'next/image'\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <h1>My Homepage</h1>\r\n      <Image\r\n        src=\"/me.png\"\r\n        alt=\"Picture of the author\"\r\n        width={500}\r\n        height={500}\r\n        priority\r\n      />\r\n      <p>Welcome to my homepage!</p>\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import Image from 'next/image'\r\nimport profilePic from '../public/me.png'\r\nexport default function Page() {\r\n  return <Image src={profilePic} alt=\"Picture of the author\" priority />\r\n}\r\nSee more about priority in the next/image component documentation. Image Sizing\r\nOne of the ways that images most commonly hurt performance is through layout shift, where the image pushes other elements around\r\non the page as it loads in. This performance problem is so annoying to users that it has its own Core Web Vital, called Cumulative\r\nLayout Shift. The way to avoid image-based layout shifts is to always size your images. This allows the browser to reserve precisely\r\nenough space for the image before it loads. Because next/image is designed to guarantee good performance results, it cannot be used in a way that will contribute to layout shift,\r\nand must be sized in one of three ways:\r\n1. Automatically, using a static import\r\n2. Explicitly, by including a width and height property\r\n3.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"70ceef81-f064-4886-828e-e2249ef18f92":{"id_":"70ceef81-f064-4886-828e-e2249ef18f92","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qIPmk1KLoU4tMDEggSHcPeBdJH03b66g/AgAPu+UEL8=","metadata":{},"hash":"XeLcIi3Cm4Aiky8XfVuSZN2s/ygnKwDJulki03MiO5s="},"PREVIOUS":{"nodeId":"d873dcf9-a862-4a1e-b0f3-262c1ed48705","metadata":{},"hash":"samD3Tig7JGzm8NmFc3idRF5iPKoPb+glrw7AXoGeRk="}},"hash":"lWcQAEnCT1KF+VevjtLad873zfMKn7PSEGzRZzI+wcA=","text":"Explicitly, by including a width and height property\r\n3. Implicitly, by using fill which causes the image to expand to fill its parent element. What if I don’t know the size of my images? If you are accessing images from a source without knowledge of the images’ sizes, there are several things you can do:\r\nUse fillfill\r\nThe fill prop allows your image to be sized by its parent element. Consider using CSS to give the image’s parent element\r\nspace on the page along sizes prop to match any media query break points. You can also use object-fit with fill,\r\ncontain, or cover, and object-position to define how the image should occupy that space. Normalize your images\r\nIf you’re serving images from a source that you control, consider modifying your image pipeline to normalize the images to a\r\nspecific size. Modify your API calls","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d334bab6-0786-4f3c-9042-665913092176":{"id_":"d334bab6-0786-4f3c-9042-665913092176","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HvU+e3mVrz5/HxU8bbTyLIhaviFPFrnI9y0wjA6egSg=","metadata":{},"hash":"UePpXB9bj0XnS+Cw+Qx6OVkdDRIwofJdct+VvNTxYKU="}},"hash":"YCdAgbGZKEO6SJgXOqxBPFEV1cZJIlX3JbFCkA7X9Fs=","text":"If your application is retrieving image URLs using an API call (such as to a CMS), you may be able to modify the API call to return\r\nthe image dimensions along with the URL. If none of the suggested methods works for sizing your images, the next/image component is designed to work well on a page\r\nalongside standard <img> elements. Styling\r\nStyling the Image component is similar to styling a normal <img> element, but there are a few guidelines to keep in mind:\r\nUse className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc. You can also use the style prop to assign inline styles. You cannot use styled-jsx because it’s scoped to the current component (unless you mark the style as global). When using fill, the parent element must have position: relative\r\nThis is necessary for the proper rendering of the image element in that layout mode. When using fill, the parent element must have display: block\r\nThis is the default for <div> elements but should be specified otherwise. Examples\r\nResponsive\r\nimport Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\nexport default function Responsive() {\r\n  return (\r\n    <div style={{ display: 'flex', flexDirection: 'column' }}>\r\n      <Image\r\n        alt=\"Mountains\"\r\n        // Importing an image will\r\n        // automatically set the width and height\r\n        src={mountains}\r\n        sizes=\"100vw\"\r\n        // Make the image display full width\r\n        style={{\r\n          width: '100%',\r\n          height: 'auto',\r\n        }}\r\n      />\r\n    </div>\r\n  )\r\n}\r\nFill Container","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8748f1a8-a398-4cb4-8657-8554bb131039":{"id_":"8748f1a8-a398-4cb4-8657-8554bb131039","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2w+4lXapFaMd2SYxzOA2Cx2ck7JK49VKXGpVwrdSYn4=","metadata":{},"hash":"Z+F8WJL9uAFl1Nhgmy9/WS5V1HxSvHvHvkaFA98jB/A="}},"hash":"7XOzPZa/9SnDn7wkgXyzyIfNNWx5YuyFcd5BhVE9aVc=","text":"import Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\nexport default function Fill() {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'grid',\r\n        gridGap: '8px',\r\n        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',\r\n      }}\r\n    >\r\n      <div style={{ position: 'relative', height: '400px' }}>\r\n        <Image\r\n          alt=\"Mountains\"\r\n          src={mountains}\r\n          fill\r\n          sizes=\"(min-width: 808px) 50vw, 100vw\"\r\n          style={{\r\n            objectFit: 'cover', // cover, contain, none\r\n          }}\r\n        />\r\n      </div>\r\n      {/* And more images in the grid... */}\r\n    </div>\r\n  )\r\n}\r\nBackground Image\r\nimport Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\nexport default function Background() {\r\n  return (\r\n    <Image\r\n      alt=\"Mountains\"\r\n      src={mountains}\r\n      placeholder=\"blur\"\r\n      quality={100}\r\n      fill","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fa02d750-7fe7-4470-b542-1f594c2cddad":{"id_":"fa02d750-7fe7-4470-b542-1f594c2cddad","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+QFKdCV116Z7UnVPen2qTXSCVducl2RIC8QXeX0YeDg=","metadata":{},"hash":"e0E+8CxHe/L+nMK550h4IMuR5BeVoRqv6RHie7IptKM="}},"hash":"2fwLQ7XGCHxm93AbjMXGx26M6D/KqDdZBrrkcd7GoDU=","text":"sizes=\"100vw\"\r\n      style={{\r\n        objectFit: 'cover',\r\n      }}\r\n    />\r\n  )\r\n}\r\nFor examples of the Image component used with the various styles, see the Image Component Demo. Other Properties\r\nView all properties available to the next/imagenext/image component. Configuration\r\nThe next/image component and Next.js Image Optimization API can be configured in the next.config.js file. These configurations\r\nallow you to enable remote images, define custom image breakpoints, change caching behavior and more. Read the full image configuration documentation for more information.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9be0dcec-8b8d-46bb-ac28-b904aa253591":{"id_":"9be0dcec-8b8d-46bb-ac28-b904aa253591","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"t/wdxjuw7/62wVyEPIRVtA+Y9k7l41A7VwRnAUxfiq4=","metadata":{},"hash":"b1ZvC1bei/ioTC9ahwYrk5R0Ajsn6YVScyEyuoz8DKk="},"NEXT":{"nodeId":"85af269d-a8a2-448b-9da3-b7d8c8735ccb","metadata":{},"hash":"A3IOToja0J6Qfj6ABO0DECG7ZMRUDcK+UPbLSNByml4="}},"hash":"A4iT4kKKmYqSL++3l2GymZXZiSIj9Tw4eE+tjgX6DV4=","text":"3.1.6.2 - Font Optimization\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/02-fonts\r\nDescription: Optimize your application's web fonts with the built-in `next/font` loaders. Related:\r\nTitle: API Reference\r\nRelated Description: Learn more about the next/font API. Links:\r\napp/api-reference/components/font\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nnext/fontnext/font will automatically optimize your fonts (including custom fonts) and remove external network requests for improved\r\nprivacy and performance. \u0000 Watch: Learn more about how to use next/font → YouTube (6 minutes). next/font includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with zero layout\r\nshift, thanks to the underlying CSS size-adjust property used. This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind. CSS and font files are\r\ndownloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser. Google Fonts\r\nAutomatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment. No requests are sent to Google by the browser. Get started by importing the font you would like to use from next/font/google as a function. We recommend using variable fonts for\r\nthe best performance and flexibility.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"85af269d-a8a2-448b-9da3-b7d8c8735ccb":{"id_":"85af269d-a8a2-448b-9da3-b7d8c8735ccb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"t/wdxjuw7/62wVyEPIRVtA+Y9k7l41A7VwRnAUxfiq4=","metadata":{},"hash":"b1ZvC1bei/ioTC9ahwYrk5R0Ajsn6YVScyEyuoz8DKk="},"PREVIOUS":{"nodeId":"9be0dcec-8b8d-46bb-ac28-b904aa253591","metadata":{},"hash":"A4iT4kKKmYqSL++3l2GymZXZiSIj9Tw4eE+tjgX6DV4="}},"hash":"A3IOToja0J6Qfj6ABO0DECG7ZMRUDcK+UPbLSNByml4=","text":"We recommend using variable fonts for\r\nthe best performance and flexibility. app/layout.tsx (tsx)import { Inter } from 'next/font/google'\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { Inter } from 'next/font/google'\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5b49bb6d-1fb3-47b2-8bb7-8f23bf672908":{"id_":"5b49bb6d-1fb3-47b2-8bb7-8f23bf672908","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zHPVn3C1mbIB5Pf3Qe4h1fsSfvaFGX7We21nySf+h5s=","metadata":{},"hash":"A74rhic/TTjMlNQfd+6lZwwm8T28NaDzZlSQPPKUGu0="}},"hash":"7r7+zatYdaHqqC1Q33pM8qhpYQQPrIkbfmjfI4jzDRc=","text":"If you can’t use a variable font, you will need to specify a weight:\r\napp/layout.tsx (tsx)import { Roboto } from 'next/font/google'\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { Roboto } from 'next/font/google'\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nTo use the font in all your pages, add it to _app.js file under /pages as shown below:\r\npages/_app.js (jsx)import { Inter } from 'next/font/google'\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({ subsets: ['latin'] })\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={inter.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}\r\nIf you can’t use a variable font, you will need to specify a weight:\r\npages/_app.js (jsx)import { Roboto } from 'next/font/google'\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n})\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={roboto.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"973b4bb9-fcf5-4945-bc31-196309f109e6":{"id_":"973b4bb9-fcf5-4945-bc31-196309f109e6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8w5BVllVXFWm8KwgkQ8UqfM7sfqTfKpIJu933AxPz78=","metadata":{},"hash":"b3+E5To8fiZ89K9sAfqFK/9gPD/OGZn5A0wzxUiT21c="}},"hash":"ajo+QPSTDH5jTjDbUlfTkBFi2kjyqLoIpi80LDqAjCM=","text":"You can specify multiple weights and/or styles by using an array:\r\napp/layout.js (jsx)const roboto = Roboto({\r\n  weight: ['400', '700'],\r\n  style: ['normal', 'italic'],\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nGood to know: Use an underscore (_) for font names with multiple words. E.g. Roboto Mono should be imported asRoboto_Mono\r\n. Apply the font in <head><head>\r\nYou can also use the font without a wrapper and className by injecting it inside the <head> as follows:\r\npages/_app.js (jsx)import { Inter } from 'next/font/google'\r\nconst inter = Inter({ subsets: ['latin'] })\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <style jsx global>{`\r\n        html {\r\n          font-family: ${inter.style.fontFamily};\r\n        }\r\n      `}</style>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\nSingle page usage\r\nTo use the font on a single page, add it to the specific page as shown below:\r\npages/index.js (jsx)import { Inter } from 'next/font/google'\r\nconst inter = Inter({ subsets: ['latin'] })\r\nexport default function Home() {\r\n  return (\r\n    <div className={inter.className}>\r\n      <p>Hello World</p>\r\n    </div>\r\n  )\r\n}\r\nSpecifying a subset\r\nGoogle Fonts are automatically subset. This reduces the size of the font file and improves performance. You’ll need to define which of\r\nthese subsets you want to preload. Failing to specify any subsets while preload is true will result in a warning. This can be done by adding it to the function call:\r\napp/layout.tsx (tsx)const inter = Inter({ subsets: ['latin'] })\r\napp/layout.js (jsx)const inter = Inter({ subsets: ['latin'] })\r\npages/_app.js (jsx)const inter = Inter({ subsets: ['latin'] })\r\nView the Font API Reference for more information. Using Multiple Fonts","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7fe20f6c-68b9-44f8-8fea-47aaa816b9de":{"id_":"7fe20f6c-68b9-44f8-8fea-47aaa816b9de","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QR7OJGE0G8FTAE2oCyJ8tyvuZlwzRHS7+642+d45Dlo=","metadata":{},"hash":"D4+m5ls5sJcKEMqgkmbGj9VqiZ1MnNmBqEIFW6x2wxU="}},"hash":"Fe3ruQCV7bRHJSUCcUuCFhxoU2YrSN0eCLA1r+vhn1o=","text":"You can import and use multiple fonts in your application. There are two approaches you can take. The first approach is to create a utility function that exports a font, imports it, and applies its className where needed. This ensures\r\nthe font is preloaded only when it’s rendered:\r\napp/fonts.ts (ts)import { Inter, Roboto_Mono } from 'next/font/google'\r\nexport const inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport const roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\napp/fonts.js (js)import { Inter, Roboto_Mono } from 'next/font/google'\r\nexport const inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\nexport const roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\napp/layout.tsx (tsx)import { inter } from './fonts'\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { inter } from './fonts'\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/page.tsx (tsx)import { roboto_mono } from './fonts'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1 className={roboto_mono.className}>My page</h1>\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import { roboto_mono } from './fonts'\r\nexport default function Page() {\r\n  return (","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"59b6c0e9-65a5-4834-9600-8a7530c70d2c":{"id_":"59b6c0e9-65a5-4834-9600-8a7530c70d2c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LbdbXrSMsPjsZ7LAttaJ09wi8+1r4OWaEoqlK1LaIcI=","metadata":{},"hash":"yOe7m5UFXyLNpRADm2Ekk1Zyqz2InwPzPY9FjZx079k="}},"hash":"XthjoJbjd4x31gp6CSrYkfTUhMD8Si5QzFaYjGSZ1eI=","text":"<>\r\n      <h1 className={roboto_mono.className}>My page</h1>\r\n    </>\r\n  )\r\n}\r\nIn the example above, Inter will be applied globally, and Roboto Mono can be imported and applied as needed. Alternatively, you can create a CSS variable and use it with your preferred CSS solution:\r\napp/layout.tsx (tsx)import { Inter, Roboto_Mono } from 'next/font/google'\r\nimport styles from './global.css'\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n  display: 'swap',\r\n})\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  variable: '--font-roboto-mono',\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>\r\n        <h1>My App</h1>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { Inter, Roboto_Mono } from 'next/font/google'\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n  display: 'swap',\r\n})\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  variable: '--font-roboto-mono',\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>\r\n        <h1>My App</h1>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/global.css (css)html {\r\n  font-family: var(--font-inter);\r\n}\r\nh1 {\r\n  font-family: var(--font-roboto-mono);\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a7d2ede5-baf5-4909-92e5-d6fd7f7ea862":{"id_":"a7d2ede5-baf5-4909-92e5-d6fd7f7ea862","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lG/8Cb1CNbS1PGi6GELchzwApn80s/yvs/b/a52UZuU=","metadata":{},"hash":"xyoLWz+0l5SZlAHmU+8xJq6QyivEo0yXNolkbo6pR24="}},"hash":"LXWDH2FlHYO9r5higmTHriUM6H9YVHlM6xt+wlvNwDA=","text":"In the example above, Inter will be applied globally, and any <h1> tags will be styled with Roboto Mono. Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download. Local Fonts\r\nImport next/font/local and specify the src of your local font file. We recommend using variable fonts for the best performance and\r\nflexibility. app/layout.tsx (tsx)import localFont from 'next/font/local'\r\n// Font files can be colocated inside of `app`\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import localFont from 'next/font/local'\r\n// Font files can be colocated inside of `app`\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n  display: 'swap',\r\n})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\npages/_app.js (jsx)import localFont from 'next/font/local'\r\n// Font files can be colocated inside of `pages`\r\nconst myFont = localFont({ src: './my-font.woff2' })\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={myFont.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}\r\nIf you want to use multiple files for a single font family, src can be an array:\r\nconst roboto = localFont({\r\n  src: [\r\n    {\r\n      path: './Roboto-Regular.woff2',\r\n      weight: '400',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-Italic.woff2',\r\n      weight: '400',\r\n      style: 'italic',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e7b9d44d-e6fb-4e8b-a352-9e92646535d2":{"id_":"e7b9d44d-e6fb-4e8b-a352-9e92646535d2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mfoyLSo2dIHnZUNIFccpvRYP7EssdNlIEjBzAPnXBdw=","metadata":{},"hash":"fNkvmu8EmVTTW+B3CGFC+KDMEefx/AbGeEfw8QTUFIw="}},"hash":"uH2Pn4P8fyaJM8GiEnW5+UKW2sLyeNUTW+tzrNP55H4=","text":"},\r\n    {\r\n      path: './Roboto-Bold.woff2',\r\n      weight: '700',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-BoldItalic.woff2',\r\n      weight: '700',\r\n      style: 'italic',\r\n    },\r\n  ],\r\n})\r\nView the Font API Reference for more information. With Tailwind CSS\r\nnext/font can be used with Tailwind CSS through a CSS variable. In the example below, we use the font Inter from next/font/google (you can use any font from Google or Local Fonts). Load your\r\nfont with the variable option to define your CSS variable name and assign it to inter. Then, use inter.variable to add the CSS\r\nvariable to your HTML document. app/layout.tsx (tsx)import { Inter, Roboto_Mono } from 'next/font/google'\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-inter',\r\n})\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-roboto-mono',\r\n})\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { Inter, Roboto_Mono } from 'next/font/google'\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-inter',\r\n})\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-roboto-mono',\r\n})\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8dba5314-bc27-4cfd-8433-8843500ebaa5":{"id_":"8dba5314-bc27-4cfd-8433-8843500ebaa5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jP8RRRKZWdNdEICLto8/ebokjlBpeSQ4U6pHzYtyFzE=","metadata":{},"hash":"FHidtzuKap5ujjLJ522w4PCcz9y2K3KOAYZOCMmqVcc="},"NEXT":{"nodeId":"1219e4f1-46e7-4110-acc3-c4f87556d3a8","metadata":{},"hash":"0tGbCZI+ushepLWONV/6+6BkJTs5vnzdoJU/fnmPGeE="}},"hash":"+2darAAbs05081ex8zD2eNcpAQ/k4K453X/CHqN9GE8=","text":"pages/_app.js (jsx)import { Inter } from 'next/font/google'\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n})\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={`${inter.variable} font-sans`}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}\r\nFinally, add the CSS variable to your Tailwind CSS config:\r\ntailwind.config.js (js)/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  content: [\r\n    './pages/**/*.{js,ts,jsx,tsx}',\r\n    './components/**/*.{js,ts,jsx,tsx}',\r\n    './app/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n  theme: {\r\n    extend: {\r\n      fontFamily: {\r\n        sans: ['var(--font-inter)'],\r\n        mono: ['var(--font-roboto-mono)'],\r\n      },\r\n    },\r\n  },\r\n  plugins: [],\r\n}\r\nYou can now use the font-sans and font-mono utility classes to apply the font to your elements. Preloading\r\nWhen a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only\r\npreloaded on the related routes based on the type of file where it is used:\r\nIf it’s a unique page, it is preloaded on the unique route for that page. If it’s a layout, it is preloaded on all the routes wrapped by the layout. If it’s the root layout, it is preloaded on all routes. When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only\r\npreloaded on the related route/s based on the type of file where it is used:\r\nif it’s a unique page, it is preloaded on the unique route for that page\r\nif it’s in the custom App, it is preloaded on all the routes of the site under /pages\r\nReusing fonts\r\nEvery time you call the localFont or Google font function, that font is hosted as one instance in your application. Therefore, if you\r\nload the same font function in multiple files, multiple instances of the same font are hosted.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1219e4f1-46e7-4110-acc3-c4f87556d3a8":{"id_":"1219e4f1-46e7-4110-acc3-c4f87556d3a8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jP8RRRKZWdNdEICLto8/ebokjlBpeSQ4U6pHzYtyFzE=","metadata":{},"hash":"FHidtzuKap5ujjLJ522w4PCcz9y2K3KOAYZOCMmqVcc="},"PREVIOUS":{"nodeId":"8dba5314-bc27-4cfd-8433-8843500ebaa5","metadata":{},"hash":"+2darAAbs05081ex8zD2eNcpAQ/k4K453X/CHqN9GE8="}},"hash":"0tGbCZI+ushepLWONV/6+6BkJTs5vnzdoJU/fnmPGeE=","text":"In this situation, it is recommended to do\r\nthe following:\r\nCall the font loader function in one shared file\r\nExport it as a constant\r\nImport the constant in each file where you would like to use this font","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1f7e0a7a-6e97-472d-9303-867529987c5c":{"id_":"1f7e0a7a-6e97-472d-9303-867529987c5c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BYhehyEKK9LLpb99seHwi7/P8qaOkabmy1F5TlpFk1Q=","metadata":{},"hash":"yZES0ECaqIz7uEvoysP11yL60cOaCdKxyHwc6yv/9eU="}},"hash":"5UeSErWXDR+qtdPXBF60f3FCVz1YJcep7lDG2/0DsfM=","text":"3.1.6.3 - Script Optimization\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/03-scripts\r\nDescription: Optimize 3rd party scripts with the built-in Script component. Related:\r\nTitle: API Reference\r\nRelated Description: Learn more about the next/script API. Links:\r\napp/api-reference/components/script\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nLayout Scripts\r\nTo load a third-party script for multiple routes, import next/script and include the script directly in your layout component:\r\napp/dashboard/layout.tsx (tsx)import Script from 'next/script'\r\nexport default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      <section>{children}</section>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}\r\napp/dashboard/layout.js (jsx)import Script from 'next/script'\r\nexport default function DashboardLayout({ children }) {\r\n  return (\r\n    <>\r\n      <section>{children}</section>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}\r\nThe third-party script is fetched when the folder route (e.g. dashboard/page.js) or any nested route (e.g. dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script will only load once, even if a user navigates\r\nbetween multiple routes in the same layout. Application Scripts\r\nTo load a third-party script for all routes, import next/script and include the script directly in your root layout:\r\napp/layout.tsx (tsx)import Script from 'next/script'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </html>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7579faa3-b39d-4d62-88e2-422a32603df1":{"id_":"7579faa3-b39d-4d62-88e2-422a32603df1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rNfYGqboh2U3YsBUIfxjnWcyiCXhPJMl9fi41Jedx6w=","metadata":{},"hash":"aI6Ii7D0arQuDf6nF/IVG5XfRSMXhmwEjd/JWmiVzHI="},"NEXT":{"nodeId":"2608dc1e-a889-48d1-bb23-04e62337c3da","metadata":{},"hash":"aNhdyIu1iqWN5tHkxYAtNyot9sE38VGfRQAvXnAfGeU="}},"hash":"tisbjLOMaFJ0FNfIW4js7sn5JDwsBJ5Rm+3iXNigzMw=","text":"app/layout.js (jsx)import Script from 'next/script'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </html>\r\n  )\r\n}\r\nTo load a third-party script for all routes, import next/script and include the script directly in your custom _app:\r\npages/_app.js (jsx)import Script from 'next/script'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}\r\nThis script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even\r\nif a user navigates between multiple pages. Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any\r\nunnecessary impact to performance. Strategy\r\nAlthough the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading\r\nbehavior by using the strategy property:\r\nbeforeInteractive: Load the script before any Next.js code and before any page hydration occurs. afterInteractive: (default) Load the script early but after some hydration on the page occurs. lazyOnload: Load the script later during browser idle time. worker: (experimental) Load the script in a web worker. Refer to the next/script API reference documentation to learn more about each strategy and their use cases. Offloading Scripts To A Web Worker (Experimental)\r\nWarning: The worker strategy is not yet stable and does not yet work with the app directory. Use with caution. Scripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of\r\nyour site by dedicating the main thread to the rest of your application code.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2608dc1e-a889-48d1-bb23-04e62337c3da":{"id_":"2608dc1e-a889-48d1-bb23-04e62337c3da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rNfYGqboh2U3YsBUIfxjnWcyiCXhPJMl9fi41Jedx6w=","metadata":{},"hash":"aI6Ii7D0arQuDf6nF/IVG5XfRSMXhmwEjd/JWmiVzHI="},"PREVIOUS":{"nodeId":"7579faa3-b39d-4d62-88e2-422a32603df1","metadata":{},"hash":"tisbjLOMaFJ0FNfIW4js7sn5JDwsBJ5Rm+3iXNigzMw="}},"hash":"aNhdyIu1iqWN5tHkxYAtNyot9sE38VGfRQAvXnAfGeU=","text":"This strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    nextScriptWorkers: true,\r\n  },\r\n}\r\nThen, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to\r\nfinish the setup:\r\nTerminal (bash)npm run dev\r\nYou’ll see instructions like these: Please install Partytown by running npm install @builder.io/partytown\r\nOnce setup is complete, defining strategy=\"worker\" will automatically instantiate Partytown in your application and offload the\r\nscript to a web worker. pages/home.tsx (tsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"047ba2af-7fb8-4b98-b04c-ce104fb44264":{"id_":"047ba2af-7fb8-4b98-b04c-ce104fb44264","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QgBhu+Wi2P3z9SSjGbbudiVhoTdqDJa7HjHPZajZOag=","metadata":{},"hash":"vvLKstMJ2Pp9nbgreiC4reQSrqs4K9xTue7RGuETAA0="}},"hash":"g98kTQSr7CXvghRDwqhoJzCgYE4OKq+ZsOe2pIEVwyc=","text":"import Script from 'next/script'\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}\r\npages/home.js (jsx)import Script from 'next/script'\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}\r\nThere are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown’s\r\ntradeoffs documentation for more information. Inline Scripts\r\nInline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing\r\nthe JavaScript within curly braces:\r\n<Script id=\"show-banner\">\r\n  {`document.getElementById('banner').classList.remove('hidden')`}\r\n</Script>\r\nOr by using the dangerouslySetInnerHTML property:\r\n<Script\r\n  id=\"show-banner\"\r\n  dangerouslySetInnerHTML={{\r\n    __html: `document.getElementById('banner').classList.remove('hidden')`,\r\n  }}\r\n/>\r\nWarning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script. Executing Additional Code\r\nEvent handlers can be used with the Script component to execute additional code after a certain event occurs:\r\nonLoad: Execute code after the script has finished loading. onReady: Execute code after the script has finished loading and every time the component is mounted. onError: Execute code if the script fails to load. These handlers will only work when next/script is imported and used inside of a Client Component where \"use client\" is defined\r\nas the first line of code:\r\napp/page.tsx (tsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ce3f4b54-c979-4cfd-b14e-a786f5047bf9":{"id_":"ce3f4b54-c979-4cfd-b14e-a786f5047bf9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ep1zGVUUmEl7mwj7sx1nE+LgqvGRBAB6RxKJaz4FGHY=","metadata":{},"hash":"W5juBzpna+lQ19k+QR4z2N6FhwNotCrPQt0+0P44Kao="}},"hash":"KgtB68i0tFZC/MGiAjDdHuPpJnZqwy0vfR0H1IoyIE4=","text":"app/page.js (jsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nRefer to the next/script API reference to learn more about each event handler and view examples. These handlers will only work when next/script is imported and used inside of a Client Component where \"use client\" is defined\r\nas the first line of code:\r\npages/index.tsx (tsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\npages/index.js (jsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nRefer to the next/script API reference to learn more about each event handler and view examples. Additional Attributes\r\nThere are many DOM attributes that can be assigned to a <script> element that are not used by the Script component, like nonce or\r\ncustom data attributes. Including any additional attributes will automatically forward it to the final, optimized <script> element that\r\nis included in the HTML. app/page.tsx (tsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"53f8d67d-d767-45f7-be28-da35a92eea1e":{"id_":"53f8d67d-d767-45f7-be28-da35a92eea1e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"W+kZp4jkX9Kin3ec43AQ6ZE7F7ssiTPivgMEklwCKLo=","metadata":{},"hash":"1CcBLrdpyuhLoKlg7JU5LaDLF2CF6tgwJxyZb/YCzbM="}},"hash":"GGe0kClQXT8LNYy8mdbX9elofMK77qCMTHx4tLRRlDE=","text":"/>\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}\r\npages/index.tsx (tsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}\r\npages/index.js (jsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9b73bb9d-0e55-4fa0-866a-786039ad6625":{"id_":"9b73bb9d-0e55-4fa0-866a-786039ad6625","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XPPBkNKc6/iHioIbMYXrXjnFR1s1Q8qD7cQqJ8YGr8Y=","metadata":{},"hash":"hGh0iSqGvojMbc6S6WNWXIoTfTJ5VKQI0tWhqBGAyXc="}},"hash":"FI0G9xIhhX5Be/rcsIPRwBD6LcewcveVDDhHMQgQ8F0=","text":"3.1.6.4 - Metadata\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/04-metadata\r\nDescription: Use the Metadata API to define metadata in any layout or page. Related:\r\nTitle: Related\r\nRelated Description: View all the Metadata API options. Links:\r\napp/api-reference/functions/generate-metadata\r\napp/api-reference/file-conventions/metadata\r\napp/api-reference/functions/generate-viewport\r\nNext.js has a Metadata API that can be used to define your application metadata (e.g. meta and link tags inside your HTML head\r\nelement) for improved SEO and web shareability. There are two ways you can add metadata to your application:\r\nConfig-based Metadata: Export a static metadata object or a dynamic generateMetadata function in a layout.js or page.js\r\nfile. File-based Metadata: Add static or dynamically generated special files to route segments. With both these options, Next.js will automatically generate the relevant <head> elements for your pages. You can also create dynamic\r\nOG images using the ImageResponse constructor. Static Metadata\r\nTo define static metadata, export a Metadata object from a layout.js or static page.js file. layout.tsx | page.tsx (tsx)import type { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: '...',\r\n  description: '...',\r\n}\r\nexport default function Page() {}\r\nlayout.js | page.js (jsx)export const metadata = {\r\n  title: '...',\r\n  description: '...',\r\n}\r\nexport default function Page() {}\r\nFor all the available options, see the API Reference. Dynamic Metadata\r\nYou can use generateMetadata function to fetch metadata that requires dynamic values. app/products/[id]/page.tsx (tsx)import type { Metadata, ResolvingMetadata } from 'next'\r\ntype Props = {\r\n  params: { id: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  // read route params\r\n  const id = params.id","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7e200b62-dcb2-484d-aaff-0af47ff4199d":{"id_":"7e200b62-dcb2-484d-aaff-0af47ff4199d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/9amWfSNEp7HnzPIGjJz7PSfkfBG0FUgfHp/wlnjYYo=","metadata":{},"hash":"lFzBvrnAXEamjmRJgL8/SeAekIsUdNPczjUuJOQ+9s0="}},"hash":"b7NRKludTuUs+0/rHfRJVRq+JjSqmE9nHPvDxWrdr6M=","text":"// fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }: Props) {}\r\napp/products/[id]/page.js (jsx)export async function generateMetadata({ params, searchParams }, parent) {\r\n  // read route params\r\n  const id = params.id\r\n  // fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }) {}\r\nFor all the available params, see the API Reference. Good to know:\r\nBoth static and dynamic metadata through generateMetadata are only supported in Server Components. fetch requests are automatically memoized for the same data across generateMetadata, generateStaticParams,\r\nLayouts, Pages, and Server Components. React cache can be used if fetch is unavailable. Next.js will wait for data fetching inside generateMetadata to complete before streaming UI to the client. This guarantees\r\nthe first part of a streamed response includes <head> tags. File-based metadata\r\nThese special files are available for metadata:\r\nfavicon.ico, apple-icon.jpg, and icon.jpg\r\nopengraph-image.jpg and twitter-image.jpg\r\nrobots.txt\r\nsitemap.xml\r\nYou can use these for static metadata, or you can programmatically generate these files with code. For implementation and examples, see the Metadata Files API Reference and Dynamic Image Generation. Behavior\r\nFile-based metadata has the higher priority and will override any config-based metadata. Default Fields\r\nThere are two default meta tags that are always added even if a route doesn’t define metadata:\r\nThe meta charset tag sets the character encoding for the website. The meta viewport tag sets the viewport width and scale for the website to adjust for different devices.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"83bc20bb-3146-44de-8891-e8fe7abd5360":{"id_":"83bc20bb-3146-44de-8891-e8fe7abd5360","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vElKmutu8JlbCqpk45M50WrsP2FqyoEBOmJiBHF1l4A=","metadata":{},"hash":"Fo30b3QldnyeF1LhWlJ1eeL10CEyc3SkKIUf6JwIJR8="}},"hash":"P3JIW01xhyVDgNbSQ1jtVo7wXNppaWCVzJapy3D3T/g=","text":"<meta charset=\"utf-8\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\nGood to know: You can overwrite the default viewport meta tag. Ordering\r\nMetadata is evaluated in order, starting from the root segment down to the segment closest to the final page.js segment. For\r\nexample:\r\n1. app/layout.tsx (Root Layout)\r\n2. app/blog/layout.tsx (Nested Blog Layout)\r\n3. app/blog/[slug]/page.tsx (Blog Page)\r\nMerging\r\nFollowing the evaluation order, Metadata objects exported from multiple segments in the same route are shallowly merged together\r\nto form the final metadata output of a route. Duplicate keys are replaced based on their ordering. This means metadata with nested fields such as openGraph and robots that are defined in an earlier segment are overwritten by the\r\nlast segment to define them. Overwriting fields\r\napp/layout.js (jsx)export const metadata = {\r\n  title: 'Acme',\r\n  openGraph: {\r\n    title: 'Acme',\r\n    description: 'Acme is a...',\r\n  },\r\n}\r\napp/blog/page.js (jsx)export const metadata = {\r\n  title: 'Blog',\r\n  openGraph: {\r\n    title: 'Blog',\r\n  },\r\n}\r\n// Output:\r\n// <title>Blog</title>\r\n// <meta property=\"og:title\" content=\"Blog\" />\r\nIn the example above:\r\ntitle from app/layout.js is replaced by title in app/blog/page.js. All openGraph fields from app/layout.js are replaced in app/blog/page.js because app/blog/page.js sets openGraph\r\nmetadata. Note the absence of openGraph.description. If you’d like to share some nested fields between segments while overwriting others, you can pull them out into a separate variable:\r\napp/shared-metadata.js (jsx)export const openGraphImage = { images: ['http://... '] }\r\napp/page.js (jsx)import { openGraphImage } from './shared-metadata'\r\nexport const metadata = {\r\n  openGraph: {\r\n    ...openGraphImage,\r\n    title: 'Home',\r\n  },\r\n}\r\napp/about/page.js (jsx)import { openGraphImage } from '../shared-metadata'\r\nexport const metadata = {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"61ddeaee-0260-41cd-b391-3519a82fbfbd":{"id_":"61ddeaee-0260-41cd-b391-3519a82fbfbd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Erlb88L4Pg4Tb3mh//iv8lprU7QhrN/AS14duQsjybY=","metadata":{},"hash":"wjPlz1xPwIvuA5WHU0p78+1WrlZ4h+wjoacjuFUjEKY="}},"hash":"KtUoR0jYulEezTgk1iwjtHG4po+Z6YfgjnFeeAeccIY=","text":"openGraph: {\r\n    ...openGraphImage,\r\n    title: 'About',\r\n  },\r\n}\r\nIn the example above, the OG image is shared between app/layout.js and app/about/page.js while the titles are different. Inheriting fields\r\napp/layout.js (jsx)export const metadata = {\r\n  title: 'Acme',\r\n  openGraph: {\r\n    title: 'Acme',\r\n    description: 'Acme is a...',\r\n  },\r\n}\r\napp/about/page.js (jsx)export const metadata = {\r\n  title: 'About',\r\n}\r\n// Output:\r\n// <title>About</title>\r\n// <meta property=\"og:title\" content=\"Acme\" />\r\n// <meta property=\"og:description\" content=\"Acme is a... \" />\r\nNotes\r\ntitle from app/layout.js is replaced by title in app/about/page.js. All openGraph fields from app/layout.js are inherited in app/about/page.js because app/about/page.js doesn’t set\r\nopenGraph metadata. Dynamic Image Generation\r\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for creating social media\r\nimages such as Open Graph images, Twitter cards, and more. ImageResponse uses the Edge Runtime, and Next.js automatically adds the correct headers to cached images at the edge, helping\r\nimprove performance and reducing recomputation. To use it, you can import ImageResponse from next/og:\r\napp/about/route.js (jsx)import { ImageResponse } from 'next/og'\r\nexport const runtime = 'edge'\r\nexport async function GET() {\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          textAlign: 'center',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        Hello world! </div>\r\n    ),\r\n    {\r\n      width: 1200,\r\n      height: 600,\r\n    }\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"42d8d0bc-d5d9-4c75-8eb0-ee8a7984491d":{"id_":"42d8d0bc-d5d9-4c75-8eb0-ee8a7984491d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Pd6NvIKNVHG9R7QECOiikFAsrCw9GhoM+fm8ZKXmnGs=","metadata":{},"hash":"vB4uiynq0KFOpjGUg1yGniW26kskiXbVwhuhhEY8Ko4="},"NEXT":{"nodeId":"8bf920e4-9992-4022-9cf6-8a908cd0137a","metadata":{},"hash":"tNaqlyGLhTUmgrL5TcDp9wZzAb0Ye5FUNgqKxZs0xnk="}},"hash":"ElMNBRQjn/X3OnTQV/lcj/RCetS+mfMaytilkrdGuSk=","text":"}\r\nImageResponse integrates well with other Next.js APIs, including Route Handlers and file-based Metadata. For example, you can use\r\nImageResponse in a opengraph-image.tsx file to generate Open Graph images at build time or dynamically at request time. ImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering,\r\nand nested images. See the full list of supported CSS properties. Good to know:\r\nExamples are available in the Vercel OG Playground.ImageResponse\r\n uses @vercel/og, Satori, and Resvg to convert HTML and CSS into PNG. Only the Edge Runtime is supported. The default Node.js runtime will not work. Only flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work. Maximum bundle size of 500KB. The bundle size includes your JSX, CSS, fonts, images, and any other assets. If you exceed\r\nthe limit, consider reducing the size of any assets or fetching at runtime. Only ttf, otf, and woff font formats are supported. To maximize the font parsing speed, ttf or otf are preferred over\r\nwoff. JSON-LD\r\nJSON-LD is a format for structured data that can be used by search engines to understand your content. For example, you can use it to\r\ndescribe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities. Our current recommendation for JSON-LD is to render structured data as a <script> tag in your layout.js or page.js components. For example:\r\napp/products/[id]/page.tsx (tsx)export default async function Page({ params }) {\r\n  const product = await getProduct(params.id)\r\n  const jsonLd = {\r\n    '@context': 'https://schema.org',\r\n    '@type': 'Product',\r\n    name: product.name,\r\n    image: product.image,\r\n    description: product.description,\r\n  }\r\n  return (\r\n    <section>\r\n      {/* Add JSON-LD to your page */}\r\n      <script\r\n        type=\"application/ld+json\"\r\n        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}\r\n      />\r\n      {/* ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8bf920e4-9992-4022-9cf6-8a908cd0137a":{"id_":"8bf920e4-9992-4022-9cf6-8a908cd0137a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Pd6NvIKNVHG9R7QECOiikFAsrCw9GhoM+fm8ZKXmnGs=","metadata":{},"hash":"vB4uiynq0KFOpjGUg1yGniW26kskiXbVwhuhhEY8Ko4="},"PREVIOUS":{"nodeId":"42d8d0bc-d5d9-4c75-8eb0-ee8a7984491d","metadata":{},"hash":"ElMNBRQjn/X3OnTQV/lcj/RCetS+mfMaytilkrdGuSk="}},"hash":"tNaqlyGLhTUmgrL5TcDp9wZzAb0Ye5FUNgqKxZs0xnk=","text":"*/}\r\n    </section>\r\n  )\r\n}\r\napp/products/[id]/page.js (jsx)export default async function Page({ params }) {\r\n  const product = await getProduct(params.id)\r\n  const jsonLd = {\r\n    '@context': 'https://schema.org',\r\n    '@type': 'Product',\r\n    name: product.name,\r\n    image: product.image,\r\n    description: product.description,\r\n  }\r\n  return (\r\n    <section>\r\n      {/* Add JSON-LD to your page */}\r\n      <script\r\n        type=\"application/ld+json\"\r\n        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}\r\n      />\r\n      {/* ... */}\r\n    </section>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6f55eb23-d98c-47c5-952b-72f068f7e85e":{"id_":"6f55eb23-d98c-47c5-952b-72f068f7e85e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"s0+7anJa0MB3mIowkBLnH3yZkSTtuKmcEUngc2WK38U=","metadata":{},"hash":"chXS98aORqM4j9uV2fJkn4chaju/UqN3V2JsNcdmntc="}},"hash":"/c9v/0BEljEB7KLitO1+9Oqu0sUm+sGi+i9ZTB6sG80=","text":")\r\n}\r\nYou can validate and test your structured data with the Rich Results Test for Google or the generic Schema Markup Validator. You can type your JSON-LD with TypeScript using community packages like schema-dts:\r\nimport { Product, WithContext } from 'schema-dts'\r\nconst jsonLd: WithContext<Product> = {\r\n  '@context': 'https://schema.org',\r\n  '@type': 'Product',\r\n  name: 'Next.js Sticker',\r\n  image: 'https://nextjs.org/imgs/sticker.png',\r\n  description: 'Dynamic at the speed of static.',\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3df87331-6ce9-4e7f-af24-00c4a567fbef":{"id_":"3df87331-6ce9-4e7f-af24-00c4a567fbef","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LV317cp0kt6FDzlW2fwg7ePRXO30j7A6AChy5hnsU/A=","metadata":{},"hash":"nC6SNgIosyMxLot8llQ1A/lT88GqF7TgfUpx7D2Cd1Q="}},"hash":"GK+jsLz32ROop9s/EsrFWjvd20fIs+HkWfFK5JpSmEo=","text":"3.1.6.5 - Static Assets\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/05-static-assets\r\nDescription: Next.js allows you to serve static files, like images, in the public directory. You can learn how it works here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced\r\nby your code starting from the base URL (/). For example, if you add me.png inside public, the following code will access the image:\r\nAvatar.js (jsx)import Image from 'next/image'\r\nexport function Avatar() {\r\n  return <Image src=\"/me.png\" alt=\"me\" width=\"64\" height=\"64\" />\r\n}\r\nThis folder is also useful for robots.txt, favicon.ico, Google Site Verification, and any other static files (including .html). But make\r\nsure to not have a static file with the same name as a file in the pages/ directory, as this will result in an error. Read more. For static metadata files, such as robots.txt, favicon.ico, etc, you should use special metadata files inside the app folder. Good to know:\r\nThe directory must be named public. The name cannot be changed and it’s the only directory used to serve static assets. Only assets that are in the public directory at build time will be served by Next.js. Files added at request time won’t be\r\navailable. We recommend using a third-party service like AWS S3 for persistent file storage.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a840639-1456-4879-b37a-481ce89622b8":{"id_":"2a840639-1456-4879-b37a-481ce89622b8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SWF0RP9cgnBl+TjFJ7jp71DbviP1LOEmQx2iUD4clso=","metadata":{},"hash":"b1rtbXPIg1MHYgtAvRn76/7SIqx61Yx17yPGSP/YgmE="},"NEXT":{"nodeId":"0fdc3457-38e3-49b7-9e4d-f4f3b907f0e9","metadata":{},"hash":"4sw5bbeTjgOqPrTxQQDxhjAR3CSqhesFwotvxCNhDbI="}},"hash":"BaKRA8CloOTof9EcX7Q1A7QWXbl2ZLUc5VX8hXEny1o=","text":"3.1.6.6 - Lazy Loading\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/06-lazy-loading\r\nDescription: Lazy load imported libraries and React Components to improve your application's loading performance. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nLazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed\r\nto render a route. It allows you to defer loading of Client Components and imported libraries, and only include them in the client bundle when they’re\r\nneeded. For example, you might want to defer loading a modal until a user clicks to open it. There are two ways you can implement lazy loading in Next.js:\r\n1. Using Dynamic Imports with next/dynamic\r\n2. Using React.lazy() with Suspense\r\nBy default, Server Components are automatically code split, and you can use streaming to progressively send pieces of UI from the\r\nserver to the client. Lazy loading applies to Client Components.next/dynamicnext/dynamic\r\nnext/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for\r\nincremental migration. Examples\r\nImporting Client Components\r\napp/page.js (jsx)'use client'\r\nimport { useState } from 'react'\r\nimport dynamic from 'next/dynamic'\r\n// Client Components:\r\nconst ComponentA = dynamic(() => import('../components/A'))\r\nconst ComponentB = dynamic(() => import('../components/B'))\r\nconst ComponentC = dynamic(() => import('../components/C'), { ssr: false })\r\nexport default function ClientComponentExample() {\r\n  const [showMore, setShowMore] = useState(false)\r\n  return (\r\n    <div>\r\n      {/* Load immediately, but in a separate client bundle */}\r\n      <ComponentA />\r\n      {/* Load on demand, only when/if the condition is met */}\r\n      {showMore && <ComponentB />}\r\n      <button onClick={() => setShowMore(!showMore)}>Toggle</button>\r\n      {/* Load only on the client side */}\r\n      <ComponentC />\r\n    </div>\r\n  )\r\n}\r\nSkipping SSR\r\nWhen using React.lazy() and Suspense, Client Components will be pre-rendered (SSR) by default.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0fdc3457-38e3-49b7-9e4d-f4f3b907f0e9":{"id_":"0fdc3457-38e3-49b7-9e4d-f4f3b907f0e9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SWF0RP9cgnBl+TjFJ7jp71DbviP1LOEmQx2iUD4clso=","metadata":{},"hash":"b1rtbXPIg1MHYgtAvRn76/7SIqx61Yx17yPGSP/YgmE="},"PREVIOUS":{"nodeId":"2a840639-1456-4879-b37a-481ce89622b8","metadata":{},"hash":"BaKRA8CloOTof9EcX7Q1A7QWXbl2ZLUc5VX8hXEny1o="}},"hash":"4sw5bbeTjgOqPrTxQQDxhjAR3CSqhesFwotvxCNhDbI=","text":"If you want to disable pre-rendering for a Client Component, you can use the ssr option set to false:\r\nconst ComponentC = dynamic(() => import('../components/C'), { ssr: false })\r\nImporting Server Components","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7922debe-6677-49bd-b64f-4863a58fa9f1":{"id_":"7922debe-6677-49bd-b64f-4863a58fa9f1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ffv6tKOXXyvJ+Dn/wS4HAeBT6KJ+ilryB2ZfZ7xSRfQ=","metadata":{},"hash":"Vz/pj7/qlOoj3YTROQHfxYHvNexU2VNyL/06flJ6gmQ="}},"hash":"Q2A+WNy+sHD6OmhePO+znCh3I3Tro1D0UB1F6I7cBFA=","text":"If you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-\r\nloaded - not the Server Component itself. app/page.js (jsx)import dynamic from 'next/dynamic'\r\n// Server Component:\r\nconst ServerComponent = dynamic(() => import('../components/ServerComponent'))\r\nexport default function ServerComponentExample() {\r\n  return (\r\n    <div>\r\n      <ServerComponent />\r\n    </div>\r\n  )\r\n}\r\nLoading External Libraries\r\nExternal libraries can be loaded on demand using the import() function. This example uses the external library fuse.js for fuzzy\r\nsearch. The module is only loaded on the client after the user types in the search input. app/page.js (jsx)'use client'\r\nimport { useState } from 'react'\r\nconst names = ['Tim', 'Joe', 'Bel', 'Lee']\r\nexport default function Page() {\r\n  const [results, setResults] = useState()\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import('fuse.js')).default\r\n          const fuse = new Fuse(names)\r\n          setResults(fuse.search(value))\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  )\r\n}\r\nAdding a custom loading component\r\napp/page.js (jsx)import dynamic from 'next/dynamic'\r\nconst WithCustomLoading = dynamic(\r\n  () => import('../components/WithCustomLoading'),\r\n  {\r\n    loading: () => <p>Loading...</p>,\r\n  }\r\n)\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      {/* The loading component will be rendered while  <WithCustomLoading/> is loading */}\r\n      <WithCustomLoading />\r\n    </div>\r\n  )\r\n}\r\nImporting Named Exports","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7eb602b9-316d-41fe-9ca8-57c50f38eead":{"id_":"7eb602b9-316d-41fe-9ca8-57c50f38eead","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GmbgfoVgNWdCsj8AYwVp7Q+tuI9n8qcX8a0NFd26TM0=","metadata":{},"hash":"Yq3xnmLpgkJ7YzmVc2ZvDxIbpFz3ykPIyRsCx/z9aK4="}},"hash":"r+EW0319FWoceTQtLgGBJdyLXWzAGk4o8oSx3QrtxKU=","text":"To dynamically import a named export, you can return it from the Promise returned by import() function:\r\ncomponents/hello.js (jsx)'use client'\r\nexport function Hello() {\r\n  return <p>Hello!</p>\r\n}\r\napp/page.js (jsx)import dynamic from 'next/dynamic'\r\nconst ClientComponent = dynamic(() =>\r\n  import('../components/hello').then((mod) => mod.Hello)\r\n)\r\nBy using next/dynamic, the header component will not be included in the page’s initial JavaScript bundle. The page will render the\r\nSuspense fallback first, followed by the Header component when the Suspense boundary is resolved. import dynamic from 'next/dynamic'\r\nconst DynamicHeader = dynamic(() => import('../components/header'), {\r\n  loading: () => <p>Loading...</p>,\r\n})\r\nexport default function Home() {\r\n  return <DynamicHeader />\r\n}\r\nGood to know: In import('path/to/component'), the path must be explicitly written. It can’t be a template string nor a\r\nvariable. Furthermore the import() has to be inside the dynamic() call for Next.js to be able to match webpack bundles /\r\nmodule ids to the specific dynamic() call and preload them before rendering. dynamic() can’t be used inside of React\r\nrendering as it needs to be marked in the top level of the module for preloading to work, similar to React.lazy. With named exports\r\nTo dynamically import a named export, you can return it from the Promise returned by import():\r\ncomponents/hello.js (jsx)export function Hello() {\r\n  return <p>Hello!</p>\r\n}\r\n// pages/index.js\r\nimport dynamic from 'next/dynamic'\r\nconst DynamicComponent = dynamic(() =>\r\n  import('../components/hello').then((mod) => mod.Hello)\r\n)\r\nWith no SSR\r\nTo dynamically load a component on the client side, you can use the ssr option to disable server-rendering. This is useful if an external\r\ndependency or component relies on browser APIs like window. import dynamic from 'next/dynamic'\r\nconst DynamicHeader = dynamic(() => import('../components/header'), {\r\n  ssr: false,\r\n})\r\nWith external libraries\r\nThis example uses the external library fuse.js for fuzzy search. The module is only loaded in the browser after the user types in the\r\nsearch input. import { useState } from 'react'\r\nconst names = ['Tim', 'Joe', 'Bel', 'Lee']","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b3f7e6e-c11d-4e1b-a26a-1914924497a2":{"id_":"7b3f7e6e-c11d-4e1b-a26a-1914924497a2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XOFm4pBDpgO922liwLJffAR/GIdwpJSW6SWxB2h490w=","metadata":{},"hash":"1/BF1YvQuJf2Nypc18Htn+DNYbb5h3sYfJFAkJJoC5o="}},"hash":"ALjFMO7Ojd1q2EbRgKzVa5rkNQf9tSnEGD8GRYNIQ3M=","text":"export default function Page() {\r\n  const [results, setResults] = useState()\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import('fuse.js')).default\r\n          const fuse = new Fuse(names)\r\n          setResults(fuse.search(value))\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0f7359e2-479f-48e4-9586-b4c4aea07316":{"id_":"0f7359e2-479f-48e4-9586-b4c4aea07316","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iI5LzB39ekL5XaOBuR1zdeY4MEQ5x/5DdJzh2VmlKlo=","metadata":{},"hash":"4EMmwBwAkUFEvliU7khTEpS9oY40GMbiTn1DwB5LSJQ="}},"hash":"MsNXX5HnmhWsd6G08SoYEG7aAzRAq31CXgV0eFTpYus=","text":"3.1.6.7 - Analytics\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/07-analytics\r\nDescription: Measure and track page performance using Next.js Speed Insights\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to\r\nmanage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you. Build Your Own\r\npages/_app.js (jsx)import { useReportWebVitals } from 'next/web-vitals'\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n  return <Component {...pageProps} />\r\n}\r\nView the API Reference for more information. app/_components/web-vitals.js (jsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n}\r\napp/layout.js (jsx)import { WebVitals } from './_components/web-vitals'\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <WebVitals />\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nSince the useReportWebVitals hook requires the \"use client\" directive, the most performant approach is to create a\r\nseparate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component. View the API Reference for more information. Web Vitals\r\nWeb Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:\r\nTime to First Byte (TTFB)\r\nFirst Contentful Paint (FCP)\r\nLargest Contentful Paint (LCP)\r\nFirst Input Delay (FID)\r\nCumulative Layout Shift (CLS)\r\nInteraction to Next Paint (INP)\r\nYou can handle all the results of these metrics using the name property.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b5b2879a-239a-48b9-a69f-04a7d7cc2a04":{"id_":"b5b2879a-239a-48b9-a69f-04a7d7cc2a04","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MBbHZ/i2z4uR6bdbY8cjdH1RQq3jopaRE66V0d+H6JQ=","metadata":{},"hash":"Sw8PVrHzn8Snsq0AwQXGel0NuFwe1FcBnhB5By4e9Bo="}},"hash":"McfENLr+MFk97ngXw2yZMsfTZUkNa4bra2YO6sZC8JY=","text":"pages/_app.js (jsx)import { useReportWebVitals } from 'next/web-vitals'\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n  return <Component {...pageProps} />\r\n}\r\napp/components/web-vitals.tsx (tsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n}\r\napp/components/web-vitals.js (jsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n}\r\nCustom Metrics\r\nIn addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to\r\nhydrate and render:\r\nNext.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms)\r\nNext.js-route-change-to-render: Length of time it takes for a page to start rendering after a route change (in ms)\r\nNext.js-render: Length of time it takes for a page to finish render after a route change (in ms)\r\nYou can handle all the results of these metrics separately:\r\nexport function reportWebVitals(metric) {\r\n  switch (metric.name) {\r\n    case 'Next.js-hydration':\r\n      // handle hydration results\r\n      break","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f446ebfd-5cac-4b99-8a65-4d48b849fe1d":{"id_":"f446ebfd-5cac-4b99-8a65-4d48b849fe1d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HuLaZBFINggQqe+6iet23tP4MucgKL5EtEibwxw1Vog=","metadata":{},"hash":"5/579yFQDblQtbUopwJj7+B4ybXio/AXFwEj+DBpBDM="}},"hash":"GlGGi7Nnhfo6vUxPdE/jyQSHr4iZSuHoQcPW5g/xz24=","text":"case 'Next.js-route-change-to-render':\r\n      // handle route-change to render results\r\n      break\r\n    case 'Next.js-render':\r\n      // handle render results\r\n      break\r\n    default:\r\n      break\r\n  }\r\n}\r\nThese metrics work in all browsers that support the User Timing API. Sending results to external systems\r\nYou can send results to any endpoint to measure and track real user performance on your site. For example:\r\nuseReportWebVitals((metric) => {\r\n  const body = JSON.stringify(metric)\r\n  const url = 'https://example.com/analytics'\r\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`. if (navigator.sendBeacon) {\r\n    navigator.sendBeacon(url, body)\r\n  } else {\r\n    fetch(url, { body, method: 'POST', keepalive: true })\r\n  }\r\n})\r\nGood to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to\r\ncalculate percentiles, etc. )\r\njs useReportWebVitals(metric => { // Use `window.gtag` if you initialized Google Analytics as this\r\nexample: // https://github.com/vercel/next.js/blob/canary/examples/with-google-\r\nanalytics/pages/_app.js window.gtag('event', metric.name, { value: Math.round(metric.name === 'CLS'\r\n? metric.value * 1000 : metric.value), // values must be integers event_label: metric.id, // id\r\nunique to current page load non_interaction: true, // avoids affecting bounce rate. }); }\r\nRead more about sending results to Google Analytics.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0e8b6d1a-ef3e-4c99-baa5-c27dbbd3eae0":{"id_":"0e8b6d1a-ef3e-4c99-baa5-c27dbbd3eae0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Uzyurc8SquMvzoFahNaTmBSH7tbt3yQenUNsTYwsGW8=","metadata":{},"hash":"TIARpz8CJfL/MD7UJl0kAUfy8rJ09YF0HpxGLyxGYM0="},"NEXT":{"nodeId":"c080e59b-1c19-4f48-997e-d3f8a635d1ee","metadata":{},"hash":"g4c8IR7j5APqP13J8nm89ngJZ5z+BihtjAJYOHbYeJw="}},"hash":"YVFY3YtqtvOyD0Vc+WLhnn/QqkrQ+WUnMaH928l4u48=","text":"3.1.6.8 - OpenTelemetry\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/08-open-telemetry\r\nDescription: Learn how to instrument your Next.js app with OpenTelemetry. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nGood to know: This feature is experimental, you need to explicitly opt-in by providingexperimental.instrumentationHook = true;\r\n in your next.config.js. Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app. As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging\r\nobservability tools, such as logging and metrics, developers can gain insights into their application’s behavior and identify areas for\r\noptimization. With observability, developers can proactively address issues before they become major problems and provide a better\r\nuser experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance,\r\noptimize resources, and enhance user experience. We recommend using OpenTelemetry for instrumenting your apps. It’s a platform-agnostic way to instrument apps that allows you to\r\nchange your observability provider without changing your code. Read Official OpenTelemetry docs for more information about\r\nOpenTelemetry and how it works. This documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry\r\nObservability Primer. Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself. When you\r\nenable OpenTelemetry we will automatically wrap all your code like getStaticProps in spans with helpful attributes. Good to know: We currently support OpenTelemetry bindings only in serverless functions. We don’t provide any for edge or\r\nclient side code. Getting Started\r\nOpenTelemetry is extensible but setting it up properly can be quite verbose. That’s why we prepared a package @vercel/otel that\r\nhelps you get started quickly. It’s not extensible and you should configure OpenTelemetry manually if you need to customize your\r\nsetup.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c080e59b-1c19-4f48-997e-d3f8a635d1ee":{"id_":"c080e59b-1c19-4f48-997e-d3f8a635d1ee","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Uzyurc8SquMvzoFahNaTmBSH7tbt3yQenUNsTYwsGW8=","metadata":{},"hash":"TIARpz8CJfL/MD7UJl0kAUfy8rJ09YF0HpxGLyxGYM0="},"PREVIOUS":{"nodeId":"0e8b6d1a-ef3e-4c99-baa5-c27dbbd3eae0","metadata":{},"hash":"YVFY3YtqtvOyD0Vc+WLhnn/QqkrQ+WUnMaH928l4u48="}},"hash":"g4c8IR7j5APqP13J8nm89ngJZ5z+BihtjAJYOHbYeJw=","text":"Using @vercel/otel@vercel/otel\r\nTo get started, you must install @vercel/otel:\r\nTerminal (bash)npm install @vercel/otel\r\nNext, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):\r\nNext, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):\r\nyour-project/instrumentation.ts (ts)import { registerOTel } from '@vercel/otel'\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}\r\nyour-project/instrumentation.js (js)import { registerOTel } from '@vercel/otel'\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}\r\nGood to know\r\nThe instrumentation file should be in the root of your project and not inside the app or pages directory. If you’re using\r\nthe src folder, then place the file inside src alongside pages and app. If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename\r\nto match.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"87326532-81fc-4f71-9c8d-611c89400585":{"id_":"87326532-81fc-4f71-9c8d-611c89400585","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sOrhNpzmdXpwYlvr4zxvZX/pp9qFk4CfyzjXlgOoHEg=","metadata":{},"hash":"AQezzuK1XWKpSY9hLHWZItj2QiYrMAqmBNGIfznCkIU="},"NEXT":{"nodeId":"7617326b-b5c2-4e3a-b135-b1cbae9b5393","metadata":{},"hash":"DbesPpnQQc+Ny1eyCrVlArqmkjPqdncnWO2oX0ZNlt8="}},"hash":"ckwa3pEn40RMQHePgPUshqIZJo23rJES9XaHm4v0F1A=","text":"We have created a basic with-opentelemetry example that you can use. Good to know\r\nThe instrumentation file should be in the root of your project and not inside the app or pages directory. If you’re using\r\nthe src folder, then place the file inside src alongside pages and app. If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename\r\nto match. We have created a basic with-opentelemetry example that you can use. Manual OpenTelemetry configuration\r\nIf our wrapper @vercel/otel doesn’t suit your needs, you can configure OpenTelemetry manually. Firstly you need to install OpenTelemetry packages:\r\nTerminal (bash)npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node\r\nNow you can initialize NodeSDK in your instrumentation.ts. OpenTelemetry APIs are not compatible with edge runtime, so you\r\nneed to make sure that you are importing them only when process.env.NEXT_RUNTIME === 'nodejs'.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7617326b-b5c2-4e3a-b135-b1cbae9b5393":{"id_":"7617326b-b5c2-4e3a-b135-b1cbae9b5393","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sOrhNpzmdXpwYlvr4zxvZX/pp9qFk4CfyzjXlgOoHEg=","metadata":{},"hash":"AQezzuK1XWKpSY9hLHWZItj2QiYrMAqmBNGIfznCkIU="},"PREVIOUS":{"nodeId":"87326532-81fc-4f71-9c8d-611c89400585","metadata":{},"hash":"ckwa3pEn40RMQHePgPUshqIZJo23rJES9XaHm4v0F1A="}},"hash":"DbesPpnQQc+Ny1eyCrVlArqmkjPqdncnWO2oX0ZNlt8=","text":"We recommend creating a\r\nnew file instrumentation.node.ts which you conditionally import only when using node:\r\ninstrumentation.ts (ts)export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation.node.ts')\r\n  }\r\n}\r\ninstrumentation.js (js)export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation.node.js')\r\n  }\r\n}\r\ninstrumentation.node.ts (ts)import { NodeSDK } from '@opentelemetry/sdk-node'\r\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\r\nimport { Resource } from '@opentelemetry/resources'\r\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\r\nimport { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node'\r\nconst sdk = new NodeSDK({\r\n  resource: new Resource({\r\n    [SemanticResourceAttributes.SERVICE_NAME]: 'next-app',\r\n  }),\r\n  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),\r\n})\r\nsdk.start()\r\ninstrumentation.node.js (js)import { NodeSDK } from '@opentelemetry/sdk-node'\r\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\r\nimport { Resource } from '@opentelemetry/resources'\r\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\r\nimport { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node'\r\nconst sdk = new NodeSDK({\r\n  resource: new Resource({\r\n    [SemanticResourceAttributes.SERVICE_NAME]: 'next-app',\r\n  }),\r\n  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),\r\n})\r\nsdk.start()\r\nDoing this is equivalent to using @vercel/otel, but it’s possible to modify and extend. For example, you could use\r\n@opentelemetry/exporter-trace-otlp-grpc instead of @opentelemetry/exporter-trace-otlp-http or you can specify more\r\nresource attributes.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6755771e-60c2-4696-bd2b-ff7500b033e4":{"id_":"6755771e-60c2-4696-bd2b-ff7500b033e4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ro5kVMzgnjvZMOSyb3dFMok8Wdw9p99GEGA1h45jHl4=","metadata":{},"hash":"H4I1y2ImlfpSBbjktBmjsMZ/JwBEu4URrPnbRJ9hP04="},"NEXT":{"nodeId":"d74eceab-ea56-4d9f-846e-728773e9c2e8","metadata":{},"hash":"9HpL5iq6Qi6ilBFSdugHcm/VcwFf4ym+UqpBLiqw3Bs="}},"hash":"NaWe/wA3LOuYVHIwutQOk4f7/hhc2YHXtYSKqU99OOE=","text":"Testing your instrumentation\r\nYou need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally. We recommend using our\r\nOpenTelemetry dev environment. If everything works well you should be able to see the root server span labeled as GET /requested/pathname. All other spans from\r\nthat particular trace will be nested under it. Next.js traces more spans than are emitted by default. To see more spans, you must set NEXT_OTEL_VERBOSE=1. Deployment\r\nUsing OpenTelemetry Collector\r\nWhen you are deploying with OpenTelemetry Collector, you can use @vercel/otel. It will work both on Vercel and when self-hosted. Deploying on Vercel\r\nWe made sure that OpenTelemetry works out of the box on Vercel. Follow Vercel documentation to connect your project to an observability provider. Self-hosting\r\nDeploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process\r\nthe telemetry data from your Next.js app. To do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and\r\nconfiguring it to receive data from your Next.js app. Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective\r\ndeployment guides. Custom Exporters\r\nWe recommend using OpenTelemetry Collector. If that is not possible on your platform, you can use a custom OpenTelemetry exporter\r\nwith manual OpenTelemetry configuration\r\nCustom Spans\r\nYou can add a custom span with OpenTelemetry APIs. Terminal (bash)npm install @opentelemetry/api\r\nThe following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the\r\nfetch request’s result:\r\nimport { trace } from '@opentelemetry/api'\r\nexport async function fetchGithubStars() {\r\n  return await trace\r\n    .getTracer('nextjs-example')\r\n    .startActiveSpan('fetchGithubStars', async (span) => {\r\n      try {\r\n        return await getValue()\r\n      } finally {\r\n        span.end()\r\n      }\r\n    })\r\n}\r\nThe register function will execute before your code runs in a new environment. You can start creating new spans, and they should be\r\ncorrectly added to the exported trace.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d74eceab-ea56-4d9f-846e-728773e9c2e8":{"id_":"d74eceab-ea56-4d9f-846e-728773e9c2e8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ro5kVMzgnjvZMOSyb3dFMok8Wdw9p99GEGA1h45jHl4=","metadata":{},"hash":"H4I1y2ImlfpSBbjktBmjsMZ/JwBEu4URrPnbRJ9hP04="},"PREVIOUS":{"nodeId":"6755771e-60c2-4696-bd2b-ff7500b033e4","metadata":{},"hash":"NaWe/wA3LOuYVHIwutQOk4f7/hhc2YHXtYSKqU99OOE="}},"hash":"9HpL5iq6Qi6ilBFSdugHcm/VcwFf4ym+UqpBLiqw3Bs=","text":"You can start creating new spans, and they should be\r\ncorrectly added to the exported trace. Default Spans in Next.js\r\nNext.js automatically instruments several spans for you to provide useful insights into your application’s performance. Attributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace:\r\nnext.span_name - duplicates span name","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bcc222bf-a649-49c4-8f12-021cbf4a4df2":{"id_":"bcc222bf-a649-49c4-8f12-021cbf4a4df2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6/dQEI+0XI13S53eNxD6qorpS+P2XwSo+s97ENNNO8w=","metadata":{},"hash":"Ogrkn4UDYbF/D6BN774UTUe3OIV/S9UCx8GISn6Scts="}},"hash":"yKY7BMHpcBwnkZy1cGvAJML8aSPEbWwd18Sz6reXRB4=","text":"next.span_type - each span type has a unique identifier\r\nnext.route - The route pattern of the request (e.g., /[param]/user). next.page\r\nThis is an internal value used by an app router. You can think about it as a route to a special file (like page.ts, layout.ts, loading.ts and others)\r\nIt can be used as a unique identifier only when paired with next.route because /layout can be used to identify both\r\n/(groupA)/layout.ts and /(groupB)/layout.ts\r\n[http.method] [next.route][http.method] [next.route]\r\nnext.span_type: BaseServer.handleRequest\r\nThis span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and\r\nstatus code of the request. Attributes:\r\nCommon HTTP attributeshttp.method\r\nhttp.status_code\r\nServer HTTP attributeshttp.route\r\nhttp.target\r\nnext.span_name\r\nnext.span_type\r\nnext.route\r\nrender route (app) [next.route]render route (app) [next.route]\r\nnext.span_type: AppRender.getBodyResult. This span represents the process of rendering a route in the app router. Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.route\r\nfetch [http.method] [http.url]fetch [http.method] [http.url]\r\nnext.span_type: AppRender.fetch\r\nThis span represents the fetch request executed in your code. Attributes:\r\nCommon HTTP attributeshttp.method\r\nClient HTTP attributeshttp.url\r\nnet.peer.name\r\nnet.peer.port (only if specified)\r\nnext.span_name\r\nnext.span_type\r\nexecuting api route (app) [next.route]executing api route (app) [next.route]\r\nnext.span_type: AppRouteRouteHandlers.runHandler. This span represents the execution of an API route handler in the app router. Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.route","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"09c16574-290c-4f10-99de-4469cb04670c":{"id_":"09c16574-290c-4f10-99de-4469cb04670c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Zpu7nCiYzkMXSdAnOZzM6k0eyQZ/2sHA0ieopehSBns=","metadata":{},"hash":"4fn1VVKWB58s+nC+dI2yPpphl4a9/PlFXo0oOKpy4q0="}},"hash":"CUAjNl7iwXmIMIsLIuDb8urkgNWKc71Qj4zV/GDHKTs=","text":"getServerSideProps [next.route]getServerSideProps [next.route]\r\nnext.span_type: Render.getServerSideProps. This span represents the execution of getServerSideProps for a specific route. Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.route\r\ngetStaticProps [next.route]getStaticProps [next.route]\r\nnext.span_type: Render.getStaticProps. This span represents the execution of getStaticProps for a specific route. Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.route\r\nrender route (pages) [next.route]render route (pages) [next.route]\r\nnext.span_type: Render.renderDocument. This span represents the process of rendering the document for a specific route. Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.route\r\ngenerateMetadata [next.page]generateMetadata [next.page]\r\nnext.span_type: ResolveMetadata.generateMetadata. This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans). Attributes:\r\nnext.span_name\r\nnext.span_type\r\nnext.page","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0b7cec8b-9a4d-48a0-8f8f-925720235f38":{"id_":"0b7cec8b-9a4d-48a0-8f8f-925720235f38","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aKsm/IkbOTMnSvgcZ6M1qGrQa26fBi7thXboevOkakM=","metadata":{},"hash":"L3+FML8luYR5MTNw1fxTHMpJmqvxunLTUoi9ycghmbE="},"NEXT":{"nodeId":"e52bd352-de0a-41f9-baad-b206ab7a144a","metadata":{},"hash":"e3KKWJIygiNqsnydAba0pCccotM0hpvU2hB+pYKAU/4="}},"hash":"iUVo5d+9oST3SskAXpgRT1fsgrX10cEPn2X1n9IYDuY=","text":"3.1.6.9 - Instrumentation\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/09-instrumentation\r\nDescription: Learn how to use instrumentation to run code at server startup in your Next.js app\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nIf you export a function named register from a instrumentation.ts (or .js) file in the root directory of your project (or inside\r\nthe src folder if using one), we will call that function whenever a new Next.js server instance is bootstrapped. Good to know\r\nThis feature is experimental. To use it, you must explicitly opt in by defining experimental.instrumentationHook =\r\ntrue; in your next.config.js. The instrumentation file should be in the root of your project and not inside the app or pages directory. If you’re using\r\nthe src folder, then place the file inside src alongside pages and app. If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename\r\nto match. We have created a basic with-opentelemetry example that you can use. Good to know\r\nThis feature is experimental. To use it, you must explicitly opt in by defining experimental.instrumentationHook =\r\ntrue; in your next.config.js. The instrumentation file should be in the root of your project and not inside the app or pages directory. If you’re using\r\nthe src folder, then place the file inside src alongside pages and app. If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename\r\nto match. We have created a basic with-opentelemetry example that you can use. When your register function is deployed, it will be called on each cold boot (but exactly once in each environment). Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file\r\nthat defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global\r\nvariables the package has declared.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e52bd352-de0a-41f9-baad-b206ab7a144a":{"id_":"e52bd352-de0a-41f9-baad-b206ab7a144a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aKsm/IkbOTMnSvgcZ6M1qGrQa26fBi7thXboevOkakM=","metadata":{},"hash":"L3+FML8luYR5MTNw1fxTHMpJmqvxunLTUoi9ycghmbE="},"PREVIOUS":{"nodeId":"0b7cec8b-9a4d-48a0-8f8f-925720235f38","metadata":{},"hash":"iUVo5d+9oST3SskAXpgRT1fsgrX10cEPn2X1n9IYDuY="}},"hash":"e3KKWJIygiNqsnydAba0pCccotM0hpvU2hB+pYKAU/4=","text":"You would still have access to the global\r\nvariables the package has declared. You can import files with side effects in instrumentation.ts, which you might want to use in your register function as\r\ndemonstrated in the following example:\r\nyour-project/instrumentation.ts (ts)import { init } from 'package-init'\r\nexport function register() {\r\n  init()\r\n}\r\nyour-project/instrumentation.js (js)import { init } from 'package-init'\r\nexport function register() {\r\n  init()\r\n}\r\nHowever, we recommend importing files with side effects using import from within your register function instead. The following\r\nexample demonstrates a basic usage of import in a register function:\r\nyour-project/instrumentation.ts (ts)export async function register() {\r\n  await import('package-with-side-effect')\r\n}\r\nyour-project/instrumentation.js (js)export async function register() {\r\n  await import('package-with-side-effect')\r\n}\r\nBy doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c756f963-4d39-491b-bd0d-4ad3a7fc381d":{"id_":"c756f963-4d39-491b-bd0d-4ad3a7fc381d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mjNBL/KKqBztYYHFrYSawxSdhbo07HvSBiAlsVtVDQ4=","metadata":{},"hash":"1Hg2qZG+AQobtrRNEqhfrEVBizGf5zCtEilhcMkMPfE="}},"hash":"Opah5tj0Y2zFNeE6b1xL7G8OZBrk/lBGbCoX/rFaWwI=","text":"importing files. We call register in all environments, so it’s necessary to conditionally import any code that doesn’t support both edge and nodejs. You can use the environment variable NEXT_RUNTIME to get the current environment. Importing an environment-specific code would\r\nlook like this:\r\nyour-project/instrumentation.ts (ts)export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation-node')\r\n  }\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    await import('./instrumentation-edge')\r\n  }\r\n}\r\nyour-project/instrumentation.js (js)export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation-node')\r\n  }\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    await import('./instrumentation-edge')\r\n  }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4cadce48-8343-46e7-b0ef-e094dd5f5e3c":{"id_":"4cadce48-8343-46e7-b0ef-e094dd5f5e3c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9uaDBgUUT4rD7YVN1m67ysQN3af0Xil3t0ds4ShcyZ4=","metadata":{},"hash":"aBpiTeWhof5czvwrZMczrjL42TK9qQwiHXdQz96+Glg="},"NEXT":{"nodeId":"1ebaac4a-b0b7-47f5-8572-929b7e43a0f3","metadata":{},"hash":"pwI5H95M7dZszm8tAA0kkGjSHERQBq/wnJ9SHG8KKZQ="}},"hash":"YfptPdy5ovmk56/9+TxV/vMpEWkw+Xi1XE+SdDYbIdk=","text":"3.1.6.10 - Third Party Libraries\r\nDocumentation path: /02-app/01-building-your-application/06-optimizing/10-third-party-libraries\r\nDescription: Optimize the performance of third-party libraries in your application with the `@next/third-parties` package. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\n@next/third-parties@next/third-parties is a library that provides a collection of components and utilities that improve the performance and\r\ndeveloper experience of loading popular third-party libraries in your Next.js application. Good to know: @next/third-parties is a new experimental library that is still under active development. We’re currently\r\nworking on adding more third-party integrations. All third-party integrations provided by @next/third-parties have been optimized for performance and ease of use. Getting Started\r\nTo get started, you must install the @next/third-parties library:\r\nTerminal (bash)npm install @next/third-parties\r\nGoogle Third-Parties\r\nAll supported third-party libraries from Google can be imported from @next/third-parties/google. Google Tag Manager\r\nThe GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the\r\noriginal inline script after hydration occurs on the page.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1ebaac4a-b0b7-47f5-8572-929b7e43a0f3":{"id_":"1ebaac4a-b0b7-47f5-8572-929b7e43a0f3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9uaDBgUUT4rD7YVN1m67ysQN3af0Xil3t0ds4ShcyZ4=","metadata":{},"hash":"aBpiTeWhof5czvwrZMczrjL42TK9qQwiHXdQz96+Glg="},"PREVIOUS":{"nodeId":"4cadce48-8343-46e7-b0ef-e094dd5f5e3c","metadata":{},"hash":"YfptPdy5ovmk56/9+TxV/vMpEWkw+Xi1XE+SdDYbIdk="}},"hash":"pwI5H95M7dZszm8tAA0kkGjSHERQBq/wnJ9SHG8KKZQ=","text":"By default, it fetches the\r\noriginal inline script after hydration occurs on the page. To load Google Tag Manager for all routes, include the component directly in your root layout:\r\napp/layout.tsx (tsx)import { GoogleTagManager } from '@next/third-parties/google'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { GoogleTagManager } from '@next/third-parties/google'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n    </html>\r\n  )\r\n}\r\nTo load Google Tag Manager for all routes, include the component directly in your custom _app:\r\npages/_app.js (jsx)import { GoogleTagManager } from '@next/third-parties/google'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8cf6f22d-b897-453b-b292-b9f57caf45a8":{"id_":"8cf6f22d-b897-453b-b292-b9f57caf45a8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WTGsT2/zrujY9jzAPdx+r0Kd+h51Nuv9vPuY0lYf0Cw=","metadata":{},"hash":"1tnZMnkKWq6HdpsrspNHI2JGLR7qmHmrdwPgCAi5OY0="}},"hash":"3gP9Jnm1zHvtSMuyrzpYqWv5WIDrEz1I3Xaivy0Jpoo=","text":"<Component {...pageProps} />\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n    </>\r\n  )\r\n}\r\nTo load Google Tag Manager for a single route, include the component in your page file:\r\napp/page.js (jsx)import { GoogleTagManager } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n}\r\npages/index.js (jsx)import { GoogleTagManager } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n}\r\nSending Events\r\nThe sendGTMEvent function can be used to track user interactions on your page by sending events using the dataLayer object. For\r\nthis function to work, the <GoogleTagManager /> component must be included in either a parent layout, page, or component, or\r\ndirectly in the same file. app/page.js (jsx)'use client'\r\nimport { sendGTMEvent } from '@next/third-parties/google'\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\npages/index.js (jsx)import { sendGTMEvent } from '@next/third-parties/google'\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\nRefer to the Tag Manager developer documentation to learn about the different variables and events that can be passed into the\r\nfunction. Options\r\nOptions to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager docs. NameTypeDescription\r\ngtmIdRequiredYour GTM container id. dataLayerOptionalData layer array to instantiate the container with. Defaults to an empty array.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3895dd55-064b-475e-b1e8-a0cf98ffe644":{"id_":"3895dd55-064b-475e-b1e8-a0cf98ffe644","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZhNME3NFGMpzS9Nwv4B/FoRM7wiPLW5rF20lqiVVEEQ=","metadata":{},"hash":"IpshkdxmMge1pF5oNNDCVIURU0rElRFkqKCTsFS3tzA="}},"hash":"5Uvh/d0w2VxfiwbEouD7lXpKnpyQrfY5WiRXvg2YloU=","text":"dataLayerNameOptionalName of the data layer. Defaults to dataLayer. authOptionalValue of authentication parameter (gtm_auth) for environment snippets. previewOptionalValue of preview parameter (gtm_preview) for environment snippets. NameTypeDescription\r\nGoogle Analytics\r\nThe GoogleAnalytics component can be used to include Google Analytics 4 to your page via the Google tag (gtag.js). By default, it\r\nfetches the original scripts after hydration occurs on the page. Recommendation: If Google Tag Manager is already included in your application, you can configure Google Analytics directly\r\nusing it, rather than including Google Analytics as a separate component. Refer to the documentation to learn more about the\r\ndifferences between Tag Manager and gtag.js. To load Google Analytics for all routes, include the component directly in your root layout:\r\napp/layout.tsx (tsx)import { GoogleAnalytics } from '@next/third-parties/google'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleAnalytics gaId=\"GA-XYZ\" />\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import { GoogleAnalytics } from '@next/third-parties/google'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleAnalytics gaId=\"GA-XYZ\" />\r\n    </html>\r\n  )\r\n}\r\nTo load Google Analytics for all routes, include the component directly in your custom _app:\r\npages/_app.js (jsx)import { GoogleAnalytics } from '@next/third-parties/google'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <GoogleAnalytics gaId=\"GA-XYZ\" />\r\n    </>\r\n  )\r\n}\r\nTo load Google Analytics for a single route, include the component in your page file:\r\napp/page.js (jsx)import { GoogleAnalytics } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return <GoogleAnalytics gaId=\"GA-XYZ\" />\r\n}\r\npages/index.js (jsx)import { GoogleAnalytics } from '@next/third-parties/google'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5968ae34-d32a-4ece-ba1d-7a11b48da915":{"id_":"5968ae34-d32a-4ece-ba1d-7a11b48da915","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"IjL9OQ0ooE3cn2MNDEFLiQLIA6Zg3uPBseVbi3tU72Y=","metadata":{},"hash":"jzJLSHN4wWS6ixMWCIkFooUst3E09ivq3KL/+xJWQI0="}},"hash":"1KVW/TZusj8YFy2osmXC+3N9fN+3Z3ktOBP3LLFLkJw=","text":"export default function Page() {\r\n  return <GoogleAnalytics gaId=\"GA-XYZ\" />\r\n}\r\nSending Events\r\nThe sendGAEvent function can be used to measure user interactions on your page by sending events using the dataLayer object. For\r\nthis function to work, the <GoogleAnalytics /> component must be included in either a parent layout, page, or component, or\r\ndirectly in the same file. app/page.js (jsx)'use client'\r\nimport { sendGAEvent } from '@next/third-parties/google'\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGAEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\npages/index.js (jsx)import { sendGAEvent } from '@next/third-parties/google'\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGAEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\nRefer to the Google Analytics developer documentation to learn more about event parameters. Options\r\nOptions to pass to the <GoogleAnalytics> component. NameTypeDescription\r\ngaIdRequiredYour Google tag id. dataLayerNameOptionalName of the data layer. Defaults to dataLayer. Google Maps Embed\r\nThe GoogleMapsEmbed component can be used to add a Google Maps Embed to your page. By default, it uses the loading attribute to\r\nlazy-load the embed below the fold. app/page.js (jsx)import { GoogleMapsEmbed } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return (\r\n    <GoogleMapsEmbed\r\n      apiKey=\"XYZ\"\r\n      height={200}\r\n      width=\"100%\"\r\n      mode=\"place\"\r\n      q=\"Brooklyn+Bridge,New+York,NY\"\r\n    />","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0181cdba-d06b-43f6-af15-5a1e7e0b6f91":{"id_":"0181cdba-d06b-43f6-af15-5a1e7e0b6f91","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"14z9ThP1ojC8pctzWiWeRZmJ0y8VRRgbHf8VnEywr04=","metadata":{},"hash":"i79xvjLOpP5jA+wU6kM+QCM2PnNzzsKloIC1I0CCg6Y="}},"hash":"qZ9pSsmsahi7oNlLrO8Cx7dXInPIpeLmHCE3rkSNhjo=","text":")\r\n}\r\npages/index.js (jsx)import { GoogleMapsEmbed } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return (\r\n    <GoogleMapsEmbed\r\n      apiKey=\"XYZ\"\r\n      height={200}\r\n      width=\"100%\"\r\n      mode=\"place\"\r\n      q=\"Brooklyn+Bridge,New+York,NY\"\r\n    />\r\n  )\r\n}\r\nOptions\r\nOptions to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed docs. NameTypeDescription\r\napiKeyRequiredYour api key. modeRequiredMap mode\r\nheightOptionalHeight of the embed. Defaults to auto. widthOptionalWidth of the embed. Defaults to auto. styleOptionalPass styles to the iframe. allowfullscreenOptionalProperty to allow certain map parts to go full screen. loadingOptionalDefaults to lazy. Consider changing if you know your embed will be above the fold. qOptionalDefines map marker location. This may be required depending on the map mode. centerOptionalDefines the center of the map view. zoomOptionalSets initial zoom level of the map. maptypeOptionalDefines type of map tiles to load. languageOptionalDefines the language to use for UI elements and for the display of labels on map tiles. regionOptionalDefines the appropriate borders and labels to display, based on geo-political sensitivities. YouTube Embed\r\nThe YouTubeEmbed component can be used to load and display a YouTube embed. This component loads faster by using lite-\r\nyoutube-embed under the hood. app/page.js (jsx)import { YouTubeEmbed } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" />\r\n}\r\npages/index.js (jsx)import { YouTubeEmbed } from '@next/third-parties/google'\r\nexport default function Page() {\r\n  return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" />\r\n}\r\nOptions\r\nNameTypeDescription","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3662f50e-1775-4f91-89a5-c9efc9dd2c01":{"id_":"3662f50e-1775-4f91-89a5-c9efc9dd2c01","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AV4cdk1XRnCsEV1ZdlegcqDQb634GeHqKyXgf2yoPwg=","metadata":{},"hash":"FAhC1beaQIGg7IBWA/93+HIEX2e/1YE5pQ+qRXTkCZ8="}},"hash":"SAr48qmhGgcHhPjomI4LaxapMRS+Dn73oiVXEjqqt/w=","text":"videoidRequiredYouTube video id. widthOptionalWidth of the video container. Defaults to auto\r\nheightOptionalHeight of the video container. Defaults to auto\r\nplaylabelOptionalA visually hidden label for the play button for accessibility. paramsOptionalThe video player params defined here. Params are passed as a query param string. Eg: params=\"controls=0&start=10&end=30\"\r\nstyleOptionalUsed to apply styles to the video container. NameTypeDescription","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"802cdbc9-0496-41b6-ae49-301122bb2072":{"id_":"802cdbc9-0496-41b6-ae49-301122bb2072","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cVxcS+KPM3oDQ+h76lBnrFED1UfUSebYbW2koyQ33x4=","metadata":{},"hash":"tRA4fwf9qAzXb5wtGOLq93ALWZCzbSF5FH7Z3LT4p4g="}},"hash":"IfyuWxDCAmuIpMIcZX+Zzqbl6ARHu65X/qxuuJsq7fE=","text":"3.1.7 - Configuring\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/index\r\nDescription: Learn how to configure your Next.js application. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and\r\nmore, as well as internal configuration options such as Absolute Imports and Environment Variables.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"432ce4c2-6fef-4d55-999b-dcd05a050274":{"id_":"432ce4c2-6fef-4d55-999b-dcd05a050274","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0H5VVaIL6Gezp6Aa6qz703uz8LBETDikT81wFOfgvSI=","metadata":{},"hash":"nfEmO3pYI5yzbNpf7ai9/7HAZJOZSkdg458HK436GDg="}},"hash":"h0sezuYSKgN4oR4Fwr2ZynjID8qeJ/D6AHtUktOLTsY=","text":"3.1.7.1 - TypeScript\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/01-typescript\r\nDescription: Next.js provides a TypeScript-first development experience for building your React application. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js provides a TypeScript-first development experience for building your React application. It comes with built-in TypeScript support for automatically installing the necessary packages and configuring the proper settings. As well as a TypeScript Plugin for your editor. \u0000 Watch: Learn about the built-in TypeScript plugin → YouTube (3 minutes)\r\nNew Projects\r\ncreate-next-app now ships with TypeScript by default. Terminal (bash)npx create-next-app@latest\r\nExisting Projects\r\nAdd TypeScript to your project by renaming a file to .ts / .tsx. Run next dev and next build to automatically install the necessary\r\ndependencies and add a tsconfig.json file with the recommended config options. If you already had a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json\r\nfile, and delete the old jsconfig.json file. TypeScript Plugin\r\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-\r\nchecking and auto-completion. You can enable the plugin in VS Code by:\r\n1. Opening the command palette (Ctrl/⌘ + Shift + P)\r\n2. Searching for “TypeScript: Select TypeScript Version”\r\n3. Selecting “Use Workspace Version”\r\nNow, when editing files, the custom plugin will be enabled. When running next build, the custom type checker will be used. Plugin Features\r\nThe TypeScript plugin can help with:\r\nWarning if the invalid values for segment config options are passed. Showing available options and in-context documentation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5591c8ce-1f90-4c8e-bfe6-fbbbd83f661c":{"id_":"5591c8ce-1f90-4c8e-bfe6-fbbbd83f661c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WEe/Am4Gz5LhVP6A0RsX7m9Mcz/Xd9/jSCvtMIVbLWY=","metadata":{},"hash":"F7xjTmAFICHk76sQO1L3npCNjKy/CxqP9QgG4YabzCM="},"NEXT":{"nodeId":"7a1c9b05-2bc4-45aa-8821-e014ad0212c2","metadata":{},"hash":"Lv+TribcxElApUGtT6QnbSsKKkT+4LKIM3JEjLd47mM="}},"hash":"cluvQDc4qFDVLzJxNl8KogOO9TuXjuJ6dVpSQPcC/2s=","text":"Ensuring the use client directive is used correctly. Ensuring client hooks (like useState) are only used in Client Components. Good to know: More features will be added in the future. Minimum TypeScript Version\r\nIt is highly recommended to be on at least v4.5.2 of TypeScript to get syntax features such as type modifiers on import names and\r\nperformance improvements. Statically Typed Links\r\nNext.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating\r\nbetween pages. To opt-into this feature, experimental.typedRoutes need to be enabled and the project needs to be using TypeScript. next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    typedRoutes: true,\r\n  },\r\n}\r\nmodule.exports = nextConfig\r\nNext.js will generate a link definition in .next/types that contains information about all existing routes in your application, which\r\nTypeScript can then use to provide feedback in your editor about invalid links. Currently, experimental support includes any string literal, including dynamic segments. For non-literal strings, you currently need to\r\nmanually cast the href with as Route:\r\nimport type { Route } from 'next';\r\nimport Link from 'next/link'\r\n// No TypeScript errors if href is a valid route\r\n<Link href=\"/about\" />\r\n<Link href=\"/blog/nextjs\" />\r\n<Link href={`/blog/${slug}`} />\r\n<Link href={('/blog' + slug) as Route} />\r\n// TypeScript errors if href is not a valid route\r\n<Link href=\"/aboot\" />\r\nTo accept href in a custom component wrapping next/link, use a generic:\r\nimport type { Route } from 'next'\r\nimport Link from 'next/link'\r\nfunction Card<T extends string>({ href }: { href: Route<T> | URL }) {\r\n  return (\r\n    <Link href={href}>\r\n      <div>My Card</div>\r\n    </Link>\r\n  )\r\n}\r\nHow does it work? When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about\r\nall existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json\r\nand the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links. End-to-End Type Safety\r\nNext.js 13 has enhanced type safety.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7a1c9b05-2bc4-45aa-8821-e014ad0212c2":{"id_":"7a1c9b05-2bc4-45aa-8821-e014ad0212c2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WEe/Am4Gz5LhVP6A0RsX7m9Mcz/Xd9/jSCvtMIVbLWY=","metadata":{},"hash":"F7xjTmAFICHk76sQO1L3npCNjKy/CxqP9QgG4YabzCM="},"PREVIOUS":{"nodeId":"5591c8ce-1f90-4c8e-bfe6-fbbbd83f661c","metadata":{},"hash":"cluvQDc4qFDVLzJxNl8KogOO9TuXjuJ6dVpSQPcC/2s="}},"hash":"Lv+TribcxElApUGtT6QnbSsKKkT+4LKIM3JEjLd47mM=","text":"End-to-End Type Safety\r\nNext.js 13 has enhanced type safety. This includes:\r\n1. No serialization of data between fetching function and page: You can fetch directly in components, layouts, and pages on the\r\nserver. This data does not need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since app uses Server Components by default, we can use values like Date, Map, Set, and more without any extra steps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6c59eca8-b68e-4911-81aa-248261b8516d":{"id_":"6c59eca8-b68e-4911-81aa-248261b8516d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RXOw1YBgUxl9TL8GNckohKV+3hbTBNu4b7uXZzxMrjM=","metadata":{},"hash":"n5ZEUch2Pd5PAm1tVWNhzogI4VqfKBJukgIV/DQ0B5A="},"NEXT":{"nodeId":"03ae0166-049f-4ded-ab4b-70912d6aedbd","metadata":{},"hash":"ryTkYsYGU8prWd89yHzG5RsDkf4J2LD/zeyITpcWny8="}},"hash":"yoDaM6FgEdFa4nsyrbO3bz8AMSuVtXVGULX4RrZCTuM=","text":"Previously, you needed to manually type the boundary between server and client with Next.js-specific types. 2. Streamlined data flow between components: With the removal of _app in favor of root layouts, it is now easier to visualize the\r\ndata flow between components and pages. Previously, data flowing between individual pages and _app were difficult to type and\r\ncould introduce confusing bugs. With colocated data fetching in Next.js 13, this is no longer an issue. Data Fetching in Next.js now provides as close to end-to-end type safety as possible without being prescriptive about your database or\r\ncontent provider selection. We’re able to type the response data as you would expect with normal TypeScript. For example:\r\napp/page.tsx (tsx)async function getData() {\r\n  const res = await fetch('https://api.example.com/... ')\r\n  // The return value is *not* serialized\r\n  // You can return Date, Map, Set, etc. return res.json()\r\n}\r\nexport default async function Page() {\r\n  const name = await getData()\r\n  return '... '\r\n}\r\nFor complete end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through\r\nusing an ORM or type-safe query builder. Async Server Component TypeScript Error\r\nTo use an async Server Component with TypeScript, ensure you are using TypeScript 5.1.3 or higher and @types/react 18.2.8 or\r\nhigher. If you are using an older version of TypeScript, you may see a 'Promise<Element>' is not a valid JSX element type error. Updating to the latest version of TypeScript and @types/react should resolve this issue. Passing Data Between Server & Client Components\r\nWhen passing data between a Server and Client Component through props, the data is still serialized (converted to a string) for use in\r\nthe browser. However, it does not need a special type. It’s typed the same as passing any other props between components. Further, there is less code to be serialized, as un-rendered data does not cross between the server and client (it remains on the server). This is only now possible through support for Server Components.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"03ae0166-049f-4ded-ab4b-70912d6aedbd":{"id_":"03ae0166-049f-4ded-ab4b-70912d6aedbd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RXOw1YBgUxl9TL8GNckohKV+3hbTBNu4b7uXZzxMrjM=","metadata":{},"hash":"n5ZEUch2Pd5PAm1tVWNhzogI4VqfKBJukgIV/DQ0B5A="},"PREVIOUS":{"nodeId":"6c59eca8-b68e-4911-81aa-248261b8516d","metadata":{},"hash":"yoDaM6FgEdFa4nsyrbO3bz8AMSuVtXVGULX4RrZCTuM="}},"hash":"ryTkYsYGU8prWd89yHzG5RsDkf4J2LD/zeyITpcWny8=","text":"This is only now possible through support for Server Components. Static Generation and Server-side Rendering\r\nFor getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and\r\nGetServerSideProps types respectively:\r\npages/blog/[slug].tsx (tsx)import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'\r\nexport const getStaticProps = (async (context) => {\r\n  // ... }) satisfies GetStaticProps\r\nexport const getStaticPaths = (async () => {\r\n  // ... }) satisfies GetStaticPaths\r\nexport const getServerSideProps = (async (context) => {\r\n  // ... }) satisfies GetServerSideProps\r\nGood to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript. API Routes\r\nThe following is an example of how to use the built-in types for API routes:\r\nimport type { NextApiRequest, NextApiResponse } from 'next'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"05c28b9e-9351-4e49-8f54-6cb4756474b9":{"id_":"05c28b9e-9351-4e49-8f54-6cb4756474b9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zgapBrFdPYgd7QBuZGmNMeI/q0ypd1b9n4twmEzMr/U=","metadata":{},"hash":"8vL29nOhMZHQefXVA3iY9J5HwpM7vnzctOiyX/jlDkU="}},"hash":"Qam69kvdeqHS4nP70vPNRoXHIa1f+wxuUeZTm15OPGs=","text":"export default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  res.status(200).json({ name: 'John Doe' })\r\n}\r\nYou can also type the response data:\r\nimport type { NextApiRequest, NextApiResponse } from 'next'\r\ntype Data = {\r\n  name: string\r\n}\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<Data>\r\n) {\r\n  res.status(200).json({ name: 'John Doe' })\r\n}\r\nCustom AppApp\r\nIf you have a custom App, you can use the built-in type AppProps and change file name to ./pages/_app.tsx like so:\r\nimport type { AppProps } from 'next/app'\r\nexport default function MyApp({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}\r\nPath aliases and baseUrl\r\nNext.js automatically supports the tsconfig.json \"paths\" and \"baseUrl\" options. You can learn more about this feature on the Module Path aliases documentation. You can learn more about this feature on the Module Path aliases documentation. Type checking next.config.js\r\nThe next.config.js file must be a JavaScript file as it does not get parsed by Babel or TypeScript, however you can add some type\r\nchecking in your IDE using JSDoc as below:\r\n// @ts-check\r\n/**\r\n * @type {import('next').NextConfig}\r\n **/\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\nmodule.exports = nextConfig\r\nIncremental type checking\r\nSince v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type\r\nchecking in larger applications. Ignoring TypeScript Errors\r\nNext.js fails your production build (next build) when TypeScript errors are present in your project. If you’d like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type\r\nchecking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.js and enable the ignoreBuildErrors option in the typescript config:\r\nnext.config.js (js)module.exports = {\r\n  typescript: {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"13df09d1-68f8-4a62-b66e-d5529cbac8aa":{"id_":"13df09d1-68f8-4a62-b66e-d5529cbac8aa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"99wBn1FrSyQWD9/Qyqc8EWtfVR3+wSABNUFFkSZbCtQ=","metadata":{},"hash":"rVAVKG+T29gZhq6Gg9AMnckzB5Ieq/16qRxOqDagJ9U="}},"hash":"rRreRU/FUHu653q3RoMmq+KomAY1Dq3/U5nvHFSHYuc=","text":"// !! WARN !! // Dangerously allow production builds to successfully complete even if\r\n    // your project has type errors. // !! WARN !! ignoreBuildErrors: true,\r\n  },\r\n}\r\nVersion Changes\r\nVersionChanges\r\nv13.2.0Statically typed links are available in beta. v12.0.0SWC is now used by default to compile TypeScript and TSX for faster builds. v10.2.1Incremental type checking support added when enabled in your tsconfig.json.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"de1d5401-c0c6-4d30-a8d3-759cbf5d7109":{"id_":"de1d5401-c0c6-4d30-a8d3-759cbf5d7109","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SKZr+QGHo9gtGjSzdXVuX6EofWzeG4/BrAqr6/YIIBE=","metadata":{},"hash":"zqg9n8dji3qJmbOZSdZqmCg0lxBeT+9WiLtcGAHfprs="},"NEXT":{"nodeId":"cd25e273-757b-4836-ada6-1ae0edf9e5c3","metadata":{},"hash":"+H30eAZqapaaIYva01IOWZ5gGz7qnDGrYF0eLC4ezVg="}},"hash":"bs1gnXTFH5LJD28Nv2NsQHrcpvzyaSoebZ7tjJLgHbo=","text":"3.1.7.2 - ESLint\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/02-eslint\r\nDescription: Next.js provides an integrated ESLint experience by default. These conformance rules help you use Next.js in an optimal\r\nway. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js provides an integrated ESLint experience out of the box. Add next lint as a script to package.json:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"lint\": \"next lint\"\r\n  }\r\n}\r\nThen run npm run lint or yarn lint:\r\nTerminal (bash)yarn lint\r\nIf you don’t already have ESLint configured in your application, you will be guided through the installation and configuration process. Terminal (bash)yarn lint\r\nYou’ll see a prompt like this:\r\n? How would you like to configure ESLint? \u0000 Strict (recommended)\r\nBase\r\nCancel\r\nOne of the following three options can be selected:\r\nStrict: Includes Next.js’ base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended\r\nconfiguration for developers setting up ESLint for the first time. .eslintrc.json (json)  {\r\n    \"extends\": \"next/core-web-vitals\"\r\n  }\r\nBase: Includes Next.js’ base ESLint configuration. .eslintrc.json (json)  {\r\n    \"extends\": \"next\"\r\n  }\r\nCancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint\r\nconfiguration. If either of the two configuration options are selected, Next.js will automatically install eslint and eslint-config-next as\r\ndependencies in your application and create an .eslintrc.json file in the root of your project that includes your selected\r\nconfiguration. You can now run next lint every time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically\r\nrun during every build (next build). Errors will fail the build, while warnings will not. If you do not want ESLint to run during next build, refer to the documentation for Ignoring ESLint.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cd25e273-757b-4836-ada6-1ae0edf9e5c3":{"id_":"cd25e273-757b-4836-ada6-1ae0edf9e5c3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SKZr+QGHo9gtGjSzdXVuX6EofWzeG4/BrAqr6/YIIBE=","metadata":{},"hash":"zqg9n8dji3qJmbOZSdZqmCg0lxBeT+9WiLtcGAHfprs="},"PREVIOUS":{"nodeId":"de1d5401-c0c6-4d30-a8d3-759cbf5d7109","metadata":{},"hash":"bs1gnXTFH5LJD28Nv2NsQHrcpvzyaSoebZ7tjJLgHbo="}},"hash":"+H30eAZqapaaIYva01IOWZ5gGz7qnDGrYF0eLC4ezVg=","text":"If you do not want ESLint to run during next build, refer to the documentation for Ignoring ESLint. We recommend using an appropriate integration to view warnings and errors directly in your code editor during development. ESLint Config","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"82bdc808-acb4-490c-8f37-736ad9b5fa64":{"id_":"82bdc808-acb4-490c-8f37-736ad9b5fa64","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mX72s6KbYM3UH0vd5AboFaFSQOlnU+cj31By9j11JBI=","metadata":{},"hash":"65QD5mHAgA9JXmZyWIi2pmAe4Q+31fRkitz50DM9IsI="},"NEXT":{"nodeId":"1b76d490-89d6-4502-bda2-b397da257d9c","metadata":{},"hash":"4leneQo9VHnGxC9xPnvjubx0iiOeJTpHNpkw87ix3qY="}},"hash":"0l8LmMKp2BDgFXS5XwBS3soVSsQLF6SWAbgjnZbhhUk=","text":"The default configuration (eslint-config-next) includes everything you need to have an optimal out-of-the-box linting experience in\r\nNext.js. If you do not have ESLint already configured in your application, we recommend using next lint to set up ESLint along with\r\nthis configuration. If you would like to use eslint-config-next along with other ESLint configurations, refer to the Additional Configurations\r\nsection to learn how to do so without causing any conflicts. Recommended rule-sets from the following ESLint plugins are all used within eslint-config-next:\r\neslint-plugin-react\r\neslint-plugin-react-hooks\r\neslint-plugin-next\r\nThis will take precedence over the configuration from next.config.js. ESLint Plugin\r\nNext.js provides an ESLint plugin, eslint-plugin-next, already bundled within the base configuration that makes it possible to catch\r\ncommon issues and problems in a Next.js application. The full set of rules is as follows:\r\nEnabled in the recommended configuration\r\nRuleDescription\r\n@next/next/google-font-displayEnforce font-display behavior with Google Fonts. @next/next/google-font-preconnectEnsure preconnect is used with Google Fonts. @next/next/inline-script-idEnforce id attribute on next/script components with inline content. @next/next/next-script-for-gaPrefer \r\nnext/script component when using the inline script for Google\r\nAnalytics. @next/next/no-assign-module-variablePrevent assignment to the module variable. @next/next/no-async-client-componentPrevent client components from being async functions. @next/next/no-before-interactive-script-outside-\r\ndocument\r\nPrevent usage of next/script’s beforeInteractive strategy outside of\r\npages/_document.js. @next/next/no-css-tagsPrevent manual stylesheet tags. @next/next/no-document-import-in-pagePrevent importing next/document outside of pages/_document.js. @next/next/no-duplicate-headPrevent duplicate usage of <Head> in pages/_document.js. @next/next/no-head-elementPrevent usage of <head> element. @next/next/no-head-import-in-documentPrevent usage of next/head in pages/_document.js. @next/next/no-html-link-for-pagesPrevent usage of <a> elements to navigate to internal Next.js pages. @next/next/no-img-elementPrevent usage of <img> element due to slower LCP and higher bandwidth.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1b76d490-89d6-4502-bda2-b397da257d9c":{"id_":"1b76d490-89d6-4502-bda2-b397da257d9c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mX72s6KbYM3UH0vd5AboFaFSQOlnU+cj31By9j11JBI=","metadata":{},"hash":"65QD5mHAgA9JXmZyWIi2pmAe4Q+31fRkitz50DM9IsI="},"PREVIOUS":{"nodeId":"82bdc808-acb4-490c-8f37-736ad9b5fa64","metadata":{},"hash":"0l8LmMKp2BDgFXS5XwBS3soVSsQLF6SWAbgjnZbhhUk="}},"hash":"4leneQo9VHnGxC9xPnvjubx0iiOeJTpHNpkw87ix3qY=","text":"@next/next/no-page-custom-fontPrevent page-only custom fonts. @next/next/no-script-component-in-headPrevent usage of next/script in next/head component. @next/next/no-styled-jsx-in-documentPrevent usage of styled-jsx in pages/_document.js. @next/next/no-sync-scriptsPrevent synchronous scripts. @next/next/no-title-in-document-headPrevent usage of <title> with Head component from next/document. @next/next/no-typosPrevent common typos in Next.js’s data fetching functions\r\n@next/next/no-unwanted-polyfillioPrevent duplicate polyfills from Polyfill.io. If you already have ESLint configured in your application, we recommend extending from this plugin directly instead of includingeslint-config-next\r\n unless a few conditions are met. Refer to the Recommended Plugin Ruleset to learn more. Custom Settings","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0ecb4485-bd0c-4a4b-a5cb-cf51a3d4af89":{"id_":"0ecb4485-bd0c-4a4b-a5cb-cf51a3d4af89","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EyJjQq0iFflXib3CEdDoWqWuMv9DA6E99/aP1ohdIyk=","metadata":{},"hash":"BNpKFDo0vMzTh4EaQekwN5Frx/TwZdyjGvsBW6xVcjs="},"NEXT":{"nodeId":"16757b4e-67d5-46f0-b2f9-1b30dc8052ea","metadata":{},"hash":"b8qyTRJtd3PeNRpwCvCqMkrSwyvbBjFtC8ic7Zbib1w="}},"hash":"M1aZ652APu4Tm9fXl4NQKZQGeMBri7pJ2l0ihq6f9Ps=","text":"rootDirrootDir\r\nIf you’re using eslint-plugin-next in a project where Next.js isn’t installed in your root directory (such as a monorepo), you can tell\r\neslint-plugin-next where to find your Next.js application using the settings property in your .eslintrc:\r\n.eslintrc.json (json){\r\n  \"extends\": \"next\",\r\n  \"settings\": {\r\n    \"next\": {\r\n      \"rootDir\": \"packages/my-app/\"\r\n    }\r\n  }\r\n}\r\nrootDir can be a path (relative or absolute), a glob (i.e. \"packages/*/\"), or an array of paths and/or globs. Linting Custom Directories and Files\r\nBy default, Next.js will run ESLint for all files in the pages/, app/, components/, lib/, and src/ directories. However, you can specify\r\nwhich directories using the dirs option in the eslint config in next.config.js for production builds:\r\nnext.config.js (js)module.exports = {\r\n  eslint: {\r\n    dirs: ['pages', 'utils'], // Only run ESLint on the 'pages' and 'utils' directories during production builds (next build)\r\n  },\r\n}\r\nSimilarly, the --dir and --file flags can be used for next lint to lint specific directories and files:\r\nTerminal (bash)next lint --dir pages --dir utils --file bar.js\r\nCaching\r\nTo improve performance, information of files processed by ESLint are cached by default. This is stored in .next/cache or in your\r\ndefined build directory. If you include any ESLint rules that depend on more than the contents of a single source file and need to disable\r\nthe cache, use the --no-cache flag with next lint. To improve performance, information of files processed by ESLint are cached by default. This is stored in .next/cache or in your\r\ndefined build directory. If you include any ESLint rules that depend on more than the contents of a single source file and need to disable\r\nthe cache, use the --no-cache flag with next lint.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"16757b4e-67d5-46f0-b2f9-1b30dc8052ea":{"id_":"16757b4e-67d5-46f0-b2f9-1b30dc8052ea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EyJjQq0iFflXib3CEdDoWqWuMv9DA6E99/aP1ohdIyk=","metadata":{},"hash":"BNpKFDo0vMzTh4EaQekwN5Frx/TwZdyjGvsBW6xVcjs="},"PREVIOUS":{"nodeId":"0ecb4485-bd0c-4a4b-a5cb-cf51a3d4af89","metadata":{},"hash":"M1aZ652APu4Tm9fXl4NQKZQGeMBri7pJ2l0ihq6f9Ps="}},"hash":"b8qyTRJtd3PeNRpwCvCqMkrSwyvbBjFtC8ic7Zbib1w=","text":"Terminal (bash)next lint --no-cache\r\nDisabling Rules\r\nIf you would like to modify or disable any rules provided by the supported plugins (react, react-hooks, next), you can directly\r\nchange them using the rules property in your .eslintrc:\r\n.eslintrc.json (json){\r\n  \"extends\": \"next\",\r\n  \"rules\": {\r\n    \"react/no-unescaped-entities\": \"off\",\r\n    \"@next/next/no-page-custom-font\": \"off\"\r\n  }\r\n}\r\nCore Web Vitals\r\nThe next/core-web-vitals rule set is enabled when next lint is run for the first time and the strict option is selected. .eslintrc.json (json){\r\n  \"extends\": \"next/core-web-vitals\"\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"882f7b35-c365-4167-beab-e864ffd215f3":{"id_":"882f7b35-c365-4167-beab-e864ffd215f3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QaMF5A8jtDF/2Hm8v939lxRnlnMhzKjFki87eWxYd0E=","metadata":{},"hash":"WdtbgDTQVeD6nk0CQTRDF5eaQanQCl7RZb5ZsZIf12I="}},"hash":"ckB9L3Kat4XRnrKMRuYMxosYfpgwT6lUKMbcsrnhers=","text":"next/core-web-vitals updates eslint-plugin-next to error on a number of rules that are warnings by default if they affect Core\r\nWeb Vitals. The next/core-web-vitals entry point is automatically included for new applications built with Create Next App. Usage With Other Tools\r\nPrettier\r\nESLint also contains code formatting rules, which can conflict with your existing Prettier setup. We recommend including eslint-config-\r\nprettier in your ESLint config to make ESLint and Prettier work together. First, install the dependency:\r\nTerminal (bash)npm install --save-dev eslint-config-prettier\r\nyarn add --dev eslint-config-prettier\r\npnpm add --save-dev eslint-config-prettier\r\nbun add --dev eslint-config-prettier\r\nThen, add prettier to your existing ESLint config:\r\n.eslintrc.json (json){\r\n  \"extends\": [\"next\", \"prettier\"]\r\n}\r\nlint-staged\r\nIf you would like to use next lint with lint-staged to run the linter on staged git files, you’ll have to add the following to the\r\n.lintstagedrc.js file in the root of your project in order to specify usage of the --file flag. .lintstagedrc.js (js)const path = require('path')\r\nconst buildEslintCommand = (filenames) =>\r\n  `next lint --fix --file ${filenames\r\n    .map((f) => path.relative(process.cwd(), f))\r\n    .join(' --file ')}`\r\nmodule.exports = {\r\n  '*.{js,jsx,ts,tsx}': [buildEslintCommand],\r\n}\r\nMigrating Existing Config\r\nRecommended Plugin Ruleset\r\nIf you already have ESLint configured in your application and any of the following conditions are true:\r\nYou have one or more of the following plugins already installed (either separately or through a different config such as airbnb or\r\nreact-app):\r\nreact\r\nreact-hooks\r\njsx-a11y\r\nimport\r\nYou’ve defined specific parserOptions that are different from how Babel is configured within Next.js (this is not recommended\r\nunless you have customized your Babel configuration)\r\nYou have eslint-plugin-import installed with Node.js and/or TypeScript resolvers defined to handle imports\r\nThen we recommend either removing these settings if you prefer how these properties have been configured within eslint-config-\r\nnext or extending directly from the Next.js ESLint plugin instead:\r\nmodule.exports = {\r\n  extends: [\r\n    //...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8cffb79b-2ac8-472f-b390-92543fefe791":{"id_":"8cffb79b-2ac8-472f-b390-92543fefe791","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/GZIAdEYVf1ezTHIf5SW7VRIIRq2d5iugCyHQTJ6zKw=","metadata":{},"hash":"/QYKHSgtQLKmUhdj+b7lC46Tvg4qZlFZb08tkdOnSG8="}},"hash":"W7FVkbgg8ioO689alTRlZ4Wdau/mLwbAlhZzcJ01rnw=","text":"'plugin:@next/next/recommended',\r\n  ],\r\n}\r\nThe plugin can be installed normally in your project without needing to run next lint:\r\nTerminal (bash)npm install --save-dev @next/eslint-plugin-next\r\nyarn add --dev @next/eslint-plugin-next\r\npnpm add --save-dev @next/eslint-plugin-next\r\nbun add --dev @next/eslint-plugin-next\r\nThis eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations. Additional Configurations\r\nIf you already use a separate ESLint configuration and want to include eslint-config-next, ensure that it is extended last after other\r\nconfigurations. For example:\r\n.eslintrc.json (json){\r\n  \"extends\": [\"eslint:recommended\", \"next\"]\r\n}\r\nThe next configuration already handles setting default values for the parser, plugins and settings properties. There is no need to\r\nmanually re-declare any of these properties unless you need a different configuration for your use case. If you include any other shareable configurations, you will need to make sure that these properties are not overwritten or\r\nmodified. Otherwise, we recommend removing any configurations that share behavior with the next configuration or extending\r\ndirectly from the Next.js ESLint plugin as mentioned above.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"537d1499-fa45-454d-9fa6-6b058f44933b":{"id_":"537d1499-fa45-454d-9fa6-6b058f44933b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ge7HWWtXrenAtnCL/sCR5zY4irOa/wUJqmxbpFK/PRc=","metadata":{},"hash":"00RjT7THb6Ry+BzntJXWGATH8PzEqFGSHKA3ye/B+VQ="},"NEXT":{"nodeId":"d8a2c85c-5ab8-4c47-94f3-62a3aa6ba3cf","metadata":{},"hash":"1abF5ODqLQULZddzVCwOdpDBRn3kOY1drqN0UbmM1LQ="}},"hash":"IUDuAonu0HONVElHcAxitxZ60ozEbJFe4eiF/y/NnuI=","text":"3.1.7.3 - Environment Variables\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/03-environment-variables\r\nDescription: Learn to add and access environment variables in your Next.js application. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\nNext.js comes with built-in support for environment variables, which allows you to do the following:\r\nUse .env.local to load environment variables\r\nBundle environment variables for the browser by prefixing with NEXT_PUBLIC_\r\nLoading Environment Variables\r\nNext.js has built-in support for loading environment variables from .env.local into process.env. .env.local (txt)DB_HOST=localhost\r\nDB_USER=myuser\r\nDB_PASS=mypassword\r\nThis loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically\r\nallowing you to use them in Next.js data fetching methods and API routes. For example, using getStaticProps:\r\npages/index.js (js)export async function getStaticProps() {\r\n  const db = await myDB.connect({\r\n    host: process.env.DB_HOST,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n  })\r\n  // ... }\r\nNote: Next.js also supports multiline variables inside of your .env* files:\r\n```bash.env.local\r\nyou can write with line breaks\r\nPRIVATE_KEY=”-----BEGIN RSA PRIVATE KEY----- ... Kh9NV... ... -----END DSA PRIVATE KEY-----“or with \r\n\\n\\n\r\n inside double quotes\r\nPRIVATE_KEY=”-----BEGIN RSA PRIVATE KEY-----\\nKh9NV...\\n-----END DSA PRIVATE KEY-----\\n” ```\r\nNote: If you are using a /src folder, please note that Next.js will load the .env files only from the parent folder and not from\r\nthe /src folder. This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js\r\nenvironment automatically allowing you to use them in Route Handlers.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d8a2c85c-5ab8-4c47-94f3-62a3aa6ba3cf":{"id_":"d8a2c85c-5ab8-4c47-94f3-62a3aa6ba3cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ge7HWWtXrenAtnCL/sCR5zY4irOa/wUJqmxbpFK/PRc=","metadata":{},"hash":"00RjT7THb6Ry+BzntJXWGATH8PzEqFGSHKA3ye/B+VQ="},"PREVIOUS":{"nodeId":"537d1499-fa45-454d-9fa6-6b058f44933b","metadata":{},"hash":"IUDuAonu0HONVElHcAxitxZ60ozEbJFe4eiF/y/NnuI="}},"hash":"1abF5ODqLQULZddzVCwOdpDBRn3kOY1drqN0UbmM1LQ=","text":"For example:\r\napp/api/route.js (js)export async function GET() {\r\n  const db = await myDB.connect({\r\n    host: process.env.DB_HOST,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n  })\r\n  // ... }\r\nReferencing Other Variables","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"509cd770-5c3f-46eb-b321-7a0b12d96942":{"id_":"509cd770-5c3f-46eb-b321-7a0b12d96942","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9F+X+vicK8ScO3uJaaOzjVxqnmxId1ITeo+CPDT63uM=","metadata":{},"hash":"Ip2EpnToOuiASIkjzAa5iIRGYTX+CdnXosc4K+Mi/vU="},"NEXT":{"nodeId":"d5bfc9e0-dacc-4e2e-adbc-2b7ab155134b","metadata":{},"hash":"tH+CaSrLCCgAlraGBjf95SjIvQdzbG5ZfvA+TcgvKSY="}},"hash":"8EYzc6mBUec0fj1f/2SbKiRQbQYin7r3rxEtnvRvsb0=","text":"Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This\r\nallows you to reference other secrets. For example:\r\n.env (txt)TWITTER_USER=nextjs\r\nTWITTER_URL=https://twitter.com/$TWITTER_USER\r\nIn the above example, process.env.TWITTER_URL would be set to https://twitter.com/nextjs. Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$. Bundling Environment Variables for the Browser\r\nNon-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren’t accessible to the\r\nbrowser (the client runs in a different environment). In order to make the value of an environment variable accessible in the browser, Next.js can “inline” a value, at build time, into the js\r\nbundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do\r\nthis, you just have to prefix the variable with NEXT_PUBLIC_. For example:\r\nTerminal (txt)NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk\r\nThis will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the\r\nvalue from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any\r\nJavaScript sent to the browser. Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a\r\nHeroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker\r\nimage to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these\r\nvalues need to be set appropriately when the project is built. If you need access to runtime environment values, you’ll have to\r\nsetup your own API to provide them to the client (either on demand or during initialization). pages/index.js (js)import setupAnalyticsService from '../lib/my-analytics-service'\r\n// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'. // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d5bfc9e0-dacc-4e2e-adbc-2b7ab155134b":{"id_":"d5bfc9e0-dacc-4e2e-adbc-2b7ab155134b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9F+X+vicK8ScO3uJaaOzjVxqnmxId1ITeo+CPDT63uM=","metadata":{},"hash":"Ip2EpnToOuiASIkjzAa5iIRGYTX+CdnXosc4K+Mi/vU="},"PREVIOUS":{"nodeId":"509cd770-5c3f-46eb-b321-7a0b12d96942","metadata":{},"hash":"8EYzc6mBUec0fj1f/2SbKiRQbQYin7r3rxEtnvRvsb0="}},"hash":"tH+CaSrLCCgAlraGBjf95SjIvQdzbG5ZfvA+TcgvKSY=","text":"// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)\r\nfunction HomePage() {\r\n  return <h1>Hello World</h1>\r\n}\r\nexport default HomePage\r\nNote that dynamic lookups will not be inlined, such as:\r\n// This will NOT be inlined, because it uses a variable\r\nconst varName = 'NEXT_PUBLIC_ANALYTICS_ID'\r\nsetupAnalyticsService(process.env[varName])\r\n// This will NOT be inlined, because it uses a variable\r\nconst env = process.env\r\nsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)\r\nRuntime Environment Variables\r\nNext.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be\r\nprefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next\r\nbuild. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. With\r\nthe App Router, we can safely read environment variables on the server during dynamic rendering. This allows you to use a singular\r\nDocker image that can be promoted through multiple environments with different values. import { unstable_noStore as noStore } from 'next/cache'\r\nexport default function Component() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5346ce03-be77-4bac-8fb1-826dee934055":{"id_":"5346ce03-be77-4bac-8fb1-826dee934055","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6VBf8ZPEE6UYfmqy+wlPFyAN0nrTTBL8mdMHXQyVn0A=","metadata":{},"hash":"SmCnRmNSEpTGamrvzuykh2yyb/T3xdKKhUTWENOP4K4="},"NEXT":{"nodeId":"89ce7bec-5ff3-4dd6-b067-5ee1e255e50f","metadata":{},"hash":"Ey4vlAMaVUaue8xXspwf88SP6CaK6NpXU3Oai8H/m9M="}},"hash":"C8+iVUftd8PSSUqcwRMcUoW6xmjXG6bTrdS5+IuojlQ=","text":"noStore()\r\n  // cookies(), headers(), and other dynamic functions\r\n  // will also opt into dynamic rendering, making\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  // ... }\r\nGood to know:\r\nYou can run code on server startup using the register function. We do not recommend using the runtimeConfig option, as this does not work with the standalone output mode. Instead, we\r\nrecommend incrementally adopting the App Router. Default Environment Variables\r\nIn general only one .env.local file is needed. However, sometimes you might want to add some defaults for the development (next\r\ndev) or production (next start) environment. Next.js allows you to set defaults in .env (all environments), .env.development (development environment), and .env.production\r\n(production environment). .env.local always overrides the defaults set. Good to know: .env, .env.development, and .env.production files should be included in your repository as they define\r\ndefaults. .env*.local.env*.local should be added to .gitignore.gitignore, as those files are intended to be ignored. .env.local is where\r\nsecrets can be stored. Environment Variables on Vercel\r\nWhen deploying your Next.js application to Vercel, Environment Variables can be configured in the Project Settings. All types of Environment Variables should be configured there. Even Environment Variables used in Development – which can be\r\ndownloaded onto your local device afterwards. If you’ve configured Development Environment Variables you can pull them into a .env.local for usage on your local machine using\r\nthe following command:\r\nTerminal (bash)vercel env pull .env.local\r\nGood to know: When deploying your Next.js application to Vercel, your environment variables in .env* files will not be made\r\navailable to Edge Runtime, unless their name are prefixed with NEXT_PUBLIC_. We strongly recommend managing your\r\nenvironment variables in Project Settings instead, from where all environment variables are available. Test Environment Variables\r\nApart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults\r\nfor development or production environments, you can do the same with a .env.test file for the testing environment (though this\r\none is not as common as the previous two). Next.js will not load environment variables from .env.development or\r\n.env.production in the testing environment.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"89ce7bec-5ff3-4dd6-b067-5ee1e255e50f":{"id_":"89ce7bec-5ff3-4dd6-b067-5ee1e255e50f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6VBf8ZPEE6UYfmqy+wlPFyAN0nrTTBL8mdMHXQyVn0A=","metadata":{},"hash":"SmCnRmNSEpTGamrvzuykh2yyb/T3xdKKhUTWENOP4K4="},"PREVIOUS":{"nodeId":"5346ce03-be77-4bac-8fb1-826dee934055","metadata":{},"hash":"C8+iVUftd8PSSUqcwRMcUoW6xmjXG6bTrdS5+IuojlQ="}},"hash":"Ey4vlAMaVUaue8xXspwf88SP6CaK6NpXU3Oai8H/m9M=","text":"This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing\r\npurposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don’t need to do this manually as testing\r\ntools will address it for you. There is a small difference between test environment, and both development and production that you need to bear in mind:\r\n.env.local won’t be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the\r\nsame env defaults across different executions by ignoring your .env.local (which is intended to override the default set). Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but.env.test.local\r\n shouldn’t, as .env*.local are intended to be ignored through .gitignore. While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging theloadEnvConfig\r\n function from the @next/env package. // The below can be used in a Jest global setup file or similar for your testing set-up\r\nimport { loadEnvConfig } from '@next/env'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bdfc153f-2756-4147-ab74-e12ed7b36c8a":{"id_":"bdfc153f-2756-4147-ab74-e12ed7b36c8a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R1YSxhlbmvJawY01fzTYbuc248Wv3Allm0A6NS6AaQE=","metadata":{},"hash":"Qa/9B3gx8tiOjOXUEBen75t+miBhmBGNil3d0RlH9Zs="}},"hash":"gGT76gq7pnRuOCVizlvEvUsdtLvTnIlSjeabUZ+IOtQ=","text":"export default async () => {\r\n  const projectDir = process.cwd()\r\n  loadEnvConfig(projectDir)\r\n}\r\nEnvironment Variable Load Order\r\nEnvironment variables are looked up in the following places, in order, stopping once the variable is found. 1. process.env\r\n2. .env.$(NODE_ENV).local\r\n3. .env.local (Not checked when NODE_ENV is test. )\r\n4. .env.$(NODE_ENV)\r\n5. .env\r\nFor example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in\r\n.env.development.local will be used. Good to know: The allowed values for NODE_ENV are production, development and test. Good to know\r\nIf you are using a /src directory, .env.* files should remain in the root of your project. If the environment variable NODE_ENV is unassigned, Next.js automatically assigns development when running the next dev\r\ncommand, or production for all other commands. Version History\r\nVersionChanges\r\nv9.4.0Support .env and NEXT_PUBLIC_ introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ec25285b-0860-492e-aea0-a45a3fa1b6f2":{"id_":"ec25285b-0860-492e-aea0-a45a3fa1b6f2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dDuXmd2itnaptDRrNrXc7grmEqrny8h7xKlOKnWPVco=","metadata":{},"hash":"GUlhZkemi1l+dX/MQnOj/FPaKcoUTF6NIrBLhDhWo20="}},"hash":"j0miWEkZ2SP7U85YDMNZ+U5WalSrrPqnjFsNZ+c/lkU=","text":"3.1.7.4 - Absolute Imports and Module Path Aliases\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/04-absolute-imports-and-module-aliases\r\nDescription: Configure module path aliases that allow you to remap certain import paths. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\nNext.js has in-built support for the \"paths\" and \"baseUrl\" options of tsconfig.json and jsconfig.json files. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:\r\n// before\r\nimport { Button } from '../../../components/button'\r\n// after\r\nimport { Button } from '@/components/button'\r\nGood to know: create-next-app will prompt to configure these options for you. Absolute Imports\r\nThe baseUrl configuration option allows you to import directly from the root of the project. An example of this configuration:\r\ntsconfig.json or jsconfig.json (json){\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \". \"\r\n  }\r\n}\r\ncomponents/button.tsx (tsx)export default function Button() {\r\n  return <button>Click me</button>\r\n}\r\ncomponents/button.js (jsx)export default function Button() {\r\n  return <button>Click me</button>\r\n}\r\napp/page.tsx (tsx)import Button from 'components/button'\r\nexport default function HomePage() {\r\n  return (\r\n    <>\r\n      <h1>Hello World</h1>\r\n      <Button />\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import Button from 'components/button'\r\nexport default function HomePage() {\r\n  return (\r\n    <>\r\n      <h1>Hello World</h1>\r\n      <Button />\r\n    </>\r\n  )\r\n}\r\nModule Aliases","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2d08c571-c97d-491c-99ce-ee4a1d3943c3":{"id_":"2d08c571-c97d-491c-99ce-ee4a1d3943c3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Go0mHmEiCemksoAhrt511nrrcl/qzRGQce+qDAVMzrE=","metadata":{},"hash":"qjCb8ImxaT/Gs+jMujYAm3lYWYWS8fgTZgCGHr5AnW0="}},"hash":"tC35ENJm73wYV8X0s3+/sx1X7nDpqqKFZi3rsMD1OrY=","text":"In addition to configuring the baseUrl path, you can use the \"paths\" option to “alias” module paths. For example, the following configuration maps @/components/* to components/*:\r\ntsconfig.json or jsconfig.json (json){\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@/components/*\": [\"components/*\"]\r\n    }\r\n  }\r\n}\r\ncomponents/button.tsx (tsx)export default function Button() {\r\n  return <button>Click me</button>\r\n}\r\ncomponents/button.js (jsx)export default function Button() {\r\n  return <button>Click me</button>\r\n}\r\napp/page.tsx (tsx)import Button from '@/components/button'\r\nexport default function HomePage() {\r\n  return (\r\n    <>\r\n      <h1>Hello World</h1>\r\n      <Button />\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import Button from '@/components/button'\r\nexport default function HomePage() {\r\n  return (\r\n    <>\r\n      <h1>Hello World</h1>\r\n      <Button />\r\n    </>\r\n  )\r\n}\r\nEach of the \"paths\" are relative to the baseUrl location. For example:\r\n// tsconfig.json or jsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"src/\",\r\n    \"paths\": {\r\n      \"@/styles/*\": [\"styles/*\"],\r\n      \"@/components/*\": [\"components/*\"]\r\n    }\r\n  }\r\n}\r\n// pages/index.js\r\nimport Button from '@/components/button'\r\nimport '@/styles/styles.css'\r\nimport Helper from 'utils/helper'\r\nexport default function HomePage() {\r\n  return (\r\n    <Helper>\r\n      <h1>Hello World</h1>\r\n      <Button />\r\n    </Helper>\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"94767987-d111-49f6-b4b1-5a1ad792dd36":{"id_":"94767987-d111-49f6-b4b1-5a1ad792dd36","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"P1iz8xTrGApTI91ET0RwaZhAD6M8IMH3TIqyUXFsI6k=","metadata":{},"hash":"lsXrvbR+KkvYQ5U3R1Ly05JXZ6lLnylKZGYZc3doZCQ="}},"hash":"1o6pEvNv4EgtoUgbYSQeQ2z1iBpJv3POZKBf5jDDO20=","text":"}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"98693d15-4fb4-4a22-b03f-c89da86796f5":{"id_":"98693d15-4fb4-4a22-b03f-c89da86796f5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"VNruXIReAy1escCHIAWLKJ2IuF5fzsO9NOOl7ylNYZI=","metadata":{},"hash":"P8AFUzA1qpKUkAvJpl9WfUIeyU1eoM9kuATW1P4l/l8="},"NEXT":{"nodeId":"29b74f68-c516-4a26-8bda-d58bf0180fa1","metadata":{},"hash":"gx51tl8dcvsQdWmxWP9flwLZexH60sLCCl8fx7OpO8U="}},"hash":"S5FCT8+sFbinUEv0wtTozO9/S+GiK62W8/Ui86TuxUM=","text":"3.1.7.5 - Markdown and MDX\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/05-mdx\r\nDescription: Learn how to configure MDX to write JSX in your markdown files. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nMarkdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to\r\nstructurally valid HTML. It’s commonly used for writing content on websites and blogs. You write... I **love** using [Next.js](https://nextjs.org/)\r\nOutput:\r\n<p>I <strong>love</strong> using <a href=\"https://nextjs.org/\">Next.js</a></p>\r\nMDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity\r\nand embed React components within your content. Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The\r\nNext.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components\r\n(the default in App Router).@next/mdx@next/mdx\r\nThe @next/mdx package is used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing\r\nyou to create pages with a .mdx extension, directly in your /pages or /app directory. Let’s walk through how to configure and use MDX with Next.js. Getting Started\r\nInstall packages needed to render MDX:\r\nTerminal (bash)npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx\r\nCreate a mdx-components.tsx file at the root of your application (the parent folder of app/ or src/):\r\nGood to know: mdx-components.tsx is required to use MDX with App Router and will not work without it.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"29b74f68-c516-4a26-8bda-d58bf0180fa1":{"id_":"29b74f68-c516-4a26-8bda-d58bf0180fa1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"VNruXIReAy1escCHIAWLKJ2IuF5fzsO9NOOl7ylNYZI=","metadata":{},"hash":"P8AFUzA1qpKUkAvJpl9WfUIeyU1eoM9kuATW1P4l/l8="},"PREVIOUS":{"nodeId":"98693d15-4fb4-4a22-b03f-c89da86796f5","metadata":{},"hash":"S5FCT8+sFbinUEv0wtTozO9/S+GiK62W8/Ui86TuxUM="}},"hash":"gx51tl8dcvsQdWmxWP9flwLZexH60sLCCl8fx7OpO8U=","text":"mdx-components.tsx (tsx)import type { MDXComponents } from 'mdx/types'\r\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\r\n  return {\r\n    ...components,\r\n  }\r\n}\r\nmdx-components.js (js)export function useMDXComponents(components) {\r\n  return {\r\n    ...components,\r\n  }\r\n}\r\nUpdate the next.config.js file at your project’s root to configure it to use MDX:\r\nnext.config.js (js)const withMDX = require('@next/mdx')()\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Configure `pageExtensions` to include MDX files\r\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"365e80f7-9829-427f-8e4c-eef2240793df":{"id_":"365e80f7-9829-427f-8e4c-eef2240793df","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uuM7yX+T+dACc/yNkHCg4g5wfkEiaC9Npfr65IEpmj8=","metadata":{},"hash":"t/aFfieOQVkFsLG4i8FCkaJ+ySk4c1IiSzWVNiXjv8g="},"NEXT":{"nodeId":"b73ff9a9-c641-406b-9d33-fec4f1978771","metadata":{},"hash":"TC3Ih9QonF65z0ox+AczlGEEEHSWcLRENVpepwAb2mI="}},"hash":"Nenm2nxeplWEZQWo7NARjbi2WezV+7dq/lK9pERSkEA=","text":"// Optionally, add any other Next.js config below\r\n}\r\nmodule.exports = withMDX(nextConfig)\r\nThen, create a new MDX page within the /app directory:\r\n  your-project\r\n  ├── app\r\n  │   └── my-mdx-page\r\n  │       └── page.mdx\r\n  └── package.json\r\nThen, create a new MDX page within the /pages directory:\r\n  your-project\r\n  ├── pages\r\n  │   └── my-mdx-page.mdx\r\n  └── package.json\r\nNow you can use markdown and import React components directly inside your MDX page:\r\nimport { MyComponent } from 'my-components'\r\n# Welcome to my MDX page! This is some **bold** and _italics_ text. This is a list in markdown:\r\n- One\r\n- Two\r\n- Three\r\nCheckout my React component:\r\n<MyComponent />\r\nNavigating to the /my-mdx-page route should display your rendered MDX. Remote MDX\r\nIf your markdown or MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content\r\nstored in a separate local folder, CMS, database, or anywhere else. A popular community packages for this use is next-mdx-remote. Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch\r\nMDX content from a trusted source, otherwise this can lead to remote code execution (RCE). The following example uses next-mdx-remote:\r\napp/my-mdx-page-remote/page.tsx (tsx)import { MDXRemote } from 'next-mdx-remote/rsc'\r\nexport default async function RemoteMdxPage() {\r\n  // MDX text - can be from a local file, database, CMS, fetch, anywhere... const res = await fetch('https://... ')\r\n  const markdown = await res.text()\r\n  return <MDXRemote source={markdown} />\r\n}\r\napp/my-mdx-page-remote/page.js (jsx)import { MDXRemote } from 'next-mdx-remote/rsc'\r\nexport default async function RemoteMdxPage() {\r\n  // MDX text - can be from a local file, database, CMS, fetch, anywhere... const res = await fetch('https://...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b73ff9a9-c641-406b-9d33-fec4f1978771":{"id_":"b73ff9a9-c641-406b-9d33-fec4f1978771","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uuM7yX+T+dACc/yNkHCg4g5wfkEiaC9Npfr65IEpmj8=","metadata":{},"hash":"t/aFfieOQVkFsLG4i8FCkaJ+ySk4c1IiSzWVNiXjv8g="},"PREVIOUS":{"nodeId":"365e80f7-9829-427f-8e4c-eef2240793df","metadata":{},"hash":"Nenm2nxeplWEZQWo7NARjbi2WezV+7dq/lK9pERSkEA="}},"hash":"TC3Ih9QonF65z0ox+AczlGEEEHSWcLRENVpepwAb2mI=","text":"const res = await fetch('https://... ')\r\n  const markdown = await res.text()\r\n  return <MDXRemote source={markdown} />\r\n}\r\npages/my-mdx-page-remote.tsx (tsx)import { serialize } from 'next-mdx-remote/serialize'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"332b7158-f7c9-47d1-97b1-a6d93b8a9c24":{"id_":"332b7158-f7c9-47d1-97b1-a6d93b8a9c24","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pMhTWQ7op8dpcLeQl3IMn+pQ3mwSyvX1tyEXL5daTDY=","metadata":{},"hash":"MWv3NOUbu05iVNwJ1UeL9XVus8qqIxgF/MeUkD72yps="},"NEXT":{"nodeId":"97e7e72d-6a22-4429-8d9e-abfa58d0f2ee","metadata":{},"hash":"4Fu0B1q3fwttBqrPD1D+fl5DcNjoLQfQGr5lJWzrCNA="}},"hash":"uYl0Z+aXambFpikWLXXHVBpWJLb1oW30/CjCgRNHOh0=","text":"import { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\r\ninterface Props {\r\n  mdxSource: MDXRemoteSerializeResult\r\n}\r\nexport default function RemoteMdxPage({ mdxSource }: Props) {\r\n  return <MDXRemote {...mdxSource} />\r\n}\r\nexport async function getStaticProps() {\r\n  // MDX text - can be from a local file, database, CMS, fetch, anywhere... const res = await fetch('https:... ')\r\n  const mdxText = await res.text()\r\n  const mdxSource = await serialize(mdxText)\r\n  return { props: { mdxSource } }\r\n}\r\npages/my-mdx-page-remote.js (jsx)import { serialize } from 'next-mdx-remote/serialize'\r\nimport { MDXRemote } from 'next-mdx-remote'\r\nexport default function RemoteMdxPage({ mdxSource }) {\r\n  return <MDXRemote {...mdxSource} />\r\n}\r\nexport async function getStaticProps() {\r\n  // MDX text - can be from a local file, database, CMS, fetch, anywhere... const res = await fetch('https:... ')\r\n  const mdxText = await res.text()\r\n  const mdxSource = await serialize(mdxText)\r\n  return { props: { mdxSource } }\r\n}\r\nNavigating to the /my-mdx-page-remote route should display your rendered MDX. Layouts\r\nTo share a layout amongst MDX pages, you can use the built-in layouts support with the App Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"97e7e72d-6a22-4429-8d9e-abfa58d0f2ee":{"id_":"97e7e72d-6a22-4429-8d9e-abfa58d0f2ee","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pMhTWQ7op8dpcLeQl3IMn+pQ3mwSyvX1tyEXL5daTDY=","metadata":{},"hash":"MWv3NOUbu05iVNwJ1UeL9XVus8qqIxgF/MeUkD72yps="},"PREVIOUS":{"nodeId":"332b7158-f7c9-47d1-97b1-a6d93b8a9c24","metadata":{},"hash":"uYl0Z+aXambFpikWLXXHVBpWJLb1oW30/CjCgRNHOh0="}},"hash":"4Fu0B1q3fwttBqrPD1D+fl5DcNjoLQfQGr5lJWzrCNA=","text":"app/my-mdx-page/layout.tsx (tsx)export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}\r\napp/my-mdx-page/layout.js (jsx)export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}\r\nTo share a layout around MDX pages, create a layout component:\r\ncomponents/mdx-layout.tsx (tsx)export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}\r\ncomponents/mdx-layout.js (jsx)export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}\r\nThen, import the layout component into the MDX page, wrap the MDX content in the layout, and export it:\r\nimport MdxLayout from '../components/mdx-layout'\r\n# Welcome to my MDX page!","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1925eb97-8b0e-4572-b92a-db57c27468f4":{"id_":"1925eb97-8b0e-4572-b92a-db57c27468f4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Yq6xDo708HfG7J/KK6V4tKj78jP6iLprmR4OFnAjwEQ=","metadata":{},"hash":"9zxDqUoLN5/xga2uBtGSohnEBjl9Fmwf5oBzGBdn3wo="}},"hash":"E3elJc/vPoGjMGOWNy8t0qDsj6CqmbsVXkprW59ytXc=","text":"export default function MDXPage({ children }) {\r\n  return <MdxLayout>{children}</MdxLayout>;\r\n}\r\nRemark and Rehype Plugins\r\nYou can optionally provide remark and rehype plugins to transform the MDX content. For example, you can use remark-gfm to support GitHub Flavored Markdown. Since the remark and rehype ecosystem is ESM only, you’ll need to use next.config.mjs as the configuration file. next.config.mjs (js)import remarkGfm from 'remark-gfm'\r\nimport createMDX from '@next/mdx'\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Configure `pageExtensions`` to include MDX files\r\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],\r\n  // Optionally, add any other Next.js config below\r\n}\r\nconst withMDX = createMDX({\r\n  // Add markdown plugins here, as desired\r\n  options: {\r\n    remarkPlugins: [remarkGfm],\r\n    rehypePlugins: [],\r\n  },\r\n})\r\n// Merge MDX config with Next.js config\r\nexport default withMDX(nextConfig)\r\nFrontmatter\r\nFrontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by\r\ndefault, though there are many solutions for adding frontmatter to your MDX content, such as:\r\nremark-frontmatter\r\nremark-mdx-frontmatter\r\ngray-matter. To access page metadata with @next/mdx, you can export a metadata object from within the .mdx file:\r\nexport const metadata = {\r\n  author: 'John Doe',\r\n}\r\n# My MDX page\r\nCustom Elements\r\nOne of the pleasant aspects of using markdown, is that it maps to native HTML elements, making writing fast, and intuitive:\r\nThis is a list in markdown:\r\n- One\r\n- Two\r\n- Three\r\nThe above generates the following HTML:\r\n<p>This is a list in markdown:</p>\r\n<ul>\r\n  <li>One</li>\r\n  <li>Two</li>\r\n  <li>Three</li>\r\n</ul>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a4083e04-9ace-4bda-8255-a5b26c681431":{"id_":"a4083e04-9ace-4bda-8255-a5b26c681431","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lL3nDeB+WB0xPYAHIj/mXJoqac007odxtJdUUuWbONQ=","metadata":{},"hash":"9Ez9kK8//MzldsAyMXJoBSzR8i9efGn73iAcRpbZiss="},"NEXT":{"nodeId":"139bcf85-e520-46f6-848a-af71dc32eec6","metadata":{},"hash":"xx87wKZG+YyrldfQVopP8WX+0QIULdvmfOjHYiMbyxo="}},"hash":"XvrYQyv89JRhFRXMT+bdpvCvVVpIFQT70Vp/SgEAUeU=","text":"When you want to style your own elements for a custom feel to your website or application, you can pass in shortcodes. These are your\r\nown custom components that map to HTML elements. To do this, open the mdx-components.tsx file at the root of your application and add custom elements:\r\nTo do this, create a mdx-components.tsx file at the root of your application (the parent folder of pages/ or src/) and add custom\r\nelements:\r\nmdx-components.tsx (tsx)import type { MDXComponents } from 'mdx/types'\r\nimport Image, { ImageProps } from 'next/image'\r\n// This file allows you to provide custom React components\r\n// to be used in MDX files. You can import and use any\r\n// React component you want, including inline styles,\r\n// components from other libraries, and more. export function useMDXComponents(components: MDXComponents): MDXComponents {\r\n  return {\r\n    // Allows customizing built-in components, e.g. to add styling. h1: ({ children }) => <h1 style={{ fontSize: '100px' }}>{children}</h1>,\r\n    img: (props) => (\r\n      <Image\r\n        sizes=\"100vw\"\r\n        style={{ width: '100%', height: 'auto' }}\r\n        {...(props as ImageProps)}\r\n      />\r\n    ),\r\n    ...components,\r\n  }\r\n}\r\nmdx-components.js (js)import Image from 'next/image'\r\n// This file allows you to provide custom React components\r\n// to be used in MDX files. You can import and use any\r\n// React component you want, including inline styles,\r\n// components from other libraries, and more. export function useMDXComponents(components) {\r\n  return {\r\n    // Allows customizing built-in components, e.g. to add styling. h1: ({ children }) => <h1 style={{ fontSize: '100px' }}>{children}</h1>,\r\n    img: (props) => (\r\n      <Image\r\n        sizes=\"100vw\"\r\n        style={{ width: '100%', height: 'auto' }}\r\n        {...props}\r\n      />\r\n    ),\r\n    ...components,\r\n  }\r\n}\r\nDeep Dive: How do you transform markdown into HTML? React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be\r\naccomplished with remark and rehype. remark is an ecosystem of tools around markdown.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"139bcf85-e520-46f6-848a-af71dc32eec6":{"id_":"139bcf85-e520-46f6-848a-af71dc32eec6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lL3nDeB+WB0xPYAHIj/mXJoqac007odxtJdUUuWbONQ=","metadata":{},"hash":"9Ez9kK8//MzldsAyMXJoBSzR8i9efGn73iAcRpbZiss="},"PREVIOUS":{"nodeId":"a4083e04-9ace-4bda-8255-a5b26c681431","metadata":{},"hash":"XvrYQyv89JRhFRXMT+bdpvCvVVpIFQT70Vp/SgEAUeU="}},"hash":"xx87wKZG+YyrldfQVopP8WX+0QIULdvmfOjHYiMbyxo=","text":"remark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet\r\ntransforms markdown into HTML:\r\nimport { unified } from 'unified'\r\nimport remarkParse from 'remark-parse'\r\nimport remarkRehype from 'remark-rehype'\r\nimport rehypeSanitize from 'rehype-sanitize'\r\nimport rehypeStringify from 'rehype-stringify'\r\nmain()\r\nasync function main() {\r\n  const file = await unified()\r\n    .use(remarkParse) // Convert into markdown AST\r\n    .use(remarkRehype) // Transform to HTML AST","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"07c1f8be-b416-4168-8718-4c7ce0245ec0":{"id_":"07c1f8be-b416-4168-8718-4c7ce0245ec0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nWl09P+ocfQcsn49bqkNkSiQDjWWsIubvoK5YDUccpk=","metadata":{},"hash":"BxvhKvUfkKFjNmI1puYONQzMGJYwucbIixHbh4uVPFI="}},"hash":"PvaAkEqcs04rquskqpqHvHutw/qmwHGgLtH9QqVIF6Y=","text":".use(rehypeSanitize) // Sanitize HTML input\r\n    .use(rehypeStringify) // Convert AST into serialized HTML\r\n    .process('Hello, Next.js! ')\r\n  console.log(String(file)) // <p>Hello, Next.js!</p>\r\n}\r\nThe remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more. When using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We’re describing\r\nit here for a deeper understanding of what the @next/mdx package is doing underneath. Using the Rust-based MDX compiler (Experimental)\r\nNext.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX:\r\nnext.config.js (js)module.exports = withMDX({\r\n  experimental: {\r\n    mdxRs: true,\r\n  },\r\n})\r\nHelpful Links\r\nMDX@next/mdx\r\nremark\r\nrehype","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ebdbf71b-808b-4f76-8b0f-c9e6a51c4522":{"id_":"ebdbf71b-808b-4f76-8b0f-c9e6a51c4522","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pewK80OaPqCJ5duJcggjPygPxlkuW95/RDkPuVZ85ps=","metadata":{},"hash":"v902GVg0jLXng+N53hfcz2effwpAqqjImVE1nsyb6Hc="}},"hash":"n5zfHzhJa4Ocm4qZv1fxJCC3Wqzjs7kUDeGWBzWBD+4=","text":"3.1.7.6 - src Directory\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/06-src-directory\r\nDescription: Save pages under the `src` directory as an alternative to the root `pages` directory. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/building-your-application/routing/colocation\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nAs an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common\r\npattern of placing application code under the src directory. This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some\r\nindividuals and teams. To use the src directory, move the app Router folder or pages Router folder to src/app or src/pages respectively. Good to know\r\nThe /public directory should remain in the root of your project. Config files like package.json, next.config.js and tsconfig.json should remain in the root of your project. .env.* files should remain in the root of your project. src/app or src/pages will be ignored if app or pages are present in the root directory. If you’re using src, you’ll probably also move other application folders such as /components or /lib. If you’re using Middleware, ensure it is placed inside the src directory. If you’re using Tailwind CSS, you’ll need to add the /src prefix to the tailwind.config.js file in the content section.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e31595ae-9a93-4d94-8d00-d50d089901fd":{"id_":"e31595ae-9a93-4d94-8d00-d50d089901fd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3wAHgJsmg+e2wENFuiRit66WZeeZ4h//NmqO7nOR7nY=","metadata":{},"hash":"2DYsygWtYjQ98cEzJdqOWnv7FzqFTDyENRt/cCEGw7I="},"NEXT":{"nodeId":"6d7ecb9d-092f-421f-9e08-92810789d84f","metadata":{},"hash":"jkNJspNDvqHgfidfPYkn9xqwHtQzx63eAWumg3uh45k="}},"hash":"3vx2ppYZ8fMC53f/pBKSNDMHxCWBcmNqpS3n7ShaKUE=","text":"3.1.7.7 - Draft Mode\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/11-draft-mode\r\nDescription: Next.js has draft mode to toggle between static and dynamic pages. You can learn how it works with App Router here. Static rendering is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your\r\nheadless CMS and want to view the draft immediately on your page. You’d want Next.js to render these pages at request time instead\r\nof build time and fetch the draft content instead of the published content. You’d want Next.js to switch to dynamic rendering only for\r\nthis specific case. Next.js has a feature called Draft Mode which solves this problem. Here are instructions on how to use it. Step 1: Create and access the Route Handler\r\nFirst, create a Route Handler. It can have any name - e.g. app/api/draft/route.ts\r\nThen, import draftMode from next/headers and call the enable() method. app/api/draft/route.ts (ts)// route handler enabling draft mode\r\nimport { draftMode } from 'next/headers'\r\nexport async function GET(request: Request) {\r\n  draftMode().enable()\r\n  return new Response('Draft mode is enabled')\r\n}\r\napp/api/draft/route.js (js)// route handler enabling draft mode\r\nimport { draftMode } from 'next/headers'\r\nexport async function GET(request) {\r\n  draftMode().enable()\r\n  return new Response('Draft mode is enabled')\r\n}\r\nThis will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger Draft Mode changing the behavior\r\nfor statically generated pages (more on this later). You can test this manually by visiting /api/draft and looking at your browser’s developer tools. Notice the Set-Cookie response\r\nheader with a cookie named __prerender_bypass. Securely accessing it from your Headless CMS\r\nIn practice, you’d want to call this Route Handler securely from your headless CMS. The specific steps will vary depending on which\r\nheadless CMS you’re using, but here are some common steps you could take. These steps assume that the headless CMS you’re using supports setting custom draft URLs.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6d7ecb9d-092f-421f-9e08-92810789d84f":{"id_":"6d7ecb9d-092f-421f-9e08-92810789d84f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3wAHgJsmg+e2wENFuiRit66WZeeZ4h//NmqO7nOR7nY=","metadata":{},"hash":"2DYsygWtYjQ98cEzJdqOWnv7FzqFTDyENRt/cCEGw7I="},"PREVIOUS":{"nodeId":"e31595ae-9a93-4d94-8d00-d50d089901fd","metadata":{},"hash":"3vx2ppYZ8fMC53f/pBKSNDMHxCWBcmNqpS3n7ShaKUE="}},"hash":"jkNJspNDvqHgfidfPYkn9xqwHtQzx63eAWumg3uh45k=","text":"These steps assume that the headless CMS you’re using supports setting custom draft URLs. If it doesn’t, you can still use this method\r\nto secure your draft URLs, but you’ll need to construct and access the draft URL manually. First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js\r\napp and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing draft URLs. Second, if your headless CMS supports setting custom draft URLs, specify the following as the draft URL. This assumes that your Route\r\nHandler is located at app/api/draft/route.ts\r\nTerminal (bash)https://<your-site>/api/draft?secret=<token>&slug=<path>\r\n<your-site> should be your deployment domain. <token> should be replaced with the secret token you generated. <path> should be the path for the page that you want to view. If you want to view /posts/foo, then you should use\r\n&slug=/posts/foo. Your headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMS’s\r\ndata like so: &slug=/posts/{entry.fields.slug}\r\nFinally, in the Route Handler:\r\nCheck that the secret matches and that the slug parameter exists (if not, the request should fail).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"df8a5140-7fa4-4a1b-9c52-5b660af20374":{"id_":"df8a5140-7fa4-4a1b-9c52-5b660af20374","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lR+WVF42cZY7VeRLwRLPp8VGJXScF2TuMCOs8JBkLyg=","metadata":{},"hash":"/LJ76GIdTxBRtGumDUy09BGKV0BPg8UYmW6gSt0+bTw="},"NEXT":{"nodeId":"7b0ad509-0c12-4077-9fe5-c9dca7a33876","metadata":{},"hash":"3bfK3Ymu9+sDDONfdsDeu/oKLht0zvxIjY5NY0HFvPQ="}},"hash":"IUkjyoQJ6CgB+ZRE1a3SgHnGrTlieAYS/JDAgIq6sf0=","text":"Call draftMode.enable() to set the cookie. Then redirect the browser to the path specified by slug.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b0ad509-0c12-4077-9fe5-c9dca7a33876":{"id_":"7b0ad509-0c12-4077-9fe5-c9dca7a33876","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lR+WVF42cZY7VeRLwRLPp8VGJXScF2TuMCOs8JBkLyg=","metadata":{},"hash":"/LJ76GIdTxBRtGumDUy09BGKV0BPg8UYmW6gSt0+bTw="},"PREVIOUS":{"nodeId":"df8a5140-7fa4-4a1b-9c52-5b660af20374","metadata":{},"hash":"IUkjyoQJ6CgB+ZRE1a3SgHnGrTlieAYS/JDAgIq6sf0="},"NEXT":{"nodeId":"d8e308ea-b16d-4139-a949-65b2f63fb310","metadata":{},"hash":"kOGVX3C2FBjZ2QS8/f9y5wCEvET1sQDfDbJArHo7+gw="}},"hash":"3bfK3Ymu9+sDDONfdsDeu/oKLht0zvxIjY5NY0HFvPQ=","text":"Then redirect the browser to the path specified by slug. app/api/draft/route.ts (ts)// route handler with secret and slug\r\nimport { draftMode } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\nexport async function GET(request: Request) {\r\n  // Parse query string parameters\r\n  const { searchParams } = new URL(request.url)\r\n  const secret = searchParams.get('secret')\r\n  const slug = searchParams.get('slug')\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this route handler and the CMS\r\n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\r\n    return new Response('Invalid token', { status: 401 })\r\n  }\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(slug)\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return new Response('Invalid slug', { status: 401 })\r\n  }\r\n  // Enable Draft Mode by setting the cookie\r\n  draftMode().enable()\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities\r\n  redirect(post.slug)\r\n}\r\napp/api/draft/route.js (js)// route handler with secret and slug\r\nimport { draftMode } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\nexport async function GET(request) {\r\n  // Parse query string parameters\r\n  const { searchParams } = new URL(request.url)\r\n  const secret = searchParams.get('secret')\r\n  const slug = searchParams.get('slug')\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this route handler and the CMS\r\n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\r\n    return new Response('Invalid token', { status: 401 })\r\n  }\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(slug)\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return new Response('Invalid slug', { status: 401 })\r\n  }\r\n  // Enable Draft Mode by setting the cookie\r\n  draftMode().enable()\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities\r\n  redirect(post.slug)\r\n}\r\nIf it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d8e308ea-b16d-4139-a949-65b2f63fb310":{"id_":"d8e308ea-b16d-4139-a949-65b2f63fb310","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lR+WVF42cZY7VeRLwRLPp8VGJXScF2TuMCOs8JBkLyg=","metadata":{},"hash":"/LJ76GIdTxBRtGumDUy09BGKV0BPg8UYmW6gSt0+bTw="},"PREVIOUS":{"nodeId":"7b0ad509-0c12-4077-9fe5-c9dca7a33876","metadata":{},"hash":"3bfK3Ymu9+sDDONfdsDeu/oKLht0zvxIjY5NY0HFvPQ="}},"hash":"kOGVX3C2FBjZ2QS8/f9y5wCEvET1sQDfDbJArHo7+gw=","text":"Step 2: Update page","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4e3fc256-7a79-4c18-ab26-49cdf8d684c2":{"id_":"4e3fc256-7a79-4c18-ab26-49cdf8d684c2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6+fP9beWgBwGoAHcQTAMDo/NlghNNgxegvayZpSONIc=","metadata":{},"hash":"C5EBBB14E5wiEZ8KHWubl0kWht1QEjt+PMw/ysVlz2w="}},"hash":"EsXsWFyTaNPjsWUlhPOZIIlkP1dho4HG1QGweSwGyoQ=","text":"The next step is to update your page to check the value of draftMode().isEnabled. If you request a page which has the cookie set, then data will be fetched at request time (instead of at build time). Furthermore, the value of isEnabled will be true. app/page.tsx (tsx)// page that fetches data\r\nimport { draftMode } from 'next/headers'\r\nasync function getData() {\r\n  const { isEnabled } = draftMode()\r\n  const url = isEnabled\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n  const res = await fetch(url)\r\n  return res.json()\r\n}\r\nexport default async function Page() {\r\n  const { title, desc } = await getData()\r\n  return (\r\n    <main>\r\n      <h1>{title}</h1>\r\n      <p>{desc}</p>\r\n    </main>\r\n  )\r\n}\r\napp/page.js (jsx)// page that fetches data\r\nimport { draftMode } from 'next/headers'\r\nasync function getData() {\r\n  const { isEnabled } = draftMode()\r\n  const url = isEnabled\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n  const res = await fetch(url)\r\n  return res.json()\r\n}\r\nexport default async function Page() {\r\n  const { title, desc } = await getData()\r\n  return (\r\n    <main>\r\n      <h1>{title}</h1>\r\n      <p>{desc}</p>\r\n    </main>\r\n  )\r\n}\r\nThat’s it! If you access the draft Route Handler (with secret and slug) from your headless CMS or manually, you should now be able to\r\nsee the draft content. And if you update your draft without publishing, you should be able to view the draft. Set this as the draft URL on your headless CMS or access manually, and you should be able to see the draft. Terminal (bash)https://<your-site>/api/draft?secret=<token>&slug=<path>\r\nMore Details\r\nClear the Draft Mode cookie\r\nBy default, the Draft Mode session ends when the browser is closed. To clear the Draft Mode cookie manually, create a Route Handler that calls draftMode().disable():","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5f64eb36-b450-47d9-897a-84d8329acb80":{"id_":"5f64eb36-b450-47d9-897a-84d8329acb80","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4MkpZncy5+/ryQQoa2yizjOItpWkBDtvsIVohwBvMMs=","metadata":{},"hash":"Q41+w+I9Xlip3zYgRe+0zxDG9LNZWEGy3IKQ9y4bq4o="}},"hash":"sadkFj5qmCd/0we4du7svIDu7NRThh49+Uki69wRogg=","text":"app/api/disable-draft/route.ts (ts)import { draftMode } from 'next/headers'\r\nexport async function GET(request: Request) {\r\n  draftMode().disable()\r\n  return new Response('Draft mode is disabled')\r\n}\r\napp/api/disable-draft/route.js (js)import { draftMode } from 'next/headers'\r\nexport async function GET(request) {\r\n  draftMode().disable()\r\n  return new Response('Draft mode is disabled')\r\n}\r\nThen, send a request to /api/disable-draft to invoke the Route Handler. If calling this route using next/link, you must pass\r\nprefetch={false} to prevent accidentally deleting the cookie on prefetch. Unique per next buildnext build\r\nA new bypass cookie value will be generated each time you run next build. This ensures that the bypass cookie can’t be guessed. Good to know: To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage\r\naccess.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7f7c457d-f0ce-4393-a75f-fae3d75c366f":{"id_":"7f7c457d-f0ce-4393-a75f-fae3d75c366f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a3sDzNpwKfbBg58I/8AhMUVYWly5tSWYA/0kS37AwGw=","metadata":{},"hash":"SYHd7NuiPj00v4syk/Te4/a6MsD9M/sDehf39FBl2K0="},"NEXT":{"nodeId":"05b98675-e24c-46f9-b147-fcd969db4dce","metadata":{},"hash":"gye+E/rP8sdJ0wj9t+v+I6exCgpgCFfTwqVxvXyfFQ4="}},"hash":"3VUofDF7DZN22mp63SLtvvypUA4VUeBstKkcecf12nc=","text":"3.1.7.8 - Content Security Policy\r\nDocumentation path: /02-app/01-building-your-application/07-configuring/15-content-security-policy\r\nDescription: Learn how to set a Content Security Policy (CSP) for your Next.js application. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/building-your-application/routing/middleware\r\napp/api-reference/functions/headers\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nContent Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting\r\n(XSS), clickjacking, and other code injection attacks. By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects,\r\nmedia (audio, video), iframes, and more. Examples\r\nNonces\r\nA nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow\r\ncertain inline scripts or styles to execute, bypassing strict CSP directives. Why use a nonce? Even though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such\r\ncases, nonces offer a way to allow these scripts to execute if they have the correct nonce. Adding a nonce with Middleware\r\nMiddleware enables you to add headers and generate nonces before the page renders. Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"05b98675-e24c-46f9-b147-fcd969db4dce":{"id_":"05b98675-e24c-46f9-b147-fcd969db4dce","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a3sDzNpwKfbBg58I/8AhMUVYWly5tSWYA/0kS37AwGw=","metadata":{},"hash":"SYHd7NuiPj00v4syk/Te4/a6MsD9M/sDehf39FBl2K0="},"PREVIOUS":{"nodeId":"7f7c457d-f0ce-4393-a75f-fae3d75c366f","metadata":{},"hash":"3VUofDF7DZN22mp63SLtvvypUA4VUeBstKkcecf12nc="}},"hash":"gye+E/rP8sdJ0wj9t+v+I6exCgpgCFfTwqVxvXyfFQ4=","text":"This means that you must use dynamic rendering to add nonces. For example:\r\nmiddleware.ts (ts)import { NextRequest, NextResponse } from 'next/server'\r\nexport function middleware(request: NextRequest) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\r\n    style-src 'self' 'nonce-${nonce}';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    block-all-mixed-content;\r\n    upgrade-insecure-requests;\r\n`\r\n  // Replace newline characters and spaces\r\n  const contentSecurityPolicyHeaderValue = cspHeader\r\n    .replace(/\\s{2,}/g, ' ')\r\n    .trim()\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-nonce', nonce)\r\n  requestHeaders.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"17a4098c-bc2e-4faa-8f2f-9ea6db6a062c":{"id_":"17a4098c-bc2e-4faa-8f2f-9ea6db6a062c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pvFy+TU0vU6IKhAD9ErIQWmf8XANtH+KradiqIurCw8=","metadata":{},"hash":"9FV3eQx/8C8n9syCJGhZczUQDJdgdsorTit0RBA2ZLs="}},"hash":"IwEyhMIYG0fpPtXaq6OUVjsKZCV/lzBIunvBJZxdGhs=","text":"const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  response.headers.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n  return response\r\n}\r\nmiddleware.js (js)import { NextResponse } from 'next/server'\r\nexport function middleware(request) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\r\n    style-src 'self' 'nonce-${nonce}';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    block-all-mixed-content;\r\n    upgrade-insecure-requests;\r\n`\r\n  // Replace newline characters and spaces\r\n  const contentSecurityPolicyHeaderValue = cspHeader\r\n    .replace(/\\s{2,}/g, ' ')\r\n    .trim()\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-nonce', nonce)\r\n  requestHeaders.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n  const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  response.headers.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n  return response\r\n}\r\nBy default, Middleware runs on all requests. You can filter Middleware to run on specific paths using a matcher. We recommend ignoring matching prefetches (from next/link) and static assets that don’t need the CSP header. middleware.ts (ts)export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    {\r\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3030e0dc-e10f-4bac-a667-8bfefb4efaa1":{"id_":"3030e0dc-e10f-4bac-a667-8bfefb4efaa1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZohrqzU+LLh9c7nBEwAVlvkOdp4GM8iq/HAjdhLoVmQ=","metadata":{},"hash":"AjHJqcB+CQ8cFECUsZJW8uoYCUnqxqxeB3fqnKTjuNE="}},"hash":"U7glqNJ/zRNWn8SH8DFMiKe2MGOe7eN6wsDcVzusaYQ=","text":"],\r\n    },\r\n  ],\r\n}\r\nmiddleware.js (js)export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    {\r\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n  ],\r\n}\r\nReading the nonce\r\nYou can now read the nonce from a Server Component using headers:\r\napp/page.tsx (tsx)import { headers } from 'next/headers'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  const nonce = headers().get('x-nonce')\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}\r\napp/page.jsx (jsx)import { headers } from 'next/headers'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  const nonce = headers().get('x-nonce')\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}\r\nVersion History\r\nWe recommend using v13.4.20+ of Next.js to properly handle and apply nonces.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"444a7a2e-23f0-42b4-a587-160cdef72551":{"id_":"444a7a2e-23f0-42b4-a587-160cdef72551","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"664nTXioR+wA026FIrwriE6+pGlLSLE0oSWhxi2vmTI=","metadata":{},"hash":"vgRnbWy5JaVNxWYhBSzPuF9N3ZAXTGtAFHAYvZfQpcc="}},"hash":"iS0DvNjEhoSgXstN905A8ndR0L1IvWmXfk7nOP7uL0A=","text":"3.1.8 - Testing\r\nDocumentation path: /02-app/01-building-your-application/08-testing/index\r\nDescription: Learn how to set up Next.js with three commonly used testing tools — Cypress, Playwright, Vitest, and Jest. In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides\r\nan overview of types and commonly used tools you can use to test your application. Types of tests\r\nUnit testing involves testing individual units (or blocks of code) in isolation. In React, a unit can be a single function, hook, or\r\ncomponent. Component testing is a more focused version of unit testing where the primary subject of the tests is React components. This may\r\ninvolve testing how components are rendered, their interaction with props, and their behavior in response to user events. Integration testing involves testing how multiple units work together. This can be a combination of components, hooks, and\r\nfunctions. End-to-End (E2E) Testing involves testing user flows in an environment that simulates real user scenarios, like the browser. This\r\nmeans testing specific tasks (e.g. signup flow) in a production-like environment. Snapshot testing involves capturing the rendered output of a component and saving it to a snapshot file. When tests run, the\r\ncurrent rendered output of the component is compared against the saved snapshot. Changes in the snapshot are used to indicate\r\nunexpected changes in behavior. Async Server Components\r\nSince async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we\r\nrecommend using End-to-End Testing over Unit Testing for async components. Guides\r\nSee the guides below to learn how to set up Next.js with these commonly used testing tools:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e0146416-34ad-44c9-ad90-331d0a74393c":{"id_":"e0146416-34ad-44c9-ad90-331d0a74393c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"avxDh3E9K6by98w/wJgSnI+l4J/2zpxzc9vYhrdqWlo=","metadata":{},"hash":"BF98lGxS86LHz542IsbWI2/wKBSVaNRwJFBq1aDRhwE="}},"hash":"oPkGSrPBjrialUOHZDRvUoMtPcwK1U//dXyP8sRmhUA=","text":"3.1.8.1 - Setting up Vitest with Next.js\r\nDocumentation path: /02-app/01-building-your-application/08-testing/01-vitest\r\nDescription: Learn how to set up Vitest with Next.js for Unit Testing. Vite and React Testing Library are frequently used together for Unit Testing. This guide will show you how to setup Vitest with Next.js\r\nand write your first tests. Good to know: Since async Server Components are new to the React ecosystem, Vitest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using an E2E tests for async\r\ncomponents. Quickstart\r\nYou can use create-next-app with the Next.js with-vitest example to quickly get started:\r\nTerminal (bash)npx create-next-app@latest --example with-vitest with-vitest-app\r\nManual Setup\r\nTo manually set up Vitest, install vitest and the following packages as dev dependencies:\r\nTerminal (bash)npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react\r\n# or\r\nyarn add -D vitest @vitejs/plugin-react jsdom @testing-library/react @vitejs/plugin-react\r\n# or\r\npnpm install -D vitest @vitejs/plugin-react jsdom @testing-library/react\r\n# or\r\nbun add -D vitest @vitejs/plugin-react jsdom @testing-library/react\r\nCreate a vitest.config.ts|js file in the root of your project, and add the following options:\r\nvitest.config.ts (ts)import { defineConfig } from 'vitest/config'\r\nimport react from '@vitejs/plugin-react'\r\nexport default defineConfig({\r\n  plugins: [react()],\r\n  test: {\r\n    environment: 'jsdom',\r\n  },\r\n})\r\nvitest.config.js (js)import { defineConfig } from 'vitest/config'\r\nimport react from '@vitejs/plugin-react'\r\nexport default defineConfig({\r\n  plugins: [react()],\r\n  test: {\r\n    environment: 'jsdom',\r\n  },\r\n})\r\nFor more information on configuring Vitest, please refer to the Vitest Cofiguration docs. Then, add a test script to your package.json:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"test\": \"vitest\"\r\n  }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c7851151-c8a3-4596-8046-aee66eac3366":{"id_":"c7851151-c8a3-4596-8046-aee66eac3366","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JHLZ14cISY2jArKJ/jzGm1O/XX6zQxBBN018tmipJcE=","metadata":{},"hash":"cMDNbLqrBqCM+YsTTItggFcF68T7QriHULERtY6+H1k="}},"hash":"lVQdjn1vKceGFZaIAIz0CCnMqWlxFyA7FyholJZh5xY=","text":"When you run npm run test, Vitest will watch for changes in your project by default. Creating your first Vitest Unit Test\r\nCheck that everything is working by creating a test to check if the <Page /> component successfully renders a heading:\r\napp/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\n__tests__/page.test.tsx (tsx)import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})\r\n__tests__/page.test.jsx (jsx)import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})\r\nGood to know: The example above uses the common __tests__ convention, but test files can also be colocated inside theapp\r\n router. pages/index.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\npages/index.jsx (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9a5a8315-1c6f-4109-bbe4-ae6d8e346db0":{"id_":"9a5a8315-1c6f-4109-bbe4-ae6d8e346db0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"keWn7NOrCJdD1PSEac6J+e3WthkBjx82ydxtjF36n2g=","metadata":{},"hash":"hP6Cqz3CiFledaYSx7EE6FlJp/SdWBMjMtDkX4E/BfA="}},"hash":"RUFyNBJKNW6IGjyA5ZFFt4ATzo5bdPQv+rr/634bltE=","text":"<h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\n__tests__/index.test.tsx (tsx)import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../pages/index'\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})\r\n__tests__/index.test.jsx (jsx)import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../pages/index'\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})\r\nRunning your tests\r\nThen, run the following command to run your tests:\r\nTerminal (bash)npm run test\r\n# or\r\nyarn test\r\n# or\r\npnpm test\r\nAdditional Resources\r\nYou may find these resources helpful:\r\nNext.js with Vitest example\r\nVitest Docs\r\nReact Testing Library Docs","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"05087e41-f2df-42e6-a614-a8ad3c1665b6":{"id_":"05087e41-f2df-42e6-a614-a8ad3c1665b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uG5pqtMjh9WO+JzHJat1yEEPXTOQJzrCuTqXhXxoHXA=","metadata":{},"hash":"v5Y3HNVBcHQLcxBEI7HKwKuv2k4TOuOnvTRxK5g43uM="},"NEXT":{"nodeId":"1f8af98a-a527-43f8-a521-d968d0a81285","metadata":{},"hash":"lN5Pfjj90ri79cdadOTfe+EQ7xqbDMTSAedIPZVI5zQ="}},"hash":"edo83mxDTyWUIVIobVvWGh5MM3LrTpFzA2NkIWv0k1w=","text":"3.1.8.2 - Setting up Jest with Next.js\r\nDocumentation path: /02-app/01-building-your-application/08-testing/02-jest\r\nDescription: Learn how to set up Jest with Next.js for Unit Testing and Snapshot Testing. Jest and React Testing Library are frequently used together for Unit Testing and Snapshot Testing. This guide will show you how to set\r\nup Jest with Next.js and write your first tests. Good to know: Since async Server Components are new to the React ecosystem, Jest currently does not support them. While\r\nyou can still run unit tests for synchronous Server and Client Components, we recommend using an E2E tests for async\r\ncomponents. Quickstart\r\nYou can use create-next-app with the Next.js with-jest example to quickly get started:\r\nTerminal (bash)npx create-next-app@latest --example with-jest with-jest-app\r\nManual setup\r\nSince the release of Next.js 12, Next.js now has built-in configuration for Jest. To set up Jest, install jest and the following packages as dev dependencies:\r\nTerminal (bash)npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\r\n# or\r\nyarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\r\n# or\r\npnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\r\nGenerate a basic Jest configuration file by running the following command:\r\nTerminal (bash)npm init jest@latest\r\n# or\r\nyarn create jest@latest\r\n# or\r\npnpm create jest@latest\r\nThis will take you through a series of prompts to setup Jest for your project, including automatically creating a jest.config.ts|js\r\nfile. Update your config file to use next/jest.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1f8af98a-a527-43f8-a521-d968d0a81285":{"id_":"1f8af98a-a527-43f8-a521-d968d0a81285","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uG5pqtMjh9WO+JzHJat1yEEPXTOQJzrCuTqXhXxoHXA=","metadata":{},"hash":"v5Y3HNVBcHQLcxBEI7HKwKuv2k4TOuOnvTRxK5g43uM="},"PREVIOUS":{"nodeId":"05087e41-f2df-42e6-a614-a8ad3c1665b6","metadata":{},"hash":"edo83mxDTyWUIVIobVvWGh5MM3LrTpFzA2NkIWv0k1w="}},"hash":"lN5Pfjj90ri79cdadOTfe+EQ7xqbDMTSAedIPZVI5zQ=","text":"Update your config file to use next/jest. This transformer has all the necessary configuration options for Jest to work with Next.js:\r\njest.config.ts (ts)import type { Config } from 'jest'\r\nimport nextJest from 'next/jest.js'\r\nconst createJestConfig = nextJest({\r\n  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment\r\n  dir: './',\r\n})\r\n// Add any custom config to be passed to Jest\r\nconst config: Config = {\r\n  coverageProvider: 'v8',\r\n  testEnvironment: 'jsdom',\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],\r\n}\r\n// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async\r\nexport default createJestConfig(config)\r\njest.config.js (js)const nextJest = require('next/jest')\r\n/** @type {import('jest').Config} */","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9cc86875-6929-43b5-9baf-8bc70c455da4":{"id_":"9cc86875-6929-43b5-9baf-8bc70c455da4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NpXkF+2DPrCQCOWMvvoTmKzt7zW2cgPjXGQB11EXiM4=","metadata":{},"hash":"yIU0tr1/9FfwTRfYGryDCEuDcaYEoI5DU6Koq+x8GYo="},"NEXT":{"nodeId":"65615de9-ac31-4116-b5fc-77d479d777be","metadata":{},"hash":"O+w5b/eFjlgb88c20jJyTusXLoKCV4sP1JJaU/UDAHw="}},"hash":"3J8hsLV4Jh6RHlt04MRk+hLPT3N91STwv6Sj+0fWv2c=","text":"const createJestConfig = nextJest({\r\n  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment\r\n  dir: './',\r\n})\r\n// Add any custom config to be passed to Jest\r\nconst config = {\r\n  coverageProvider: 'v8',\r\n  testEnvironment: 'jsdom',\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],\r\n}\r\n// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async\r\nmodule.exports = createJestConfig(config)\r\nUnder the hood, next/jest is automatically configuring Jest for you, including:\r\nSetting up transform using the Next.js Compiler\r\nAuto mocking stylesheets (.css, .module.css, and their scss variants), image imports and next/font\r\nLoading .env (and all variants) into process.env\r\nIgnoring node_modules from test resolving and transforms\r\nIgnoring .next from test resolving\r\nLoading next.config.js for flags that enable SWC transforms\r\nGood to know: To test environment variables directly, load them manually in a separate setup script or in yourjest.config.ts\r\n file. For more information, please see Test Environment Variables. Setting up Jest (with Babel)\r\nIf you opt out of the Next.js Compiler and use Babel instead, you will need to manually configure Jest and install babel-jest and\r\nidentity-obj-proxy in addition to the packages above.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"65615de9-ac31-4116-b5fc-77d479d777be":{"id_":"65615de9-ac31-4116-b5fc-77d479d777be","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NpXkF+2DPrCQCOWMvvoTmKzt7zW2cgPjXGQB11EXiM4=","metadata":{},"hash":"yIU0tr1/9FfwTRfYGryDCEuDcaYEoI5DU6Koq+x8GYo="},"PREVIOUS":{"nodeId":"9cc86875-6929-43b5-9baf-8bc70c455da4","metadata":{},"hash":"3J8hsLV4Jh6RHlt04MRk+hLPT3N91STwv6Sj+0fWv2c="}},"hash":"O+w5b/eFjlgb88c20jJyTusXLoKCV4sP1JJaU/UDAHw=","text":"Here are the recommended options to configure Jest for Next.js:\r\njest.config.js (js)module.exports = {\r\n  collectCoverage: true,\r\n  // on node 14.x coverage provider v8 offers good speed and more or less good report\r\n  coverageProvider: 'v8',\r\n  collectCoverageFrom: [\r\n    '**/*.{js,jsx,ts,tsx}',\r\n    '!**/*.d.ts',\r\n    '!**/node_modules/**',\r\n    '!<rootDir>/out/**',\r\n    '!<rootDir>/.next/**',\r\n    '!<rootDir>/*.config.js',\r\n    '!<rootDir>/coverage/**',\r\n  ],\r\n  moduleNameMapper: {\r\n    // Handle CSS imports (with CSS modules)\r\n    // https://jestjs.io/docs/webpack#mocking-css-modules\r\n    '^.+\\\\.module\\\\.(css|sass|scss)$': 'identity-obj-proxy',\r\n    // Handle CSS imports (without CSS modules)\r\n    '^.+\\\\.(css|sass|scss)$': '<rootDir>/__mocks__/styleMock.js',\r\n    // Handle image imports\r\n    // https://jestjs.io/docs/webpack#handling-static-assets\r\n    '^.+\\\\.(png|jpg|jpeg|gif|webp|avif|ico|bmp|svg)$/i': `<rootDir>/__mocks__/fileMock.js`,\r\n    // Handle module aliases\r\n    '^@/components/(.*)$': '<rootDir>/components/$1',\r\n    // Handle @next/font\r\n    '@next/font/(.*)': `<rootDir>/__mocks__/nextFontMock.js`,\r\n    // Handle next/font\r\n    'next/font/(.*)': `<rootDir>/__mocks__/nextFontMock.js`,\r\n    // Disable server-only\r\n    'server-only': `<rootDir>/__mocks__/empty.js`,\r\n  },\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"95e6ab72-fdb7-4a2d-8c94-8b769bd139e0":{"id_":"95e6ab72-fdb7-4a2d-8c94-8b769bd139e0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NgPelR35h85a/bS7krRd+9i18HffQJlNS8ryroT2SoM=","metadata":{},"hash":"mEqB2G2bDgSTMdFjwZusZqrltzIdtH87mR5DbGbZZAw="},"NEXT":{"nodeId":"5b716d1f-ce53-43d4-ab3b-ce6eb3039fc1","metadata":{},"hash":"fLIJM3kRPvu0Xc8DlJXDzK4jRq0ePylUR/i5VA4fZmI="}},"hash":"er4Sddllw7fI5vQkKRs76sw4w4LFUGQcy1SXrswl6mY=","text":"testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],\r\n  testEnvironment: 'jsdom',\r\n  transform: {\r\n    // Use babel-jest to transpile tests with the next/babel preset\r\n    // https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object\r\n    '^.+\\\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],\r\n  },\r\n  transformIgnorePatterns: [\r\n    '/node_modules/',\r\n    '^.+\\\\.module\\\\.(css|sass|scss)$',\r\n  ],\r\n}\r\nYou can learn more about each configuration option in the Jest docs. We also recommend reviewing next/jest configuration to see\r\nhow Next.js configures Jest. Handling stylesheets and image imports\r\nStylesheets and images aren’t used in the tests but importing them may cause errors, so they will need to be mocked. Create the mock files referenced in the configuration above - fileMock.js and styleMock.js - inside a __mocks__ directory:\r\n__mocks__/fileMock.js (js)module.exports = 'test-file-stub'\r\n__mocks__/styleMock.js (js)module.exports = {}\r\nFor more information on handling static assets, please refer to the Jest Docs. Handling Fonts\r\nTo handle fonts, create the nextFontMock.js file inside the __mocks__ directory, and add the following configuration:\r\n__mocks__/nextFontMock.js (js)module.exports = new Proxy(\r\n  {},\r\n  {\r\n    get: function getter() {\r\n      return () => ({\r\n        className: 'className',\r\n        variable: 'variable',\r\n        style: { fontFamily: 'fontFamily' },\r\n      })\r\n    },\r\n  }\r\n)\r\nOptional: Handling Absolute Imports and Module Path Aliases\r\nIf your project is using Module Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in thejsconfig.json\r\n file with the moduleNameMapper option in the jest.config.js file. For example:\r\ntsconfig.json or jsconfig.json (json){\r\n  \"compilerOptions\": {\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"bundler\",\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"@/components/*\": [\"components/*\"]\r\n    }\r\n  }\r\n}\r\njest.config.js (js)moduleNameMapper: {\r\n  // ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5b716d1f-ce53-43d4-ab3b-ce6eb3039fc1":{"id_":"5b716d1f-ce53-43d4-ab3b-ce6eb3039fc1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NgPelR35h85a/bS7krRd+9i18HffQJlNS8ryroT2SoM=","metadata":{},"hash":"mEqB2G2bDgSTMdFjwZusZqrltzIdtH87mR5DbGbZZAw="},"PREVIOUS":{"nodeId":"95e6ab72-fdb7-4a2d-8c94-8b769bd139e0","metadata":{},"hash":"er4Sddllw7fI5vQkKRs76sw4w4LFUGQcy1SXrswl6mY="}},"hash":"fLIJM3kRPvu0Xc8DlJXDzK4jRq0ePylUR/i5VA4fZmI=","text":"'^@/components/(.*)$': '<rootDir>/components/$1',\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"26fed71f-6ba6-4de2-bb0b-5bf5497f8cd9":{"id_":"26fed71f-6ba6-4de2-bb0b-5bf5497f8cd9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"G9+VRZvKZx97VOZL7qNrXXKwVp+LaOLwqdvFH2Y8oR0=","metadata":{},"hash":"a0UXFSeYZqxAPgBwYjRaFNFNI3pLAyEHU1rwOIP5ZW8="},"NEXT":{"nodeId":"9a339032-414c-4b77-8283-0884c0ef9713","metadata":{},"hash":"2sHAWtWV4oT3l5x81mlGO01HWuxSomptkpki35oPoeo="}},"hash":"6LXjyI1RYKVpb30r6HFaD2HKIKwBIt5L4Z4e0DFxt6c=","text":"Optional: Extend Jest with custom matchers\r\n@testing-library/jest-dom includes a set of convenient custom matchers such as .toBeInTheDocument() making it easier to\r\nwrite tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file:\r\njest.config.ts (ts)setupFilesAfterEnv: ['<rootDir>/jest.setup.ts']\r\njest.config.js (js)setupFilesAfterEnv: ['<rootDir>/jest.setup.js']\r\nThen, inside jest.setup.ts, add the following import:\r\njest.setup.ts (ts)import '@testing-library/jest-dom'\r\njest.setup.js (js)import '@testing-library/jest-dom'\r\nGood to know:extend-expect was removed in v6.0, so if you are using @testing-library/jest-dom before version 6,\r\nyou will need to import @testing-library/jest-dom/extend-expect instead. If you need to add more setup options before each test, you can add them to the jest.setup.js file above. Add a test script to package.jsonpackage.json:\r\nFinally, add a Jest test script to your package.json file:\r\n```json filename=”package.json” highlight={6-7} { “scripts”: { “dev”: “next dev”, “build”: “next build”, “start”: “next start”, “test”: “jest”,\r\n“test:watch”: “jest –watch” } }\r\n`jest --watch` will re-run tests when a file is changed. For more Jest CLI options, please refer to the [Jest\r\n### Creating your first test:\r\nYour project is now ready to run tests.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9a339032-414c-4b77-8283-0884c0ef9713":{"id_":"9a339032-414c-4b77-8283-0884c0ef9713","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"G9+VRZvKZx97VOZL7qNrXXKwVp+LaOLwqdvFH2Y8oR0=","metadata":{},"hash":"a0UXFSeYZqxAPgBwYjRaFNFNI3pLAyEHU1rwOIP5ZW8="},"PREVIOUS":{"nodeId":"26fed71f-6ba6-4de2-bb0b-5bf5497f8cd9","metadata":{},"hash":"6LXjyI1RYKVpb30r6HFaD2HKIKwBIt5L4Z4e0DFxt6c="}},"hash":"2sHAWtWV4oT3l5x81mlGO01HWuxSomptkpki35oPoeo=","text":"Create a folder called `__tests__` in your project's root directory\r\n<PagesOnly>\r\nFor example, we can add a test to check if the `<Home />` component successfully renders a heading:\r\n```jsx filename=\"pages/index.js\r\nexport default function Home() {\r\n  return <h1>Home</h1>\r\n}\r\n__tests__/index.test.js (jsx)import '@testing-library/jest-dom'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Home from '../pages/index'\r\ndescribe('Home', () => {\r\n  it('renders a heading', () => {\r\n    render(<Home />)\r\n    const heading = screen.getByRole('heading', { level: 1 })\r\n    expect(heading).toBeInTheDocument()\r\n  })\r\n})\r\nFor example, we can add a test to check if the <Page /> component successfully renders a heading:\r\n```jsx filename=”app/page.js import Link from ‘next/link’\r\nexport default async function Home() { return (Home\r\nAbout\r\n) }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"79505e8e-4e06-41fc-ae5d-061b460a94d8":{"id_":"79505e8e-4e06-41fc-ae5d-061b460a94d8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OHEs+68j9nxyMFRPHoKZwny4KMa6V+07kQOoZ7f+/8k=","metadata":{},"hash":"0mGwCU4/hA/ZsXyNJUd7giUaZm2c3wvM+b0EDJ/VRu4="}},"hash":"k+oPVLstiKeIf3V2unP7Mb9Gw/iYd4KBPkCrRZuwT0c=","text":"<div class=\"code-header\"><i>__tests__/page.test.jsx (jsx)</i></div>\r\n```jsx\r\nimport '@testing-library/jest-dom'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\ndescribe('Page', () => {\r\n  it('renders a heading', () => {\r\n    render(<Page />)\r\n    const heading = screen.getByRole('heading', { level: 1 })\r\n    expect(heading).toBeInTheDocument()\r\n  })\r\n})\r\nOptionally, add a snapshot test to keep track of any unexpected changes in your component:\r\n__tests__/snapshot.js (jsx)import { render } from '@testing-library/react'\r\nimport Home from '../pages/index'\r\nit('renders homepage unchanged', () => {\r\n  const { container } = render(<Home />)\r\n  expect(container).toMatchSnapshot()\r\n})\r\nGood to know: Test files should not be included inside the Pages Router because any files inside the Pages Router are\r\nconsidered routes. __tests__/snapshot.js (jsx)import { render } from '@testing-library/react'\r\nimport Page from '../app/page'\r\nit('renders homepage unchanged', () => {\r\n  const { container } = render(<Page />)\r\n  expect(container).toMatchSnapshot()\r\n})\r\nRunning your tests\r\nThen, run the following command to run your tests:\r\nTerminal (bash)npm run test\r\n# or\r\nyarn test\r\n# or\r\npnpm test\r\nAdditional Resources\r\nFor further reading, you may find these resources helpful:\r\nNext.js with Jest example\r\nJest Docs\r\nReact Testing Library Docs\r\nTesting Playground - use good testing practices to match elements.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6f77f1cc-eccf-4dc9-bfd0-7bd7d2af0a16":{"id_":"6f77f1cc-eccf-4dc9-bfd0-7bd7d2af0a16","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4sI/qnNuldaJxe742K19fkPQzLgS1f8bAOJmZfRQWAI=","metadata":{},"hash":"Q/DYk2gSEVqB5SG6Ae2qsDlWTMCc8FkR+pfhefN8sp4="}},"hash":"BOx2Q/l/GCX2Teo3oatrsQV82YLrgqHIyMtya2YbVWU=","text":"3.1.8.3 - Setting up Playwright with Next.js\r\nDocumentation path: /02-app/01-building-your-application/08-testing/03-playwright\r\nDescription: Learn how to set up Playwright with Next.js for End-to-End (E2E) testing. Playwright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to write End-\r\nto-End (E2E) testing. This guide will show you how to set up Playwright with Next.js and write your first tests. Quickstart\r\nThe fastest way to get started is to use create-next-app with the with-playwright example. This will create a Next.js project complete\r\nwith Playwright configured. Terminal (bash)npx create-next-app@latest --example with-playwright with-playwright-app\r\nManual setup\r\nTo install Playwright, run the following command:\r\nTerminal (bash)npm init playwright\r\n# or\r\nyarn create playwright\r\n# or\r\npnpm create playwright\r\nThis will take you through a series of prompts to setup and configure Playwright for your project, including adding aplaywright.config.ts\r\n file. Please refer to the Playwright installation guide for the step-by-step guide. Creating your first Playwright E2E test\r\nCreate two new Next.js pages:\r\napp/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\napp/about/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}\r\npages/index.ts (tsx)import Link from 'next/link'\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fab9c1f7-6c74-41c7-aa6f-998a33af00d1":{"id_":"fab9c1f7-6c74-41c7-aa6f-998a33af00d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"IlQvk33XolghjsWKOx+WEohq8VZ1p76u2gaGc1ioc9k=","metadata":{},"hash":"8BQxURyhcmPcTP1OwvHfSkEJqPETIiY98uh8u70bl/Y="}},"hash":"8V+rjtC7P0R/SxD8eBAGsvor4Xp6d0bIJQ8ZrUX7p7c=","text":"}\r\npages/about.ts (tsx)import Link from 'next/link'\r\nexport default function About() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}\r\nThen, add a test to verify that your navigation is working correctly:\r\ntests/example.spec.ts (ts)import { test, expect } from '@playwright/test'\r\ntest('should navigate to the about page', async ({ page }) => {\r\n  // Start from the index page (the baseURL is set via the webServer in the playwright.config.ts)\r\n  await page.goto('http://localhost:3000/')\r\n  // Find an element with the text 'About' and click on it\r\n  await page.click('text=About')\r\n  // The new URL should be \"/about\" (baseURL is used there)\r\n  await expect(page).toHaveURL('http://localhost:3000/about')\r\n  // The new page should contain an h1 with \"About\"\r\n  await expect(page.locator('h1')).toContainText('About')\r\n})\r\nGood to know:\r\nYou can use page.goto(\"/\") instead of page.goto(\"http://localhost:3000/\"), if you add \"baseURL\":\r\n\"http://localhost:3000\" to the playwright.config.ts configuration file. Running your Playwright tests\r\nPlaywright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your\r\nNext.js server to be running. We recommend running your tests against your production code to more closely resemble how your\r\napplication will behave. Run npm run build and npm run start, then run npx playwright test in another terminal window to run the Playwright tests. Good to know: Alternatively, you can use the webServer feature to let Playwright start the development server and wait until\r\nit’s fully available. Running Playwright on Continuous Integration (CI)\r\nPlaywright will by default run your tests in the headless mode. To install all the Playwright dependencies, run npx playwright\r\ninstall-deps. You can learn more about Playwright and Continuous Integration from these resources:\r\nNext.js with Playwright example\r\nPlaywright on your CI provider\r\nPlaywright Discord","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1ea4dd5f-e19a-42e9-9b2d-0c853234065d":{"id_":"1ea4dd5f-e19a-42e9-9b2d-0c853234065d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UqhS931B0gNej6h+weHmSHl//Kh+Tx7Kz0FrJDF/A7Y=","metadata":{},"hash":"4flqfsmNAbbWWvE7q+QfW5wknEGgoPvvCNtJW7i/m+c="}},"hash":"ysZ3B44YndvrH1Vt0yG9CrGTdBy/2nYCz8aocjDiybI=","text":"3.1.8.4 - Setting up Cypress with Next.js\r\nDocumentation path: /02-app/01-building-your-application/08-testing/04-cypress\r\nDescription: Learn how to set up Cypress with Next.js for End-to-End (E2E) and Component Testing. Cypress is a test runner used for End-to-End (E2E) and Component Testing. This page will show you how to set up Cypress with\r\nNext.js and write your first tests. Warning:\r\nFor component testing, Cypress currently does not support Next.js version 14 and async Server Components. These\r\nissues are being tracked. For now, component testing works with Next.js version 13, and we recommend E2E testing forasync\r\n Server Components. Cypress currently does not support TypeScript version 5 with moduleResolution:\"bundler\". This issue is being tracked. Quickstart\r\nYou can use create-next-app with the with-cypress example to quickly get started. Terminal (bash)npx create-next-app@latest --example with-cypress with-cypress-app\r\nManual setup\r\nTo manually set up Cypress, install cypress as a dev dependency:\r\nTerminal (bash)npm install -D cypress\r\n# or\r\nyarn add -D cypress\r\n# or\r\npnpm install -D cypress\r\nAdd the Cypress open command to the package.json scripts field:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"next lint\",\r\n    \"cypress:open\": \"cypress open\"\r\n  }\r\n}\r\nRun Cypress for the first time to open the Cypress testing suite:\r\nTerminal (bash)npm run cypress:open\r\nYou can choose to configure E2E Testing and/or Component Testing. Selecting any of these options will automatically create acypress.config.js\r\n file and a cypress folder in your project. Creating your first Cypress E2E test\r\nEnsure your cypress.config.js file has the following configuration:\r\ncypress.config.ts (ts)import { defineConfig } from 'cypress'\r\nexport default defineConfig({\r\n  e2e: {\r\n    setupNodeEvents(on, config) {},\r\n  },\r\n})\r\ncypress.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"209b0341-1c9d-4352-91f1-0ca8a55adf5c":{"id_":"209b0341-1c9d-4352-91f1-0ca8a55adf5c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CGqXk5UmlGo1H3NARRXMqci9pjBTUQuf3X8EC6e24hg=","metadata":{},"hash":"Qzl1/Okts0EKLL/eIwbCPwFAgxFc68EJI0V/EioGlVY="}},"hash":"G5hLqzr6mUE+vbH8fKseOkPHSoe2Gv5Y4gtvQTWVsqo=","text":"const { defineConfig } = require('cypress')\r\nmodule.exports = defineConfig({\r\n  e2e: {\r\n    setupNodeEvents(on, config) {},\r\n  },\r\n})\r\nThen, create two new Next.js files:\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\napp/about/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}\r\npages/index.js (jsx)import Link from 'next/link'\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}\r\npages/about.js (jsx)import Link from 'next/link'\r\nexport default function About() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}\r\nAdd a test to check your navigation is working correctly:\r\ncypress/e2e/app.cy.js (js)describe('Navigation', () => {\r\n  it('should navigate to the about page', () => {\r\n    // Start from the index page\r\n    cy.visit('http://localhost:3000/')\r\n    // Find a link with an href attribute containing \"about\" and click it\r\n    cy.get('a[href*=\"about\"]').click()\r\n    // The new url should include \"/about\"\r\n    cy.url().should('include', '/about')\r\n    // The new page should contain an h1 with \"About\"\r\n    cy.get('h1').contains('About')","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cfdec447-1170-4377-b222-467dad93504d":{"id_":"cfdec447-1170-4377-b222-467dad93504d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0E1kOZQPD5/uV1OltCH47gxv3TC5k3H8H+owyaDStw8=","metadata":{},"hash":"SrFakQ7TXkzjVvk1f39sCInaLikQsZZaRc5CAFA5Tqc="},"NEXT":{"nodeId":"9cb65499-9a05-4aff-83ff-fe167a10cb90","metadata":{},"hash":"m2J/Svzofvmwu1vpsZvBh8Y+pibZ/LXYlGmmuOrM7do="}},"hash":"7IWuK61tI6FaTl1q2CBqYANE3ujBxyVBETWc+FF8Wjo=","text":"})\r\n})\r\nRunning E2E Tests\r\nCypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your\r\ntests against your production code to more closely resemble how your application will behave. Run npm run build && npm run start to build your Next.js application, then run npm run cypress:open in another terminal\r\nwindow to start Cypress and run your E2E testing suite. Good to know:\r\nYou can use cy.visit(\"/\") instead of cy.visit(\"http://localhost:3000/\") by adding baseUrl:\r\n'http://localhost:3000' to the cypress.config.js configuration file. Alternatively, you can install the start-server-and-test package to run the Next.js production server in conjuction with\r\nCypress. After installation, add \"test\": \"start-server-and-test start http://localhost:3000 cypress\" to\r\nyour package.json scripts field. Remember to rebuild your application after new changes. Creating your first Cypress component test\r\nComponent tests build and mount a specific component without having to bundle your whole application or start a server. Select Component Testing in the Cypress app, then select Next.js as your front-end framework. A cypress/component folder will be\r\ncreated in your project, and a cypress.config.js file will be updated to enable component testing.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9cb65499-9a05-4aff-83ff-fe167a10cb90":{"id_":"9cb65499-9a05-4aff-83ff-fe167a10cb90","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0E1kOZQPD5/uV1OltCH47gxv3TC5k3H8H+owyaDStw8=","metadata":{},"hash":"SrFakQ7TXkzjVvk1f39sCInaLikQsZZaRc5CAFA5Tqc="},"PREVIOUS":{"nodeId":"cfdec447-1170-4377-b222-467dad93504d","metadata":{},"hash":"7IWuK61tI6FaTl1q2CBqYANE3ujBxyVBETWc+FF8Wjo="}},"hash":"m2J/Svzofvmwu1vpsZvBh8Y+pibZ/LXYlGmmuOrM7do=","text":"Ensure your cypress.config.js file has the following configuration:\r\ncypress.config.ts (ts)import { defineConfig } from 'cypress'\r\nexport default defineConfig({\r\n  component: {\r\n    devServer: {\r\n      framework: 'next',\r\n      bundler: 'webpack',\r\n    },\r\n  },\r\n})\r\ncypress.config.js (js)const { defineConfig } = require('cypress')\r\nmodule.exports = defineConfig({\r\n  component: {\r\n    devServer: {\r\n      framework: 'next',\r\n      bundler: 'webpack',\r\n    },\r\n  },\r\n})\r\nAssuming the same components from the previous section, add a test to validate a component is rendering the expected output:\r\ncypress/component/about.cy.tsx (tsx)import Page from '../../app/page'\r\ndescribe('<Page />', () => {\r\n  it('should render and display expected content', () => {\r\n    // Mount the React component for the Home page\r\n    cy.mount(<Page />)\r\n    // The new page should contain an h1 with \"Home\"\r\n    cy.get('h1').contains('Home')\r\n    // Validate that a link with the expected URL is present\r\n    // Following the link is better suited to an E2E test\r\n    cy.get('a[href=\"/about\"]').should('be.visible')\r\n  })\r\n})\r\ncypress/component/about.cy.js (jsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e74bd1ad-265c-4492-930f-33c9924875d2":{"id_":"e74bd1ad-265c-4492-930f-33c9924875d2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0+LvYKQbmFx6OAxs3YeKJdmfkLERg37iagD+tpnrgXw=","metadata":{},"hash":"wL4pGAAJg15TIVd+6hbuB5YlaN8c+Y2bBZXOACTPnpg="}},"hash":"gfRfQ4bvjPbmNGulIK9ZqmmcffmrMsJqZbimXTkEPrs=","text":"import AboutPage from '../../pages/about'\r\ndescribe('<AboutPage />', () => {\r\n  it('should render and display expected content', () => {\r\n    // Mount the React component for the About page\r\n    cy.mount(<AboutPage />)\r\n    // The new page should contain an h1 with \"About page\"\r\n    cy.get('h1').contains('About')\r\n    // Validate that a link with the expected URL is present\r\n    // *Following* the link is better suited to an E2E test\r\n    cy.get('a[href=\"/\"]').should('be.visible')\r\n  })\r\n})\r\nGood to know:\r\nCypress currently doesn’t support component testing for async Server Components. We recommend using E2E testing. Since component tests do not require a Next.js server, features like <Image /> that rely on a server being available may\r\nnot function out-of-the-box. Running Component Tests\r\nRun npm run cypress:open in your terminal to start Cypress and run your component testing suite. Continuous Integration (CI)\r\nIn addition to interactive testing, you can also run Cypress headlessly using the cypress run command, which is better suited for CI\r\nenvironments:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    //... \"e2e\": \"start-server-and-test dev http://localhost:3000 \\\"cypress open --e2e\\\"\",\r\n    \"e2e:headless\": \"start-server-and-test dev http://localhost:3000 \\\"cypress run --e2e\\\"\",\r\n    \"component\": \"cypress open --component\",\r\n    \"component:headless\": \"cypress run --component\"\r\n  }\r\n}\r\nYou can learn more about Cypress and Continuous Integration from these resources:\r\nNext.js with Cypress example\r\nCypress Continuous Integration Docs\r\nCypress GitHub Actions Guide\r\nOfficial Cypress GitHub Action\r\nCypress Discord","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1da9343e-1c79-48cf-8adf-083f960ca4d9":{"id_":"1da9343e-1c79-48cf-8adf-083f960ca4d9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HVnXdKWYSU7KpW9NUA8cGQMRGz4uGOfqaADxDTgIGtk=","metadata":{},"hash":"P2hJPgIm7Ll7ZTB51dcklyRT3yrz1MNuw6XKLvxfyaY="},"NEXT":{"nodeId":"7ddb05ed-eb95-4789-9313-20360ebb025c","metadata":{},"hash":"E8ZkyF3Dzje8Tppr4jThCciy2EKp9kaoR9Oj+XiYRI4="}},"hash":"B7j9V1MxQlILntptxVEZfoW2F8YtZupmR+/+TUgghIw=","text":"3.1.9 - Deploying\r\nDocumentation path: /02-app/01-building-your-application/09-deploying/index\r\nDescription: Learn how to deploy your Next.js app to production, either managed or self-hosted. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nCongratulations, it’s time to ship to production. You can deploy managed Next.js with Vercel, or self-host on a Node.js server, Docker image, or even static HTML files. When deploying\r\nusing next start, all Next.js features are supported. Production Builds\r\nRunning next build generates an optimized version of your application for production. HTML, CSS, and JavaScript files are created\r\nbased on your pages. JavaScript is compiled and browser bundles are minified using the Next.js Compiler to help achieve the best\r\nperformance and support all modern browsers. Next.js produces a standard deployment output used by managed and self-hosted Next.js. This ensures all features are supported\r\nacross both methods of deployment. In the next major version, we will be transforming this output into our Build Output API\r\nspecification. Managed Next.js with Vercel\r\nVercel, the creators and maintainers of Next.js, provide managed infrastructure and a developer experience platform for your Next.js\r\napplications. Deploying to Vercel is zero-configuration and provides additional enhancements for scalability, availability, and performance globally. However, all Next.js features are still supported when self-hosted. Learn more about Next.js on Vercel or deploy a template for free to try it out. Self-Hosting\r\nYou can self-host Next.js in three different ways:\r\nA Node.js server\r\nA Docker container\r\nA static export\r\nNode.js Server\r\nNext.js can be deployed to any hosting provider that supports Node.js. Ensure your package.json has the \"build\" and \"start\"\r\nscripts:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}\r\nThen, run npm run build to build your application. Finally, run npm run start to start the Node.js server. This server supports all\r\nNext.js features.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7ddb05ed-eb95-4789-9313-20360ebb025c":{"id_":"7ddb05ed-eb95-4789-9313-20360ebb025c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HVnXdKWYSU7KpW9NUA8cGQMRGz4uGOfqaADxDTgIGtk=","metadata":{},"hash":"P2hJPgIm7Ll7ZTB51dcklyRT3yrz1MNuw6XKLvxfyaY="},"PREVIOUS":{"nodeId":"1da9343e-1c79-48cf-8adf-083f960ca4d9","metadata":{},"hash":"B7j9V1MxQlILntptxVEZfoW2F8YtZupmR+/+TUgghIw="}},"hash":"E8ZkyF3Dzje8Tppr4jThCciy2EKp9kaoR9Oj+XiYRI4=","text":"This server supports all\r\nNext.js features. Docker Image\r\nNext.js can be deployed to any hosting provider that supports Docker containers. You can use this approach when deploying to\r\ncontainer orchestrators such as Kubernetes or when running inside a container in any cloud provider. 1. Install Docker on your machine\r\n2. Clone our example (or the multi-environment example)\r\n3. Build your container: docker build -t nextjs-docker . 4. Run your container: docker run -p 3000:3000 nextjs-docker","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"64601e33-3fa0-499a-b4a0-d4d69f88da35":{"id_":"64601e33-3fa0-499a-b4a0-d4d69f88da35","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"blqZ8rqriO055BE8QnKnKYAp3kD+5QtDlL1d4tOGEzc=","metadata":{},"hash":"EPZv6DxukUrvABi+TZlzsUkMIHnDW6U7jHMoX6SNyAQ="},"NEXT":{"nodeId":"99697b6a-ac80-46e7-b98c-a6163614e9ff","metadata":{},"hash":"LlJdAlzt1VCuEwx5gaV+tPR8Eej5It47AtAgBNr9HHc="}},"hash":"71Bb4inrX8UWcv2kaQGwrdsX7FfOr7U/knZ1XGzDLrc=","text":"Next.js through Docker supports all Next.js features. Static HTML Export\r\nNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a\r\nserver. Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache. Running as a static export does not support Next.js features that require a server. Learn more. Good to know:\r\nServer Components are supported with static exports. Features\r\nImage Optimization\r\nImage Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would\r\nprefer to have a separate service to optimize images, you can configure an image loader. Image Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are\r\noptimized at runtime, not during the build. Good to know:\r\nWhen self-hosting, consider installing sharp for more performant Image Optimization in your production environment by\r\nrunning npm install sharp in your project directory. On Linux platforms, sharp may require additional configuration to\r\nprevent excessive memory usage. Learn more about the caching behavior of optimized images and how to configure the TTL. You can also disable Image Optimization and still retain other benefits of using next/image if you prefer. For example, if\r\nyou are optimizing images yourself separately. Middleware\r\nMiddleware works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming\r\nrequest, it is not supported when using a static export. Middleware uses a runtime that is a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every\r\nroute or asset in your application. This runtime does not require running “at the edge” and works in a single-region server. Additional\r\nconfiguration and infrastructure are required to run Middleware in multiple regions. If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a\r\nlayout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters\r\nto redirect or rewrite through next.config.js. If that does not work, you can also use a custom server.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"99697b6a-ac80-46e7-b98c-a6163614e9ff":{"id_":"99697b6a-ac80-46e7-b98c-a6163614e9ff","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"blqZ8rqriO055BE8QnKnKYAp3kD+5QtDlL1d4tOGEzc=","metadata":{},"hash":"EPZv6DxukUrvABi+TZlzsUkMIHnDW6U7jHMoX6SNyAQ="},"PREVIOUS":{"nodeId":"64601e33-3fa0-499a-b4a0-d4d69f88da35","metadata":{},"hash":"71Bb4inrX8UWcv2kaQGwrdsX7FfOr7U/knZ1XGzDLrc="}},"hash":"LlJdAlzt1VCuEwx5gaV+tPR8Eej5It47AtAgBNr9HHc=","text":"If that does not work, you can also use a custom server. Environment Variables\r\nNext.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be\r\nprefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next\r\nbuild. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. With\r\nthe App Router, we can safely read environment variables on the server during dynamic rendering. This allows you to use a singular\r\nDocker image that can be promoted through multiple environments with different values. import { unstable_noStore as noStore } from 'next/cache';\r\nexport default function Component() {\r\n  noStore();\r\n  // cookies(), headers(), and other dynamic functions\r\n  // will also opt into dynamic rendering, making\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  ... }\r\nGood to know:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ab932ead-3f57-4723-a592-a318c751c444":{"id_":"ab932ead-3f57-4723-a592-a318c751c444","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fKT7U/fCr4pJR8H2/RSAHumLF8jkY/36/Mcz/Ai1UlI=","metadata":{},"hash":"JkpgUQrrUnJRVcABAVO/6r4dv0hMxGDhnWSPkCbuZrI="},"NEXT":{"nodeId":"0f8d09c1-298a-4431-bdaf-a99f0dec9471","metadata":{},"hash":"v6tLHizCXNKRFo2+6jSiR7RBs96OD3cRUFlboi5WFF0="}},"hash":"qhVs83gftd4HsmX3KJya6WCJEkwcZmr500zZJ+My+hU=","text":"You can run code on server startup using the register function. We do not recommend using the runtimeConfig option, as this does not work with the standalone output mode. Instead, we\r\nrecommend incrementally adopting the App Router. Caching and ISR\r\nNext.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts. Caching and revalidating pages (using Incremental Static Regeneration (ISR) or newer functions in the App Router) use the same\r\nshared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-\r\nhosting using both the Pages and App Router. You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across\r\nmultiple containers or instances of your Next.js application. Automatic Caching\r\nNext.js sets the Cache-Control header of public, max-age=31536000, immutable to truly immutable assets. It cannot be\r\noverridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static\r\nImage Imports. You can configure the TTL for images. Incremental Static Regeneration (ISR) sets the Cache-Control header of s-maxage: <revalidate in getStaticProps>,\r\nstale-while-revalidate. This revalidation time is defined in your getStaticProps function in seconds. If you set\r\nrevalidate: false, it will default to a one-year cache duration. Dynamically rendered pages set a Cache-Control header of private, no-cache, no-store, max-age=0, must-\r\nrevalidate to prevent user-specific data from being cached. This applies to both the App Router and Pages Router. This also\r\nincludes Draft Mode. Static Assets\r\nIf you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the\r\ndownside of extra time spent on DNS and TLS resolution. Learn more about assetPrefix. Configuring Caching\r\nBy default, generated cache assets will be stored in memory (defaults to 50mb) and on disk.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0f8d09c1-298a-4431-bdaf-a99f0dec9471":{"id_":"0f8d09c1-298a-4431-bdaf-a99f0dec9471","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fKT7U/fCr4pJR8H2/RSAHumLF8jkY/36/Mcz/Ai1UlI=","metadata":{},"hash":"JkpgUQrrUnJRVcABAVO/6r4dv0hMxGDhnWSPkCbuZrI="},"PREVIOUS":{"nodeId":"ab932ead-3f57-4723-a592-a318c751c444","metadata":{},"hash":"qhVs83gftd4HsmX3KJya6WCJEkwcZmr500zZJ+My+hU="}},"hash":"v6tLHizCXNKRFo2+6jSiR7RBs96OD3cRUFlboi5WFF0=","text":"If you are hosting Next.js using a container\r\norchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache\r\nis not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching. To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file:\r\nnext.config.js (jsx)module.exports = {\r\n  experimental: {\r\n    incrementalCacheHandlerPath: require.resolve('./cache-handler.js'),\r\n    isrMemoryCacheSize: 0, // disable default in-memory caching\r\n  },\r\n}\r\nThen, create cache-handler.js in the root of your project, for example:\r\ncache-handler.js (jsx)const cache = new Map()\r\nmodule.exports = class CacheHandler {\r\n  constructor(options) {\r\n    this.options = options\r\n  }\r\n  async get(key) {\r\n    // This could be stored anywhere, like durable storage\r\n    return cache.get(key)\r\n  }\r\n  async set(key, data, ctx) {\r\n    // This could be stored anywhere, like durable storage\r\n    cache.set(key, {\r\n      value: data,\r\n      lastModified: Date.now(),\r\n      tags: ctx.tags,\r\n    })","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"873ab78f-1afe-4b01-b07b-a12ca6846bf2":{"id_":"873ab78f-1afe-4b01-b07b-a12ca6846bf2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bb+u5ubdsM6w0cLXfxuH/TsVXxGPvAMix8Jwfri2o6k=","metadata":{},"hash":"fjmkN2JhNet2/UU6d92XRwFPbioZePSn92q1tjbkQZI="},"NEXT":{"nodeId":"f1129886-1e33-4ed0-bd53-68f21c04dd82","metadata":{},"hash":"ZF+EVcLkttV990TgB8T0fT+St7k7qV3G6BVkCpA/lFY="}},"hash":"W8abTsxZQXibNpnkTBUfRqD38B5uck/U1lrmNbSE/RA=","text":"}\r\n  async revalidateTag(tag) {\r\n    // Iterate over all entries in the cache\r\n    for (let [key, value] of cache) {\r\n      // If the value's tags include the specified tag, delete this entry\r\n      if (value.tags.includes(tag)) {\r\n        cache.delete(key)\r\n      }\r\n    }\r\n  }\r\n}\r\nUsing a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you\r\ncan save the cached values anywhere, like Redis or AWS S3. Good to know:\r\nrevalidatePath is a convenience layer on top of cache tags. Calling revalidatePath will call the revalidateTag\r\nfunction with a special default tag for the provided page. Build Cache\r\nNext.js generates an ID during next build to identify which version of your application is being served. The same build should be used\r\nand boot up multiple containers. If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use\r\nthe generateBuildId command in next.config.js:\r\nnext.config.js (jsx)module.exports = {\r\n  generateBuildId: async () => {\r\n    // This could be anything, using the latest git hash\r\n    return process.env.GIT_HASH\r\n  },\r\n}\r\nVersion Skew\r\nNext.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when\r\ndetected. For example, if there is a mismatch in the build ID, transitions between pages will perform a hard navigation versus using a\r\nprefetched value. When the application is reloaded, there may be a loss of application state if it’s not designed to persist between page navigations. For\r\nexample, using URL state or local storage would persist state after a page refresh. However, component state like useState would be\r\nlost in such navigations. Vercel provides additional skew protection for Next.js applications to ensure assets and functions from the previous build are still\r\navailable while the new build is being deployed. Manual Graceful Shutdowns\r\nWhen self-hosting, you might want to run code when the server shuts down on SIGTERM or SIGINT signals. You can set the env variable NEXT_MANUAL_SIG_HANDLE to true and then register a handler for that signal inside your _document.js\r\nfile. You will need to register the environment variable directly in the package.json script, and not in the .env file.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1129886-1e33-4ed0-bd53-68f21c04dd82":{"id_":"f1129886-1e33-4ed0-bd53-68f21c04dd82","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bb+u5ubdsM6w0cLXfxuH/TsVXxGPvAMix8Jwfri2o6k=","metadata":{},"hash":"fjmkN2JhNet2/UU6d92XRwFPbioZePSn92q1tjbkQZI="},"PREVIOUS":{"nodeId":"873ab78f-1afe-4b01-b07b-a12ca6846bf2","metadata":{},"hash":"W8abTsxZQXibNpnkTBUfRqD38B5uck/U1lrmNbSE/RA="}},"hash":"ZF+EVcLkttV990TgB8T0fT+St7k7qV3G6BVkCpA/lFY=","text":"Good to know: Manual signal handling is not available in next dev. package.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"NEXT_MANUAL_SIG_HANDLE=true next start\"\r\n  }\r\n}\r\npages/_document.js (js)if (process.env.NEXT_MANUAL_SIG_HANDLE) {\r\n  process.on('SIGTERM', () => {\r\n    console.log('Received SIGTERM: cleaning up')","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0726ba57-99c3-4ba2-ab74-0dda35e3d7d1":{"id_":"0726ba57-99c3-4ba2-ab74-0dda35e3d7d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rCAFeDrXQvVXdGrxD+ez7Ag5Zt/qVtDeWXIi8u1DJVM=","metadata":{},"hash":"Mus9EjszM4lARYF3gcJsc858uMxmyY/3rzb+SwwpIjI="}},"hash":"3nNX9lbLAtH5AMEUsGSB9lCyR34bR32yMlM2ZcKYIDM=","text":"process.exit(0)\r\n  })\r\n  process.on('SIGINT', () => {\r\n    console.log('Received SIGINT: cleaning up')\r\n    process.exit(0)\r\n  })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"90b71479-9fae-4933-bc58-3956f7c190b2":{"id_":"90b71479-9fae-4933-bc58-3956f7c190b2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tZrRn6av7DCNbFgDC0Ftek3ekGUr2X4bIj6EPgoD15o=","metadata":{},"hash":"qLbz/7pafwRASXr3I88iXxwQUTPbArKEgFYABQKkyOM="},"NEXT":{"nodeId":"52291ab7-0764-4345-9fbf-54f5cbb1bac6","metadata":{},"hash":"v5r/JrwnEAsyd2ebuA3kxXBJxKe3bEDBdgJCx/0kfHU="}},"hash":"wiM/nzCJT0eThAYfvOOEhidWXhudBB9bRPXQOcdIryM=","text":"3.1.9.1 - Static Exports\r\nDocumentation path: /02-app/01-building-your-application/09-deploying/01-static-exports\r\nDescription: Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features\r\nthat require a server. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a\r\nserver. When running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can\r\navoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads. Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. Good to know: We recommend using the App Router for enhanced static export support. Configuration\r\nTo enable a static export, change the output mode inside next.config.js:\r\n```js filename=”next.config.js” highlight={5} /* * @type {import(‘next’).NextConfig} / const nextConfig = { output: ‘export’,\r\n// Optional: Change links /me -> /me/ and emit /me.html -> /me/index.html // trailingSlash: true,\r\n// Optional: Prevent automatic /me -> /me/, instead preserve href // skipTrailingSlashRedirect: true,\r\n// Optional: Change the output directory out -> dist // distDir: ‘dist’, }\r\nmodule.exports = nextConfig\r\nAfter running `next build`, Next.js will produce an `out` folder which contains the HTML/CSS/JS assets for\r\n<PagesOnly>\r\nYou can utilize [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) and\r\n</PagesOnly>\r\n<AppOnly>\r\n## Supported Features\r\nThe core of Next.js has been designed to support static exports.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"52291ab7-0764-4345-9fbf-54f5cbb1bac6":{"id_":"52291ab7-0764-4345-9fbf-54f5cbb1bac6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tZrRn6av7DCNbFgDC0Ftek3ekGUr2X4bIj6EPgoD15o=","metadata":{},"hash":"qLbz/7pafwRASXr3I88iXxwQUTPbArKEgFYABQKkyOM="},"PREVIOUS":{"nodeId":"90b71479-9fae-4933-bc58-3956f7c190b2","metadata":{},"hash":"wiM/nzCJT0eThAYfvOOEhidWXhudBB9bRPXQOcdIryM="}},"hash":"v5r/JrwnEAsyd2ebuA3kxXBJxKe3bEDBdgJCx/0kfHU=","text":"### Server Components\r\nWhen you run `next build` to generate a static export, Server Components consumed inside the `app` directory\r\nThe resulting component will be rendered into static HTML for the initial page load and a static payload for\r\n<div class=\"code-header\"><i>app/page.tsx (tsx)</i></div>\r\n```tsx\r\nexport default async function Page() {\r\n  // This fetch will run on the server during `next build`\r\n  const res = await fetch('https://api.example.com/... ')\r\n  const data = await res.json()\r\n  return <main>...</main>\r\n}\r\nClient Components\r\nIf you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests. app/other/page.tsx (tsx)'use client'\r\nimport useSWR from 'swr'\r\nconst fetcher = (url: string) => fetch(url).then((r) => r.json())\r\nexport default function Page() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"60f41cd6-6178-4e85-9b8e-ff8ebe75d105":{"id_":"60f41cd6-6178-4e85-9b8e-ff8ebe75d105","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6Lo4zQwc7djC0EuiTtNTxXlaqCTQx25ote99Go/UyOo=","metadata":{},"hash":"pgBeSWpR5B5/IakxgWo/On4f0so3TwbIekdEmxemiZ4="}},"hash":"iv10aPkCWB8Ve7T21ecezJetNAmTDwG84My4t9OGuWc=","text":"const { data, error } = useSWR(\r\n    `https://jsonplaceholder.typicode.com/posts/1`,\r\n    fetcher\r\n  )\r\n  if (error) return 'Failed to load'\r\n  if (!data) return 'Loading... '\r\n  return data.title\r\n}\r\napp/other/page.js (jsx)'use client'\r\nimport useSWR from 'swr'\r\nconst fetcher = (url) => fetch(url).then((r) => r.json())\r\nexport default function Page() {\r\n  const { data, error } = useSWR(\r\n    `https://jsonplaceholder.typicode.com/posts/1`,\r\n    fetcher\r\n  )\r\n  if (error) return 'Failed to load'\r\n  if (!data) return 'Loading... '\r\n  return data.title\r\n}\r\nSince route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to\r\nnavigate to different posts on the client:\r\napp/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>Index Page</h1>\r\n      <hr />\r\n      <ul>\r\n        <li>\r\n          <Link href=\"/post/1\">Post 1</Link>\r\n        </li>\r\n        <li>\r\n          <Link href=\"/post/2\">Post 2</Link>\r\n        </li>\r\n      </ul>\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>Index Page</h1>\r\n      <p>\r\n        <Link href=\"/other\">Other Page</Link>\r\n      </p>\r\n    </>\r\n  )\r\n}\r\nSupported Features\r\nThe majority of core Next.js features needed to build a static site are supported, including:\r\nDynamic Routes when using getStaticPaths\r\nPrefetching with next/link\r\nPreloading JavaScript\r\nDynamic Imports","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"968804c7-3cea-43ac-bdc2-5af442a84e19":{"id_":"968804c7-3cea-43ac-bdc2-5af442a84e19","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eAHlutXEJPqPUs93BYMxk2rulC6ReLjHWrLCRTds2MU=","metadata":{},"hash":"luoi0IF+Haer9flO3OKJZEXgvaMlVbZFJgOAemLqfzQ="}},"hash":"LNhLlnqR5W7iPL6ARPfYWOQix9jZvumB4VUee3GMggM=","text":"Any styling options (e.g. CSS Modules, styled-jsx)\r\nClient-side data fetchinggetStaticProps\r\ngetStaticPaths\r\nImage Optimization\r\nImage Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For\r\nexample, you can optimize images with a service like Cloudinary:\r\nnext.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export',\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my-loader.ts',\r\n  },\r\n}\r\nmodule.exports = nextConfig\r\nThis custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for\r\nCloudinary:\r\nmy-loader.ts (ts)export default function cloudinaryLoader({\r\n  src,\r\n  width,\r\n  quality,\r\n}: {\r\n  src: string\r\n  width: number\r\n  quality?: number\r\n}) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\r\n    ','\r\n  )}${src}`\r\n}\r\nmy-loader.js (js)export default function cloudinaryLoader({ src, width, quality }) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\r\n    ','\r\n  )}${src}`\r\n}\r\nYou can then use next/image in your application, defining relative paths to the image in Cloudinary:\r\napp/page.tsx (tsx)import Image from 'next/image'\r\nexport default function Page() {\r\n  return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} />\r\n}\r\napp/page.js (jsx)import Image from 'next/image'\r\nexport default function Page() {\r\n  return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} />\r\n}\r\nRoute Handlers\r\nRoute Handlers will render a static response when running next build. Only the GET HTTP verb is supported. This can be used to\r\ngenerate static HTML, JSON, TXT, or other files from cached or uncached data. For example:\r\napp/data.json/route.ts (ts)export async function GET() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"be13f415-0e23-42da-bfb9-dc384ccf255d":{"id_":"be13f415-0e23-42da-bfb9-dc384ccf255d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dWW3TrEJfiMNgTkZokw64for8QwT08PQFqQM5TBlTiQ=","metadata":{},"hash":"Ky1gkH7OXg7K8MXi3GTfrXN2dE9eLYIeN1JTxDZmNd8="}},"hash":"GESoWBIVMQZtqHzLUUS1sn4bLm0uGEyRrBFxyictf+E=","text":"return Response.json({ name: 'Lee' })\r\n}\r\napp/data.json/route.js (js)export async function GET() {\r\n  return Response.json({ name: 'Lee' })\r\n}\r\nThe above file app/data.json/route.ts will render to a static file during next build, producing data.json containing { name:\r\n'Lee' }. If you need to read dynamic values from the incoming request, you cannot use a static export. Browser APIs\r\nClient Components are pre-rendered to HTML during next build. Because Web APIs like window, localStorage, and navigator are\r\nnot available on the server, you need to safely access these APIs only when running in the browser. For example:\r\n'use client';\r\nimport { useEffect } from 'react';\r\nexport default function ClientComponent() {\r\n  useEffect(() => {\r\n    // You now have access to `window`\r\n    console.log(window.innerHeight);\r\n  }, [])\r\n  return ...;\r\n}\r\nUnsupported Features\r\nFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported:\r\nDynamic Routes with dynamicParams: true\r\nDynamic Routes without generateStaticParams()\r\nRoute Handlers that rely on Request\r\nCookies\r\nRewrites\r\nRedirects\r\nHeaders\r\nMiddleware\r\nIncremental Static Regeneration\r\nImage Optimization with the default loader\r\nDraft Mode\r\nAttempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the\r\nroot layout. export const dynamic = 'error'\r\nInternationalized Routing\r\nAPI Routes\r\nRewrites\r\nRedirects\r\nHeaders\r\nMiddleware\r\nIncremental Static Regeneration\r\nImage Optimization with the default loader\r\nDraft ModegetStaticPaths\r\n with fallback: true\r\ngetStaticPaths with fallback: 'blocking'\r\ngetServerSideProps\r\nDeploying","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"da4cb722-5d11-4356-8f95-db3e1c5af3e2":{"id_":"da4cb722-5d11-4356-8f95-db3e1c5af3e2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/qyjrXaSKcNFuz+uaPsmeqItlbolTV8+YyfPgYX6W8o=","metadata":{},"hash":"gHZQyWAwPcFWfO+UjYMRvOU5BKbV/dk9PfGrK9SFMuc="}},"hash":"QDZDP95tWRVL9nI2sb07RKLMeg9P0bjj1127grGY1fQ=","text":"With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. When running next build, Next.js generates the static export into the out folder. For example, let’s say you have the following routes:\r\n/\r\n/blog/[id]\r\nAfter running next build, Next.js will generate the following files:\r\n/out/index.html\r\n/out/404.html\r\n/out/blog/post-1.html\r\n/out/blog/post-2.html\r\nIf you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:\r\nnginx.conf (nginx)server {\r\n  listen 80;\r\n  server_name acme.com;\r\n  root /var/www/out;\r\n  location / {\r\n      try_files $uri $uri.html $uri/ =404;\r\n  }\r\n  # This is necessary when `trailingSlash: false`. # You can omit this when `trailingSlash: true`. location /blog/ {\r\n      rewrite ^/blog/(.*)$ /blog/$1.html break;\r\n  }\r\n  error_page 404 /404.html;\r\n  location = /404.html {\r\n      internal;\r\n  }\r\n}\r\nVersion History\r\nVersionChanges\r\nv14.0.0next export has been removed in favor of \"output\": \"export\"\r\nv13.4.0App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers. v13.3.0next export is deprecated and replaced with \"output\": \"export\"","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ec6aaa52-dbdd-415f-842b-baeb2ace3a77":{"id_":"ec6aaa52-dbdd-415f-842b-baeb2ace3a77","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RvwXW36JO/t0cE0qyPyamg5FRpDbTQQ/SERT4HFEwI0=","metadata":{},"hash":"oNyBs5VLJXKLaQicyueaTuYpcw+/EHkT4uElAAysdCc="}},"hash":"+Jauvsfiuf2Lz5UwB8Of7BgUVB3LycxS8RPLYrxmtAg=","text":"3.1.10 - Upgrade Guide\r\nDocumentation path: /02-app/01-building-your-application/10-upgrading/index\r\nDescription: Learn how to upgrade to the latest versions of Next.js. Upgrade your application to newer versions of Next.js or migrate from the Pages Router to the App Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8f88129d-dfc6-4bd3-99fc-25460c779f5e":{"id_":"8f88129d-dfc6-4bd3-99fc-25460c779f5e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UXBje2gnR0rvxBRq8eTaynAMWoX9GvuhXF7kRJQJn+U=","metadata":{},"hash":"3sEJIywCabdgZTBtJUcIgD4jkiTjv44i07frSewhFzY="}},"hash":"vRwVLKxGTXCHqMP0CDhuz6yhSjkVmYY16c8NBFr6TZk=","text":"3.1.10.1 - Codemods\r\nDocumentation path: /02-app/01-building-your-application/10-upgrading/01-codemods\r\nDescription: Use codemods to upgrade your Next.js codebase when new features are released. Codemods are transformations that run on your codebase programmatically. This allows a large number of changes to be\r\nprogrammatically applied without having to manually go through every file. Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated. Usage\r\nIn your terminal, navigate (cd) into your project’s folder, then run:\r\nTerminal (bash)npx @next/codemod <transform> <path>\r\nReplacing <transform> and <path> with appropriate values. transform - name of transform\r\npath - files or directory to transform\r\n--dry Do a dry-run, no code will be edited\r\n--print Prints the changed output for comparison\r\nNext.js Codemods\r\n14.0\r\nMigrate ImageResponseImageResponse imports\r\nnext-og-importnext-og-import\r\nTerminal (bash)npx @next/codemod@latest next-og-import . This codemod moves transforms imports from next/server to next/og for usage of Dynamic OG Image Generation. For example:\r\nimport { ImageResponse } from 'next/server'\r\nTransforms into:\r\nimport { ImageResponse } from 'next/og'\r\nUse viewportviewport export\r\nmetadata-to-viewport-exportmetadata-to-viewport-export\r\nTerminal (bash)npx @next/codemod@latest metadata-to-viewport-export . This codemod migrates certain viewport metadata to viewport export. For example:\r\nexport const metadata = {\r\n  title: 'My App',\r\n  themeColor: 'dark',\r\n  viewport: {\r\n    width: 1,\r\n  },\r\n}\r\nTransforms into:\r\nexport const metadata = {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6b858199-9383-44d3-8f0b-cc6aeff5d7c0":{"id_":"6b858199-9383-44d3-8f0b-cc6aeff5d7c0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uMZBil0BlHfkblpoIGVhkUzdz/ftqLwNe8JjhaltQqY=","metadata":{},"hash":"pUyxKKjShxDTa6WM5MEIsNgzN9UwUfCuuUyGSPxpkME="}},"hash":"dufrAr5Q8dCD9ULzySuhWKLSDiVZNfwjAIAlg5zY63w=","text":"title: 'My App',\r\n}\r\nexport const viewport = {\r\n  width: 1,\r\n  themeColor: 'dark',\r\n}\r\n13.2\r\nUse Built-in Font\r\nbuilt-in-next-fontbuilt-in-next-font\r\nTerminal (bash)npx @next/codemod@latest built-in-next-font . This codemod uninstalls the @next/font package and transforms @next/font imports into the built-in next/font. For example:\r\nimport { Inter } from '@next/font/google'\r\nTransforms into:\r\nimport { Inter } from 'next/font/google'\r\n13.0\r\nRename Next Image Imports\r\nnext-image-to-legacy-imagenext-image-to-legacy-image\r\nTerminal (bash)npx @next/codemod@latest next-image-to-legacy-image . Safely renames next/image imports in existing Next.js 10, 11, or 12 applications to next/legacy/image in Next.js 13. Also renames\r\nnext/future/image to next/image. For example:\r\npages/index.js (jsx)import Image1 from 'next/image'\r\nimport Image2 from 'next/future/image'\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\r\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\r\n    </div>\r\n  )\r\n}\r\nTransforms into:\r\npages/index.js (jsx)// 'next/image' becomes 'next/legacy/image'\r\nimport Image1 from 'next/legacy/image'\r\n// 'next/future/image' becomes 'next/image'\r\nimport Image2 from 'next/image'\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\r\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\r\n    </div>\r\n  )\r\n}\r\nMigrate to the New Image Component","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7aa91ecc-1873-4c96-9980-8bd7d857c539":{"id_":"7aa91ecc-1873-4c96-9980-8bd7d857c539","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cUya4aZ/jqUliH6o5rS+w7SWiXX5sZ9mkEeVEwpnVVA=","metadata":{},"hash":"flG17FycG2stAED4FBgsQwx5ozPcwko5dqBFSqDVy+g="}},"hash":"1JeWgVAtvRd5myAw4iANvC0K5f4ueFYiR3/QfQ+UPjY=","text":"next-image-experimentalnext-image-experimental\r\nTerminal (bash)npx @next/codemod@latest next-image-experimental . Dangerously migrates from next/legacy/image to the new next/image by adding inline styles and removing unused props. Removes layout prop and adds style. Removes objectFit prop and adds style. Removes objectPosition prop and adds style. Removes lazyBoundary prop. Removes lazyRoot prop. Remove <a><a> Tags From Link Components\r\nnew-linknew-link\r\nTerminal (bash)npx @next/codemod@latest new-link . Remove <a> tags inside Link Components, or add a legacyBehavior prop to Links that cannot be auto-fixed. Remove <a> tags inside Link Components, or add a legacyBehavior prop to Links that cannot be auto-fixed. For example:\r\n<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n// transforms into\r\n<Link href=\"/about\">\r\n  About\r\n</Link>\r\n<Link href=\"/about\">\r\n  <a onClick={() => console.log('clicked')}>About</a>\r\n</Link>\r\n// transforms into\r\n<Link href=\"/about\" onClick={() => console.log('clicked')}>\r\n  About\r\n</Link>\r\nIn cases where auto-fixing can’t be applied, the legacyBehavior prop is added. This allows your app to keep functioning using the old\r\nbehavior for that particular link. const Component = () => <a>About</a>\r\n<Link href=\"/about\">\r\n  <Component />\r\n</Link>\r\n// becomes\r\n<Link href=\"/about\" legacyBehavior>\r\n  <Component />\r\n</Link>\r\n11\r\nMigrate from CRA\r\ncra-to-nextcra-to-next\r\nTerminal (bash)npx @next/codemod cra-to-next\r\nMigrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only\r\nrendering is leveraged initially to prevent breaking compatibility due to window usage during SSR and can be enabled seamlessly to\r\nallow the gradual adoption of Next.js specific features. Please share any feedback related to this transform in this discussion. 10","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9c91d2dd-84ea-451b-babf-3773d852c4c6":{"id_":"9c91d2dd-84ea-451b-babf-3773d852c4c6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EGP3dXWknOnn2bDY1vrNiSnkR7/X4LBLtT5ilo53Y3Q=","metadata":{},"hash":"P2H0L56ASAr5J+7fXh81ImNQvOLK008sKV3/jlXVtHM="}},"hash":"us77vc05vPrXzxZzE4c6muodCEXOliZJEZhnlrsgrFY=","text":"Add React imports\r\nadd-missing-react-importadd-missing-react-import\r\nTerminal (bash)npx @next/codemod add-missing-react-import\r\nTransforms files that do not import React to include the import in order for the new React JSX transform to work. For example:\r\nmy-component.js (jsx)export default class Home extends React.Component {\r\n  render() {\r\n    return <div>Hello World</div>\r\n  }\r\n}\r\nTransforms into:\r\nmy-component.js (jsx)import React from 'react'\r\nexport default class Home extends React.Component {\r\n  render() {\r\n    return <div>Hello World</div>\r\n  }\r\n}\r\n9\r\nTransform Anonymous Components into Named Components\r\nname-default-componentname-default-component\r\nTerminal (bash)npx @next/codemod name-default-component\r\nVersions 9 and above. Transforms anonymous components into named components to make sure they work with Fast Refresh. For example:\r\nmy-component.js (jsx)export default function () {\r\n  return <div>Hello World</div>\r\n}\r\nTransforms into:\r\nmy-component.js (jsx)export default function MyComponent() {\r\n  return <div>Hello World</div>\r\n}\r\nThe component will have a camel-cased name based on the name of the file, and it also works with arrow functions. 8\r\nTransform AMP HOC into page config\r\nwithamp-to-configwithamp-to-config\r\nTerminal (bash)npx @next/codemod withamp-to-config\r\nTransforms the withAmp HOC into Next.js 9 page configuration. For example:\r\n// Before\r\nimport { withAmp } from 'next/amp'\r\nfunction Home() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2038bfec-8e71-43a1-89ca-f194aa6f6dfb":{"id_":"2038bfec-8e71-43a1-89ca-f194aa6f6dfb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"F025vLjFJzGdgyzN+/dwsu9tadFk8PLkdLxXPa/LNXo=","metadata":{},"hash":"VcIJk7NvWTBsSTv3EZ361fc997sbICBhB3MWqlHMySo="}},"hash":"DHmotX7YA5xs9fzhI65+RcZgi3QVVIk1zTX25vnce7o=","text":"return <h1>My AMP Page</h1>\r\n}\r\nexport default withAmp(Home)\r\n// After\r\nexport default function Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\nexport const config = {\r\n  amp: true,\r\n}\r\n6\r\nUse withRouterwithRouter\r\nurl-to-withrouterurl-to-withrouter\r\nTerminal (bash)npx @next/codemod url-to-withrouter\r\nTransforms the deprecated automatically injected url property on top level pages to using withRouter and the router property it\r\ninjects. Read more here: https://nextjs.org/docs/messages/url-deprecated\r\nFor example:\r\nFrom (js)import React from 'react'\r\nexport default class extends React.Component {\r\n  render() {\r\n    const { pathname } = this.props.url\r\n    return <div>Current pathname: {pathname}</div>\r\n  }\r\n}\r\nTo (js)import React from 'react'\r\nimport { withRouter } from 'next/router'\r\nexport default withRouter(\r\n  class extends React.Component {\r\n    render() {\r\n      const { pathname } = this.props.router\r\n      return <div>Current pathname: {pathname}</div>\r\n    }\r\n  }\r\n)\r\nThis is one case. All the cases that are transformed (and tested) can be found in the __testfixtures__ directory.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"59f8ae41-9aaf-4630-a174-3733aa89cb43":{"id_":"59f8ae41-9aaf-4630-a174-3733aa89cb43","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7frVgsXOJi5kc0nD0nTEZUzvuOmvyjHm1RoOnB81Bc8=","metadata":{},"hash":"RpHgLXGLzck2rDLgUoO1sY/Aw4LI8sJ03cfACKOMkO8="},"NEXT":{"nodeId":"55d6e89a-94ee-48a3-91d9-a4ffc46bd292","metadata":{},"hash":"3x4RXd/Z6slitxIHNmyhBKFE+uBQjaWJU5NctjUpTZ0="}},"hash":"1er6PggPgHPd5ELg0R/YJo6bPBpPboJ1lUUkQfG/B4A=","text":"3.1.10.2 - App Router Incremental Adoption Guide\r\nDocumentation path: /02-app/01-building-your-application/10-upgrading/02-app-router-migration\r\nDescription: Learn how to upgrade your existing Next.js application from the Pages Router to the App Router. This guide will help you:\r\nUpdate your Next.js application from version 12 to version 13\r\nUpgrade features that work in both the pages and the app directories\r\nIncrementally migrate your existing application from pages to app\r\nUpgrading\r\nNode.js Version\r\nThe minimum Node.js version is now v18.17. See the Node.js documentation for more information. Next.js Version\r\nTo update to Next.js version 13, run the following command using your preferred package manager:\r\nTerminal (bash)npm install next@latest react@latest react-dom@latest\r\nESLint Version\r\nIf you’re using ESLint, you need to upgrade your ESLint version:\r\nTerminal (bash)npm install -D eslint-config-next@latest\r\nGood to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command\r\nPalette (cmd+shift+p on Mac; ctrl+shift+p on Windows) and search for ESLint: Restart ESLint Server. Next Steps\r\nAfter you’ve updated, see the following sections for next steps:\r\nUpgrade new features: A guide to help you upgrade to new features such as the improved Image and Link Components. Migrate from the pages to app directory: A step-by-step guide to help you incrementally migrate from the pages to the app\r\ndirectory. Upgrading New Features\r\nNext.js 13 introduced the new App Router with new features and conventions. The new Router is available in the app directory and co-\r\nexists with the pages directory. Upgrading to Next.js 13 does not require using the new App Router. You can continue using pages with new features that work in both\r\ndirectories, such as the updated Image component, Link component, Script component, and Font optimization. <Image/><Image/> Component\r\nNext.js 12 introduced new improvements to the Image Component with a temporary import: next/future/image. These\r\nimprovements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy\r\nloading. In version 13, this new behavior is now the default for next/image.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"55d6e89a-94ee-48a3-91d9-a4ffc46bd292":{"id_":"55d6e89a-94ee-48a3-91d9-a4ffc46bd292","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7frVgsXOJi5kc0nD0nTEZUzvuOmvyjHm1RoOnB81Bc8=","metadata":{},"hash":"RpHgLXGLzck2rDLgUoO1sY/Aw4LI8sJ03cfACKOMkO8="},"PREVIOUS":{"nodeId":"59f8ae41-9aaf-4630-a174-3733aa89cb43","metadata":{},"hash":"1er6PggPgHPd5ELg0R/YJo6bPBpPboJ1lUUkQfG/B4A="}},"hash":"3x4RXd/Z6slitxIHNmyhBKFE+uBQjaWJU5NctjUpTZ0=","text":"In version 13, this new behavior is now the default for next/image. There are two codemods to help you migrate to the new Image Component:\r\nnext-image-to-legacy-imagenext-image-to-legacy-image codemod: Safely and automatically renames next/image imports to next/legacy/image. Existing components will maintain the same behavior.next-image-experimentalnext-image-experimental\r\n codemod: Dangerously adds inline styles and removes unused props. This will change the behavior\r\nof existing components to match the new defaults. To use this codemod, you need to run the next-image-to-legacy-image\r\ncodemod first.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4023f3ab-a061-436d-8fc3-dd436b57aa55":{"id_":"4023f3ab-a061-436d-8fc3-dd436b57aa55","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3DCBOjPkEC+bZ0trl0lfT8VZrVK90Wf50hYShXL9NsU=","metadata":{},"hash":"RitXL8y0EtkyvhWDk5PIGOBUD7wcTyqEIwzb//uSX6A="},"NEXT":{"nodeId":"cd5f10db-33e8-4429-ad42-2382ae594661","metadata":{},"hash":"abIfdtIWuboIowk1WSMRf6WGJHLNj8McHk+t4qmouTs="}},"hash":"Z+y//PtCad/rsYw09wcnUzV5Ut0NoBqrfdlqOpC3Sjk=","text":"<Link><Link> Component\r\nThe <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option\r\nin version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag. For example:\r\nimport Link from 'next/link'\r\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\r\n<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n// Next.js 13: `<Link>` always renders `<a>` under the hood\r\n<Link href=\"/about\">\r\n  About\r\n</Link>\r\nTo upgrade your links to Next.js 13, you can use the new-link codemod. <Script><Script> Component\r\nThe behavior of next/script has been updated to support both pages and app, but some changes need to be made to ensure a\r\nsmooth migration:\r\nMove any beforeInteractive scripts you previously included in _document.js to the root layout file (app/layout.tsx). The experimental worker strategy does not yet work in app and scripts denoted with this strategy will either have to be removed\r\nor modified to use a different strategy (e.g. lazyOnload). onLoad, onReady, and onError handlers will not work in Server Components so make sure to move them to a Client Component\r\nor remove them altogether. Font Optimization\r\nPreviously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you\r\nthe ability to customize your font loading experience while still ensuring great performance and privacy. next/font is supported in\r\nboth the pages and app directories. While inlining CSS still works in pages, it does not work in app. You should use next/font instead. See the Font Optimization page to learn how to use next/font. Migrating from pagespages to appapp\r\n\u0000 Watch: Learn how to incrementally adopt the App Router → YouTube (16 minutes). Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components,\r\nSuspense, and more. When combined with new Next.js features such as special files and layouts, migration means new concepts,\r\nmental models, and behavioral changes to learn. We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cd5f10db-33e8-4429-ad42-2382ae594661":{"id_":"cd5f10db-33e8-4429-ad42-2382ae594661","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3DCBOjPkEC+bZ0trl0lfT8VZrVK90Wf50hYShXL9NsU=","metadata":{},"hash":"RitXL8y0EtkyvhWDk5PIGOBUD7wcTyqEIwzb//uSX6A="},"PREVIOUS":{"nodeId":"4023f3ab-a061-436d-8fc3-dd436b57aa55","metadata":{},"hash":"Z+y//PtCad/rsYw09wcnUzV5Ut0NoBqrfdlqOpC3Sjk="}},"hash":"abIfdtIWuboIowk1WSMRf6WGJHLNj8McHk+t4qmouTs=","text":"We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. The app\r\ndirectory is intentionally designed to work simultaneously with the pages directory to allow for incremental page-by-page migration. The app directory supports nested routes and layouts. Learn more. Use nested folders to define routes and a special page.js file to make a route segment publicly accessible. Learn more. Special file conventions are used to create UI for each route segment. The most common special files are page.js and layout.js. Use page.js to define UI unique to a route. Use layout.js to define UI that is shared across multiple routes. .js, .jsx, or .tsx file extensions can be used for special files. You can colocate other files inside the app directory such as components, styles, tests, and more. Learn more. Data fetching functions like getServerSideProps and getStaticProps have been replaced with a new API inside app. getStaticPaths has been replaced with generateStaticParams. pages/_app.js and pages/_document.js have been replaced with a single app/layout.js root layout. Learn more. pages/_error.js has been replaced with more granular error.js special files. Learn more. pages/404.js has been replaced with the not-found.js file. pages/api/* currently remain inside the pages directory.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c075444d-a969-44f7-a349-436e6865a9ac":{"id_":"c075444d-a969-44f7-a349-436e6865a9ac","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ze/jcpFFOAkg6nzYZWA/H5nCLcJq7BEgDmLuBVGrhcM=","metadata":{},"hash":"/TZZNpidcIkUVPqGHl3Bp+cDFmWfQFtVzjR9zczvEgI="}},"hash":"3LkObBWMxtsgojP0HywyRKrH81fIp/+XJ3yLndIy+f0=","text":"Step 1: Creating the appapp directory\r\nUpdate to the latest Next.js version (requires 13.4 or greater):\r\nnpm install next@latest\r\nThen, create a new app directory at the root of your project (or src/ directory). Step 2: Creating a Root Layout\r\nCreate a new app/layout.tsx file inside the app directory. This is a root layout that will apply to all routes inside app. app/layout.tsx (tsx)export default function RootLayout({\r\n  // Layouts must accept a children prop. // This will be populated with nested layouts or pages\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({\r\n  // Layouts must accept a children prop. // This will be populated with nested layouts or pages\r\n  children,\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nThe app directory must include a root layout. The root layout must define <html>, and <body> tags since Next.js does not automatically create them\r\nThe root layout replaces the pages/_app.tsx and pages/_document.tsx files. .js, .jsx, or .tsx extensions can be used for layout files. To manage <head> HTML elements, you can use the built-in SEO support:\r\napp/layout.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'Home',\r\n  description: 'Welcome to Next.js',\r\n}\r\napp/layout.js (jsx)export const metadata = {\r\n  title: 'Home',\r\n  description: 'Welcome to Next.js',\r\n}\r\nMigrating _document.js_document.js and _app.js_app.js\r\nIf you have an existing _app or _document file, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles in app/layout.tsx will not apply to pages/*. You should keep _app/_document while migrating to prevent your pages/*\r\nroutes from breaking. Once fully migrated, you can then safely delete them. If you are using any React Context providers, they will need to be moved to a Client Component. Migrating the getLayout()getLayout() pattern to Layouts (Optional)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"56f37a11-aabd-4954-9abb-dd6973a2f726":{"id_":"56f37a11-aabd-4954-9abb-dd6973a2f726","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Pt6Q9fKf1mY8wHuaLP7wf7uVNytJbT0hNH3V6/NlCfo=","metadata":{},"hash":"ZGPT9b3RGoXsAT+75BZmWY9VA390/oHtROictabi0pw="}},"hash":"90uvl8YmnGNYo9dfGV3U2E+DlEhg3UzSbbNRhL2a9I8=","text":"Next.js recommended adding a property to Page components to achieve per-page layouts in the pages directory. This pattern can be\r\nreplaced with native support for nested layouts in the app directory. See before and after example\r\nStep 3: Migrating next/headnext/head\r\nIn the pages directory, the next/head React component is used to manage <head> HTML elements such as title and meta . In the\r\napp directory, next/head is replaced with the new built-in SEO support. Before:\r\npages/index.tsx (tsx)import Head from 'next/head'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n    </>\r\n  )\r\n}\r\npages/index.js (jsx)import Head from 'next/head'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n    </>\r\n  )\r\n}\r\nAfter:\r\napp/page.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'My Page Title',\r\n}\r\nexport default function Page() {\r\n  return '... '\r\n}\r\napp/page.js (jsx)export const metadata = {\r\n  title: 'My Page Title',\r\n}\r\nexport default function Page() {\r\n  return '... '\r\n}\r\nSee all metadata options. Step 4: Migrating Pages\r\nPages in the app directory are Server Components by default. This is different from the pages directory where pages are Client\r\nComponents. Data fetching has changed in app. getServerSideProps, getStaticProps and getInitialProps have been replaced with a\r\nsimpler API. The app directory uses nested folders to define routes and a special page.js file to make a route segment publicly accessible. pagespages Directoryappapp DirectoryRoute","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d42ada96-2b89-4447-b86b-722bc74a832b":{"id_":"d42ada96-2b89-4447-b86b-722bc74a832b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZG/O8g8S5Mxte9wHGmsphDDpWjvvTR5GFvfB7wjzWSA=","metadata":{},"hash":"3ZyGfng/oBMVQ0EVw98JqqIdAgxatihigIcponPfDFA="},"NEXT":{"nodeId":"0686c6c8-0300-4319-8535-3360d221cd42","metadata":{},"hash":"bueT9EQoVPcwWui/zywpZhLwJWhq/H/5gQNKYaKTdT4="}},"hash":"JwZaFlTHPG6L8wD0PDJztUm1DP1MhVqos5IpH5ak0xk=","text":"index.jspage.js/\r\nabout.jsabout/page.js/about\r\nblog/[slug].jsblog/[slug]/page.js/blog/post-1\r\npagespages Directoryappapp DirectoryRoute\r\nWe recommend breaking down the migration of a page into two main steps:\r\nStep 1: Move the default exported Page Component into a new Client Component. Step 2: Import the new Client Component into a new page.js file inside the app directory. Good to know: This is the easiest migration path because it has the most comparable behavior to the pages directory. Step 1: Create a new Client Component\r\nCreate a new separate file inside the app directory (i.e. app/home-page.tsx or similar) that exports a Client Component. To define\r\nClient Components, add the 'use client' directive to the top of the file (before any imports). Move the default exported page component from pages/index.js to app/home-page.tsx. app/home-page.tsx (tsx)'use client'\r\n// This is a Client Component. It receives data as props and\r\n// has access to state and effects just like Page components\r\n// in the `pages` directory. export default function HomePage({ recentPosts }) {\r\n  return (\r\n    <div>\r\n      {recentPosts.map((post) => (\r\n        <div key={post.id}>{post.title}</div>\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\napp/home-page.js (jsx)'use client'\r\n// This is a Client Component. It receives data as props and\r\n// has access to state and effects just like Page components\r\n// in the `pages` directory. export default function HomePage({ recentPosts }) {\r\n  return (\r\n    <div>\r\n      {recentPosts.map((post) => (\r\n        <div key={post.id}>{post.title}</div>\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\nStep 2: Create a new page\r\nCreate a new app/page.tsx file inside the app directory. This is a Server Component by default. Import the home-page.tsx Client Component into the page. If you were fetching data in pages/index.js, move the data fetching logic directly into the Server Component using the new data\r\nfetching APIs. See the data fetching upgrade guide for more details. app/page.tsx (tsx)  // Import your Client Component\r\n  import HomePage from './home-page'\r\n  async function getPosts() {\r\n    const res = await fetch('https://...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0686c6c8-0300-4319-8535-3360d221cd42":{"id_":"0686c6c8-0300-4319-8535-3360d221cd42","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZG/O8g8S5Mxte9wHGmsphDDpWjvvTR5GFvfB7wjzWSA=","metadata":{},"hash":"3ZyGfng/oBMVQ0EVw98JqqIdAgxatihigIcponPfDFA="},"PREVIOUS":{"nodeId":"d42ada96-2b89-4447-b86b-722bc74a832b","metadata":{},"hash":"JwZaFlTHPG6L8wD0PDJztUm1DP1MhVqos5IpH5ak0xk="}},"hash":"bueT9EQoVPcwWui/zywpZhLwJWhq/H/5gQNKYaKTdT4=","text":"')\r\n    const posts = await res.json()\r\n    return posts\r\n  }\r\n  export default async function Page() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3c550c39-6e3d-41c5-8423-a02ad6d3837f":{"id_":"3c550c39-6e3d-41c5-8423-a02ad6d3837f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tBaQFBVhs8qkEQxKdUJBVjv4EaNs/hFoZJPU5BvtiKI=","metadata":{},"hash":"7k/yJKw9ac+g3aMXZNwAZCoZpHh01Q6w2M6yK127GNw="},"NEXT":{"nodeId":"f2fab6d3-bb48-4575-b82c-a4a2f56fc835","metadata":{},"hash":"fKo0/jALzYCxsD4puFdt1eHteG3KFLfIUjRkrU4yvdU="}},"hash":"7fhMh7FHhg4R9aDByFy2usqfrEsFPH7fCRNf/lHpFhc=","text":"// Fetch data directly in a Server Component\r\n    const recentPosts = await getPosts()\r\n    // Forward fetched data to your Client Component\r\n    return <HomePage recentPosts={recentPosts} />\r\n  }\r\napp/page.js (jsx)  // Import your Client Component\r\n  import HomePage from './home-page'\r\n  async function getPosts() {\r\n    const res = await fetch('https://... ')\r\n    const posts = await res.json()\r\n    return posts\r\n  }\r\n  export default async function Page() {\r\n    // Fetch data directly in a Server Component\r\n    const recentPosts = await getPosts()\r\n    // Forward fetched data to your Client Component\r\n    return <HomePage recentPosts={recentPosts} />\r\n  }\r\nIf your previous page used useRouter, you’ll need to update to the new routing hooks. Learn more. Start your development server and visit http://localhost:3000. You should see your existing index route, now served through\r\nthe app directory. Step 5: Migrating Routing Hooks\r\nA new router has been added to support the new behavior in the app directory. In app, you should use the three new hooks imported from next/navigation: useRouter(), usePathname(), and\r\nuseSearchParams(). The new useRouter hook is imported from next/navigation and has different behavior to the useRouter hook in pages which\r\nis imported from next/router. The useRouter hook imported from next/router is not supported in the app directory but can continue to be used in the pages\r\ndirectory. The new useRouter does not return the pathname string. Use the separate usePathname hook instead. The new useRouter does not return the query object. Use the separate useSearchParams hook instead. You can use useSearchParams and usePathname together to listen to page changes. See the Router Events section for more\r\ndetails. These new hooks are only supported in Client Components. They cannot be used in Server Components. app/example-client-component.tsx (tsx)'use client'\r\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  // ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f2fab6d3-bb48-4575-b82c-a4a2f56fc835":{"id_":"f2fab6d3-bb48-4575-b82c-a4a2f56fc835","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tBaQFBVhs8qkEQxKdUJBVjv4EaNs/hFoZJPU5BvtiKI=","metadata":{},"hash":"7k/yJKw9ac+g3aMXZNwAZCoZpHh01Q6w2M6yK127GNw="},"PREVIOUS":{"nodeId":"3c550c39-6e3d-41c5-8423-a02ad6d3837f","metadata":{},"hash":"7fhMh7FHhg4R9aDByFy2usqfrEsFPH7fCRNf/lHpFhc="}},"hash":"fKo0/jALzYCxsD4puFdt1eHteG3KFLfIUjRkrU4yvdU=","text":"}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  // ... }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"87a8d991-8bd0-46d4-a952-c20015234c74":{"id_":"87a8d991-8bd0-46d4-a952-c20015234c74","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MME3WTQupYOeRPv2PHJg0hvPelIE7+yzCuK7c+DYURI=","metadata":{},"hash":"ae5QqWY2Fw9fIC9RNwejMJD6ko10hY+3Pq/+AvcZgU0="},"NEXT":{"nodeId":"5b3c3c77-6cd8-4396-a509-79da9f9de2bd","metadata":{},"hash":"Tl/JiqnIk8kmzfAOGichf1sTF0WeigWwJ75PoZS82Cg="}},"hash":"W+fwxK2VdDNWcug7DTQ96wLilJa+OKMoe2JiEeUOBeU=","text":"In addition, the new useRouter hook has the following changes:\r\nisFallback has been removed because fallback has been replaced. The locale, locales, defaultLocales, domainLocales values have been removed because built-in i18n Next.js features are no\r\nlonger necessary in the app directory. Learn more about i18n. basePath has been removed. The alternative will not be part of useRouter. It has not yet been implemented. asPath has been removed because the concept of as has been removed from the new router. isReady has been removed because it is no longer necessary. During static rendering, any component that uses the\r\nuseSearchParams() hook will skip the prerendering step and instead be rendered on the client at runtime. View the useRouter() API reference. Step 6: Migrating Data Fetching Methods\r\nThe pages directory uses getServerSideProps and getStaticProps to fetch data for pages. Inside the app directory, these previous\r\ndata fetching functions are replaced with a simpler API built on top of fetch() and async React Server Components. app/page.tsx (tsx)export default async function Page() {\r\n  // This request should be cached until manually invalidated. // Similar to `getStaticProps`. // `force-cache` is the default and can be omitted. const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n  // This request should be refetched on every request. // Similar to `getServerSideProps`. const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n  // This request should be cached with a lifetime of 10 seconds. // Similar to `getStaticProps` with the `revalidate` option. const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n  return <div>...</div>\r\n}\r\napp/page.js (jsx)export default async function Page() {\r\n  // This request should be cached until manually invalidated. // Similar to `getStaticProps`. // `force-cache` is the default and can be omitted. const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n  // This request should be refetched on every request. // Similar to `getServerSideProps`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5b3c3c77-6cd8-4396-a509-79da9f9de2bd":{"id_":"5b3c3c77-6cd8-4396-a509-79da9f9de2bd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MME3WTQupYOeRPv2PHJg0hvPelIE7+yzCuK7c+DYURI=","metadata":{},"hash":"ae5QqWY2Fw9fIC9RNwejMJD6ko10hY+3Pq/+AvcZgU0="},"PREVIOUS":{"nodeId":"87a8d991-8bd0-46d4-a952-c20015234c74","metadata":{},"hash":"W+fwxK2VdDNWcug7DTQ96wLilJa+OKMoe2JiEeUOBeU="}},"hash":"Tl/JiqnIk8kmzfAOGichf1sTF0WeigWwJ75PoZS82Cg=","text":"// Similar to `getServerSideProps`. const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n  // This request should be cached with a lifetime of 10 seconds. // Similar to `getStaticProps` with the `revalidate` option. const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n  return <div>...</div>\r\n}\r\nServer-side Rendering (getServerSidePropsgetServerSideProps)\r\nIn the pages directory, getServerSideProps is used to fetch data on the server and forward props to the default exported React\r\ncomponent in the file. The initial HTML for the page is prerendered from the server, followed by “hydrating” the page in the browser\r\n(making it interactive). pages/dashboard.js (jsx)// `pages` directory\r\nexport async function getServerSideProps() {\r\n  const res = await fetch(`https://... `)\r\n  const projects = await res.json()\r\n  return { props: { projects } }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"257a3860-9718-454b-92bd-e5ea51211bd2":{"id_":"257a3860-9718-454b-92bd-e5ea51211bd2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"r6aV0gEG4lUS+J6yoRR1ZhaXnptgOLDpT5Eu4nNU2Os=","metadata":{},"hash":"dcgysdIKp49BBFLbBktO+2SeUfdYvyMJEzvUNByPTh8="}},"hash":"Rkdq3I+Fdiw/T0fEIfRhXZr9TjfhJkn94oiTch0nkpc=","text":"export default function Dashboard({ projects }) {\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nIn the app directory, we can colocate our data fetching inside our React components using Server Components. This allows us to send\r\nless JavaScript to the client, while maintaining the rendered HTML from the server. By setting the cache option to no-store, we can indicate that the fetched data should never be cached. This is similar to\r\ngetServerSideProps in the pages directory. app/dashboard/page.tsx (tsx)// `app` directory\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://...`, { cache: 'no-store' })\r\n  const projects = await res.json()\r\n  return projects\r\n}\r\nexport default async function Dashboard() {\r\n  const projects = await getProjects()\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\napp/dashboard/page.js (jsx)// `app` directory\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://...`, { cache: 'no-store' })\r\n  const projects = await res.json()\r\n  return projects\r\n}\r\nexport default async function Dashboard() {\r\n  const projects = await getProjects()\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nAccessing Request Object\r\nIn the pages directory, you can retrieve request-based data based on the Node.js HTTP API. For example, you can retrieve the req object from getServerSideProps and use it to retrieve the request’s cookies and headers. pages/index.js (jsx)// `pages` directory\r\nexport async function getServerSideProps({ req, query }) {\r\n  const authHeader = req.getHeaders()['authorization'];\r\n  const theme = req.cookies['theme'];","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1254ab36-c94c-4e1f-8ba1-512b16e408ac":{"id_":"1254ab36-c94c-4e1f-8ba1-512b16e408ac","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JkOZ7HP1RjNx4/OcbgH2LsrRankk0kx8oQFzNbrnW/0=","metadata":{},"hash":"kr46IfmZzipl4rRYXst+WDY/uKHh4+Ot2HuW6QrZOrA="}},"hash":"bm6LSsg/o/kRDWypCFefSv/wTLEl7srf1dYB/ZUU6O8=","text":"return { props: { ... }}\r\n}\r\nexport default function Page(props) {\r\n  return ... }\r\nThe app directory exposes new read-only functions to retrieve request data:\r\nheaders(): Based on the Web Headers API, and can be used inside Server Components to retrieve request headers. cookies(): Based on the Web Cookies API, and can be used inside Server Components to retrieve cookies. app/page.tsx (tsx)// `app` directory\r\nimport { cookies, headers } from 'next/headers'\r\nasync function getData() {\r\n  const authHeader = headers().get('authorization')\r\n  return '... '\r\n}\r\nexport default async function Page() {\r\n  // You can use `cookies()` or `headers()` inside Server Components\r\n  // directly or in your data fetching function\r\n  const theme = cookies().get('theme')\r\n  const data = await getData()\r\n  return '... '\r\n}\r\napp/page.js (jsx)// `app` directory\r\nimport { cookies, headers } from 'next/headers'\r\nasync function getData() {\r\n  const authHeader = headers().get('authorization')\r\n  return '... '\r\n}\r\nexport default async function Page() {\r\n  // You can use `cookies()` or `headers()` inside Server Components\r\n  // directly or in your data fetching function\r\n  const theme = cookies().get('theme')\r\n  const data = await getData()\r\n  return '... '\r\n}\r\nStatic Site Generation (getStaticPropsgetStaticProps)\r\nIn the pages directory, the getStaticProps function is used to pre-render a page at build time. This function can be used to fetch\r\ndata from an external API or directly from a database, and pass this data down to the entire page as it’s being generated during the\r\nbuild. pages/index.js (jsx)// `pages` directory\r\nexport async function getStaticProps() {\r\n  const res = await fetch(`https://... `)\r\n  const projects = await res.json()\r\n  return { props: { projects } }\r\n}\r\nexport default function Index({ projects }) {\r\n  return projects.map((project) => <div>{project.name}</div>)\r\n}\r\nIn the app directory, data fetching with fetch() will default to cache: 'force-cache', which will cache the request data until\r\nmanually invalidated. This is similar to getStaticProps in the pages directory. app/page.js (jsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1df12d1d-6ef6-480a-80ed-2b0a54eb1460":{"id_":"1df12d1d-6ef6-480a-80ed-2b0a54eb1460","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YNqgEoGxWCuev37WPD9jNhemIEFjZi7kxw4r9+67/W4=","metadata":{},"hash":"Ns7wEffaZx1PrY8Ikq/ovERkI2aLpHG4F83nBouvvZI="}},"hash":"B0wIEWz9oPHKvGotFreFj79mDSMtNSup97ZBQyv7zyg=","text":"// `app` directory\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://... `)\r\n  const projects = await res.json()\r\n  return projects\r\n}\r\nexport default async function Index() {\r\n  const projects = await getProjects()\r\n  return projects.map((project) => <div>{project.name}</div>)\r\n}\r\nDynamic paths (getStaticPathsgetStaticPaths)\r\nIn the pages directory, the getStaticPaths function is used to define the dynamic paths that should be pre-rendered at build time. pages/posts/[id].js (jsx)// `pages` directory\r\nimport PostLayout from '@/components/post-layout'\r\nexport async function getStaticPaths() {\r\n  return {\r\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\r\n  }\r\n}\r\nexport async function getStaticProps({ params }) {\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n  return { props: { post } }\r\n}\r\nexport default function Post({ post }) {\r\n  return <PostLayout post={post} />\r\n}\r\nIn the app directory, getStaticPaths is replaced with generateStaticParams. generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and can be\r\nused inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of nested param objects\r\nor a string of resolved paths. app/posts/[id]/page.js (jsx)// `app` directory\r\nimport PostLayout from '@/components/post-layout'\r\nexport async function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }]\r\n}\r\nasync function getPost(params) {\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n  return post\r\n}\r\nexport default async function Post({ params }) {\r\n  const post = await getPost(params)\r\n  return <PostLayout post={post} />\r\n}\r\nUsing the name generateStaticParams is more appropriate than getStaticPaths for the new model in the app directory. The get\r\nprefix is replaced with a more descriptive generate, which sits better alone now that getStaticProps and getServerSideProps\r\nare no longer necessary. The Paths suffix is replaced by Params, which is more appropriate for nested routing with multiple dynamic\r\nsegments.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"df8f2b7b-6ae3-46d1-98aa-e0592ff3d29a":{"id_":"df8f2b7b-6ae3-46d1-98aa-e0592ff3d29a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"khApgVuWZRVf5kfax/bYAiwhMdJpX4NPcvzRnw6ploA=","metadata":{},"hash":"O33FQlzI3pDwPsC+JNCILrjruW0DyHELPg+OO3hQnQI="}},"hash":"j/yKU8fysTr28pRLE7Wa0HNqICgy/Qhpg7x43IiKY9I=","text":"Replacing fallbackfallback\r\nIn the pages directory, the fallback property returned from getStaticPaths is used to define the behavior of a page that isn’t pre-\r\nrendered at build time. This property can be set to true to show a fallback page while the page is being generated, false to show a\r\n404 page, or blocking to generate the page at request time. pages/posts/[id].js (jsx)// `pages` directory\r\nexport async function getStaticPaths() {\r\n  return {\r\n    paths: [],\r\n    fallback: 'blocking'\r\n  };\r\n}\r\nexport async function getStaticProps({ params }) {\r\n  ... }\r\nexport default function Post({ post }) {\r\n  return ... }\r\nIn the app directory the config.dynamicParams property controls how params outside of generateStaticParams are handled:\r\ntruetrue: (default) Dynamic segments not included in generateStaticParams are generated on demand. falsefalse: Dynamic segments not included in generateStaticParams will return a 404. This replaces the fallback: true | false | 'blocking' option of getStaticPaths in the pages directory. The fallback:\r\n'blocking' option is not included in dynamicParams because the difference between 'blocking' and true is negligible with\r\nstreaming. app/posts/[id]/page.js (jsx)// `app` directory\r\nexport const dynamicParams = true;\r\nexport async function generateStaticParams() {\r\n  return [... ]\r\n}\r\nasync function getPost(params) {\r\n  ... }\r\nexport default async function Post({ params }) {\r\n  const post = await getPost(params);\r\n  return ... }\r\nWith dynamicParams set to true (the default), when a route segment is requested that hasn’t been generated, it will be server-\r\nrendered and cached. Incremental Static Regeneration (getStaticPropsgetStaticProps with revalidaterevalidate)\r\nIn the pages directory, the getStaticProps function allows you to add a revalidate field to automatically regenerate a page after a\r\ncertain amount of time. pages/index.js (jsx)// `pages` directory\r\nexport async function getStaticProps() {\r\n  const res = await fetch(`https://.../posts`)\r\n  const posts = await res.json()\r\n  return {\r\n    props: { posts },\r\n    revalidate: 60,\r\n  }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"43623ca5-b442-43be-b08f-39554b30a440":{"id_":"43623ca5-b442-43be-b08f-39554b30a440","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"usv8edQgDrdg751/60WJS55wsyBPiCkwHAl2X9aUuKk=","metadata":{},"hash":"NPA4RQAoSCH53IMS0DyhewdgDInjxA+/ZduRENI1TAE="}},"hash":"fYXOfxjI76jz/nqqH8djTQftEHRh9l0o9tmXNu+Af9g=","text":"export default function Index({ posts }) {\r\n  return (\r\n    <Layout>\r\n      <PostList posts={posts} />\r\n    </Layout>\r\n  )\r\n}\r\nIn the app directory, data fetching with fetch() can use revalidate, which will cache the request for the specified amount of\r\nseconds. app/page.js (jsx)// `app` directory\r\nasync function getPosts() {\r\n  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })\r\n  const data = await res.json()\r\n  return data.posts\r\n}\r\nexport default async function PostList() {\r\n  const posts = await getPosts()\r\n  return posts.map((post) => <div>{post.name}</div>)\r\n}\r\nAPI Routes\r\nAPI Routes continue to work in the pages/api directory without any changes. However, they have been replaced by Route Handlers in\r\nthe app directory. Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. app/api/route.ts (ts)export async function GET(request: Request) {}\r\napp/api/route.js (js)export async function GET(request) {}\r\nGood to know: If you previously used API routes to call an external API from the client, you can now use Server Components\r\ninstead to securely fetch data. Learn more about data fetching. Step 7: Styling\r\nIn the pages directory, global stylesheets are restricted to only pages/_app.js. With the app directory, this restriction has been lifted. Global styles can be added to any layout, page, or component. CSS Modules\r\nTailwind CSS\r\nGlobal Styles\r\nCSS-in-JS\r\nExternal Stylesheets\r\nSass\r\nTailwind CSS\r\nIf you’re using Tailwind CSS, you’ll need to add the app directory to your tailwind.config.js file:\r\ntailwind.config.js (js)module.exports = {\r\n  content: [\r\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add this line\r\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\r\n  ],\r\n}\r\nYou’ll also need to import your global styles in your app/layout.js file:\r\napp/layout.js (jsx)import '../styles/globals.css'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d62a6481-df62-478a-978d-466f35cf142c":{"id_":"d62a6481-df62-478a-978d-466f35cf142c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"G6iBBf4/bj3uh3M2d41p3VhnDt7IzJXpmkeQFa6vioA=","metadata":{},"hash":"XcnbGzAylmCG5CpwEXm1jjr8VP8G6nbrXyGk9FmQVG4="}},"hash":"lVRU9QRrQ+xYd2QQMpuzwsmu4+lsADde6WlVApmnG2w=","text":"export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nLearn more about styling with Tailwind CSS\r\nCodemods\r\nNext.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. See Codemods for more\r\ninformation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1bc5c3c-412d-47fc-b5b0-e02d95b92fae":{"id_":"f1bc5c3c-412d-47fc-b5b0-e02d95b92fae","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Um9nv4fOYalM1UVDvF356UCt5OeZeJ4TxQbtw6i5SMA=","metadata":{},"hash":"PeNdWeg2Y/5dRFOEo4IIwXwdkPUfXP9zfrpTknZnCTw="}},"hash":"IVyUHYvHTkyRb4W/gLmJynLTTVIsaKKvB08H5WsVfBg=","text":"3.1.10.3 - Version 14\r\nDocumentation path: /02-app/01-building-your-application/10-upgrading/03-version-14\r\nDescription: Upgrade your Next.js Application from Version 13 to 14. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nUpgrading from 13 to 14\r\nTo update to Next.js version 14, run the following command using your preferred package manager:\r\nTerminal (bash)npm i next@latest react@latest react-dom@latest eslint-config-next@latest\r\nTerminal (bash)yarn add next@latest react@latest react-dom@latest eslint-config-next@latest\r\nTerminal (bash)pnpm up next react react-dom eslint-config-next --latest\r\nTerminal (bash)bun add next@latest react@latest react-dom@latest eslint-config-next@latest\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest\r\nversions. v14 Summary\r\nThe minimum Node.js version has been bumped from 16.14 to 18.17, since 16.x has reached end-of-life. The next export command is deprecated in favor of output: 'export'. Please see the docs for more information. The next/server import for ImageResponse was renamed to next/og. A codemod is available to safely and automatically\r\nrename your imports. The @next/font package has been fully removed in favor of the built-in next/font. A codemod is available to safely and\r\nautomatically rename your imports. The WASM target for next-swc has been removed.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6949e186-36d5-419d-b780-519873138eb0":{"id_":"6949e186-36d5-419d-b780-519873138eb0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Nhx6UXL/skM2yQDTflqzCD2ykFOF7+NEPs1MAO2/JWk=","metadata":{},"hash":"e8bHjS7hVVHgIH10SGtWyotgWz8GaS4ytJRvDmI0ZeY="},"NEXT":{"nodeId":"7b6c5684-edbe-4ad5-80af-581f13b24f4a","metadata":{},"hash":"pCDQM6cunla0b3mInoLmw+qEBIZWhWjPIPzIgoqQHoo="}},"hash":"S/A7n+Jjo/VOJu92VQ5HYy37Q66pRLlHEtbgFNz/tDo=","text":"3.1.10.4 - Migrating from Vite\r\nDocumentation path: /02-app/01-building-your-application/10-upgrading/04-from-vite\r\nDescription: Learn how to migrate your existing React application from Vite to Next.js. This guide will help you migrate an existing Vite application to Next.js. Why Switch? There are several reasons why you might want to switch from Vite to Next.js:\r\n1. Slow initial page loading time: If you have built your application with the default Vite plugin for React, your application is a purely\r\nclient-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial\r\npage loading time. This happens due to a couple of reasons:\r\n2. The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to\r\nsend requests to load some data. 3. Your application code grows with every new feature and extra dependency you add. 4. No automatic code splitting: The previous issue of slow loading times can be somewhat managed with code splitting. However, if\r\nyou try to do code splitting manually, you’ll often make performance worse. It’s easy to inadvertently introduce network waterfalls\r\nwhen code-splitting manually. Next.js provides automatic code splitting built into its router. 5. Network waterfalls: A common cause of poor performance occurs when applications make sequential client-server requests to\r\nfetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the\r\ncomponent has mounted. Unfortunately, this means that a child component that fetches data can’t start fetching until the parent\r\ncomponent has finished loading its own data. On Next.js, this issue is resolved by fetching data in Server Components. 6. Fast and intentional loading states: Thanks to built-in support for Streaming with Suspense, with Next.js, you can be more\r\nintentional about which parts of your UI you want to load first and in what order without introducing network waterfalls. This\r\nenables you to build pages that are faster to load and also eliminate layout shifts. 7. Choose the data fetching strategy: Depending on your needs, Next.js allows you to choose your data fetching strategy on a page\r\nand component basis.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b6c5684-edbe-4ad5-80af-581f13b24f4a":{"id_":"7b6c5684-edbe-4ad5-80af-581f13b24f4a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Nhx6UXL/skM2yQDTflqzCD2ykFOF7+NEPs1MAO2/JWk=","metadata":{},"hash":"e8bHjS7hVVHgIH10SGtWyotgWz8GaS4ytJRvDmI0ZeY="},"PREVIOUS":{"nodeId":"6949e186-36d5-419d-b780-519873138eb0","metadata":{},"hash":"S/A7n+Jjo/VOJu92VQ5HYy37Q66pRLlHEtbgFNz/tDo="}},"hash":"pCDQM6cunla0b3mInoLmw+qEBIZWhWjPIPzIgoqQHoo=","text":"You can decide to fetch at build time, at request time on the server, or on the client. For example, you can\r\nfetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN. 8. Middleware: Next.js Middleware allows you to run code on the server before a request is completed. This is especially useful to\r\navoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login\r\npage. The middleware is also useful for experimentation and internationalization. 9. Built-in Optimizations: Images, fonts, and third-party scripts often have significant impact on an application’s performance. Next.js comes with built-in components that automatically optimize those for you. Migration Steps\r\nOur goal with this migration is to get a working Next.js application as quickly as possible, so that you can then adopt Next.js features\r\nincrementally. To begin with, we’ll keep it as a purely client-side application (SPA) without migrating your existing router. This helps\r\nminimize the chances of encountering issues during the migration process and reduces merge conflicts. Step 1: Install the Next.js Dependency\r\nThe first thing you need to do is to install next as a dependency:\r\nTerminal (bash)npm install next@latest\r\nStep 2: Create the Next.js Configuration File\r\nCreate a next.config.mjs at the root of your project. This file will hold your Next.js configuration options. next.config.mjs (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export', // Outputs a Single-Page Application (SPA). distDir: './dist', // Changes the build output directory to `./dist/`. }\r\nexport default nextConfig\r\nGood to know: You can use either .js or .mjs for your Next.js configuration file. Step 3: Update TypeScript Configuration","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1d542d2a-9482-44b2-8247-b81a76571081":{"id_":"1d542d2a-9482-44b2-8247-b81a76571081","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Z2ZawkQhSFnz4a3+toVoFhvo8e8RmrBK/mym5Q9UbeU=","metadata":{},"hash":"sXtBgLD/Hg1IyZHUkNJ8mqdyXfZq3ztCcvupuI+GjFw="},"NEXT":{"nodeId":"7dc674ca-e9d0-4812-8a69-7be2647801c1","metadata":{},"hash":"y8iirpUZpj1bunQmRnI1XS+goM9JKSaIn/mzNuOkQfg="}},"hash":"VZb01KMbziJXo+MxUYvdpsByLuBZgYKLdEfgtNQRSY8=","text":"If you’re using TypeScript, you need to update your tsconfig.json file with the following changes to make it compatible with Next.js. If you’re not using TypeScript, you can skip this step. 1. Remove the project reference to tsconfig.node.json\r\n2. Add ./dist/types/**/*.ts and ./next-env.d.ts to the include array\r\n3. Add ./node_modules to the exclude array\r\n4. Add { \"name\": \"next\" } to the plugins array in compilerOptions: \"plugins\": [{ \"name\": \"next\" }]\r\n5. Set esModuleInterop to true: \"esModuleInterop\": true\r\n6. Set jsx to preserve: \"jsx\": \"preserve\"\r\n7. Set allowJs to true: \"allowJs\": true\r\n8. Set forceConsistentCasingInFileNames to true: \"forceConsistentCasingInFileNames\": true\r\n9. Set incremental to true: \"incremental\": true\r\nHere’s an example of a working tsconfig.json with those changes:\r\ntsconfig.json (json){\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES2020\",\r\n    \"useDefineForClassFields\": true,\r\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\r\n    \"module\": \"ESNext\",\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"moduleResolution\": \"bundler\",\r\n    \"allowImportingTsExtensions\": true,\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"strict\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"noUnusedParameters\": true,\r\n    \"noFallthroughCasesInSwitch\": true,\r\n    \"allowJs\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"incremental\": true,\r\n    \"plugins\": [{ \"name\": \"next\" }]\r\n  },\r\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\r\n  \"exclude\": [\"./node_modules\"]\r\n}\r\nYou can find more information about configuring TypeScript on the Next.js docs. Step 4: Create the Root Layout\r\nA Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all pages in your\r\napplication.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7dc674ca-e9d0-4812-8a69-7be2647801c1":{"id_":"7dc674ca-e9d0-4812-8a69-7be2647801c1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Z2ZawkQhSFnz4a3+toVoFhvo8e8RmrBK/mym5Q9UbeU=","metadata":{},"hash":"sXtBgLD/Hg1IyZHUkNJ8mqdyXfZq3ztCcvupuI+GjFw="},"PREVIOUS":{"nodeId":"1d542d2a-9482-44b2-8247-b81a76571081","metadata":{},"hash":"VZb01KMbziJXo+MxUYvdpsByLuBZgYKLdEfgtNQRSY8="}},"hash":"y8iirpUZpj1bunQmRnI1XS+goM9JKSaIn/mzNuOkQfg=","text":"This file is defined at the top level of the app directory. The closest equivalent to the root layout file in a Vite application is the index.html file, which contains your <html>, <head>, and\r\n<body> tags. In this step, you’ll convert your index.html file into a root layout file:\r\n1. Create a new app directory in your src directory. 2. Create a new layout.tsx file inside that app directory:\r\napp/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return null\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return null\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e65c6122-328a-4f49-be92-bb095e8db92b":{"id_":"e65c6122-328a-4f49-be92-bb095e8db92b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"soB9Z2wwsdeVhXQbhgLyqwmLICboJWVTazltBBVaxrM=","metadata":{},"hash":"qMx18g40GeVbblNVCf0yNcH4subQE18HVUMe8fcrnFA="},"NEXT":{"nodeId":"9d339c9f-ea8a-4c78-bf8a-dce55a606a49","metadata":{},"hash":"3ruFpMQwl01iuI0M3TNEaED44waqw37zMkSsCAMp/K0="}},"hash":"twPcsKdSKoyhu1TNr9LEu48AVlz8tY+cgDNMmzns4T0=","text":"Good to know: .js, .jsx, or .tsx extensions can be used for Layout files. 1. Copy the content of your index.html file into the previously created <RootLayout> component while replacing the\r\nbody.div#root and body.script tags with <div id=\"root\">{children}</div>:\r\napp/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a... \" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a... \" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\n1. Next.js already includes by default the meta charset and meta viewport tags, so you can safely remove those from your <head>:\r\napp/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9d339c9f-ea8a-4c78-bf8a-dce55a606a49":{"id_":"9d339c9f-ea8a-4c78-bf8a-dce55a606a49","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"soB9Z2wwsdeVhXQbhgLyqwmLICboJWVTazltBBVaxrM=","metadata":{},"hash":"qMx18g40GeVbblNVCf0yNcH4subQE18HVUMe8fcrnFA="},"PREVIOUS":{"nodeId":"e65c6122-328a-4f49-be92-bb095e8db92b","metadata":{},"hash":"twPcsKdSKoyhu1TNr9LEu48AVlz8tY+cgDNMmzns4T0="}},"hash":"3ruFpMQwl01iuI0M3TNEaED44waqw37zMkSsCAMp/K0=","text":"\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6db6dc52-cba2-4e7e-a0b3-511ab788f7c2":{"id_":"6db6dc52-cba2-4e7e-a0b3-511ab788f7c2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hkg2JdDmNnQRxnQtj72MjPCsuKNLd39eCDMAazLgPsU=","metadata":{},"hash":"8NYqegOTjnHVSSYcg7IOQFa8dgL2Jtm1KwaiEujm8Uk="}},"hash":"l6FthRjhqM6PZwQAllLb4aqYiZfWMwE32qSPTGm+ZPk=","text":"<title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a... \" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\n1. Any metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application <head> tag as long\r\nas you have them placed into the top level of the app directory. After moving all supported files into the app directory you can\r\nsafely delete their <link> tags:\r\napp/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a... \" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a... \" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\n1. Finally, Next.js can manage your last <head> tags with the Metadata API. Move your final metadata info into an exported metadata\r\nobject:\r\napp/layout.tsx (tsx)import type { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'My App',\r\n  description: 'My App is a...',\r\n}\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"25088ca0-73c7-4f3d-8c5b-8ed45c85e7a3":{"id_":"25088ca0-73c7-4f3d-8c5b-8ed45c85e7a3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yqegpQssjhs6DmSmnDHOjW3SNk7s1scQycZPiSlou9Q=","metadata":{},"hash":"gsG0rJdHw0gYiQ7qT2qZ6x/CAy4fDk6EGTXQsWXH9zk="},"NEXT":{"nodeId":"91187f56-fd49-492e-8993-a2b6c8841e4f","metadata":{},"hash":"nNQwtsHz1AzX/Zd00+GcL0asYQv8+M1OQfOgm2ylLXo="}},"hash":"ac+bVMqPkXX9zX/jXTed4K3BipsS1BN6idLfXhIkgWI=","text":"app/layout.js (jsx)export const metadata = {\r\n  title: 'My App',\r\n  description: 'My App is a...',\r\n}\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nWith the above changes, you shifted from declaring everything in your index.html to using Next.js’ convention-based approach built\r\ninto the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages. Step 5: Create the Entrypoint Page\r\nOn Next.js you declare an entrypoint for your application by creating a page.tsx file. The closest equivalent of this file on Vite is your\r\nmain.tsx file. In this step, you’ll set up the entrypoint of your application. 1. Create a [[...slug]][[...slug]] directory in your appapp directory. Since in this guide we’re aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch\r\nall possible routes of your application. For that, create a new [[...slug]] directory in your app directory. This directory is what is called an optional catch-all route segment. Next.js uses a file-system based router where directories are used\r\nto define routes. This special directory will make sure that all routes of your application will be directed to its containing page.tsx file. 1. Create a new page.tsxpage.tsx file inside the app/[[...slug]]app/[[...slug]] directory with the following content:\r\napp/[[...slug]]/page.tsx (tsx)'use client'\r\nimport dynamic from 'next/dynamic'\r\nimport '../../index.css'\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\nexport default function Page() {\r\n  return <App />\r\n}\r\napp/[[...slug]]/page.js (jsx)'use client'\r\nimport dynamic from 'next/dynamic'\r\nimport '../../index.css'\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\nexport default function Page() {\r\n  return <App />\r\n}\r\nGood to know: .js, .jsx, or .tsx extensions can be used for Page files.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"91187f56-fd49-492e-8993-a2b6c8841e4f":{"id_":"91187f56-fd49-492e-8993-a2b6c8841e4f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yqegpQssjhs6DmSmnDHOjW3SNk7s1scQycZPiSlou9Q=","metadata":{},"hash":"gsG0rJdHw0gYiQ7qT2qZ6x/CAy4fDk6EGTXQsWXH9zk="},"PREVIOUS":{"nodeId":"25088ca0-73c7-4f3d-8c5b-8ed45c85e7a3","metadata":{},"hash":"ac+bVMqPkXX9zX/jXTed4K3BipsS1BN6idLfXhIkgWI="}},"hash":"nNQwtsHz1AzX/Zd00+GcL0asYQv8+M1OQfOgm2ylLXo=","text":"This file contains a <Page> component which is marked as a Client Component by the 'use client' directive. Without that directive,\r\nthe component would have been a Server Component. In Next.js, Client Components are prerendered to HTML on the server before being sent to the client, but since we want to first have a\r\npurely client-side application, you need to tell Next.js to disable the prerendering for the <App> component by dynamically importing it\r\nwith the ssr option set to false:\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\nStep 6: Update Static Image Imports\r\nNext.js handles static image imports slightly different from Vite. With Vite, importing an image file will return its public URL as a string:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f11126c3-c1fc-4269-ac4e-5b3b9581b4a6":{"id_":"f11126c3-c1fc-4269-ac4e-5b3b9581b4a6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4BcGtwgtVTWw4YBMeiu+6IUdCZQ2UA4+L3maxuE5Ol4=","metadata":{},"hash":"XZKHGqSk6ppvZB8/qNR3WHuFXqdLrO5PHK1uApYl7lo="},"NEXT":{"nodeId":"947f467d-ff03-4b05-8295-1aa261d296cf","metadata":{},"hash":"+xU1nwDEvX7uTejUSh5zZN1q/zRh79ps4lKze/2gKj8="}},"hash":"t+oriZ3hq2rqi9PRuTHry46n5FDsusKjTsdXmU1Ss40=","text":"App.tsx (tsx)import image from './img.png' // `image` will be '/assets/img.2d8efhg.png' in production\r\nexport default function App() {\r\n  return <img src={image} />\r\n}\r\nWith Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you\r\ncan use the object’s src property with your existing <img> tag. The <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the\r\nwidth and height attributes of the resulting <img> based on the image’s dimensions. This prevents layout shifts when the image\r\nloads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other\r\nstyled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute’s value, which can cause the\r\nimage to appear distorted. Keeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. However, you’ll still want to\r\nlater migrate to the <Image> component to take advantage of the automatic optimizations. 1. Convert absolute import paths for images imported from /public/public into relative imports:\r\n// Before\r\nimport logo from '/logo.png'\r\n// After\r\nimport logo from '../public/logo.png'\r\n1. Pass the image srcsrc property instead of the whole image object to your <img><img> tag:\r\n// Before\r\n<img src={logo} />\r\n// After\r\n<img src={logo.src} />\r\nWarning: If you’re using TypeScript, you might encounter type errors when accessing the src property. You can safely ignore\r\nthose for now. They will be fixed by the end of this guide. Step 7: Migrate the Environment Variables\r\nNext.js has support for .env environment variables similar to Vite. The main difference is the prefix used to expose environment\r\nvariables on the client-side. Change all environment variables with the VITE_ prefix to NEXT_PUBLIC_. Vite exposes a few built-in environment variables on the special import.meta.env object which aren’t supported by Next.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"947f467d-ff03-4b05-8295-1aa261d296cf":{"id_":"947f467d-ff03-4b05-8295-1aa261d296cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4BcGtwgtVTWw4YBMeiu+6IUdCZQ2UA4+L3maxuE5Ol4=","metadata":{},"hash":"XZKHGqSk6ppvZB8/qNR3WHuFXqdLrO5PHK1uApYl7lo="},"PREVIOUS":{"nodeId":"f11126c3-c1fc-4269-ac4e-5b3b9581b4a6","metadata":{},"hash":"t+oriZ3hq2rqi9PRuTHry46n5FDsusKjTsdXmU1Ss40="}},"hash":"+xU1nwDEvX7uTejUSh5zZN1q/zRh79ps4lKze/2gKj8=","text":"You need\r\nto update their usage as follows:\r\nimport.meta.env.MODE \u0000 process.env.NODE_ENV\r\nimport.meta.env.PROD \u0000 process.env.NODE_ENV === 'production'\r\nimport.meta.env.DEV \u0000 process.env.NODE_ENV !== 'production'\r\nimport.meta.env.SSR \u0000 typeof window !== 'undefined'\r\nNext.js also doesn’t provide a built-in BASE_URL environment variable. However, you can still configure one, if you need it:\r\n1. Add the following to your .env.env file:\r\n.env (bash)# ... NEXT_PUBLIC_BASE_PATH=\"/some-base-path\"\r\n1. Set basePathbasePath to process.env.NEXT_PUBLIC_BASE_PATHprocess.env.NEXT_PUBLIC_BASE_PATH in your next.config.mjsnext.config.mjs file:\r\nnext.config.mjs (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export', // Outputs a Single-Page Application (SPA). distDir: './dist', // Changes the build output directory to `./dist/`. basePath: process.env.NEXT_PUBLIC_BASE_PATH, // Sets the base path to `/some-base-path`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1abace2e-aeea-4d05-af78-3a8e95e9d0da":{"id_":"1abace2e-aeea-4d05-af78-3a8e95e9d0da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"igP5qEuDqpDBqXezW/mlYPztuD3m4SwC4xbWyovCo+g=","metadata":{},"hash":"BtC/GoMZQ/8CJlpci9tsHCMxqi5sMSI+ZMmhMsTCC5s="}},"hash":"oy3f3QfZTEZbbBHQ5hPszYxXJIh4xI9ZPZrAaIovVVE=","text":"}\r\nexport default nextConfig\r\n1. Update import.meta.env.BASE_URLimport.meta.env.BASE_URL usages to process.env.NEXT_PUBLIC_BASE_PATHprocess.env.NEXT_PUBLIC_BASE_PATH\r\nStep 8: Update Scripts in package.jsonpackage.json\r\nYou should now be able to run your application to test if you successfully migrated to Next.js. But before that, you need to update yourscripts\r\n in your package.json with Next.js related commands, and add .next and next-env.d.ts to your .gitignore:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}\r\n.gitignore (txt)# ... .next\r\nnext-env.d.ts\r\nNow run npm run dev, and open http://localhost:3000. You should hopefully see your application now running on Next.js. If your application followed a conventional Vite configuration, this is all you would need to do to have a working version of your\r\napplication. Example: Check out this pull request for a working example of a Vite application migrated to Next.js. Step 9: Clean Up\r\nYou can now clean up your codebase from Vite related artifacts:\r\nDelete main.tsx\r\nDelete index.html\r\nDelete vite-env.d.ts\r\nDelete tsconfig.node.json\r\nDelete vite.config.ts\r\nUninstall Vite dependencies\r\nNext Steps\r\nIf everything went according to plan, you now have a functioning Next.js application running as a single-page application. However, you\r\naren’t yet taking advantage of most of Next.js’ benefits, but you can now start making incremental changes to reap all the benefits. Here’s what you might want to do next:\r\nMigrate from React Router to the Next.js App Router to get:\r\nAutomatic code splitting\r\nStreaming Server-Rendering\r\nReact Server Components\r\nOptimize images with the <Image> component\r\nOptimize fonts with next/font\r\nOptimize third-party scripts with the <Script> component\r\nUpdate your ESLint configuration to support Next.js rules","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b5911109-ab58-477a-9114-354146e53744":{"id_":"b5911109-ab58-477a-9114-354146e53744","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J+e1nBX4f83PuNvnXnfesIr32vV/n+ewlnQJ5ZQrZ+k=","metadata":{},"hash":"hpm+bBpC/OrgNJXpqBtSDMSnsjzOOXhv1QdMkptsqS8="}},"hash":"BcgViu3C8LLuxe8oOJI+8f3VUJzALMLdnvLil0BB8P0=","text":"3.2 - API Reference\r\nDocumentation path: /02-app/02-api-reference/index\r\nDescription: Next.js API Reference for the App Router. The Next.js API reference is divided into the following sections:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"63f6dc09-52ed-4292-aec4-4195e06de873":{"id_":"63f6dc09-52ed-4292-aec4-4195e06de873","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HJD0c/ND8UfIOZcRPJxkE8mf8J3Asc+MPAtzZVfUP4s=","metadata":{},"hash":"X3OI3ax3aAvsvy76KXsNv2Hto1qDSDEJywlK54pDsfE="}},"hash":"4/ZBgjO+ylcn2pMIaWHfXEjSUot5As9flughPIhmRQ0=","text":"3.2.1 - Components\r\nDocumentation path: /02-app/02-api-reference/01-components/index\r\nDescription: API Reference for Next.js built-in components. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dc1e0b8a-d24c-4bab-8c0e-cdd6cea72df7":{"id_":"dc1e0b8a-d24c-4bab-8c0e-cdd6cea72df7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+JIPRg+6eBemWneBNm1yBHhSRJoc44w29xsVmf1sdtA=","metadata":{},"hash":"ioT9da6QVOPdpzkSj2ffpmDiadmem5H8WIacQ6rolXU="}},"hash":"jz43PUKVTlwP7gg89/+LD2BswrWCE1SweNUdMhDhVTo=","text":"3.2.1.1 - Font Module\r\nDocumentation path: /02-app/02-api-reference/01-components/font\r\nDescription: Optimizing loading web fonts with the built-in `next/font` loaders. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThis API reference will help you understand how to use next/font/google and next/font/local. For features and usage, please see\r\nthe Optimizing Fonts page. Font Function Arguments\r\nFor usage, review Google Fonts and Local Fonts. Keyfont/googlefont/googlefont/localfont/localTypeRequired\r\nsrcString or Array of ObjectsYes\r\nweightString or ArrayRequired/Optional\r\nstyleString or Array-\r\nsubsetsArray of Strings-\r\naxesArray of Strings-\r\ndisplayString-\r\npreloadBoolean-\r\nfallbackArray of Strings-\r\nadjustFontFallbackBoolean or String-\r\nvariableString-\r\ndeclarationsArray of Objects-\r\nsrcsrc\r\nThe path of the font file as a string or an array of objects (with type Array<{path: string, weight?: string, style?:\r\nstring}>) relative to the directory where the font loader function is called. Used in next/font/local\r\nRequired\r\nExamples:\r\nsrc:'./fonts/my-font.woff2' where my-font.woff2 is placed in a directory named fonts inside the app directory\r\nsrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight:\r\n'400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]\r\nif the font loader function is called in app/page.tsx using src:'../styles/fonts/my-font.ttf', then my-font.ttf is placed\r\nin styles/fonts at the root of the project\r\nweightweight\r\nThe font weight with the following possibilities:\r\nA string with possible values of the weights available for the specific font or a range of values if it’s a variable font\r\nAn array of weight values if the font is not a variable google font. It applies to next/font/google only. Used in next/font/google and next/font/local\r\nRequired if the font being used is not variable\r\nExamples:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c6462052-d530-4de9-b78a-5e18cf0c3cba":{"id_":"c6462052-d530-4de9-b78a-5e18cf0c3cba","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lP6S+R4yxb+2VjSQf8NhU7xoY4t5jcYB/+pB60LZiUg=","metadata":{},"hash":"7jR2nyz30q31l426JjsasikjWY9la0vm7b3BTpNlw84="},"NEXT":{"nodeId":"65a11390-3507-4cd3-a744-6b7541b59371","metadata":{},"hash":"/qc7PM5y20X/VpUdKkRYgTkZenVvUyrhx+3nbscgaAc="}},"hash":"NH7mNAvwRUTX63lqg/epOmJLGah/rw/3VqFLTcZOpEY=","text":"weight: '400': A string for a single weight value - for the font Inter, the possible values are '100', '200', '300', '400',\r\n'500', '600', '700', '800', '900' or 'variable' where 'variable' is the default)\r\nweight: '100 900': A string for the range between 100 and 900 for a variable font\r\nweight: ['100','400','900']: An array of 3 possible values for a non variable font\r\nstylestyle\r\nThe font style with the following possibilities:\r\nA string value with default value of 'normal'\r\nAn array of style values if the font is not a variable google font. It applies to next/font/google only. Used in next/font/google and next/font/local\r\nOptional\r\nExamples:\r\nstyle: 'italic': A string - it can be normal or italic for next/font/google\r\nstyle: 'oblique': A string - it can take any value for next/font/local but is expected to come from standard font styles\r\nstyle: ['italic','normal']: An array of 2 values for next/font/google - the values are from normal and italic\r\nsubsetssubsets\r\nThe font subsets defined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via\r\nsubsets will have a link preload tag injected into the head when the preload option is true, which is the default. Used in next/font/google\r\nOptional\r\nExamples:\r\nsubsets: ['latin']: An array with the subset latin\r\nYou can find a list of all subsets on the Google Fonts page for your font. axesaxes\r\nSome variable fonts have extra axes that can be included. By default, only the font weight is included to keep the file size down. The\r\npossible values of axes depend on the specific font. Used in next/font/google\r\nOptional\r\nExamples:\r\naxes: ['slnt']: An array with value slnt for the Inter variable font which has slnt as additional axes as shown here. You can\r\nfind the possible axes values for your font by using the filter on the Google variable fonts page and looking for axes other than\r\nwght\r\ndisplaydisplay\r\nThe font display with possible string values of 'auto', 'block', 'swap', 'fallback' or 'optional' with default value of 'swap'.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"65a11390-3507-4cd3-a744-6b7541b59371":{"id_":"65a11390-3507-4cd3-a744-6b7541b59371","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lP6S+R4yxb+2VjSQf8NhU7xoY4t5jcYB/+pB60LZiUg=","metadata":{},"hash":"7jR2nyz30q31l426JjsasikjWY9la0vm7b3BTpNlw84="},"PREVIOUS":{"nodeId":"c6462052-d530-4de9-b78a-5e18cf0c3cba","metadata":{},"hash":"NH7mNAvwRUTX63lqg/epOmJLGah/rw/3VqFLTcZOpEY="}},"hash":"/qc7PM5y20X/VpUdKkRYgTkZenVvUyrhx+3nbscgaAc=","text":"Used in next/font/google and next/font/local\r\nOptional\r\nExamples:\r\ndisplay: 'optional': A string assigned to the optional value\r\npreloadpreload\r\nA boolean value that specifies whether the font should be preloaded or not. The default is true. Used in next/font/google and next/font/local","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e2c37db5-5926-4105-9606-278d04632bb7":{"id_":"e2c37db5-5926-4105-9606-278d04632bb7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"liyDNJdC4Be7Q8Z6DVPC9lJTlGnIwA10Cae6yHT1NPg=","metadata":{},"hash":"ApemnrzR+GO+BQK7mGv3uWthw4qM8REK5bK95gPYlHw="}},"hash":"HjVcug8hSc2bOm13MrK62sJ0m9V0L22GAuh/zOQ5ITk=","text":"Optional\r\nExamples:\r\npreload: false\r\nfallbackfallback\r\nThe fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default. Optional\r\nUsed in next/font/google and next/font/local\r\nExamples:\r\nfallback: ['system-ui', 'arial']: An array setting the fallback fonts to system-ui or arial\r\nadjustFontFallbackadjustFontFallback\r\nFor next/font/google: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout\r\nShift. The default is true. For next/font/local: A string or boolean false value that sets whether an automatic fallback font should be used to reduce\r\nCumulative Layout Shift. The possible values are 'Arial', 'Times New Roman' or false. The default is 'Arial'. Used in next/font/google and next/font/local\r\nOptional\r\nExamples:\r\nadjustFontFallback: false: for next/font/google\r\nadjustFontFallback: 'Times New Roman': for next/font/local\r\nvariablevariable\r\nA string value to define the CSS variable name to be used if the style is applied with the CSS variable method. Used in next/font/google and next/font/local\r\nOptional\r\nExamples:\r\nvariable: '--my-font': The CSS variable --my-font is declared\r\ndeclarationsdeclarations\r\nAn array of font face descriptor key-value pairs that define the generated @font-face further. Used in next/font/local\r\nOptional\r\nExamples:\r\ndeclarations: [{ prop: 'ascent-override', value: '90%' }]\r\nApplying Styles\r\nYou can apply the font styles in three ways:\r\nclassName\r\nstyle\r\nCSS Variables\r\nclassNameclassName\r\nReturns a read-only CSS className for the loaded font to be passed to an HTML element. <p className={inter.className}>Hello, Next.js!</p>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"32c90a42-05db-40f6-b5e6-bddcadcb9b2f":{"id_":"32c90a42-05db-40f6-b5e6-bddcadcb9b2f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"j0dT99Z8Tb/GyOyhVk3G4pBpLPyIkQt7lROS5PFC2+8=","metadata":{},"hash":"gRV02IxBlm2/YS2vFDGocI7Mr+jziLs4zqNqAE+dyKM="},"NEXT":{"nodeId":"9165fde9-aedd-4121-8a4a-310acbef0000","metadata":{},"hash":"26sLi4+gpzA6raTu1/5E9iVtHEaoSdeH5u2PID5EcE4="}},"hash":"IQVU/TiN/DkpFKeFh++caplBwdllL7sx5laqUPF2oSE=","text":"stylestyle\r\nReturns a read-only CSS style object for the loaded font to be passed to an HTML element, including style.fontFamily to access\r\nthe font family name and fallback fonts. <p style={inter.style}>Hello World</p>\r\nCSS Variables\r\nIf you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method. In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font\r\nloader object as follows:\r\napp/page.tsx (tsx)import { Inter } from 'next/font/google'\r\nimport styles from '../styles/component.module.css'\r\nconst inter = Inter({\r\n  variable: '--font-inter',\r\n})\r\napp/page.js (jsx)import { Inter } from 'next/font/google'\r\nimport styles from '../styles/component.module.css'\r\nconst inter = Inter({\r\n  variable: '--font-inter',\r\n})\r\nTo use the font, set the className of the parent container of the text you would like to style to the font loader’s variable value and\r\nthe className of the text to the styles property from the external CSS file. app/page.tsx (tsx)<main className={inter.variable}>\r\n  <p className={styles.text}>Hello World</p>\r\n</main>\r\napp/page.js (jsx)<main className={inter.variable}>\r\n  <p className={styles.text}>Hello World</p>\r\n</main>\r\nDefine the text selector class in the component.module.css CSS file as follows:\r\nstyles/component.module.css (css).text {\r\n  font-family: var(--font-inter);\r\n  font-weight: 200;\r\n  font-style: italic;\r\n}\r\nIn the example above, the text Hello World is styled using the Inter font and the generated font fallback with font-weight: 200\r\nand font-style: italic. Using a font definitions file\r\nEvery time you call the localFont or Google font function, that font will be hosted as one instance in your application. Therefore, if\r\nyou need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file. For example, create a fonts.ts file in a styles folder at the root of your app directory.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9165fde9-aedd-4121-8a4a-310acbef0000":{"id_":"9165fde9-aedd-4121-8a4a-310acbef0000","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"j0dT99Z8Tb/GyOyhVk3G4pBpLPyIkQt7lROS5PFC2+8=","metadata":{},"hash":"gRV02IxBlm2/YS2vFDGocI7Mr+jziLs4zqNqAE+dyKM="},"PREVIOUS":{"nodeId":"32c90a42-05db-40f6-b5e6-bddcadcb9b2f","metadata":{},"hash":"IQVU/TiN/DkpFKeFh++caplBwdllL7sx5laqUPF2oSE="}},"hash":"26sLi4+gpzA6raTu1/5E9iVtHEaoSdeH5u2PID5EcE4=","text":"For example, create a fonts.ts file in a styles folder at the root of your app directory. Then, specify your font definitions as follows:\r\nstyles/fonts.ts (ts)import { Inter, Lora, Source_Sans_3 } from 'next/font/google'\r\nimport localFont from 'next/font/local'\r\n// define your variable fonts\r\nconst inter = Inter()","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1850a535-29f1-4248-bfac-2fb5d8e0d112":{"id_":"1850a535-29f1-4248-bfac-2fb5d8e0d112","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"54ey8v+PmjvSoQc+maQCYGT6jGPuya5VQGgNap1SkNI=","metadata":{},"hash":"hAslAJGnnBckS/Hi06Sfe5KfmJsARFf7Qko5G1NZiUg="}},"hash":"ITlKP+plvFPmQKu9dza/m4ZKj5BBgj6+rFnlRocMcFg=","text":"const lora = Lora()\r\n// define 2 weights of a non-variable font\r\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\r\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\r\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\r\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\r\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }\r\nstyles/fonts.js (js)import { Inter, Lora, Source_Sans_3 } from 'next/font/google'\r\nimport localFont from 'next/font/local'\r\n// define your variable fonts\r\nconst inter = Inter()\r\nconst lora = Lora()\r\n// define 2 weights of a non-variable font\r\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\r\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\r\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\r\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\r\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }\r\nYou can now use these definitions in your code as follows:\r\napp/page.tsx (tsx)import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p className={inter.className}>Hello world using Inter font</p>\r\n      <p style={lora.style}>Hello world using Lora font</p>\r\n      <p className={sourceCodePro700.className}>\r\n        Hello world using Source_Sans_3 font with weight 700\r\n      </p>\r\n      <p className={greatVibes.className}>My title in Great Vibes font</p>\r\n    </div>\r\n  )\r\n}\r\napp/page.js (jsx)import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p className={inter.className}>Hello world using Inter font</p>\r\n      <p style={lora.style}>Hello world using Lora font</p>\r\n      <p className={sourceCodePro700.className}>\r\n        Hello world using Source_Sans_3 font with weight 700\r\n      </p>\r\n      <p className={greatVibes.className}>My title in Great Vibes font</p>\r\n    </div>\r\n  )\r\n}\r\nTo make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json or jsconfig.json\r\nfiles as follows:\r\ntsconfig.json (json){\r\n  \"compilerOptions\": {\r\n    \"paths\": {\r\n      \"@/fonts\": [\"./styles/fonts\"]\r\n    }\r\n  }\r\n}\r\nYou can now import any font definition as follows:\r\napp/about/page.tsx (tsx)import { greatVibes, sourceCodePro400 } from '@/fonts'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ccc24611-dc1f-4d75-9925-4ba35e3a10eb":{"id_":"ccc24611-dc1f-4d75-9925-4ba35e3a10eb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cXhrFr+LD9LGvKyhRl935H8GfZ7obFCSK8/5z81L4aU=","metadata":{},"hash":"VoSd4qij7qr/I0kKJJnNdwcjk7/ViFWjPM3hNuiUwS8="}},"hash":"l9ygrv6wseOeQ17rjj/0hnyw7iUjOgeHeGnoIbelPkA=","text":"app/about/page.js (jsx)import { greatVibes, sourceCodePro400 } from '@/fonts'\r\nVersion Changes\r\nVersionChanges\r\nv13.2.0@next/font renamed to next/font. Installation no longer required. v13.0.0@next/font was added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"26ca59f0-f902-43ae-aab0-c898c6a5ae16":{"id_":"26ca59f0-f902-43ae-aab0-c898c6a5ae16","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yzGs3LPA9xdi6+mmwF9vlRQwamxqM8Hfwov8CtWhpdY=","metadata":{},"hash":"D/+X0TtJWKg3x8VlYnLl+WI6kxGvASLX3b0pW32KNSg="},"NEXT":{"nodeId":"d25a5555-1e16-4a5b-82a0-5f547e8c9bce","metadata":{},"hash":"yLpWhUjhsJiJ88/eZ0q7PzkEVK/Jb1oh6Q4BNTeovF8="}},"hash":"U/R05nE+N2u3QaGuSgqC54WG1Kfgrz2C5IznMU1CuaM=","text":"3.2.1.2 - <Image>\r\nDocumentation path: /02-app/02-api-reference/01-components/image\r\nDescription: Optimize Images in your Next.js Application using the built-in `next/image` Component. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\nGood to know: If you are using a version of Next.js prior to 13, you’ll want to use the next/legacy/image documentation since\r\nthe component was renamed. This API reference will help you understand how to use props and configuration options available for the Image Component. For\r\nfeatures and usage, please see the Image Component page.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d25a5555-1e16-4a5b-82a0-5f547e8c9bce":{"id_":"d25a5555-1e16-4a5b-82a0-5f547e8c9bce","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yzGs3LPA9xdi6+mmwF9vlRQwamxqM8Hfwov8CtWhpdY=","metadata":{},"hash":"D/+X0TtJWKg3x8VlYnLl+WI6kxGvASLX3b0pW32KNSg="},"PREVIOUS":{"nodeId":"26ca59f0-f902-43ae-aab0-c898c6a5ae16","metadata":{},"hash":"U/R05nE+N2u3QaGuSgqC54WG1Kfgrz2C5IznMU1CuaM="},"NEXT":{"nodeId":"0dbf10a5-e337-4158-8f07-e21a168e8be4","metadata":{},"hash":"Oe5Q0fjbnxQweeslX1hZgNeRwnemZ6Bc64zApfjdxIU="}},"hash":"yLpWhUjhsJiJ88/eZ0q7PzkEVK/Jb1oh6Q4BNTeovF8=","text":"For\r\nfeatures and usage, please see the Image Component page. app/page.js (jsx)import Image from 'next/image'\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"/profile.png\"\r\n      width={500}\r\n      height={500}\r\n      alt=\"Picture of the author\"\r\n    />\r\n  )\r\n}\r\nProps\r\nHere’s a summary of the props available for the Image Component:\r\n| Prop | Example | Type | Status | | ----------------------------------------- | ---------------------------------------- | --------------- | ---------- | | [`src`](#src) |\r\n`src=\"/profile.png\"` | String | Required | | [`width`](#width) | `width={500}` | Integer (px) | Required | | [`height`](#height) | `height=\r\n{500}` | Integer (px) | Required | | [`alt`](#alt) | `alt=\"Picture of the author\"` | String | Required | | [`loader`](#loader) | `loader=\r\n{imageLoader}` | Function | - | | [`fill`](#fill) | `fill={true}` | Boolean | - | | [`sizes`](#sizes) | `sizes=\"(max-width: 768px) 100vw, 33vw\"` |\r\nString | - | | [`quality`](#quality) | `quality={80}` | Integer (1-100) | - | | [`priority`](#priority) | `priority={true}` | Boolean | - | |\r\n[`placeholder`](#placeholder) | `placeholder=\"blur\"` | String | - | | [`style`](#style) | `style={{objectFit: \"contain\"}}` | Object | - | |\r\n[`onLoadingComplete`](#onloadingcomplete) | `onLoadingComplete={img => done())}` | Function | Deprecated | | [`onLoad`](#onload) |\r\n`onLoad={event => done())}` | Function | - | | [`onError`](#onerror) | `onError(event => fail()}` | Function | - | | [`loading`](#loading) |\r\n`loading=\"lazy\"` | String | - | | [`blurDataURL`](#blurdataurl) | `blurDataURL=\"data:image/jpeg... \"` | String | - |\r\nRequired Props\r\nThe Image Component requires the following properties: src, width, height, and alt.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0dbf10a5-e337-4158-8f07-e21a168e8be4":{"id_":"0dbf10a5-e337-4158-8f07-e21a168e8be4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yzGs3LPA9xdi6+mmwF9vlRQwamxqM8Hfwov8CtWhpdY=","metadata":{},"hash":"D/+X0TtJWKg3x8VlYnLl+WI6kxGvASLX3b0pW32KNSg="},"PREVIOUS":{"nodeId":"d25a5555-1e16-4a5b-82a0-5f547e8c9bce","metadata":{},"hash":"yLpWhUjhsJiJ88/eZ0q7PzkEVK/Jb1oh6Q4BNTeovF8="}},"hash":"Oe5Q0fjbnxQweeslX1hZgNeRwnemZ6Bc64zApfjdxIU=","text":"app/page.js (jsx)import Image from 'next/image'\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <Image\r\n        src=\"/profile.png\"\r\n        width={500}\r\n        height={500}\r\n        alt=\"Picture of the author\"\r\n      />\r\n    </div>\r\n  )\r\n}\r\nsrcsrc\r\nMust be one of the following:\r\nA statically imported image file\r\nA path string. This can be either an absolute external URL, or an internal path depending on the loader prop.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3633e714-454c-441c-aea5-f9c7d0fdef3e":{"id_":"3633e714-454c-441c-aea5-f9c7d0fdef3e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"TCXHpIu3azMr80fa2T6lvt2lg59Q+z025VZYdoJ32b0=","metadata":{},"hash":"1GlGCakklzPw/DVoveJXadXI38x/CM9plpDxy92a2e0="}},"hash":"ZkNUuxs2CG3sKELmDh22gol6nTg3LG+aaeXIFjGDGJo=","text":"When using an external URL, you must add it to remotePatterns in next.config.js. widthwidth\r\nThe width property represents the rendered width in pixels, so it will affect how large the image appears. Required, except for statically imported images or images with the fill property. heightheight\r\nThe height property represents the rendered height in pixels, so it will affect how large the image appears. Required, except for statically imported images or images with the fill property. altalt\r\nThe alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been\r\ndisabled or an error occurs while loading the image. It should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image\r\nand should not repeat information that is already provided in the captions above or below the image. If the image is purely decorative or not intended for the user, the alt property should be an empty string (alt=\"\"). Learn more\r\nOptional Props\r\nThe <Image /> component accepts a number of additional properties beyond those which are required. This section describes the\r\nmost commonly-used properties of the Image component. Find details about more rarely-used properties in the Advanced Props\r\nsection. loaderloader\r\nA custom function used to resolve image URLs. A loader is a function returning a URL string for the image, given the following parameters:\r\nsrc\r\nwidth\r\nquality\r\nHere is an example of using a custom loader:\r\n'use client'\r\nimport Image from 'next/image'\r\nconst imageLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      loader={imageLoader}\r\n      src=\"me.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}\r\nGood to know: Using props like loader, which accept a function, require using Client Components to serialize the provided\r\nfunction. Alternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your\r\napplication, without passing a prop. fillfill","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"93609a16-8a53-42a8-a1a5-84ef6ed3692b":{"id_":"93609a16-8a53-42a8-a1a5-84ef6ed3692b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"TY27b9blbbu2+B9JU9GOyLHJ5ddCyW12txAQ5Rcal1E=","metadata":{},"hash":"6Q2xwvB5xDTZk6HG3Yl4TPcpa7wQG8abHW7VffSQaEQ="},"NEXT":{"nodeId":"f8ce9175-fcc4-4274-8f4f-5ab3fd62ef46","metadata":{},"hash":"e/3OE3bcN426tTnWq6dyeMcZqEHMj5un1X7MKyrdMx0="}},"hash":"r/URPIh5cf+VppCbA90DwuXb0iDX1uVempeS+cnjLhQ=","text":"fill={true} // {true} | {false}\r\nA boolean that causes the image to fill the parent element, which is useful when the width and height are unknown. The parent element must assign position: \"relative\", position: \"fixed\", or position: \"absolute\" style. By default, the img element will automatically be assigned the position: \"absolute\" style. If no styles are applied to the image, the image will stretch to fit the container. You may prefer to set object-fit: \"contain\" for an\r\nimage which is letterboxed to fit the container and preserve aspect ratio. Alternatively, object-fit: \"cover\" will cause the image to fill the entire container and be cropped to preserve aspect ratio. For this\r\nto look correct, the overflow: \"hidden\" style should be assigned to the parent element. For more information, see also:\r\nposition\r\nobject-fit\r\nobject-position\r\nsizessizes\r\nA string, similar to a media query, that provides information about how wide the image will be at different breakpoints. The value ofsizes\r\n will greatly affect performance for images using fill or which are styled to have a responsive size. The sizes property serves two important purposes related to image performance:\r\nFirst, the value of sizes is used by the browser to determine which size of the image to download, from next/image’s\r\nautomatically generated srcset. When the browser chooses, it does not yet know the size of the image on the page, so it selects an\r\nimage that is the same size or larger than the viewport. The sizes property allows you to tell the browser that the image will\r\nactually be smaller than full screen. If you don’t specify a sizes value in an image with the fill property, a default value of 100vw\r\n(full screen width) is used. Second, the sizes property changes the behavior of the automatically generated srcset value. If no sizes value is present, a\r\nsmall srcset is generated, suitable for a fixed-size image (1x/2x/etc). If sizes is defined, a large srcset is generated, suitable for\r\na responsive image (640w/750w/etc). If the sizes property includes sizes such as 50vw, which represent a percentage of the\r\nviewport width, then the srcset is trimmed to not include any values which are too small to ever be necessary.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f8ce9175-fcc4-4274-8f4f-5ab3fd62ef46":{"id_":"f8ce9175-fcc4-4274-8f4f-5ab3fd62ef46","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"TY27b9blbbu2+B9JU9GOyLHJ5ddCyW12txAQ5Rcal1E=","metadata":{},"hash":"6Q2xwvB5xDTZk6HG3Yl4TPcpa7wQG8abHW7VffSQaEQ="},"PREVIOUS":{"nodeId":"93609a16-8a53-42a8-a1a5-84ef6ed3692b","metadata":{},"hash":"r/URPIh5cf+VppCbA90DwuXb0iDX1uVempeS+cnjLhQ="}},"hash":"e/3OE3bcN426tTnWq6dyeMcZqEHMj5un1X7MKyrdMx0=","text":"For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-\r\ncolumn layout on desktop displays, you should include a sizes property such as the following:\r\nimport Image from 'next/image'\r\nexport default function Page() {\r\n  return (\r\n    <div className=\"grid-element\">\r\n      <Image\r\n        fill\r\n        src=\"/example.png\"\r\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\r\n      />\r\n    </div>\r\n  )\r\n}\r\nThis example sizes could have a dramatic effect on performance metrics. Without the 33vw sizes, the image selected from the server\r\nwould be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, without sizes the user would\r\ndownload an image that’s 9 times larger than necessary. Learn more about srcset and sizes:\r\nweb.dev\r\nmdn\r\nqualityquality\r\nquality={75} // {number 1-100}\r\nThe quality of the optimized image, an integer between 1 and 100, where 100 is the best quality and therefore largest file size. Defaults\r\nto 75.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"da4ab38a-0def-4266-905a-e43c889f4c50":{"id_":"da4ab38a-0def-4266-905a-e43c889f4c50","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WDHaU5WRUetxMMTsmT2d3C1l1cNYYdifNe1yxds9rZs=","metadata":{},"hash":"DEGmwABFdic8T7ugerkjcGsIKVWS8ng4Uk6QxaBckpo="},"NEXT":{"nodeId":"d4dcd1d7-23c1-4f67-b6d6-c962e8a9ef49","metadata":{},"hash":"N6wOK5ZWISDzVngOxaxXrDhL1mZQeYsVSm27AaSoqgM="}},"hash":"6MBbjZfPWE0UbTde8c4auBOsth32vTAFTkBxPBsLDm8=","text":"prioritypriority\r\npriority={false} // {false} | {true}\r\nWhen true, the image will be considered high priority and preload. Lazy loading is automatically disabled for images using priority. You should use the priority property on any image detected as the Largest Contentful Paint (LCP) element. It may be appropriate to\r\nhave multiple priority images, as different images may be the LCP element for different viewport sizes. Should only be used when the image is visible above the fold. Defaults to false. placeholderplaceholder\r\nplaceholder = 'empty' // \"empty\" | \"blur\" | \"data:image/... \"\r\nA placeholder to use while the image is loading. Possible values are blur, empty, or data:image/.... Defaults to empty. When blur, the blurDataURL property will be used as the placeholder. If src is an object from a static import and the imported image\r\nis .jpg, .png, .webp, or .avif, then blurDataURL will be automatically populated, except when the image is detected to be\r\nanimated. For dynamic images, you must provide the blurDataURL property. Solutions such as Plaiceholder can help with base64 generation. When data:image/..., the Data URL will be used as the placeholder while the image is loading. When empty, there will be no placeholder while the image is loading, only empty space. Try it out:\r\nDemo the blur placeholder\r\nDemo the shimmer effect with data URL placeholder prop\r\nDemo the color effect with blurDataURL prop\r\nAdvanced Props\r\nIn some cases, you may need more advanced usage. The <Image /> component optionally accepts the following advanced properties. stylestyle\r\nAllows passing CSS styles to the underlying image element. components/ProfileImage.js (jsx)const imageStyle = {\r\n  borderRadius: '50%',\r\n  border: '1px solid #fff',\r\n}\r\nexport default function ProfileImage() {\r\n  return <Image src=\"... \" style={imageStyle} />\r\n}\r\nRemember that the required width and height props can interact with your styling. If you use styling to modify an image’s width, you\r\nshould also style its height to auto to preserve its intrinsic aspect ratio, or your image will be distorted. onLoadingCompleteonLoadingComplete\r\n'use client'\r\n<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />\r\nWarning: Deprecated since Next.js 14 in favor of onLoad.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d4dcd1d7-23c1-4f67-b6d6-c962e8a9ef49":{"id_":"d4dcd1d7-23c1-4f67-b6d6-c962e8a9ef49","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WDHaU5WRUetxMMTsmT2d3C1l1cNYYdifNe1yxds9rZs=","metadata":{},"hash":"DEGmwABFdic8T7ugerkjcGsIKVWS8ng4Uk6QxaBckpo="},"PREVIOUS":{"nodeId":"da4ab38a-0def-4266-905a-e43c889f4c50","metadata":{},"hash":"6MBbjZfPWE0UbTde8c4auBOsth32vTAFTkBxPBsLDm8="}},"hash":"N6wOK5ZWISDzVngOxaxXrDhL1mZQeYsVSm27AaSoqgM=","text":"A callback function that is invoked once the image is completely loaded and the placeholder has been removed. The callback function will be called with one argument, a reference to the underlying <img> element. Good to know: Using props like onLoadingComplete, which accept a function, require using Client Components to serialize\r\nthe provided function. onLoadonLoad","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6963e574-55cd-40c1-b612-4eb5ffc7a865":{"id_":"6963e574-55cd-40c1-b612-4eb5ffc7a865","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gb6bSvgUGo+tibwI2cFdJ2Hrk85d3LkJ1ctbnktP8CE=","metadata":{},"hash":"V4tw1KB8UG3QkgyYEKnriyMXf/fLbCM1DnO8HpP8ANs="}},"hash":"QWa1VQCdkNUVlt8g454ER/GYXXAx48vSFMs8k9U5i0w=","text":"<Image onLoad={(e) => console.log(e.target.naturalWidth)} />\r\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed. The callback function will be called with one argument, the Event which has a target that references the underlying <img> element. Good to know: Using props like onLoad, which accept a function, require using Client Components to serialize the provided\r\nfunction. onErroronError\r\n<Image onError={(e) => console.error(e.target.id)} />\r\nA callback function that is invoked if the image fails to load. Good to know: Using props like onError, which accept a function, require using Client Components to serialize the provided\r\nfunction. loadingloading\r\nRecommendation: This property is only meant for advanced use cases. Switching an image to load with eager will normally\r\nhurt performance. We recommend using the priority property instead, which will eagerly preload the image. loading = 'lazy' // {lazy} | {eager}\r\nThe loading behavior of the image. Defaults to lazy. When lazy, defer loading the image until it reaches a calculated distance from the viewport. When eager, load the image immediately. Learn more about the loading attribute. blurDataURLblurDataURL\r\nA Data URL to be used as a placeholder image before the src image successfully loads. Only takes effect when combined with\r\nplaceholder=\"blur\". Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or less) is recommended. Including larger\r\nimages as placeholders may harm your application performance. Try it out:\r\nDemo the default blurDataURL prop\r\nDemo the color effect with blurDataURL prop\r\nYou can also generate a solid color Data URL to match the image. unoptimizedunoptimized\r\nunoptimized = {false} // {false} | {true}\r\nWhen true, the source image will be served as-is instead of changing quality, size, or format. Defaults to false. import Image from 'next/image'\r\nconst UnoptimizedImage = (props) => {\r\n  return <Image {...props} unoptimized />\r\n}\r\nSince Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    unoptimized: true,\r\n  },\r\n}\r\nOther Props","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"52bdd28f-88dd-4509-9a4c-4faaf1533807":{"id_":"52bdd28f-88dd-4509-9a4c-4faaf1533807","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zIfBPUY+aiqHkpkaGu71xvDCMG7cAo5c8hR1oCmKm14=","metadata":{},"hash":"WkslQuYXUMkLI4eo2XqOsGUyM90kImu0tREVnDSkMR8="},"NEXT":{"nodeId":"fae358b7-c398-48a0-92cf-9d52fb7ed209","metadata":{},"hash":"UaYvKqxbtkW0yeTrJnNLYNtaUCgCXjVEW6EFzUFyoIo="}},"hash":"CoCXPxDQWZx7d4+bUYln1IHIQ/4tQgJmJ8ld9wufO6Y=","text":"Other properties on the <Image /> component will be passed to the underlying img element with the exception of the following:\r\nsrcSet. Use Device Sizes instead. decoding. It is always \"async\". Configuration Options\r\nIn addition to props, you can configure the Image Component in next.config.js. The following options are available:\r\nremotePatternsremotePatterns\r\nTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only\r\nexternal images from your account can be served from the Next.js Image Optimization API. These external images can be configured\r\nwith the remotePatterns property in your next.config.js file, as shown below:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'example.com',\r\n        port: '',\r\n        pathname: '/account123/**',\r\n      },\r\n    ],\r\n  },\r\n}\r\nGood to know: The example above will ensure the src property of next/image must start withhttps://example.com/account123/\r\n. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad\r\nRequest. Below is another example of the remotePatterns property in the next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: '**.example.com',\r\n      },\r\n    ],\r\n  },\r\n}\r\nGood to know: The example above will ensure the src property of next/image must start with https://img1.example.com\r\nor https://me.avatar.example.com or any number of subdomains. Any other protocol or unmatched hostname will\r\nrespond with 400 Bad Request. Wildcard patterns can be used for both pathname and hostname and have the following syntax:\r\n* match a single path segment or subdomain\r\n** match any number of path segments at the end or subdomains at the beginning\r\nThe ** syntax does not work in the middle of the pattern. domainsdomains\r\nWarning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious\r\nusers. Only use domains if you own all the content served from the domain. Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fae358b7-c398-48a0-92cf-9d52fb7ed209":{"id_":"fae358b7-c398-48a0-92cf-9d52fb7ed209","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zIfBPUY+aiqHkpkaGu71xvDCMG7cAo5c8hR1oCmKm14=","metadata":{},"hash":"WkslQuYXUMkLI4eo2XqOsGUyM90kImu0tREVnDSkMR8="},"PREVIOUS":{"nodeId":"52bdd28f-88dd-4509-9a4c-4faaf1533807","metadata":{},"hash":"CoCXPxDQWZx7d4+bUYln1IHIQ/4tQgJmJ8ld9wufO6Y="}},"hash":"UaYvKqxbtkW0yeTrJnNLYNtaUCgCXjVEW6EFzUFyoIo=","text":"Below is an example of the domains property in the next.config.js file:\r\nnext.config.js (js)module.exports = {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"23172a5e-5d1a-4b3c-8aea-fb4b1b785f7e":{"id_":"23172a5e-5d1a-4b3c-8aea-fb4b1b785f7e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"svR06JISPnpNYI1A4GZ+S/e+C8a2UZq13QhGx4dMt84=","metadata":{},"hash":"Xq64NcQgkdiwaiq+1TUaZ+D4zLuMXZvkamSozL3Rlws="},"NEXT":{"nodeId":"9b6c79db-2527-4b6b-9e8a-6e58e545049c","metadata":{},"hash":"ibybn/hlg6FbE9/dKtL7yvnPhasm2p5ZkYuhmWuj/uY="}},"hash":"4kcxdFQJB9jU4Izmgy+isED0f+/8j2AAOWAV69w/5io=","text":"images: {\r\n    domains: ['assets.acme.com'],\r\n  },\r\n}\r\nloaderFileloaderFile\r\nIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure\r\nthe loaderFile in your next.config.js like the following:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my/image/loader.js',\r\n  },\r\n}\r\nThis must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for\r\nexample:\r\n'use client'\r\nexport default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\nAlternatively, you can use the loader prop to configure each instance of next/image. Examples:\r\nCustom Image Loader Configuration\r\nGood to know: Customizing the image loader file, which accepts a function, require using Client Components to serialize the\r\nprovided function. Advanced\r\nThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you\r\nwill override any changes to the Next.js defaults in future updates. deviceSizesdeviceSizes\r\nIf you know the expected device widths of your users, you can specify a list of device width breakpoints using the deviceSizes\r\nproperty in next.config.js. These widths are used when the next/image component uses sizes prop to ensure the correct image\r\nis served for user’s device. If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\r\n  },\r\n}\r\nimageSizesimageSizes\r\nYou can specify a list of image widths using the images.imageSizes property in your next.config.js file. These widths are\r\nconcatenated with the array of device sizes to form the full array of sizes used to generate image srcsets. The reason there are two separate lists is that imageSizes is only used for images which provide a sizes prop, which indicates that the\r\nimage is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in\r\ndeviceSizes. If no configuration is provided, the default below is used.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9b6c79db-2527-4b6b-9e8a-6e58e545049c":{"id_":"9b6c79db-2527-4b6b-9e8a-6e58e545049c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"svR06JISPnpNYI1A4GZ+S/e+C8a2UZq13QhGx4dMt84=","metadata":{},"hash":"Xq64NcQgkdiwaiq+1TUaZ+D4zLuMXZvkamSozL3Rlws="},"PREVIOUS":{"nodeId":"23172a5e-5d1a-4b3c-8aea-fb4b1b785f7e","metadata":{},"hash":"4kcxdFQJB9jU4Izmgy+isED0f+/8j2AAOWAV69w/5io="}},"hash":"ibybn/hlg6FbE9/dKtL7yvnPhasm2p5ZkYuhmWuj/uY=","text":"If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ec29e1dc-07f6-4366-81bc-8543f9ed2a40":{"id_":"ec29e1dc-07f6-4366-81bc-8543f9ed2a40","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zaly+l67cEvbMylFjjCEFdkIEE66vhqOAMIvcOwDOb4=","metadata":{},"hash":"awj7rwtQzyJ5AOgB5te0lFQcxkH0apYuFWrhtVq3iTA="},"NEXT":{"nodeId":"368939e6-5638-46f1-aeaf-9d6189e9e955","metadata":{},"hash":"dkxgYXP2Tgg+9RA3W3TEKU5RKevpnp6kmaNTiIPEmC4="}},"hash":"EW1abKsBvHzmXEeaEvOiqEcj3SE/FndWJBsrQgwboB8=","text":"formatsformats\r\nThe default Image Optimization API will automatically detect the browser’s supported image formats via the request’s Accept header. If the Accept head matches more than one of the configured formats, the first match in the array is used. Therefore, the array order\r\nmatters. If there is no match (or the source image is animated), the Image Optimization API will fallback to the original image’s format. If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    formats: ['image/webp'],\r\n  },\r\n}\r\nYou can enable AVIF support with the following configuration. next.config.js (js)module.exports = {\r\n  images: {\r\n    formats: ['image/avif', 'image/webp'],\r\n  },\r\n}\r\nGood to know:\r\nAVIF generally takes 20% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time\r\nan image is requested, it will typically be slower and then subsequent requests that are cached will be faster. If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the Accept header. Caching Behavior\r\nThe following describes the caching algorithm for the default loader. For all other loaders, please refer to your cloud provider’s\r\ndocumentation. Images are optimized dynamically upon request and stored in the <distDir>/cache/images directory. The optimized image file will\r\nbe served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the\r\nexpired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to\r\nthe cache with the new expiration date. The cache status of an image can be determined by reading the value of the x-nextjs-cache response header. The possible values are\r\nthe following:\r\nMISS - the path is not in the cache (occurs at most once, on the first visit)\r\nSTALE - the path is in the cache but exceeded the revalidate time so it will be updated in the background\r\nHIT - the path is in the cache and has not exceeded the revalidate time\r\nThe expiration (or rather Max Age) is defined by either the minimumCacheTTL configuration or the upstream image Cache-Control\r\nheader, whichever is larger. Specifically, the max-age value of the Cache-Control header is used.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"368939e6-5638-46f1-aeaf-9d6189e9e955":{"id_":"368939e6-5638-46f1-aeaf-9d6189e9e955","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zaly+l67cEvbMylFjjCEFdkIEE66vhqOAMIvcOwDOb4=","metadata":{},"hash":"awj7rwtQzyJ5AOgB5te0lFQcxkH0apYuFWrhtVq3iTA="},"PREVIOUS":{"nodeId":"ec29e1dc-07f6-4366-81bc-8543f9ed2a40","metadata":{},"hash":"EW1abKsBvHzmXEeaEvOiqEcj3SE/FndWJBsrQgwboB8="}},"hash":"dkxgYXP2Tgg+9RA3W3TEKU5RKevpnp6kmaNTiIPEmC4=","text":"Specifically, the max-age value of the Cache-Control header is used. If both s-maxage and max-age are\r\nfound, then s-maxage is preferred. The max-age is also passed-through to any downstream clients including CDNs and browsers. You can configure minimumCacheTTL to increase the cache duration when the upstream image does not include Cache-Control\r\nheader or the value is very low. You can configure deviceSizes and imageSizes to reduce the total number of possible generated images. You can configure formats to disable multiple formats in favor of a single image format. minimumCacheTTLminimumCacheTTL\r\nYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it’s better to use a Static Image Import\r\nwhich will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable. next.config.js (js)module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 60,\r\n  },\r\n}\r\nThe expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"20ec7116-ce58-4710-8f18-7269c552be1b":{"id_":"20ec7116-ce58-4710-8f18-7269c552be1b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1cuBJPqfjgpm5sd7Kutt30HvU3t2YI7cOqoBghjhhf4=","metadata":{},"hash":"KX/K0LH54EXMnjaXAbjCEfHuNLcLx9bPisVzzMNA1MY="},"NEXT":{"nodeId":"878a2d20-0b4e-4348-8347-896dbe32798c","metadata":{},"hash":"bgcWu9Mb1maAzeukL6f3auEF3QbdSwYlaVJ4Q9jCDbo="}},"hash":"uOVJXsUlw7idpsbDlHNdbgufevUl9BU7YdlTpze0jqM=","text":"Control header, whichever is larger. If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream\r\nimage (e.g. /some-asset.jpg, not /_next/image itself). There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to\r\nmanually change the src prop or delete <distDir>/cache/images. disableStaticImagesdisableStaticImages\r\nThe default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src\r\nproperty. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently. You can disable static image imports inside your next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}\r\ndangerouslyAllowSVGdangerouslyAllowSVG\r\nThe default loader does not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without a proper Content Security Policy. If you need to serve SVG images with the default Image Optimization API, you can set dangerouslyAllowSVG inside your\r\nnext.config.js:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n    contentDispositionType: 'attachment',\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n}\r\nIn addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as\r\ncontentSecurityPolicy to prevent scripts embedded in the image from executing. Animated Images\r\nThe default loader will automatically bypass Image Optimization for animated images and serve the image as-is. Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization\r\nfor a given animated image, use the unoptimized prop. Responsive Images\r\nThe default generated srcset contains 1x and 2x images in order to support different device pixel ratios. However, you may wish to\r\nrender a responsive image that stretches with the viewport. In that case, you’ll need to set sizes as well as style (or className).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"878a2d20-0b4e-4348-8347-896dbe32798c":{"id_":"878a2d20-0b4e-4348-8347-896dbe32798c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1cuBJPqfjgpm5sd7Kutt30HvU3t2YI7cOqoBghjhhf4=","metadata":{},"hash":"KX/K0LH54EXMnjaXAbjCEfHuNLcLx9bPisVzzMNA1MY="},"PREVIOUS":{"nodeId":"20ec7116-ce58-4710-8f18-7269c552be1b","metadata":{},"hash":"uOVJXsUlw7idpsbDlHNdbgufevUl9BU7YdlTpze0jqM="}},"hash":"bgcWu9Mb1maAzeukL6f3auEF3QbdSwYlaVJ4Q9jCDbo=","text":"In that case, you’ll need to set sizes as well as style (or className). You can render a responsive image using one of the following methods below. Responsive image using a static import\r\nIf the source image is not dynamic, you can statically import to create a responsive image:\r\ncomponents/author.js (jsx)import Image from 'next/image'\r\nimport me from '../photos/me.jpg'\r\nexport default function Author() {\r\n  return (\r\n    <Image\r\n      src={me}\r\n      alt=\"Picture of the author\"\r\n      sizes=\"100vw\"\r\n      style={{","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8e56f746-e651-4727-b1a6-e8e54afaf8cf":{"id_":"8e56f746-e651-4727-b1a6-e8e54afaf8cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nzMlSHiVN02KoavJf69TmBu1vCLHckTI75iJPZoCCHY=","metadata":{},"hash":"yfIIajP1a0V1PKMrqOXo5J57S0x7DS7RPuUycIA8/Ns="}},"hash":"4YcaoQoorcn+Imjdl71JFFQW0FuKPyPzc5Fx7uDPo9A=","text":"width: '100%',\r\n        height: 'auto',\r\n      }}\r\n    />\r\n  )\r\n}\r\nTry it out:\r\nDemo the image responsive to viewport\r\nResponsive image with aspect ratio\r\nIf the source image is a dynamic or a remote url, you will also need to provide width and height to set the correct aspect ratio of the\r\nresponsive image:\r\ncomponents/page.js (jsx)import Image from 'next/image'\r\nexport default function Page({ photoUrl }) {\r\n  return (\r\n    <Image\r\n      src={photoUrl}\r\n      alt=\"Picture of the author\"\r\n      sizes=\"100vw\"\r\n      style={{\r\n        width: '100%',\r\n        height: 'auto',\r\n      }}\r\n      width={500}\r\n      height={300}\r\n    />\r\n  )\r\n}\r\nTry it out:\r\nDemo the image responsive to viewport\r\nResponsive image with fillfill\r\nIf you don’t know the aspect ratio, you will need to set the fill prop and set position: relative on the parent. Optionally, you can\r\nset object-fit style depending on the desired stretch vs crop behavior:\r\napp/page.js (jsx)import Image from 'next/image'\r\nexport default function Page({ photoUrl }) {\r\n  return (\r\n    <div style={{ position: 'relative', width: '500px', height: '300px' }}>\r\n      <Image\r\n        src={photoUrl}\r\n        alt=\"Picture of the author\"\r\n        sizes=\"500px\"\r\n        fill\r\n        style={{\r\n          objectFit: 'contain',\r\n        }}\r\n      />\r\n    </div>\r\n  )\r\n}\r\nTry it out:\r\nDemo the fill prop\r\nTheme Detection\r\nIf you want to display a different image for light and dark mode, you can create a new component that wraps two <Image> components\r\nand reveals the correct one based on a CSS media query. components/theme-image.module.css (css)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"56a979c5-b944-4879-abcd-993b53082b1b":{"id_":"56a979c5-b944-4879-abcd-993b53082b1b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"edLlVjkjD00MY2iXpL4x7eF8mBeK33p1YvCa7f4qakg=","metadata":{},"hash":"qGpa5Dv8FupJYhqO3DmuyC9dGJaEdF2BTNQsnXScS0c="},"NEXT":{"nodeId":"03cfd8ad-2d6f-4eca-894c-a8eb70af3c9e","metadata":{},"hash":"YX1Sj/jhr90dIhGUADaG++TnKSuP2jjgFECPuhCDh/Q="}},"hash":"Vlsf1gK0+rjmsWoQRm7gxPyj3ibbDNdx2OlnxNNiFio=","text":".imgDark {\r\n  display: none;\r\n}\r\n@media (prefers-color-scheme: dark) {\r\n  .imgLight {\r\n    display: none;\r\n  }\r\n  .imgDark {\r\n    display: unset;\r\n  }\r\n}\r\ncomponents/theme-image.tsx (tsx)import styles from './theme-image.module.css'\r\nimport Image, { ImageProps } from 'next/image'\r\ntype Props = Omit<ImageProps, 'src' | 'priority' | 'loading'> & {\r\n  srcLight: string\r\n  srcDark: string\r\n}\r\nconst ThemeImage = (props: Props) => {\r\n  const { srcLight, srcDark, ...rest } = props\r\n  return (\r\n    <>\r\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\r\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\r\n    </>\r\n  )\r\n}\r\ncomponents/theme-image.js (jsx)import styles from './theme-image.module.css'\r\nimport Image from 'next/image'\r\nconst ThemeImage = (props) => {\r\n  const { srcLight, srcDark, ...rest } = props\r\n  return (\r\n    <>\r\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\r\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\r\n    </>\r\n  )\r\n}\r\nGood to know: The default behavior of loading=\"lazy\" ensures that only the correct image is loaded. You cannot usepriority\r\n or loading=\"eager\" because that would cause both images to load. Instead, you can use\r\nfetchPriority=\"high\". Try it out:\r\nDemo light/dark mode theme detection\r\nKnown Browser Bugs\r\nThis next/image component uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari\r\n15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles withwidth\r\n/height of auto, it is possible to cause Layout Shift on older browsers before Safari 15 that don’t preserve the aspect ratio. For\r\nmore details, see this MDN video. Safari 15 - 16.3 display a gray border while loading. Safari 16.4 fixed this issue.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"03cfd8ad-2d6f-4eca-894c-a8eb70af3c9e":{"id_":"03cfd8ad-2d6f-4eca-894c-a8eb70af3c9e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"edLlVjkjD00MY2iXpL4x7eF8mBeK33p1YvCa7f4qakg=","metadata":{},"hash":"qGpa5Dv8FupJYhqO3DmuyC9dGJaEdF2BTNQsnXScS0c="},"PREVIOUS":{"nodeId":"56a979c5-b944-4879-abcd-993b53082b1b","metadata":{},"hash":"Vlsf1gK0+rjmsWoQRm7gxPyj3ibbDNdx2OlnxNNiFio="}},"hash":"YX1Sj/jhr90dIhGUADaG++TnKSuP2jjgFECPuhCDh/Q=","text":"Safari 16.4 fixed this issue. Possible solutions:\r\nUse CSS @supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=\"lazy\"] {\r\nclip-path: inset(0.6px) } }\r\nUse priority if the image is above the fold\r\nFirefox 67+ displays a white background while loading. Possible solutions:\r\nEnable AVIF formats\r\nUse placeholder","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0648072b-674c-4137-b6dd-984eea6da0ed":{"id_":"0648072b-674c-4137-b6dd-984eea6da0ed","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Jv+PvG+sdIzhGVzNKhXD5/hNwCDxjj1wuCBrl69eVrs=","metadata":{},"hash":"cOXkZrwsOJx5Ug7ysDb12CyvODhBuRWTjsgscfu7wu4="}},"hash":"ZsB/F9/+NBvfPAHPwwjl04EorST39Tkf7vqcuuS3KS8=","text":"Version History\r\nVersionChanges\r\nv14.0.0onLoadingComplete prop and domains config deprecated. v13.4.14placeholder prop support for data:/image... v13.2.0contentDispositionType configuration added. v13.0.6ref prop added. v13.0.0\r\nThe next/image import was renamed to next/legacy/image. The next/future/image import was renamed to\r\nnext/image. A codemod is available to safely and automatically rename your imports. <span> wrapper removed. layout, objectFit, objectPosition, lazyBoundary, lazyRoot props removed. alt is required. onLoadingComplete receives reference to img element. Built-in loader config removed. v12.3.0remotePatterns and unoptimized configuration is stable. v12.2.0Experimental remotePatterns and experimental unoptimized configuration added. layout=\"raw\" removed. v12.1.1style prop added. Experimental support for layout=\"raw\" added. v12.1.0dangerouslyAllowSVG and contentSecurityPolicy configuration added. v12.0.9lazyRoot prop added. v12.0.0\r\nformats configuration added. AVIF support added. Wrapper <div> changed to <span>. v11.1.0onLoadingComplete and lazyBoundary props added. v11.0.0\r\nsrc prop support for static import. placeholder prop added. blurDataURL prop added. v10.0.5loader prop added. v10.0.1layout prop added. v10.0.0next/image introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1c922593-1fc3-4f83-b76d-88c924c49e92":{"id_":"1c922593-1fc3-4f83-b76d-88c924c49e92","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ILVWhsHzX5V5G5v/LGLkcHeMTRDjX3xjIl6riBVkQCY=","metadata":{},"hash":"Vx7aK597O8mrVy8YJtZpSkP+EQ9t4CvW9Aht/+7qym4="}},"hash":"JSwX2ijHuiudcoW67XiXyASXAiBKwMZRVCeJ5jIurlc=","text":"3.2.1.3 - <Link>\r\nDocumentation path: /02-app/02-api-reference/01-components/link\r\nDescription: Enable fast client-side navigation with the built-in `next/link` component. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nExamples\r\n<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It\r\nis the primary way to navigate between routes in Next.js. app/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}\r\nFor an example, consider a pages directory with the following files:\r\npages/index.js\r\npages/about.js\r\npages/blog/[slug].js\r\nWe can have a link to each of these pages like so:\r\nimport Link from 'next/link'\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link href=\"/\">Home</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/about\">About Us</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/blog/hello-world\">Blog Post</Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\nexport default Home\r\nProps\r\nHere’s a summary of the props available for the Link Component:\r\nPropExampleTypeRequired\r\nhrefhref=\"/dashboard\"String or ObjectYes\r\nreplacereplace={false}Boolean-\r\nscrollscroll={false}Boolean-\r\nprefetchprefetch={false}Boolean-","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6e147335-c837-497b-bc86-fed0c2a78267":{"id_":"6e147335-c837-497b-bc86-fed0c2a78267","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"h9kRD0HDLiXhCbrF2St9LvjDx/DKKkHh/7Jpt9TU4U8=","metadata":{},"hash":"5PZN7Hw6oHq5gAO9rAFevTuFLBy0goieCPgWeZ6Aulk="}},"hash":"gChGQhHVroRMFwK/5DevcsugSFAx5ZA/2lR6ILtP60M=","text":"Good to know: <a> tag attributes such as className or target=\"_blank\" can be added to <Link> as props and will be\r\npassed to the underlying <a> element. hrefhref (required)\r\nThe path or URL to navigate to. <Link href=\"/dashboard\">Dashboard</Link>\r\nhref can also accept an object, for example:\r\n// Navigate to /about?name=test\r\n<Link\r\n  href={{\r\n    pathname: '/about',\r\n    query: { name: 'test' },\r\n  }}\r\n>\r\n  About\r\n</Link>\r\nreplacereplace\r\nDefaults to falsefalse. When true, next/link will replace the current history state instead of adding a new URL into the browser’s\r\nhistory stack. app/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\nscrollscroll\r\nDefaults to truetrue. The default behavior of <Link> is to scroll to the top of a new route or to maintain the scroll position for backwards\r\nand forwards navigation. When false, next/link will not scroll to the top of the page after a navigation. app/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"37b70e8a-31cd-496d-be94-8f0fc3a84f55":{"id_":"37b70e8a-31cd-496d-be94-8f0fc3a84f55","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zAf5V6zTEKPwgylTF0miH4KxLksBRRiuG4HqYJz/h1g=","metadata":{},"hash":"L8ZGQWLD9Dr3W+Vd+zPaH5fdQ/1B/shmp3KUH159VAs="}},"hash":"4ekXi5wYI9j5w7gdUQXDds3I1a6yNTlXWbU/vwrorLk=","text":")\r\n}\r\nprefetchprefetch\r\nDefaults to truetrue. When true, next/link will prefetch the page (denoted by the href) in the background. This is useful for improving\r\nthe performance of client-side navigations. Any <Link /> in the viewport (initially or through scroll) will be preloaded. Prefetch can be disabled by passing prefetch={false}. Prefetching is only enabled in production. app/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\napp/page.js (jsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\nOther Props\r\nlegacyBehaviorlegacyBehavior\r\nAn <a> element is no longer required as a child of <Link>. Add the legacyBehavior prop to use the legacy behavior or remove the\r\n<a> to upgrade. A codemod is available to automatically upgrade your code. Good to know: when legacyBehavior is not set to true, all anchor tag properties can be passed to next/link as well such\r\nas, className, onClick, etc. passHrefpassHref\r\nForces Link to send the href property to its child. Defaults to false\r\nscrollscroll\r\nScroll to the top of the page after a navigation. Defaults to true\r\nshallowshallow\r\nUpdate the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to\r\nfalse\r\nlocalelocale\r\nThe active locale is automatically prepended. locale allows for providing a different locale. When false href has to include the locale\r\nas the default behavior is disabled. Examples\r\nLinking to Dynamic Routes\r\nFor dynamic routes, it can be handy to use template literals to create the link’s path. For example, you can generate a list of links to the dynamic route pages/blog/[slug].js","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b14e0fa9-132b-4f06-b448-4d7b5c9ef10c":{"id_":"b14e0fa9-132b-4f06-b448-4d7b5c9ef10c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BGxr6hMtEMCvKSOIAcuO6qFQryIqIFCZ71QraC6DSXs=","metadata":{},"hash":"1M/dLzLFkFO5VeHJXOWZAM0ljjNiQ+SspwPu70i5FVA="},"NEXT":{"nodeId":"fa4fcf79-f508-4fb7-ae44-a84d786f6412","metadata":{},"hash":"LAtacoEUKc4x2d8MPBttooP8tXpNPU2cacX12gG9Na0="}},"hash":"nfy04fbCJMWiDvrn0pg3cW68PH8p0sXRBFsqjzA7ZMY=","text":"pages/blog/index.js (jsx)import Link from 'next/link'\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nexport default Posts\r\nFor example, you can generate a list of links to the dynamic route app/blog/[slug]/page.js:\r\napp/blog/page.js (jsx)import Link from 'next/link'\r\nfunction Page({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nIf the child is a custom component that wraps an <a><a> tag\r\nIf the child of Link is a custom component that wraps an <a> tag, you must add passHref to Link. This is necessary if you’re using\r\nlibraries like styled-components. Without this, the <a> tag will not have the href attribute, which hurts your site’s accessibility and\r\nmight affect SEO. If you’re using ESLint, there is a built-in rule next/link-passhref to ensure correct usage of passHref. If the child of Link is a custom component that wraps an <a> tag, you must add passHref to Link. This is necessary if you’re using\r\nlibraries like styled-components. Without this, the <a> tag will not have the href attribute, which hurts your site’s accessibility and\r\nmight affect SEO. If you’re using ESLint, there is a built-in rule next/link-passhref to ensure correct usage of passHref. import Link from 'next/link'\r\nimport styled from 'styled-components'\r\n// This creates a custom component that wraps an <a> tag\r\nconst RedLink = styled.a`\r\n  color: red;\r\n`\r\nfunction NavLink({ href, name }) {\r\n  return (\r\n    <Link href={href} passHref legacyBehavior>\r\n      <RedLink>{name}</RedLink>\r\n    </Link>\r\n  )\r\n}\r\nexport default NavLink\r\nIf you’re using emotion’s JSX pragma feature (@jsx jsx), you must use passHref even if you use an <a> tag directly.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fa4fcf79-f508-4fb7-ae44-a84d786f6412":{"id_":"fa4fcf79-f508-4fb7-ae44-a84d786f6412","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BGxr6hMtEMCvKSOIAcuO6qFQryIqIFCZ71QraC6DSXs=","metadata":{},"hash":"1M/dLzLFkFO5VeHJXOWZAM0ljjNiQ+SspwPu70i5FVA="},"PREVIOUS":{"nodeId":"b14e0fa9-132b-4f06-b448-4d7b5c9ef10c","metadata":{},"hash":"nfy04fbCJMWiDvrn0pg3cW68PH8p0sXRBFsqjzA7ZMY="}},"hash":"LAtacoEUKc4x2d8MPBttooP8tXpNPU2cacX12gG9Na0=","text":"The component should support onClick property to trigger navigation correctly\r\nIf the child is a functional component\r\nIf the child of Link is a functional component, in addition to using passHref and legacyBehavior, you must wrap the component in\r\nReact.forwardRef:\r\nimport Link from 'next/link'\r\n// `onClick`, `href`, and `ref` need to be passed to the DOM element","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3b5e9ea6-9c76-4861-a803-378aad0b54a7":{"id_":"3b5e9ea6-9c76-4861-a803-378aad0b54a7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DJvwLJSLuDW7Bw8x5J9EftvdooSBd5q6fMJcKpMDIbI=","metadata":{},"hash":"0k/W9nUbZusT2CBpbqQ4LL3YaCdQYB+IjNbyeOvN7ws="}},"hash":"KFM1R6SPNgp5cZkCADXVIhc6NuZG34ko416wyS/F+Dk=","text":"// for proper handling\r\nconst MyButton = React.forwardRef(({ onClick, href }, ref) => {\r\n  return (\r\n    <a href={href} onClick={onClick} ref={ref}>\r\n      Click Me\r\n    </a>\r\n  )\r\n})\r\nfunction Home() {\r\n  return (\r\n    <Link href=\"/about\" passHref legacyBehavior>\r\n      <MyButton />\r\n    </Link>\r\n  )\r\n}\r\nexport default Home\r\nWith URL Object\r\nLink can also receive a URL object and it will automatically format it to create the URL string. Here’s how to do it:\r\nimport Link from 'next/link'\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/about',\r\n            query: { name: 'test' },\r\n          }}\r\n        >\r\n          About us\r\n        </Link>\r\n      </li>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/blog/[slug]',\r\n            query: { slug: 'my-post' },\r\n          }}\r\n        >\r\n          Blog Post\r\n        </Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\nexport default Home\r\nThe above example has a link to:\r\nA predefined route: /about?name=test\r\nA dynamic route: /blog/my-post\r\nYou can use every property as defined in the Node.js URL module documentation. Replace the URL instead of push\r\nThe default behavior of the Link component is to push a new URL into the history stack. You can use the replace prop to prevent\r\nadding a new entry, as in the following example:\r\n<Link href=\"/about\" replace>\r\n  About us\r\n</Link>\r\nDisable scrolling to the top of the page\r\nThe default behavior of Link is to scroll to the top of the page. When there is a hash defined it will scroll to the specific id, like a normal","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"07e46d56-1839-425d-b058-3a4bb10c021f":{"id_":"07e46d56-1839-425d-b058-3a4bb10c021f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CunGRO9El4IBVaZts2g/1Fi37KDZ0bsvn1/n4o+7MC4=","metadata":{},"hash":"IaV0xBnJJ5cZPOR4+2up90pwsMz8BZOlHM4FXC7zgqo="},"NEXT":{"nodeId":"6e4ee188-c908-4a22-b8ba-eacc07ce5fd5","metadata":{},"hash":"IwE0gQ3kvW+N2AoNYLxptRR41V3ppcQAXh2Lwyx1VCc="}},"hash":"BJEnEYs9BqCm0BbllUf+3cwlmc5YsmBSVBQpH16Ypeo=","text":"<a> tag. To prevent scrolling to the top / hash scroll={false} can be added to Link:\r\n<Link href=\"/#hashid\" scroll={false}>\r\n  Disables scrolling to the top\r\n</Link>\r\nMiddleware\r\nIt’s common to use Middleware for authentication or other purposes that involve rewriting the user to a different page. In order for the<Link />\r\n component to properly prefetch links with rewrites via Middleware, you need to tell Next.js both the URL to display and the\r\nURL to prefetch. This is required to avoid un-necessary fetches to middleware to know the correct route to prefetch. For example, if you want to serve a /dashboard route that has authenticated and visitor views, you may add something similar to the\r\nfollowing in your Middleware to redirect the user to the correct page:\r\nmiddleware.js (js)export function middleware(req) {\r\n  const nextUrl = req.nextUrl\r\n  if (nextUrl.pathname === '/dashboard') {\r\n    if (req.cookies.authToken) {\r\n      return NextResponse.rewrite(new URL('/auth/dashboard', req.url))\r\n    } else {\r\n      return NextResponse.rewrite(new URL('/public/dashboard', req.url))\r\n    }\r\n  }\r\n}\r\nIn this case, you would want to use the following code in your <Link /> component:\r\nimport Link from 'next/link'\r\nimport useIsAuthed from './hooks/useIsAuthed'\r\nexport default function Page() {\r\n  const isAuthed = useIsAuthed()\r\n  const path = isAuthed ? '/auth/dashboard' : '/dashboard'\r\n  return (\r\n    <Link as=\"/dashboard\" href={path}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}\r\nGood to know: If you’re using Dynamic Routes, you’ll need to adapt your as and href props. For example, if you have a\r\nDynamic Route like /dashboard/[user] that you want to present differently via middleware, you would write: <Link href=\r\n{{ pathname: '/dashboard/authed/[user]', query: { user: username } }}\r\nas=\"/dashboard/[user]\">Profile</Link>. Version History\r\nVersionChanges\r\nv13.0.0No longer requires a child <a> tag. A codemod is provided to automatically update your codebase. v10.0.0href props pointing to a dynamic route are automatically resolved and no longer require an as prop. v8.0.0Improved prefetching performance.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6e4ee188-c908-4a22-b8ba-eacc07ce5fd5":{"id_":"6e4ee188-c908-4a22-b8ba-eacc07ce5fd5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CunGRO9El4IBVaZts2g/1Fi37KDZ0bsvn1/n4o+7MC4=","metadata":{},"hash":"IaV0xBnJJ5cZPOR4+2up90pwsMz8BZOlHM4FXC7zgqo="},"PREVIOUS":{"nodeId":"07e46d56-1839-425d-b058-3a4bb10c021f","metadata":{},"hash":"BJEnEYs9BqCm0BbllUf+3cwlmc5YsmBSVBQpH16Ypeo="}},"hash":"IwE0gQ3kvW+N2AoNYLxptRR41V3ppcQAXh2Lwyx1VCc=","text":"v8.0.0Improved prefetching performance. v1.0.0next/link introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"40b9f684-b562-4234-8eff-e0af815e47fa":{"id_":"40b9f684-b562-4234-8eff-e0af815e47fa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2bjAH2r0ll6m1EkY/uZYQkmyyI6Cz4tt3NLvIdc/Vmw=","metadata":{},"hash":"JXraGqy5PUzyXoDUnAJr2pquGhQcqStY2gXate2BUJ4="}},"hash":"UWctaLIFysLMrsAuX/XSSu+PvsuxDyr4k8hCYxXUrxg=","text":"3.2.1.4 - <Script>\r\nDocumentation path: /02-app/02-api-reference/01-components/script\r\nDescription: Optimize third-party scripts in your Next.js application using the built-in `next/script` Component. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThis API reference will help you understand how to use props available for the Script Component. For features and usage, please see\r\nthe Optimizing Scripts page. app/dashboard/page.tsx (tsx)import Script from 'next/script'\r\nexport default function Dashboard() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}\r\napp/dashboard/page.js (jsx)import Script from 'next/script'\r\nexport default function Dashboard() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}\r\nProps\r\nHere’s a summary of the props available for the Script Component:\r\nPropExampleTypeRequired\r\nsrcsrc=\"http://example.com/script\"StringRequired unless inline script is used\r\nstrategystrategy=\"lazyOnload\"String-\r\nonLoadonLoad={onLoadFunc}Function-\r\nonReadyonReady={onReadyFunc}Function-\r\nonErroronError={onErrorFunc}Function-\r\nRequired Props\r\nThe <Script /> component requires the following properties. srcsrc\r\nA path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src property\r\nis required unless an inline script is used. Optional Props\r\nThe <Script /> component accepts a number of additional properties beyond those which are required. strategystrategy\r\nThe loading strategy of the script. There are four different strategies that can be used:\r\nbeforeInteractive: Load before any Next.js code and before any page hydration occurs.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0dcc1a14-fb7c-46c9-b62b-3b023af30326":{"id_":"0dcc1a14-fb7c-46c9-b62b-3b023af30326","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"oZ2jk7co7DGnRrdPQfN1BEXL11skqYODCXuKmKBnux8=","metadata":{},"hash":"WgWwmNCd8HwT9jrkk/QOUoSGG4KP3f6403sUN/J7wRY="}},"hash":"P9ktdaUdIDD9GXQlMD7Cvq/crcsBtujkeHxADvcu6sI=","text":"afterInteractive: (default) Load early but after some hydration on the page occurs. lazyOnload: Load during browser idle time. worker: (experimental) Load in a web worker. beforeInteractivebeforeInteractive\r\nScripts that load with the beforeInteractive strategy are injected into the initial HTML from the server, downloaded before any\r\nNext.js module, and executed in the order they are placed before any hydration occurs on the page. Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page\r\nhydration from occurring. beforeInteractive scripts must be placed inside the root layout (app/layout.tsx) and are designed to load scripts that are\r\nneeded by the entire site (i.e. the script will load when any page in the application has been loaded server-side). This strategy should only be used for critical scripts that need to be fetched before any part of the page becomes\r\ninteractive. app/layout.tsx (tsx)import Script from 'next/script'\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        strategy=\"beforeInteractive\"\r\n      />\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)import Script from 'next/script'\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        strategy=\"beforeInteractive\"\r\n      />\r\n    </html>\r\n  )\r\n}\r\nimport { Html, Head, Main, NextScript } from 'next/document'\r\nimport Script from 'next/script'\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n        <Script\r\n          src=\"https://example.com/script.js\"\r\n          strategy=\"beforeInteractive\"\r\n        />\r\n      </body>\r\n    </Html>\r\n  )\r\n}\r\nGood to know: Scripts with beforeInteractive will always be injected inside the head of the HTML document regardless of\r\nwhere it’s placed in the component.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d1b39123-203f-4d03-a6be-96cca441770f":{"id_":"d1b39123-203f-4d03-a6be-96cca441770f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ps3cKMnLLYos4AejdEBNdMjQfFMqZY91tB9hxlIkMF4=","metadata":{},"hash":"+6zqhLnS7gLYFmxfYx/u4sGfqQKMjgULDJoEuxsnbWc="},"NEXT":{"nodeId":"773f01d4-5310-4d64-baa4-6d87edf6d506","metadata":{},"hash":"d7WFYwqXejpeQ1YGzj0/IOMH86Z0DVLFo8cnflp2T7E="}},"hash":"kxu+eVFOaD1WJj312gHe9f/hYHapp/PUYcBiDpCoQlo=","text":"Some examples of scripts that should be loaded as soon as possible with beforeInteractive include:\r\nBot detectors\r\nCookie consent managers\r\nafterInteractiveafterInteractive\r\nScripts that use the afterInteractive strategy are injected into the HTML client-side and will load after some (or all) hydration\r\noccurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon\r\nas possible but not before any first-party Next.js code. afterInteractive scripts can be placed inside of any page or layout and will only load and execute when that page (or group of\r\npages) is opened in the browser. app/page.js (jsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" />\r\n    </>\r\n  )\r\n}\r\nSome examples of scripts that are good candidates for afterInteractive include:\r\nTag managers\r\nAnalytics\r\nlazyOnloadlazyOnload\r\nScripts that use the lazyOnload strategy are injected into the HTML client-side during browser idle time and will load after all\r\nresources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to\r\nload early. lazyOnload scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is\r\nopened in the browser. app/page.js (jsx)import Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" />\r\n    </>\r\n  )\r\n}\r\nExamples of scripts that do not need to load immediately and can be fetched with lazyOnload include:\r\nChat support plugins\r\nSocial media widgets\r\nworkerworker\r\nWarning: The worker strategy is not yet stable and does not yet work with the app directory. Use with caution. Scripts that use the worker strategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical,\r\nfirst-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed\r\nto support all third-party scripts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"773f01d4-5310-4d64-baa4-6d87edf6d506":{"id_":"773f01d4-5310-4d64-baa4-6d87edf6d506","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ps3cKMnLLYos4AejdEBNdMjQfFMqZY91tB9hxlIkMF4=","metadata":{},"hash":"+6zqhLnS7gLYFmxfYx/u4sGfqQKMjgULDJoEuxsnbWc="},"PREVIOUS":{"nodeId":"d1b39123-203f-4d03-a6be-96cca441770f","metadata":{},"hash":"kxu+eVFOaD1WJj312gHe9f/hYHapp/PUYcBiDpCoQlo="}},"hash":"d7WFYwqXejpeQ1YGzj0/IOMH86Z0DVLFo8cnflp2T7E=","text":"To use worker as a strategy, the nextScriptWorkers flag must be enabled in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    nextScriptWorkers: true,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fc888667-99dc-4f5e-a3f3-569a311da031":{"id_":"fc888667-99dc-4f5e-a3f3-569a311da031","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LiP9cBLiqvWaTpVuTD0rGcT4wCzwY9hlHEo+KPKPc3Q=","metadata":{},"hash":"jnlTcjyuIny+zusAZ2Bd+N/mDyvfAQ8KFRi5w0dKvfs="}},"hash":"UMlu2+QncGKKpKrFVoaPjgeJxJNumTTVh8FL2/pDPXc=","text":"worker scripts can only currently be used in the pages/pages/ directory:\r\npages/home.tsx (tsx)import Script from 'next/script'\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}\r\npages/home.js (jsx)import Script from 'next/script'\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}\r\nonLoadonLoad\r\nWarning: onLoad does not yet work with Server Components and can only be used in Client Components. Further, onLoad\r\ncan’t be used with beforeInteractive – consider using onReady instead. Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or\r\ncall a function. If you are loading a script with either afterInteractive or lazyOnload as a loading strategy, you can execute code after it\r\nhas loaded using the onLoad property. Here’s an example of executing a lodash method only after the library has been loaded. app/page.tsx (tsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\r\n        onLoad={() => {\r\n          console.log(_.sample([1, 2, 3, 4]))\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\r\n        onLoad={() => {\r\n          console.log(_.sample([1, 2, 3, 4]))\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nonReadyonReady","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"15a6b6d2-16aa-4c51-a21d-53fa501b4913":{"id_":"15a6b6d2-16aa-4c51-a21d-53fa501b4913","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0nV5KYCeWhgAEVvadDvxEPqpKFCZY4YMbWHU+4cece8=","metadata":{},"hash":"4kk9xOVWJQqFbrWzCYs2HnW7grB8+POMY6igzkaff+I="}},"hash":"vv+mazgMlCT0vAR/rqX/CbiK2Xf+GPECdRCP4dy5W1k=","text":"Warning: onReady does not yet work with Server Components and can only be used in Client Components. Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is\r\nmounted (after a route navigation for example). You can execute code after the script’s load event when it first loads and then after\r\nevery subsequent component re-mount using the onReady property. Here’s an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:\r\napp/page.tsx (tsx)'use client'\r\nimport { useRef } from 'react'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  const mapRef = useRef()\r\n  return (\r\n    <>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },\r\n            zoom: 8,\r\n          })\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)'use client'\r\nimport { useRef } from 'react'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  const mapRef = useRef()\r\n  return (\r\n    <>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },\r\n            zoom: 8,\r\n          })\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nimport { useRef } from 'react';\r\nimport Script from 'next/script';\r\nexport default function Page() {\r\n  const mapRef = useRef();\r\n  return (\r\n    <PagesOnly>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"42f25f63-865d-417d-82cd-fe8c8a405e5d":{"id_":"42f25f63-865d-417d-82cd-fe8c8a405e5d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vJ9gAnsOtUmKZlUnjDNC7KjMUpinzVQB9T03lduapqY=","metadata":{},"hash":"cKNgmrvMg4YJIBzA+lkCgUwuED6zbkQ7dbA6NLEPb1U="}},"hash":"C7qbyfG6apUqEXmivTIMLb8qxFdqsfkEkULXr7a97OE=","text":"zoom: 8,\r\n          });\r\n        }}\r\n      />\r\n    </>\r\n  );\r\n}\r\nonErroronError\r\nWarning: onError does not yet work with Server Components and can only be used in Client Components. onError cannot be\r\nused with the beforeInteractive loading strategy. Sometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError property:\r\napp/page.tsx (tsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e: Error) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\napp/page.js (jsx)'use client'\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e: Error) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nimport Script from 'next/script'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e: Error) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.0.0beforeInteractive and afterInteractive is modified to support app.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2c38d7e5-d681-40e0-83be-2eb44b9bbf17":{"id_":"2c38d7e5-d681-40e0-83be-2eb44b9bbf17","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kE0Xv0DkGzJpR4/1pPwu7vMe0DkCC7d6uInKl123Myo=","metadata":{},"hash":"RN/iqXiug73trKnxsEQOfdSAihSMVEax3YPIa2N4/Ek="}},"hash":"AlW9osG9Qw3Bca0UIOb7pM3NBc/mqA83ivxvo6bzBAA=","text":"v12.2.4onReady prop added. v12.2.2Allow next/script with beforeInteractive to be placed in _document. v11.0.0next/script introduced. VersionChanges","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"789d56c0-2ab4-48a1-9e3f-1f6269b57c14":{"id_":"789d56c0-2ab4-48a1-9e3f-1f6269b57c14","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jJsQAhCRA8zYkwl0CmTpSYdMGOkjk1UzFGKwFrCNsaE=","metadata":{},"hash":"Xg+cYabCXD6Ql7gyt4qPWGlskg73Kb9tag4lQnnSB+Y="}},"hash":"DD+ffgKsx3diBH/JLb1ZVbdhDNd4CfRvcUZo0xigQ4c=","text":"3.2.2 - File Conventions\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/index\r\nDescription: API Reference for Next.js Special Files.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"42f8f068-d011-422f-ba56-1a2c68386426":{"id_":"42f8f068-d011-422f-ba56-1a2c68386426","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3o14HdViWLZq3zMcVQrHMta2DT2xbizvM0LZG0z6WwA=","metadata":{},"hash":"omxynO2XDkDkrUpUjrCLtVjfMhk5UhekMzs8/GbcA0k="}},"hash":"Z+b/EwJ6LnJdgt9HwUCuoUx2W0L7v3RCy0tW0zhfopU=","text":"3.2.2.1 - Metadata Files API Reference\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/index\r\nDescription: API documentation for the metadata file conventions. This section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to\r\nroute segments. Each file convention can be defined using a static file (e.g. opengraph-image.jpg), or a dynamic variant that uses code to generate the\r\nfile (e.g. opengraph-image.js). Once a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head\r\nelements with the correct metadata, such as the asset’s URL, file type, and image size.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"82d24926-4ddf-4f0d-a206-dab381f2b5f1":{"id_":"82d24926-4ddf-4f0d-a206-dab381f2b5f1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9m2FHcHG1HZbRU51SAqSuAZYWDnoxGZMfzSjr8trWCw=","metadata":{},"hash":"ZAyiaGCUKvtPqS/eQxrmvsxZKLHJEb5gcBuJbgSMjEg="},"NEXT":{"nodeId":"81744980-b3b3-4b14-8804-043b025d0dfe","metadata":{},"hash":"wRfRgXu+XbQpXo2btcXFnm7R5z0euw53+LO8Z0zVggI="}},"hash":"dyRuHbbM9MO7ezpohj1Avae9WODlYUo7CAwZhVAh9po=","text":"3.2.2.1.1 - favicon, icon, and apple-icon\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/app-icons\r\nDescription: API Reference for the Favicon, Icon and Apple Icon file conventions. The favicon, icon, or apple-icon file conventions allow you to set icons for your application. They are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results. There are two ways to set app icons:\r\nUsing image files (.ico, .jpg, .png)\r\nUsing code to generate an icon (.js, .ts, .tsx)\r\nImage files (.ico, .jpg, .png)\r\nUse an image file to set an app icon by placing a favicon, icon, or apple-icon image file within your /app directory. The favicon\r\nimage can only be located in the top level of app/. Next.js will evaluate the file and automatically add the appropriate tags to your app’s <head> element. File conventionSupported file typesValid locations\r\nfavicon.icoapp/\r\nicon.ico, .jpg, .jpeg, .png, .svgapp/**/*\r\napple-icon.jpg, .jpeg, .pngapp/**/*\r\nfaviconfavicon\r\nAdd a favicon.ico image file to the root /app route segment. output (html)<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />\r\niconicon\r\nAdd an icon.(ico|jpg|jpeg|png|svg) image file. output (html)<link\r\n  rel=\"icon\"\r\n  href=\"/icon?<generated>\"\r\n  type=\"image/<generated>\"\r\n  sizes=\"<generated>\"\r\n/>\r\napple-iconapple-icon\r\nAdd an apple-icon.(jpg|jpeg|png) image file. output (html)<link\r\n  rel=\"apple-touch-icon\"\r\n  href=\"/apple-icon?<generated>\"\r\n  type=\"image/<generated>\"\r\n  sizes=\"<generated>\"\r\n/>\r\nGood to know\r\nYou can set multiple icons by adding a number suffix to the file name. For example, icon1.png, icon2.png, etc. Numbered files will sort lexically. Favicons can only be set in the root /app segment. If you need more granularity, you can use icon. The appropriate <link> tags and attributes such as rel, href, type, and sizes are determined by the icon type and\r\nmetadata of the evaluated file.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"81744980-b3b3-4b14-8804-043b025d0dfe":{"id_":"81744980-b3b3-4b14-8804-043b025d0dfe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9m2FHcHG1HZbRU51SAqSuAZYWDnoxGZMfzSjr8trWCw=","metadata":{},"hash":"ZAyiaGCUKvtPqS/eQxrmvsxZKLHJEb5gcBuJbgSMjEg="},"PREVIOUS":{"nodeId":"82d24926-4ddf-4f0d-a206-dab381f2b5f1","metadata":{},"hash":"dyRuHbbM9MO7ezpohj1Avae9WODlYUo7CAwZhVAh9po="}},"hash":"wRfRgXu+XbQpXo2btcXFnm7R5z0euw53+LO8Z0zVggI=","text":"For example, a 32 by 32px .png file will have type=\"image/png\" and sizes=\"32x32\" attributes.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1445963-8750-4c54-80d5-5daf8f6edc4d":{"id_":"f1445963-8750-4c54-80d5-5daf8f6edc4d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SxoIi3Wz0ADpVSDyW4wen/1Ev12bWbsUDdyhOcmcv64=","metadata":{},"hash":"Djki+aiesvpHSCBsysZmopb4FYqRS1yZUm7X/h4yY8s="}},"hash":"VuTg8DR88QzSi5kq1/QoXKdHhdIB/j0QKab/LFXB/HA=","text":"sizes=\"any\" is added to favicon.ico output to avoid a browser bug where an .ico icon is favored over .svg. Generate icons using code (.js, .ts, .tsx)\r\nIn addition to using literal image files, you can programmatically generate icons using code. Generate an app icon by creating an icon or apple-icon route that default exports a function. File conventionSupported file types\r\nicon.js, .ts, .tsx\r\napple-icon.js, .ts, .tsx\r\nThe easiest way to generate an icon is to use the ImageResponse API from next/og. app/icon.tsx (tsx)import { ImageResponse } from 'next/og'\r\n// Route segment config\r\nexport const runtime = 'edge'\r\n// Image metadata\r\nexport const size = {\r\n  width: 32,\r\n  height: 32,\r\n}\r\nexport const contentType = 'image/png'\r\n// Image generation\r\nexport default function Icon() {\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 24,\r\n          background: 'black',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          color: 'white',\r\n        }}\r\n      >\r\n        A\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported icons size metadata\r\n      // config to also set the ImageResponse's width and height. ...size,\r\n    }\r\n  )\r\n}\r\napp/icon.js (jsx)import { ImageResponse } from 'next/og'\r\n// Route segment config\r\nexport const runtime = 'edge'\r\n// Image metadata\r\nexport const size = {\r\n  width: 32,\r\n  height: 32,\r\n}\r\nexport const contentType = 'image/png'\r\n// Image generation\r\nexport default function Icon() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"92fc5bc8-b6b2-4e8d-8f0f-ea01824373a5":{"id_":"92fc5bc8-b6b2-4e8d-8f0f-ea01824373a5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iM2evfZXJTnJLZVUvXp6GNDIfa8ExYcgA2Q0QpDJG1w=","metadata":{},"hash":"wBj3KmeEnf8cPbBwb1PfwMQC6cX3aT0+hozu6j0Aec8="}},"hash":"eJb2JTOZbiODDtxvn2evrz2ZcSbGIMORofmpt+H+eQw=","text":"return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 24,\r\n          background: 'black',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          color: 'white',\r\n        }}\r\n      >\r\n        A\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported icons size metadata\r\n      // config to also set the ImageResponse's width and height. ...size,\r\n    }\r\n  )\r\n}\r\noutput (html)<link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" />\r\nGood to know\r\nBy default, generated icons are statically optimized (generated at build time and cached) unless they use dynamic\r\nfunctions or uncached data. You can generate multiple icons in the same file using generateImageMetadata. You cannot generate a favicon icon. Use icon or a favicon.ico file instead. Props\r\nThe default export function receives the following props:\r\nparamsparams (optional)\r\nAn object containing the dynamic route parameters object from the root segment down to the segment icon or apple-icon is\r\ncolocated in. app/shop/[slug]/icon.tsx (tsx)export default function Icon({ params }: { params: { slug: string } }) {\r\n  // ... }\r\napp/shop/[slug]/icon.js (jsx)export default function Icon({ params }) {\r\n  // ... }\r\nRouteURLparamsparams\r\napp/shop/icon.js/shopundefined\r\napp/shop/[slug]/icon.js/shop/1{ slug: '1' }\r\napp/shop/[tag]/[item]/icon.js/shop/1/2{ tag: '1', item: '2' }\r\napp/shop/[...slug]/icon.js/shop/1/2{ slug: ['1', '2'] }\r\nReturns\r\nThe default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e62934a5-d795-468b-b23a-8bdc8d932df5":{"id_":"e62934a5-d795-468b-b23a-8bdc8d932df5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RZ7m/e4DMcVZQko2aygciX+dklfC4Nnz/rxvba8SQIA=","metadata":{},"hash":"CXMmxtCFuBGNfy/6mkZARtVLATxN0617AVmMlQVh4b8="}},"hash":"HwxFMC7RK/r6YVZP+WrN+0zARDgp7vY3/t8SjuOXaoU=","text":"Good to know: ImageResponse satisfies this return type. Config exports\r\nYou can optionally configure the icon’s metadata by exporting size and contentType variables from the icon or apple-icon route. OptionType\r\nsize{ width: number; height: number }\r\ncontentTypestring - image MIME type\r\nsizesize\r\nicon.tsx | apple-icon.tsx (tsx)export const size = { width: 32, height: 32 }\r\nexport default function Icon() {}\r\nicon.js | apple-icon.js (jsx)export const size = { width: 32, height: 32 }\r\nexport default function Icon() {}\r\noutput (html)<link rel=\"icon\" sizes=\"32x32\" />\r\ncontentTypecontentType\r\nicon.tsx | apple-icon.tsx (tsx)export const contentType = 'image/png'\r\nexport default function Icon() {}\r\nicon.js | apple-icon.js (jsx)export const contentType = 'image/png'\r\nexport default function Icon() {}\r\noutput (html)<link rel=\"icon\" type=\"image/png\" />\r\nRoute Segment Config\r\nicon and apple-icon are specialized Route Handlers that can use the same route segment configuration options as Pages and\r\nLayouts. OptionTypeDefault\r\ndynamic'auto' \\| 'force-dynamic' \\| 'error' \\| 'force-static''auto'\r\nrevalidatefalse \\| 'force-cache' \\| 0 \\| numberfalse\r\nruntime'nodejs' \\| 'edge''nodejs'\r\npreferredRegion'auto' \\| 'global' \\| 'home' \\| string \\| string[]'auto'\r\napp/icon.tsx (tsx)export const runtime = 'edge'\r\nexport default function Icon() {}\r\napp/icon.js (jsx)export const runtime = 'edge'\r\nexport default function Icon() {}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cfe5dec8-cb50-4ed8-809d-9e2fe2760ffe":{"id_":"cfe5dec8-cb50-4ed8-809d-9e2fe2760ffe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jfSvYSg1KnmdQ1SL++E4XJ3JITeGhB6VI1chIofB6x0=","metadata":{},"hash":"6f7TVZLd7HH3qwXrqFnOgvpiw/CVJi/8txnV+PLJ224="}},"hash":"Upg0peOVq1ftfr73AeoM4pFx2NxxBJHO2R7oQgxKCV0=","text":"Version History\r\nVersionChanges\r\nv13.3.0favicon icon and apple-icon introduced","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6f130a98-4782-4e98-a2e4-2c094e887ce5":{"id_":"6f130a98-4782-4e98-a2e4-2c094e887ce5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+HwYmCr4WAk7UL9vV2OPZsxH8iIKq3SYvKoQgQhLygY=","metadata":{},"hash":"S6QRmbmBShu02eU0W3svp5wJGY4BT77FLAIQniCdMjk="}},"hash":"NSwYJTjI6zkGP9wKdAB2JFMu/iEyfTo3eZU9Cyp/nBE=","text":"3.2.2.1.2 - manifest.json\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/manifest\r\nDescription: API Reference for manifest.json file. Add or generate a manifest.(json|webmanifest) file that matches the Web Manifest Specification in the root of app directory to\r\nprovide information about your web application for the browser. Static Manifest file\r\napp/manifest.json | app/manifest.webmanifest (json){\r\n  \"name\": \"My Next.js Application\",\r\n  \"short_name\": \"Next.js App\",\r\n  \"description\": \"An application built with Next.js\",\r\n  \"start_url\": \"/\"\r\n  // ... }\r\nGenerate a Manifest file\r\nAdd a manifest.js or manifest.ts file that returns a Manifest object. app/manifest.ts (ts)import { MetadataRoute } from 'next'\r\nexport default function manifest(): MetadataRoute.Manifest {\r\n  return {\r\n    name: 'Next.js App',\r\n    short_name: 'Next.js App',\r\n    description: 'Next.js App',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#fff',\r\n    theme_color: '#fff',\r\n    icons: [\r\n      {\r\n        src: '/favicon.ico',\r\n        sizes: 'any',\r\n        type: 'image/x-icon',\r\n      },\r\n    ],\r\n  }\r\n}\r\napp/manifest.js (js)export default function manifest() {\r\n  return {\r\n    name: 'Next.js App',\r\n    short_name: 'Next.js App',\r\n    description: 'Next.js App',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#fff',\r\n    theme_color: '#fff',\r\n    icons: [\r\n      {\r\n        src: '/favicon.ico',\r\n        sizes: 'any',\r\n        type: 'image/x-icon',\r\n      },\r\n    ],\r\n  }\r\n}\r\nManifest Object\r\nThe manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the\r\ncurrent options, refer to the MetadataRoute.Manifest type in your code editor if using TypeScript or see the MDN docs.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"627e62d4-62cd-4f8f-836b-70537e24206a":{"id_":"627e62d4-62cd-4f8f-836b-70537e24206a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+VtrgOmIFgU+kwfzOCk+7xWjbzlsbB8OiaWw9UGaBw8=","metadata":{},"hash":"z8d5j24BTG8RI2jcWrSiJ9EyMpkPUH4cmwSQ51NJu8Y="},"NEXT":{"nodeId":"5af93855-07be-4a05-8e49-30ff93c5d6da","metadata":{},"hash":"sR7Yn2I3qcrAZGUw9iYFHTOJaid9CCpW2mjMxvg7V9g="}},"hash":"7KXfzUSmqJXb0DaAKTXqKJ2OkSael5d4cFC0D9tkDwM=","text":"3.2.2.1.3 - opengraph-image and twitter-image\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/opengraph-image\r\nDescription: API Reference for the Open Graph Image and Twitter Image file conventions. The opengraph-image and twitter-image file conventions allow you to set Open Graph and Twitter images for a route segment. They are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site. There are two ways to set Open Graph and Twitter images:\r\nUsing image files (.jpg, .png, .gif)\r\nUsing code to generate images (.js, .ts, .tsx)\r\nImage files (.jpg, .png, .gif)\r\nUse an image file to set a route segment’s shared image by placing an opengraph-image or twitter-image image file in the segment. Next.js will evaluate the file and automatically add the appropriate tags to your app’s <head> element. File conventionSupported file types\r\nopengraph-image.jpg, .jpeg, .png, .gif\r\ntwitter-image.jpg, .jpeg, .png, .gif\r\nopengraph-image.alt.txt\r\ntwitter-image.alt.txt\r\nopengraph-imageopengraph-image\r\nAdd an opengraph-image.(jpg|jpeg|png|gif) image file to any route segment. output (html)<meta property=\"og:image\" content=\"<generated>\" />\r\n<meta property=\"og:image:type\" content=\"<generated>\" />\r\n<meta property=\"og:image:width\" content=\"<generated>\" />\r\n<meta property=\"og:image:height\" content=\"<generated>\" />\r\ntwitter-imagetwitter-image\r\nAdd a twitter-image.(jpg|jpeg|png|gif) image file to any route segment. output (html)<meta name=\"twitter:image\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:type\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:width\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:height\" content=\"<generated>\" />\r\nopengraph-image.alt.txtopengraph-image.alt.txt\r\nAdd an accompanying opengraph-image.alt.txt file in the same route segment as the opengraph-image.(jpg|jpeg|png|gif)\r\nimage it’s alt text.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5af93855-07be-4a05-8e49-30ff93c5d6da":{"id_":"5af93855-07be-4a05-8e49-30ff93c5d6da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+VtrgOmIFgU+kwfzOCk+7xWjbzlsbB8OiaWw9UGaBw8=","metadata":{},"hash":"z8d5j24BTG8RI2jcWrSiJ9EyMpkPUH4cmwSQ51NJu8Y="},"PREVIOUS":{"nodeId":"627e62d4-62cd-4f8f-836b-70537e24206a","metadata":{},"hash":"7KXfzUSmqJXb0DaAKTXqKJ2OkSael5d4cFC0D9tkDwM="}},"hash":"sR7Yn2I3qcrAZGUw9iYFHTOJaid9CCpW2mjMxvg7V9g=","text":"opengraph-image.alt.txt (txt)About Acme\r\noutput (html)<meta property=\"og:image:alt\" content=\"About Acme\" />\r\ntwitter-image.alt.txttwitter-image.alt.txt\r\nAdd an accompanying twitter-image.alt.txt file in the same route segment as the twitter-image.(jpg|jpeg|png|gif) image\r\nit’s alt text. twitter-image.alt.txt (txt)About Acme","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6e8e1a02-d4f8-4999-bfe7-d77380a5db41":{"id_":"6e8e1a02-d4f8-4999-bfe7-d77380a5db41","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eu3wWqi/1k07rBTM9kpDu0e6SsJO8tsvixn1RbAsL60=","metadata":{},"hash":"qPsacYEThqn0bRKrV02q46NrHxtTVJHbO0Wqo0Ftiuc="}},"hash":"V9F7Z3LMb13DkLfWnWDF4QRmKX9aDtrFWDlDiN8fhTk=","text":"output (html)<meta property=\"twitter:image:alt\" content=\"About Acme\" />\r\nGenerate images using code (.js, .ts, .tsx)\r\nIn addition to using literal image files, you can programmatically generate images using code. Generate a route segment’s shared image by creating an opengraph-image or twitter-image route that default exports a function. File conventionSupported file types\r\nopengraph-image.js, .ts, .tsx\r\ntwitter-image.js, .ts, .tsx\r\nGood to know\r\nBy default, generated images are statically optimized (generated at build time and cached) unless they use dynamic\r\nfunctions or uncached data. You can generate multiple Images in the same file using generateImageMetadata. The easiest way to generate an image is to use the ImageResponse API from next/og. app/about/opengraph-image.tsx (tsx)import { ImageResponse } from 'next/og'\r\n// Route segment config\r\nexport const runtime = 'edge'\r\n// Image metadata\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'\r\n// Image generation\r\nexport default async function Image() {\r\n  // Font\r\n  const interSemiBold = fetch(\r\n    new URL('./Inter-SemiBold.ttf', import.meta.url)\r\n  ).then((res) => res.arrayBuffer())\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        About Acme\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height. ...size,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: await interSemiBold,\r\n          style: 'normal',\r\n          weight: 400,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"54b4d4ae-30b9-42ea-9d5b-dab791a61f7e":{"id_":"54b4d4ae-30b9-42ea-9d5b-dab791a61f7e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"I5p4GRWeISUmEPTD/nWsocNZoKY3LrBGiZZ0CBcRN9I=","metadata":{},"hash":"zpyTaYgGBDoivhXKfDFYfkrQKZdydCvPGwawBFa1bAY="}},"hash":"Ml0haiyMJ1j4AOqA1vM241lYg+sed0iNErkqKOcMY/A=","text":"},\r\n      ],\r\n    }\r\n  )\r\n}\r\napp/about/opengraph-image.js (jsx)import { ImageResponse } from 'next/og'\r\n// Route segment config\r\nexport const runtime = 'edge'\r\n// Image metadata\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'\r\n// Image generation\r\nexport default async function Image() {\r\n  // Font\r\n  const interSemiBold = fetch(\r\n    new URL('./Inter-SemiBold.ttf', import.meta.url)\r\n  ).then((res) => res.arrayBuffer())\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        About Acme\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height. ...size,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: await interSemiBold,\r\n          style: 'normal',\r\n          weight: 400,\r\n        },\r\n      ],\r\n    }\r\n  )\r\n}\r\noutput (html)<meta property=\"og:image\" content=\"<generated>\" />\r\n<meta property=\"og:image:alt\" content=\"About Acme\" />\r\n<meta property=\"og:image:type\" content=\"image/png\" />\r\n<meta property=\"og:image:width\" content=\"1200\" />\r\n<meta property=\"og:image:height\" content=\"630\" />\r\nProps\r\nThe default export function receives the following props:\r\nparamsparams (optional)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ffd0ee25-bdc2-44c1-8017-1466516f170a":{"id_":"ffd0ee25-bdc2-44c1-8017-1466516f170a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0dzhkXHKRDrNxHapncEnqKTi0S5A05jcJJQ+1n9Wv58=","metadata":{},"hash":"nZvky9A+33j5j28Tvl2yEUnxfISfjRMNA8PqV8Nnlu8="}},"hash":"uKWgZJhAORIr3gN5nx/IKy9vxEcLUzTG2+ZO/VX8P8Q=","text":"An object containing the dynamic route parameters object from the root segment down to the segment opengraph-image or\r\ntwitter-image is colocated in. app/shop/[slug]/opengraph-image.tsx (tsx)export default function Image({ params }: { params: { slug: string } }) {\r\n  // ... }\r\napp/shop/[slug]/opengraph-image.js (jsx)export default function Image({ params }) {\r\n  // ... }\r\nRouteURLparamsparams\r\napp/shop/opengraph-image.js/shopundefined\r\napp/shop/[slug]/opengraph-image.js/shop/1{ slug: '1' }\r\napp/shop/[tag]/[item]/opengraph-image.js/shop/1/2{ tag: '1', item: '2' }\r\napp/shop/[...slug]/opengraph-image.js/shop/1/2{ slug: ['1', '2'] }\r\nReturns\r\nThe default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response. Good to know: ImageResponse satisfies this return type. Config exports\r\nYou can optionally configure the image’s metadata by exporting alt, size, and contentType variables from opengraph-image or\r\ntwitter-image route. OptionType\r\naltstring\r\nsize{ width: number; height: number }\r\ncontentTypestring - image MIME type\r\naltalt\r\nopengraph-image.tsx | twitter-image.tsx (tsx)export const alt = 'My images alt text'\r\nexport default function Image() {}\r\nopengraph-image.js | twitter-image.js (jsx)export const alt = 'My images alt text'\r\nexport default function Image() {}\r\noutput (html)<meta property=\"og:image:alt\" content=\"My images alt text\" />\r\nsizesize\r\nopengraph-image.tsx | twitter-image.tsx (tsx)export const size = { width: 1200, height: 630 }\r\nexport default function Image() {}\r\nopengraph-image.js | twitter-image.js (jsx)export const size = { width: 1200, height: 630 }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"22be03ae-7a36-43a0-a245-4db645dbdec4":{"id_":"22be03ae-7a36-43a0-a245-4db645dbdec4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6KIT5B0FoVa/fOnozX33JcG9PUkU4ROdROZgXKAE0ZE=","metadata":{},"hash":"haHoOpqLEP0K6wz+MViGbjArDdthKh5H+HpbYn6BFXQ="}},"hash":"uBFV78LyxZ3Lr88BPgNnEZg4utYO8JgCO2rkc5qQx9M=","text":"export default function Image() {}\r\noutput (html)<meta property=\"og:image:width\" content=\"1200\" />\r\n<meta property=\"og:image:height\" content=\"630\" />\r\ncontentTypecontentType\r\nopengraph-image.tsx | twitter-image.tsx (tsx)export const contentType = 'image/png'\r\nexport default function Image() {}\r\nopengraph-image.js | twitter-image.js (jsx)export const contentType = 'image/png'\r\nexport default function Image() {}\r\noutput (html)<meta property=\"og:image:type\" content=\"image/png\" />\r\nRoute Segment Config\r\nopengraph-image and twitter-image are specialized Route Handlers that can use the same route segment configuration options as\r\nPages and Layouts. OptionTypeDefault\r\ndynamic'auto' \\| 'force-dynamic' \\| 'error' \\| 'force-static''auto'\r\nrevalidatefalse \\| 'force-cache' \\| 0 \\| numberfalse\r\nruntime'nodejs' \\| 'edge''nodejs'\r\npreferredRegion'auto' \\| 'global' \\| 'home' \\| string \\| string[]'auto'\r\napp/opengraph-image.tsx (tsx)export const runtime = 'edge'\r\nexport default function Image() {}\r\napp/opengraph-image.js (jsx)export const runtime = 'edge'\r\nexport default function Image() {}\r\nExamples\r\nUsing external data\r\nThis example uses the params object and external data to generate the image. Good to know: By default, this generated image will be statically optimized. You can configure the individual fetch options\r\nor route segments options to change this behavior. app/posts/[slug]/opengraph-image.tsx (tsx)import { ImageResponse } from 'next/og'\r\nexport const runtime = 'edge'\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"802c4a35-90df-4492-8685-e680f6522b82":{"id_":"802c4a35-90df-4492-8685-e680f6522b82","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kMyOZj59JFccFIo7lVR4D3IGZtJPn9OCKFhCTnCLKOc=","metadata":{},"hash":"mEbTp52PCbBG9Qq6oedHS4RG/VgSYEHY1PNj2epvwrI="}},"hash":"bfneLGiOfgKkGFXhMMyLFqJNiYlNgd0ZiXjNIKPmrgw=","text":"export default async function Image({ params }: { params: { slug: string } }) {\r\n  const post = await fetch(`https://.../posts/${params.slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          fontSize: 48,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    ),\r\n    {\r\n      ...size,\r\n    }\r\n  )\r\n}\r\napp/posts/[slug]/opengraph-image.js (jsx)import { ImageResponse } from 'next/og'\r\nexport const runtime = 'edge'\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'\r\nexport default async function Image({ params }) {\r\n  const post = await fetch(`https://.../posts/${params.slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          fontSize: 48,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    ),\r\n    {\r\n      ...size,\r\n    }\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.3.0opengraph-image and twitter-image introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8872ee87-7374-4680-8eea-4df63285dfdb":{"id_":"8872ee87-7374-4680-8eea-4df63285dfdb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xVHnlgEYRjc/y+YCt5QBikxrLfsQJ9A7a6ouosVwCHY=","metadata":{},"hash":"lZ2BMRcA7XyCgG7X75QZm9nmmlmJaeAy8Cr4zr9Q0H4="}},"hash":"bw/izyxJzspxTazaKok7VnWznAypuGKJhgF/tcfzQpk=","text":"3.2.2.1.4 - robots.txt\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/robots\r\nDescription: API Reference for robots.txt file. Add or generate a robots.txt file that matches the Robots Exclusion Standard in the root of app directory to tell search engine\r\ncrawlers which URLs they can access on your site. Static robots.txtrobots.txt\r\napp/robots.txt (txt)User-Agent: *\r\nAllow: /\r\nDisallow: /private/\r\nSitemap: https://acme.com/sitemap.xml\r\nGenerate a Robots file\r\nAdd a robots.js or robots.ts file that returns a Robots object. app/robots.ts (ts)import { MetadataRoute } from 'next'\r\nexport default function robots(): MetadataRoute.Robots {\r\n  return {\r\n    rules: {\r\n      userAgent: '*',\r\n      allow: '/',\r\n      disallow: '/private/',\r\n    },\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}\r\napp/robots.js (js)export default function robots() {\r\n  return {\r\n    rules: {\r\n      userAgent: '*',\r\n      allow: '/',\r\n      disallow: '/private/',\r\n    },\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}\r\nOutput:\r\nUser-Agent: *\r\nAllow: /\r\nDisallow: /private/\r\nSitemap: https://acme.com/sitemap.xml\r\nRobots object\r\ntype Robots = {\r\n  rules:\r\n    | {\r\n        userAgent?: string | string[]\r\n        allow?: string | string[]\r\n        disallow?: string | string[]\r\n        crawlDelay?: number\r\n      }\r\n    | Array<{\r\n        userAgent: string | string[]\r\n        allow?: string | string[]\r\n        disallow?: string | string[]","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e8d9281e-fd55-4b17-a6b2-44afb2769dcb":{"id_":"e8d9281e-fd55-4b17-a6b2-44afb2769dcb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3XTdec3D599JrxXmBHob+q3epeYknTpHANQqlEyvnws=","metadata":{},"hash":"+uXvEC24IED8yYJz379DRObv5C+U+IQrL2yIRyvGqzo="}},"hash":"GcgYpb6DnONLqtl4yfzW8ihd+KSHWAfMnWo6VyamuH8=","text":"crawlDelay?: number\r\n      }>\r\n  sitemap?: string | string[]\r\n  host?: string\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.3.0robots introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dcc4571a-1e4d-41ce-8ada-13fcfbedd6df":{"id_":"dcc4571a-1e4d-41ce-8ada-13fcfbedd6df","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p02x7T8jn/yW9i4aHSv/Ftbc6EcG4/KMhhxZIjn+/3Y=","metadata":{},"hash":"0IuXPHpcLg5rordCGdXTMCFPIgAx5zFzn55Z2QlDswU="},"NEXT":{"nodeId":"9187c137-c26c-4b26-b128-3d6e99a8e0a0","metadata":{},"hash":"YnP68eZz6IiXDbaI4vPpL5ybmZCjH8GRZr6q/H8RW0U="}},"hash":"+KOg3oL9UZDA3QgWkXyFmY4xhHKsS6qRFCX/Jlr3eug=","text":"3.2.2.1.5 - sitemap.xml\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/01-metadata/sitemap\r\nDescription: API Reference for the sitemap.xml file. Related:\r\nTitle: Next Steps\r\nRelated Description: Learn how to use the generateSitemaps function. Links:\r\napp/api-reference/functions/generate-sitemaps\r\nsitemap.(xml|js|ts) is a special file that matches the Sitemaps XML format to help search engine crawlers index your site more\r\nefficiently. Sitemap files (.xml)\r\nFor smaller applications, you can create a sitemap.xml file and place it in the root of your app directory. app/sitemap.xml (xml)<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n  <url>\r\n    <loc>https://acme.com</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>yearly</changefreq>\r\n    <priority>1</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/about</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>monthly</changefreq>\r\n    <priority>0.8</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/blog</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>\r\nGenerating a sitemap using code (.js, .ts)\r\nYou can use the sitemap.(js|ts) file convention to programmatically generate a sitemap by exporting a default function that\r\nreturns an array of URLs. If using TypeScript, a Sitemap type is available.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9187c137-c26c-4b26-b128-3d6e99a8e0a0":{"id_":"9187c137-c26c-4b26-b128-3d6e99a8e0a0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p02x7T8jn/yW9i4aHSv/Ftbc6EcG4/KMhhxZIjn+/3Y=","metadata":{},"hash":"0IuXPHpcLg5rordCGdXTMCFPIgAx5zFzn55Z2QlDswU="},"PREVIOUS":{"nodeId":"dcc4571a-1e4d-41ce-8ada-13fcfbedd6df","metadata":{},"hash":"+KOg3oL9UZDA3QgWkXyFmY4xhHKsS6qRFCX/Jlr3eug="}},"hash":"YnP68eZz6IiXDbaI4vPpL5ybmZCjH8GRZr6q/H8RW0U=","text":"If using TypeScript, a Sitemap type is available. app/sitemap.ts (ts)import { MetadataRoute } from 'next'\r\nexport default function sitemap(): MetadataRoute.Sitemap {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'yearly',\r\n      priority: 1,\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'monthly',\r\n      priority: 0.8,\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n    },\r\n  ]\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bb62d2cf-5cce-4060-9e79-f84e055f4854":{"id_":"bb62d2cf-5cce-4060-9e79-f84e055f4854","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dqW5W0mJXX79dQ5Db4I1zeMrc1I1R/n8OYBXLgtFD/4=","metadata":{},"hash":"ncy3c6ZQobdNUn7louNonHNoFjEcqXK8bZH83PKtg7w="},"NEXT":{"nodeId":"f60338a1-5d21-4723-aac6-3354ce98270c","metadata":{},"hash":"osZEqGAnaLbv+uqZAaTe0e02eeYc259gcZNf5WmzcbY="}},"hash":"TMlYBlcgxdPwGRXWSIJUDBADEQd9IyPyUJJWvd+lYao=","text":"app/sitemap.js (js)export default function sitemap() {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'yearly',\r\n      priority: 1,\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'monthly',\r\n      priority: 0.8,\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n    },\r\n  ]\r\n}\r\nOutput:\r\nacme.com/sitemap.xml (xml)<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n  <url>\r\n    <loc>https://acme.com</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>yearly</changefreq>\r\n    <priority>1</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/about</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>monthly</changefreq>\r\n    <priority>0.8</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/blog</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>\r\nGenerating multiple sitemaps\r\nWhile a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files. There are two ways you can create multiple sitemaps:\r\nBy nesting sitemap.(xml|js|ts) inside multiple route segments e.g. app/sitemap.xml and app/products/sitemap.xml. By using the generateSitemaps function. For example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate\r\nthe unique sitemaps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f60338a1-5d21-4723-aac6-3354ce98270c":{"id_":"f60338a1-5d21-4723-aac6-3354ce98270c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dqW5W0mJXX79dQ5Db4I1zeMrc1I1R/n8OYBXLgtFD/4=","metadata":{},"hash":"ncy3c6ZQobdNUn7louNonHNoFjEcqXK8bZH83PKtg7w="},"PREVIOUS":{"nodeId":"bb62d2cf-5cce-4060-9e79-f84e055f4854","metadata":{},"hash":"TMlYBlcgxdPwGRXWSIJUDBADEQd9IyPyUJJWvd+lYao="}},"hash":"osZEqGAnaLbv+uqZAaTe0e02eeYc259gcZNf5WmzcbY=","text":"Then, use the id to generate\r\nthe unique sitemaps. app/product/sitemap.ts (ts)import { BASE_URL } from '@/app/lib/constants'\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\nexport default async function sitemap({\r\n  id,\r\n}: {\r\n  id: number\r\n}): Promise<MetadataRoute.Sitemap> {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"efc19911-7111-4316-b6a9-8a5c91069ad4":{"id_":"efc19911-7111-4316-b6a9-8a5c91069ad4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RVGDJqTOClJQ8mbI/QY6QcRm7vVb/UzJbU2I6xPJIkg=","metadata":{},"hash":"1D2+Tj+GRd67PumyH24/SZ0qPlDNXzms+JVIHeAkOwE="}},"hash":"HM1H6ujJs31m36LBNoectN7JaRwdNV+EluFd8iO2hqk=","text":"const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${id}`,\r\n    lastModified: product.date,\r\n  }))\r\n}\r\napp/product/sitemap.js (js)import { BASE_URL } from '@/app/lib/constants'\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\nexport default async function sitemap({ id }) {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${id}`\r\n    lastModified: product.date,\r\n  }))\r\n}\r\nIn production, your generated sitemaps will be available at /.../sitemap/[id].xml. For example, /product/sitemap/1.xml. In development, you can view the generated sitemap on /.../sitemap.xml/[id]. For example, /product/sitemap.xml/1. This\r\ndifference is temporary and will follow the production format. See the generateSitemaps API reference for more information. Returns\r\nThe default function exported from sitemap.(xml|ts|js) should return an array of objects with the following properties:\r\ntype Sitemap = Array<{\r\n  url: string\r\n  lastModified?: string | Date\r\n  changeFrequency?:\r\n    | 'always'\r\n    | 'hourly'\r\n    | 'daily'\r\n    | 'weekly'\r\n    | 'monthly'\r\n    | 'yearly'\r\n    | 'never'\r\n  priority?: number\r\n}>\r\nVersion History\r\nVersionChanges\r\nv13.3.0sitemap introduced. v13.4.5Add changeFrequency and priority attributes to sitemaps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"958d98ee-0b7c-4b6e-b898-27ae4027d58a":{"id_":"958d98ee-0b7c-4b6e-b898-27ae4027d58a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"elmWgqJETGiJV9iDtuhvY+Nj68cqZdGykGPRDqwyvDo=","metadata":{},"hash":"0QE5rEwNNj9/kCS7nf0SN+XhlkNVj/r63JdjSkQfNpc="}},"hash":"eSMi6jcTXYV64EPLlJEM3Fzrk/bCIyWXjkadGNaetwI=","text":"3.2.2.2 - default.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/default\r\nDescription: API Reference for the default.js file. This documentation is still being written. Please check back later.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"495db859-9c86-4d3d-b297-1759f3737c08":{"id_":"495db859-9c86-4d3d-b297-1759f3737c08","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YJTcbtp8hYpXZuuE6aRFJoc0LY+YgvufJy1ewOhSm+c=","metadata":{},"hash":"yOh0Fm5ewgQ1NBw87+fJbhrBjShvc3x7tWE9fyvGWMk="}},"hash":"yd+JIfyKn93yWA31afCicQh3YMV1Owefg8uSHjfPFKI=","text":"3.2.2.3 - error.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/error\r\nDescription: API reference for the error.js special file. Related:\r\nTitle: Learn more about error handling\r\nRelated Description: No related description\r\nLinks:\r\napp/building-your-application/routing/error-handling\r\nAn error file defines an error UI boundary for a route segment. It is useful for catching unexpected errors that occur in Server Components and Client Components and displaying a fallback UI. app/dashboard/error.tsx (tsx)'use client' // Error components must be Client Components\r\nimport { useEffect } from 'react'\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\napp/dashboard/error.js (jsx)'use client' // Error components must be Client Components\r\nimport { useEffect } from 'react'\r\nexport default function Error({ error, reset }) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7e3500d2-648f-43b6-a8a3-4dbb5eb2def4":{"id_":"7e3500d2-648f-43b6-a8a3-4dbb5eb2def4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KzJ19yQkMerA7MuZhKjJv5DpsTyna5sa4inauW1ZlG8=","metadata":{},"hash":"czIuvWAYiBBvUL8oQ4+o+7ef8clKbB5SYMu5F2e3ToA="}},"hash":"NI81LxRMZrzrjf66KETlUbwsEbRB7Md1RnDVRPidbJM=","text":"Props\r\nerrorerror\r\nAn instance of an Error object forwarded to the error.js Client Component. error.messageerror.message\r\nThe error message. For errors forwarded from Client Components, this will be the original Error’s message. For errors forwarded from Server Components, this will be a generic error message to avoid leaking sensitive details.errors.digest\r\n can be used to match the corresponding error in server-side logs. error.digesterror.digest\r\nAn automatically generated hash of the error thrown in a Server Component. It can be used to match the corresponding error in server-\r\nside logs. resetreset\r\nA function to reset the error boundary. When executed, the function will try to re-render the Error boundary’s contents. If successful,\r\nthe fallback error component is replaced with the result of the re-render. Can be used to prompt the user to attempt to recover from the error. Good to know:\r\nerror.js boundaries must be Client Components. In Production builds, errors forwarded from Server Components will be stripped of specific error details to avoid leaking\r\nsensitive information. An error.js boundary will not handle errors thrown in a layout.js component in the same segment because the error\r\nboundary is nested inside that layouts component. To handle errors for a specific layout, place an error.js file in the layouts parent segment. To handle errors within the root layout or template, use a variation of error.js called app/global-error.js.global-error.jsglobal-error.js\r\nTo specifically handle errors in root layout.js, use a variation of error.js called app/global-error.js located in the root app\r\ndirectory. app/global-error.tsx (tsx)'use client'\r\nexport default function GlobalError({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\napp/global-error.js (jsx)'use client'\r\nexport default function GlobalError({ error, reset }) {\r\n  return (\r\n    <html>\r\n      <body>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d4c9d6d5-37ea-4c32-b5f1-86603a722e7e":{"id_":"d4c9d6d5-37ea-4c32-b5f1-86603a722e7e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kBnC3hBSFE5+crzu9yfIyOFv5pUWeCilsdkr1sPzD+o=","metadata":{},"hash":"3/sazpAM9GuUwjh3Y9VooD3KZm5iRhfKV2px08+1wW0="}},"hash":"Vi4Ru6lWGbkHzuap4UKwK63sTqu4ydal2uyKmhHweWI=","text":"<h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nGood to know:\r\nglobal-error.js replaces the root layout.js when active and so must define its own <html> and <body> tags. While designing error UI, you may find it helpful to use the React Developer Tools to manually toggle Error boundaries. not-found.js\r\nThe not-found file is used to render UI when the notFound() function is thrown within a route segment. Version History\r\nVersionChanges\r\nv13.1.0global-error introduced. v13.0.0error introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"eb21a0b6-ef4c-4051-ae10-76355a7c94db":{"id_":"eb21a0b6-ef4c-4051-ae10-76355a7c94db","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9DuY9231LaF2QLqO4nHQf7icN/zeVGcPyKh/O0pcByk=","metadata":{},"hash":"3ZhdmcFWqy4rPlIzTSp1qJA8w1auvdGTYB9A5wtZnvo="}},"hash":"ikiJ5AwxKyQA7tUnQwkn4dVGaSTMa52lgNxGVKAOqVc=","text":"3.2.2.4 - layout.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/layout\r\nDescription: API reference for the layout.js file. A layout is UI that is shared between routes. app/dashboard/layout.tsx (tsx)export default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <section>{children}</section>\r\n}\r\napp/dashboard/layout.js (jsx)export default function DashboardLayout({ children }) {\r\n  return <section>{children}</section>\r\n}\r\nA root layout is the top-most layout in the root app directory. It is used to define the <html> and <body> tags and other globally\r\nshared UI. app/layout.tsx (tsx)export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\napp/layout.js (jsx)export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}\r\nProps\r\nchildrenchildren (required)\r\nLayout components should accept and use a children prop. During rendering, children will be populated with the route segments\r\nthe layout is wrapping. These will primarily be the component of a child Layout (if it exists) or Page, but could also be other special files\r\nlike Loading or Error when applicable. paramsparams (optional)\r\nThe dynamic route parameters object from the root segment down to that layout. ExampleURLparamsparams\r\napp/dashboard/[team]/layout.js/dashboard/1{ team: '1' }\r\napp/shop/[tag]/[item]/layout.js/shop/1/2{ tag: '1', item: '2' }\r\napp/blog/[...slug]/layout.js/blog/1/2{ slug: ['1', '2'] }\r\nFor example:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5b746665-e82a-48ef-8287-caceacda9f20":{"id_":"5b746665-e82a-48ef-8287-caceacda9f20","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RGcJm63UBktPw8mZNcqJOB695Uj/cd80N/UUHm/GzBM=","metadata":{},"hash":"aV9GTWP1t/mFBEaD34Mf06Vc8M0TZe3NXMuqCWu/7G0="}},"hash":"oyy4X6FWINdj+D/yLiD8wypqAnvjwWx54g7efkAH+/s=","text":"app/shop/[tag]/[item]/layout.tsx (tsx)export default function ShopLayout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: {\r\n    tag: string\r\n    item: string\r\n  }\r\n}) {\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  return <section>{children}</section>\r\n}\r\napp/shop/[tag]/[item]/layout.js (jsx)export default function ShopLayout({ children, params }) {\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  return <section>{children}</section>\r\n}\r\nGood to know\r\nLayouts do not receive searchParamssearchParams\r\nUnlike Pages, Layout components do not receive the searchParams prop. This is because a shared layout is not re-rendered during\r\nnavigation which could lead to stale searchParams between navigations. When using client-side navigation, Next.js automatically only renders the part of the page below the common layout between two\r\nroutes. For example, in the following directory structure, dashboard/layout.tsx is the common layout for both /dashboard/settings and\r\n/dashboard/analytics:\r\nWhen navigating from /dashboard/settings to /dashboard/analytics, page.tsx in /dashboard/analytics will rerender on\r\nthe server, while dashboard/layout.tsx will not rerender because it’s a common UI shared between the two routes. This performance optimization allows navigation between pages that share a layout to be quicker as only the data fetching and\r\nrendering for the page has to run, instead of the entire route that could include shared layouts that fetch their own data. Because dashboard/layout.tsx doesn’t re-render, the searchParams prop in the layout Server Component might become stale\r\nafter navigation. Instead, use the Page searchParams prop or the useSearchParams hook in a Client Component, which is re-rendered on the\r\nclient with the latest searchParams. Root Layouts\r\nThe app directory must include a root app/layout.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"33d6ce75-8764-42c1-8a42-d877109eb0f9":{"id_":"33d6ce75-8764-42c1-8a42-d877109eb0f9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UDlAteemsA4GmuaYu2X9H9CwXJjIN61XULMZJXc/6jw=","metadata":{},"hash":"BqDO6KFvgPaXvs1/otna+XXv90PRmVd+4DcmgAy7aDI="}},"hash":"3j5qRZzkSqC3B2e8RRaQng6zZqRpEba7QxiQnHaBInM=","text":"The root layout must define <html> and <body> tags. You should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, you should use the Metadata API\r\nwhich automatically handles advanced requirements such as streaming and de-duplicating <head> elements. You can use route groups to create multiple root layouts. Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example,\r\nnavigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js will cause a full page\r\nload. This only applies to multiple root layouts. Version History\r\nVersionChanges\r\nv13.0.0layout introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0aa5aac0-0ee8-4d3f-9f1a-dc183aedc5ef":{"id_":"0aa5aac0-0ee8-4d3f-9f1a-dc183aedc5ef","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ecDSG1SxDcv7uWRTDsySHfyH9xMBdSisABMtmSyEzEU=","metadata":{},"hash":"h0BRJkT+nPCH10Lewf9ocsqre9wBn2ecs+jQw8+2T/8="}},"hash":"J/SBHdS/Pfc5IixuJBw6iMK6ymP7bV24OXQmNT89Uz0=","text":"3.2.2.5 - loading.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/loading\r\nDescription: API reference for the loading.js file. A loading file can create instant loading states built on Suspense. By default, this file is a Server Component - but can also be used as a Client Component through the \"use client\" directive. app/feed/loading.tsx (tsx)export default function Loading() {\r\n  // Or a custom loading skeleton component\r\n  return <p>Loading...</p>\r\n}\r\napp/feed/loading.js (jsx)export default function Loading() {\r\n  // Or a custom loading skeleton component\r\n  return <p>Loading...</p>\r\n}\r\nLoading UI components do not accept any parameters. Good to know\r\nWhile designing loading UI, you may find it helpful to use the React Developer Tools to manually toggle Suspense\r\nboundaries. Version History\r\nVersionChanges\r\nv13.0.0loading introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0314f5ed-2f26-4632-8e3a-25d809452ce5":{"id_":"0314f5ed-2f26-4632-8e3a-25d809452ce5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aBUSy5GwkNgxkxIs4l5KYGzRD6xBe1WSRciY5FLthO4=","metadata":{},"hash":"hDApw4gNsjze0fPsy0I0wDdo1IfN29la7Q6PITGPjHY="}},"hash":"SQAH/Wjh78uFMPdfLHQR605OccxN7KkLtSMtQvUTahU=","text":"3.2.2.6 - not-found.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/not-found\r\nDescription: API reference for the not-found.js file. The not-found file is used to render UI when the notFound function is thrown within a route segment. Along with serving a custom UI,\r\nNext.js will return a 200 HTTP status code for streamed responses, and 404 for non-streamed responses. app/not-found.tsx (tsx)import Link from 'next/link'\r\nexport default function NotFound() {\r\n  return (\r\n    <div>\r\n      <h2>Not Found</h2>\r\n      <p>Could not find requested resource</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}\r\napp/blog/not-found.js (jsx)import Link from 'next/link'\r\nexport default function NotFound() {\r\n  return (\r\n    <div>\r\n      <h2>Not Found</h2>\r\n      <p>Could not find requested resource</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}\r\nGood to know: In addition to catching expected notFound() errors, the root app/not-found.js file also handles any\r\nunmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the\r\nUI exported by the app/not-found.js file. Props\r\nnot-found.js components do not accept any props. Data Fetching\r\nBy default, not-found is a Server Component. You can mark it as async to fetch and display data:\r\napp/not-found.tsx (tsx)import Link from 'next/link'\r\nimport { headers } from 'next/headers'\r\nexport default async function NotFound() {\r\n  const headersList = headers()\r\n  const domain = headersList.get('host')\r\n  const data = await getSiteData(domain)\r\n  return (\r\n    <div>\r\n      <h2>Not Found: {data.name}</h2>\r\n      <p>Could not find requested resource</p>\r\n      <p>\r\n        View <Link href=\"/blog\">all posts</Link>\r\n      </p>\r\n    </div>\r\n  )\r\n}\r\napp/not-found.jsx (jsx)import Link from 'next/link'\r\nimport { headers } from 'next/headers'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b2c00668-d738-422c-bace-5e40cb69566a":{"id_":"b2c00668-d738-422c-bace-5e40cb69566a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AYAemwAKTzEqTKnbaSLquAuuvdVh1JUng963MWB+AC8=","metadata":{},"hash":"iVKBnsma0OfbE9bO1d/4HVjZT6V+yyF7WnlqhAjG01I="}},"hash":"B96O1x6l4nmSpejMXS5l95VIB2IT9afSVfLAOWoSzNI=","text":"export default async function NotFound() {\r\n  const headersList = headers()\r\n  const domain = headersList.get('host')\r\n  const data = await getSiteData(domain)\r\n  return (\r\n    <div>\r\n      <h2>Not Found: {data.name}</h2>\r\n      <p>Could not find requested resource</p>\r\n      <p>\r\n        View <Link href=\"/blog\">all posts</Link>\r\n      </p>\r\n    </div>\r\n  )\r\n}\r\nIf you need to use Client Component hooks like usePathname to display content based on the path, you must fetch data on the client-\r\nside instead. Version History\r\nVersionChanges\r\nv13.3.0Root app/not-found handles global unmatched URLs. v13.0.0not-found introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"86391a0e-b065-49eb-8b89-387dbe58623a":{"id_":"86391a0e-b065-49eb-8b89-387dbe58623a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JmE0ai/6ns328xXcJfg/EaGisIUUHY3htfwyh8L7abQ=","metadata":{},"hash":"2dEBKLEXFv4NL6teZ0z8U6UYpFoERlEVQKJP9jBtEgA="}},"hash":"VrA9NOUjKc/IGEh7vvJmMrK4dBWEGjMBlUq94lgKPOo=","text":"3.2.2.7 - page.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/page\r\nDescription: API reference for the page.js file. A page is UI that is unique to a route. app/blog/[slug]/page.tsx (tsx)export default function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: { slug: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}) {\r\n  return <h1>My Page</h1>\r\n}\r\napp/blog/[slug]/page.js (jsx)export default function Page({ params, searchParams }) {\r\n  return <h1>My Page</h1>\r\n}\r\nProps\r\nparamsparams (optional)\r\nAn object containing the dynamic route parameters from the root segment down to that page. For example:\r\nExampleURLparamsparams\r\napp/shop/[slug]/page.js/shop/1{ slug: '1' }\r\napp/shop/[category]/[item]/page.js/shop/1/2{ category: '1', item: '2' }\r\napp/shop/[...slug]/page.js/shop/1/2{ slug: ['1', '2'] }\r\nsearchParamssearchParams (optional)\r\nAn object containing the search parameters of the current URL. For example:\r\nURLsearchParamssearchParams\r\n/shop?a=1{ a: '1' }\r\n/shop?a=1&b=2{ a: '1', b: '2' }\r\n/shop?a=1&a=2{ a: ['1', '2'] }\r\nGood to know:\r\nsearchParams is a Dynamic API whose values cannot be known ahead of time. Using it will opt the page into dynamic\r\nrendering at request time.searchParams\r\n returns a plain JavaScript object and not a URLSearchParams instance. Version History\r\nVersionChanges\r\nv13.0.0page introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d26c3f77-26c0-461b-bfa4-873d631328ad":{"id_":"d26c3f77-26c0-461b-bfa4-873d631328ad","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uHqHPla0v8SKZmKIt6KL91mvaMhQuofHZSRay8DHiwU=","metadata":{},"hash":"NUWgrE4/3bkSFGwx8rgnqxhVaVVI0kKGM2MS9ETXzsQ="}},"hash":"UWRTOgirm2ogwYJADSh2p4IxddfA0pC8pg3uEM6a0PU=","text":"3.2.2.8 - Route Segment Config\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/route-segment-config\r\nDescription: Learn about how to configure options for Next.js route segments. The Route Segment options allows you configure the behavior of a Page, Layout, or Route Handler by directly exporting the following\r\nvariables:\r\nOptionTypeDefault\r\ndynamic'auto' \\| 'force-dynamic' \\| 'error' \\| 'force-static''auto'\r\ndynamicParamsbooleantrue\r\nrevalidatefalse \\| 'force-cache' \\| 0 \\| numberfalse\r\nfetchCache'auto' \\| 'default-cache' \\| 'only-cache' \\| 'force-cache' \\| 'force-no-store' \\| 'default-no-store' \\| 'only-no-store''auto'\r\nruntime'nodejs' \\| 'edge''nodejs'\r\npreferredRegion'auto' \\| 'global' \\| 'home' \\| string \\| string[]'auto'\r\nmaxDurationnumberSet bydeployment\r\nplatform\r\nlayout.tsx | page.tsx | route.ts (tsx)export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'\r\nexport const maxDuration = 5\r\nexport default function MyComponent() {}\r\nlayout.js | page.js | route.js (jsx)export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'\r\nexport const maxDuration = 5\r\nexport default function MyComponent() {}\r\nGood to know:\r\nThe values of the config options currently need be statically analyzable. For example revalidate = 600 is valid, but\r\nrevalidate = 60 * 10 is not. Options\r\ndynamicdynamic\r\nChange the dynamic behavior of a layout or page to fully static or fully dynamic. layout.tsx | page.tsx | route.ts (tsx)export const dynamic = 'auto'\r\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'\r\nlayout.js | page.js | route.js (js)export const dynamic = 'auto'\r\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"966384ff-bcf5-4656-8734-1af9a14fccd7":{"id_":"966384ff-bcf5-4656-8734-1af9a14fccd7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"B7Q0ltYLL8fLcSfi1gqeR1eX69NHDfCUOL7t+/PNY44=","metadata":{},"hash":"uGXbmoUxvKjC30cVtp8Hcr9CF0/53DcJKoj+y1ne4bA="},"NEXT":{"nodeId":"f97cf7bc-0b03-4934-9461-4976d07b19b4","metadata":{},"hash":"IM71tNUNMsfyCyRKhSIHBMw/w+T2jQkiPkrWBX1v9TI="}},"hash":"HFUrR6yVr9r0VRFT4SJacMK2SpYiPEdAs5VyarBItrI=","text":"Good to know: The new model in the app directory favors granular caching control at the fetch request level over the binary\r\nall-or-nothing model of getServerSideProps and getStaticProps at the page-level in the pages directory. The dynamic\r\noption is a way to opt back in to the previous model as a convenience and provides a simpler migration path. 'auto''auto' (default): The default option to cache as much as possible without preventing any components from opting into dynamic\r\nbehavior. 'force-dynamic''force-dynamic': Force dynamic rendering, which will result in routes being rendered for each user at request time. This option\r\nis equivalent to getServerSideProps() in the pages directory. 'error''error': Force static rendering and cache the data of a layout or page by causing an error if any components use dynamic\r\nfunctions or uncached data. This option is equivalent to:\r\ngetStaticProps() in the pages directory. Setting the option of every fetch() request in a layout or page to { cache: 'force-cache' }. Setting the segment config to fetchCache = 'only-cache', dynamicParams = false. dynamic = 'error' changes the default of dynamicParams from true to false. You can opt back into dynamically rendering\r\npages for dynamic params not generated by generateStaticParams by manually setting dynamicParams = true. 'force-static''force-static': Force static rendering and cache the data of a layout or page by forcing cookies(), headers() and\r\nuseSearchParams() to return empty values. Good to know:\r\nInstructions on how to migrate from getServerSideProps and getStaticProps to dynamic: 'force-dynamic' and\r\ndynamic: 'error' can be found in the upgrade guide. dynamicParamsdynamicParams\r\nControl what happens when a dynamic segment is visited that was not generated with generateStaticParams. layout.tsx | page.tsx (tsx)export const dynamicParams = true // true | false,\r\nlayout.js | page.js | route.js (js)export const dynamicParams = true // true | false,\r\ntruetrue (default): Dynamic segments not included in generateStaticParams are generated on demand. falsefalse: Dynamic segments not included in generateStaticParams will return a 404. Good to know:\r\nThis option replaces the fallback: true | false | blocking option of getStaticPaths in the pages directory. When dynamicParams = true, the segment uses Streaming Server Rendering.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f97cf7bc-0b03-4934-9461-4976d07b19b4":{"id_":"f97cf7bc-0b03-4934-9461-4976d07b19b4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"B7Q0ltYLL8fLcSfi1gqeR1eX69NHDfCUOL7t+/PNY44=","metadata":{},"hash":"uGXbmoUxvKjC30cVtp8Hcr9CF0/53DcJKoj+y1ne4bA="},"PREVIOUS":{"nodeId":"966384ff-bcf5-4656-8734-1af9a14fccd7","metadata":{},"hash":"HFUrR6yVr9r0VRFT4SJacMK2SpYiPEdAs5VyarBItrI="}},"hash":"IM71tNUNMsfyCyRKhSIHBMw/w+T2jQkiPkrWBX1v9TI=","text":"When dynamicParams = true, the segment uses Streaming Server Rendering. If the dynamic = 'error' and dynamic = 'force-static' are used, it’ll change the default of dynamicParams to\r\nfalse. revalidaterevalidate\r\nSet the default revalidation time for a layout or page. This option does not override the revalidate value set by individual fetch\r\nrequests. layout.tsx | page.tsx | route.ts (tsx)export const revalidate = false\r\n// false | 'force-cache' | 0 | number\r\nlayout.js | page.js | route.js (js)export const revalidate = false\r\n// false | 'force-cache' | 0 | number\r\nfalsefalse: (default) The default heuristic to cache any fetch requests that set their cache option to 'force-cache' or are\r\ndiscovered before a dynamic function is used. Semantically equivalent to revalidate: Infinity which effectively means the\r\nresource should be cached indefinitely. It is still possible for individual fetch requests to use cache: 'no-store' or\r\nrevalidate: 0 to avoid being cached and make the route dynamically rendered. Or set revalidate to a positive number lower\r\nthan the route default to increase the revalidation frequency of a route.00\r\n: Ensure a layout or page is always dynamically rendered even if no dynamic functions or uncached data fetches are discovered. This option changes the default of fetch requests that do not set a cache option to 'no-store' but leaves fetch requests that","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3097174c-1ee9-436a-95a3-6a67e7c467af":{"id_":"3097174c-1ee9-436a-95a3-6a67e7c467af","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"L88ZIih3SOfFQFDtmy6jiVFZ3kX38BLCmScTDtrp7Pk=","metadata":{},"hash":"fIDgaY0dJ9Cf4X58tZtWlbP7E8TtUXARgt8Lz4dQgkQ="},"NEXT":{"nodeId":"63b491d2-a99d-47b8-800a-5ac4a1dd238d","metadata":{},"hash":"+ksAARCUKAVVoybO2YsadJNwYzKTuPZ41RSLLXjXcMo="}},"hash":"leS6uTG3zoBMKD1i1eJrTo1cNrcPIawIAgnLX+M/oV0=","text":"opt into 'force-cache' or use a positive revalidate as is. numbernumber: (in seconds) Set the default revalidation frequency of a layout or page to n seconds. Good to know: The revalidate option is only available when using the Node.js Runtime. This means using the revalidate\r\noption with runtime = 'edge' will not work. Revalidation Frequency\r\nThe lowest revalidate across each layout and page of a single route will determine the revalidation frequency of the entire route. This ensures that child pages are revalidated as frequently as their parent layouts. Individual fetch requests can set a lower revalidate than the route’s default revalidate to increase the revalidation frequency\r\nof the entire route. This allows you to dynamically opt-in to more frequent revalidation for certain routes based on some criteria. fetchCachefetchCache\r\nThis is an advanced option that should only be used if you specifically need to override the default behavior. runtimeruntime\r\nlayout.tsx | page.tsx | route.ts (tsx)export const runtime = 'nodejs'\r\n// 'edge' | 'nodejs'\r\nlayout.js | page.js | route.js (js)export const runtime = 'nodejs'\r\n// 'edge' | 'nodejs'\r\nnodejsnodejs (default)\r\nedgeedge\r\nLearn more about the Edge and Node.js runtimes. preferredRegionpreferredRegion\r\nlayout.tsx | page.tsx | route.ts (tsx)export const preferredRegion = 'auto'\r\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\r\nlayout.js | page.js | route.js (js)export const preferredRegion = 'auto'\r\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\r\nSupport for preferredRegion, and regions supported, is dependent on your deployment platform. Good to know:\r\nIf a preferredRegion is not specified, it will inherit the option of the nearest parent layout. The root layout defaults to all regions. maxDurationmaxDuration\r\nBased on your deployment platform, you may be able to use a higher default execution time for your function. This setting allows you\r\nto opt into a higher execution time within your plans limit. Note: This settings requires Next.js 13.4.10 or higher.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"63b491d2-a99d-47b8-800a-5ac4a1dd238d":{"id_":"63b491d2-a99d-47b8-800a-5ac4a1dd238d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"L88ZIih3SOfFQFDtmy6jiVFZ3kX38BLCmScTDtrp7Pk=","metadata":{},"hash":"fIDgaY0dJ9Cf4X58tZtWlbP7E8TtUXARgt8Lz4dQgkQ="},"PREVIOUS":{"nodeId":"3097174c-1ee9-436a-95a3-6a67e7c467af","metadata":{},"hash":"leS6uTG3zoBMKD1i1eJrTo1cNrcPIawIAgnLX+M/oV0="}},"hash":"+ksAARCUKAVVoybO2YsadJNwYzKTuPZ41RSLLXjXcMo=","text":"Note: This settings requires Next.js 13.4.10 or higher. layout.tsx | page.tsx | route.ts (tsx)export const maxDuration = 5\r\nlayout.js | page.js | route.js (js)export const maxDuration = 5\r\nGood to know:\r\nIf a maxDuration is not specified, the default value is dependent on your deployment platform and plan. generateStaticParamsgenerateStaticParams","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3cc06555-6e0a-4b16-a9ff-d886c9692923":{"id_":"3cc06555-6e0a-4b16-a9ff-d886c9692923","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1iLcW2jdJSjaqmi44Jrc3WlyBxixcWFw/73sxWLLF2c=","metadata":{},"hash":"xIylJVkK7dLfyys8n+upKw4LXfP/TLNlaBaLjaTpJMI="}},"hash":"gxFpV1yiKWJx3QFjT9UjxBV8Z+QfJkjij3mi3aeM2pU=","text":"The generateStaticParams function can be used in combination with dynamic route segments to define the list of route segment\r\nparameters that will be statically generated at build time instead of on-demand at request time. See the API reference for more details.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ea488961-226d-4494-a560-e8c56de8bb66":{"id_":"ea488961-226d-4494-a560-e8c56de8bb66","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ueUtW15MAk1EyW0KvtgtRbxnjOSgrZL3pBZaodENDkQ=","metadata":{},"hash":"wPcVrw0kXU/hVBUiC7sT9NlVkFEBHX1t4MfPKOnoExk="}},"hash":"tUthVVq8eixr0wc2n630f61CXb1tkf3VGcfBPUmAo5g=","text":"3.2.2.9 - route.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/route\r\nDescription: API reference for the route.js special file. Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. HTTP Methods\r\nA route file allows you to create custom request handlers for a given route. The following HTTP methods are supported: GET, POST,\r\nPUT, PATCH, DELETE, HEAD, and OPTIONS. route.ts (ts)export async function GET(request: Request) {}\r\nexport async function HEAD(request: Request) {}\r\nexport async function POST(request: Request) {}\r\nexport async function PUT(request: Request) {}\r\nexport async function DELETE(request: Request) {}\r\nexport async function PATCH(request: Request) {}\r\n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and  set the appropriate Response `Allow` header depending on the other methods defined in the route handler. export async function OPTIONS(request: Request) {}\r\nroute.js (js)export async function GET(request) {}\r\nexport async function HEAD(request) {}\r\nexport async function POST(request) {}\r\nexport async function PUT(request) {}\r\nexport async function DELETE(request) {}\r\nexport async function PATCH(request) {}\r\n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and  set the appropriate Response `Allow` header depending on the other methods defined in the route handler. export async function OPTIONS(request) {}\r\nGood to know: Route Handlers are only available inside the app directory. You do not need to use API Routes (pages) and\r\nRoute Handlers (app) together, as Route Handlers should be able to handle all use cases. Parameters\r\nrequestrequest (optional)\r\nThe request object is a NextRequest object, which is an extension of the Web Request API. NextRequest gives you further control\r\nover the incoming request, including easily accessing cookies and an extended, parsed, URL object nextUrl. contextcontext (optional)\r\napp/dashboard/[team]/route.js (ts)export async function GET(request, context: { params }) {\r\n  const team = params.team // '1'\r\n}\r\nCurrently, the only value of context is params, which is an object containing the dynamic route parameters for the current route. ExampleURLparamsparams\r\napp/dashboard/[team]/route.js/dashboard/1{ team: '1' }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1ae28fa4-589f-472b-b694-5c132871766e":{"id_":"1ae28fa4-589f-472b-b694-5c132871766e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"al6bAOU8hBpFNdStJQ3FSod2FKsVTABZPqMm4rCtWCQ=","metadata":{},"hash":"xZdrNGnmFHoh0Ztflae/dHJZGoLGTOJr/l5xxzMiXDc="}},"hash":"NdA0asWWjb60X+mF9b5JAsGWI7H7OWyF3rczjjRFfkI=","text":"app/shop/[tag]/[item]/route.js/shop/1/2{ tag: '1', item: '2' }\r\napp/blog/[...slug]/route.js/blog/1/2{ slug: ['1', '2'] }\r\nExampleURLparamsparams\r\nNextResponse\r\nRoute Handlers can extend the Web Response API by returning a NextResponse object. This allows you to easily set cookies, headers,\r\nredirect, and rewrite. View the API reference. Version History\r\nVersionChanges\r\nv13.2.0Route handlers are introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"10216f94-db41-4cba-8f59-a99885e06925":{"id_":"10216f94-db41-4cba-8f59-a99885e06925","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UYTIoo1zbtxy540OoFpiiK+cW6M852/8BKc+F7TLwIE=","metadata":{},"hash":"Zxm7o2rNKahFK3mMaq+leQFEkVbJ8mmisA2tag/6PdI="}},"hash":"DFZyxe3i0xiAu/e0hmVCMzk9d2J9zsCNToCAb3lwGb8=","text":"3.2.2.10 - template.js\r\nDocumentation path: /02-app/02-api-reference/02-file-conventions/template\r\nDescription: API Reference for the template.js file. A template file is similar to a layout in that it wraps each child layout or page. Unlike layouts that persist across routes and maintain\r\nstate, templates create a new instance for each of their children on navigation. app/template.tsx (tsx)export default function Template({ children }: { children: React.ReactNode }) {\r\n  return <div>{children}</div>\r\n}\r\napp/template.jsx (jsx)export default function Template({ children }) {\r\n  return <div>{children}</div>\r\n}\r\nWhile less common, you might choose a template over a layout if you want:\r\nFeatures that rely on useEffect (e.g logging page views) and useState (e.g a per-page feedback form). To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time\r\nthe Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation. Props\r\nchildrenchildren (required)\r\nTemplate components should accept and use a children prop. template is rendered between a layout and its children. For example:\r\nOutput (jsx)<Layout>\r\n  {/* Note that the template is given a unique key. */}\r\n  <Template key={routeParam}>{children}</Template>\r\n</Layout>\r\nGood to know:\r\nBy default, template is a Server Component, but can also be used as a Client Component through the \"use client\"\r\ndirective. When a user navigates between routes that share a template, a new instance of the component is mounted, DOM\r\nelements are recreated, state is not preserved, and effects are re-synchronized. Version History\r\nVersionChanges\r\nv13.0.0template introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1335ae03-1351-4a8e-9a7c-fa72799e7331":{"id_":"1335ae03-1351-4a8e-9a7c-fa72799e7331","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QZjeIrl1rq59wf7pWBnnmKovBRr93GwV+faXt6YRmVs=","metadata":{},"hash":"NGp62yw3bXwoL5M2pRntfD5WRGj9KgcBh+D4sDUKknU="}},"hash":"yetNlYs8oxvdqEqiL4aLrvY2wBlwxwOB4DZvgCY8fnw=","text":"3.2.3 - Functions\r\nDocumentation path: /02-app/02-api-reference/04-functions/index\r\nDescription: API Reference for Next.js Functions and Hooks. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"93251145-dc37-4f78-b9e5-c07279c3c3ad":{"id_":"93251145-dc37-4f78-b9e5-c07279c3c3ad","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ExhWz378xX3J8yO/GjPRzBnxXGjfv0Qko+NVqpRTPkU=","metadata":{},"hash":"260ixb8iqzRUH0z3bqN4MhL21DWsIqMl790xARaznW0="}},"hash":"fMBq0YeWtOLj83CG011ousstYT9RKuDy+dBriGr61Ac=","text":"3.2.3.1 - cookies\r\nDocumentation path: /02-app/02-api-reference/04-functions/cookies\r\nDescription: API Reference for the cookies function. Related:\r\nTitle: Next Steps\r\nRelated Description: For more information on what to do next, we recommend the following sections\r\nLinks:\r\napp/building-your-application/data-fetching/server-actions-and-mutations\r\nThe cookies function allows you to read the HTTP incoming request cookies from a Server Component or write outgoing request\r\ncookies in a Server Action or Route Handler. Good to know: cookies() is a Dynamic Function whose returned values cannot be known ahead of time. Using it in a layout\r\nor page will opt a route into dynamic rendering at request time.cookies().get(name)cookies().get(name)\r\nA method that takes a cookie name and returns an object with name and value. If a cookie with name isn’t found, it returns undefined. If multiple cookies match, it will only return the first match. app/page.js (jsx)import { cookies } from 'next/headers'\r\nexport default function Page() {\r\n  const cookieStore = cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '... '\r\n}\r\ncookies().getAll()cookies().getAll()\r\nA method that is similar to get, but returns a list of all the cookies with a matching name. If name is unspecified, it returns all the\r\navailable cookies. app/page.js (jsx)import { cookies } from 'next/headers'\r\nexport default function Page() {\r\n  const cookieStore = cookies()\r\n  return cookieStore.getAll().map((cookie) => (\r\n    <div key={cookie.name}>\r\n      <p>Name: {cookie.name}</p>\r\n      <p>Value: {cookie.value}</p>\r\n    </div>\r\n  ))\r\n}\r\ncookies().has(name)cookies().has(name)\r\nA method that takes a cookie name and returns a boolean based on if the cookie exists (true) or not (false). app/page.js (jsx)import { cookies } from 'next/headers'\r\nexport default function Page() {\r\n  const cookiesList = cookies()\r\n  const hasCookie = cookiesList.has('theme')\r\n  return '... '\r\n}\r\ncookies().set(name, value, options)cookies().set(name, value, options)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a9fcd808-426c-409a-bafd-95f408e8c5a6":{"id_":"a9fcd808-426c-409a-bafd-95f408e8c5a6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0U8i1kjso+iKKZxDtrW9o3zGXFnD/LFq0SolNVAxtAc=","metadata":{},"hash":"3MMCxF/M3mos4Bk5zDcZ70oE3qA1Tr0nBg2/A9edWjs="}},"hash":"Do8t7rOsgkljn0l47jGoBwr8JDNs0cinvnIkNwO8/ZU=","text":"A method that takes a cookie name, value, and options and sets the outgoing request cookie. Good to know: HTTP does not allow setting cookies after streaming starts, so you must use .set() in a Server Action or Route\r\nHandler. app/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nasync function create(data) {\r\n  cookies().set('name', 'lee')\r\n  // or\r\n  cookies().set('name', 'lee', { secure: true })\r\n  // or\r\n  cookies().set({\r\n    name: 'name',\r\n    value: 'lee',\r\n    httpOnly: true,\r\n    path: '/',\r\n  })\r\n}\r\nDeleting cookies\r\nGood to know: You can only delete cookies in a Server Action or Route Handler. There are several options for deleting a cookie:\r\ncookies().delete(name)cookies().delete(name)\r\nYou can explicitly delete a cookie with a given name. app/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nasync function delete(data) {\r\n  cookies().delete('name')\r\n}\r\ncookies().set(name, '')cookies().set(name, '')\r\nAlternatively, you can set a new cookie with the same name and an empty value. app/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nasync function delete(data) {\r\n  cookies().set('name', '')\r\n}\r\nGood to know: .set() is only available in a Server Action or Route Handler. cookies().set(name, value, { maxAge: 0 })cookies().set(name, value, { maxAge: 0 })\r\nSetting maxAge to 0 will immediately expire a cookie. app/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nasync function delete(data) {\r\n  cookies().set('name', 'value', { maxAge: 0 })\r\n}\r\ncookies().set(name, value, { expires: timestamp })cookies().set(name, value, { expires: timestamp })","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cdd93454-24c1-4a23-88cc-6125e2c66e49":{"id_":"cdd93454-24c1-4a23-88cc-6125e2c66e49","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"e8+U27jCrAOXj7LaieEhkAGYRs79xjLVVZ4jaNsxDRQ=","metadata":{},"hash":"Wq/XtDtLqpMwNe5KxwowDV6eDNwmQhkMPfOcelJk9VA="}},"hash":"VZf02Lf/06sJw4CDNc9SxWvhypalzjpnEHHBWZgHRHI=","text":"Setting expires to any value in the past will immediately expire a cookie. app/actions.js (js)'use server'\r\nimport { cookies } from 'next/headers'\r\nasync function delete(data) {\r\n  const oneDay = 24 * 60 * 60 * 1000\r\n  cookies().set('name', 'value', { expires: Date.now() - oneDay })\r\n}\r\nGood to know: You can only delete cookies that belong to the same domain from which .set() is called. Additionally, the\r\ncode must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete. Version History\r\nVersionChanges\r\nv13.0.0cookies introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"57894b80-c895-422e-97b7-fdf2ae01b65f":{"id_":"57894b80-c895-422e-97b7-fdf2ae01b65f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J/TUMciF0H+7J2JnsGEZrlHlNZe0zto4XpBb9cifTcw=","metadata":{},"hash":"U5jerPCYEZ7mWjoILlHHAarcs9JEW0jiXkIICRxcB5Y="}},"hash":"xNDnlWcjJOvp8UIW81CPQlnWqMJJIG+/Xg+WtnTArWo=","text":"3.2.3.2 - draftMode\r\nDocumentation path: /02-app/02-api-reference/04-functions/draft-mode\r\nDescription: API Reference for the draftMode function. The draftMode function allows you to detect Draft Mode inside a Server Component. app/page.js (jsx)import { draftMode } from 'next/headers'\r\nexport default function Page() {\r\n  const { isEnabled } = draftMode()\r\n  return (\r\n    <main>\r\n      <h1>My Blog Post</h1>\r\n      <p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>\r\n    </main>\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.4.0draftMode introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"55a1a580-92d4-46a3-a07e-b8adfaac44c0":{"id_":"55a1a580-92d4-46a3-a07e-b8adfaac44c0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R5dWKeQjNrJuIj6dor97KhddHh6/VTm8tcflBAKLdDE=","metadata":{},"hash":"UrqKs3dUT9eU0z2SbTwsF9HA2Z5LyTlwVDgnOZmVXvU="},"NEXT":{"nodeId":"ba2fdecc-4537-49d2-9ecf-9acd649d794e","metadata":{},"hash":"7yKje+laKUHqTGQ8YPqGdsqTF/7kFrs0A4jt5nZZafA="}},"hash":"w7d8aLqVGZvBPmEiUog/XiEuB6CCAdppJpV11uCAhqE=","text":"3.2.3.3 - fetch\r\nDocumentation path: /02-app/02-api-reference/04-functions/fetch\r\nDescription: API reference for the extended fetch function. Next.js extends the native Web fetch() API to allow each request on the server to set its own persistent caching semantics. In the browser, the cache option indicates how a fetch request will interact with the browser’s HTTP cache. With this extension, cache\r\nindicates how a server-side fetch request will interact with the framework’s persistent HTTP cache. You can call fetch with async and await directly within Server Components. app/page.tsx (tsx)export default async function Page() {\r\n  // This request should be cached until manually invalidated. // Similar to `getStaticProps`. // `force-cache` is the default and can be omitted. const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n  // This request should be refetched on every request. // Similar to `getServerSideProps`. const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n  // This request should be cached with a lifetime of 10 seconds. // Similar to `getStaticProps` with the `revalidate` option. const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n  return <div>...</div>\r\n}\r\napp/page.js (jsx)export default async function Page() {\r\n  // This request should be cached until manually invalidated. // Similar to `getStaticProps`. // `force-cache` is the default and can be omitted. const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n  // This request should be refetched on every request. // Similar to `getServerSideProps`. const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n  // This request should be cached with a lifetime of 10 seconds. // Similar to `getStaticProps` with the `revalidate` option. const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n  return <div>...</div>\r\n}\r\nfetch(url, options)fetch(url, options)\r\nSince Next.js extends the Web fetch() API, you can use any of the native options available.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ba2fdecc-4537-49d2-9ecf-9acd649d794e":{"id_":"ba2fdecc-4537-49d2-9ecf-9acd649d794e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R5dWKeQjNrJuIj6dor97KhddHh6/VTm8tcflBAKLdDE=","metadata":{},"hash":"UrqKs3dUT9eU0z2SbTwsF9HA2Z5LyTlwVDgnOZmVXvU="},"PREVIOUS":{"nodeId":"55a1a580-92d4-46a3-a07e-b8adfaac44c0","metadata":{},"hash":"w7d8aLqVGZvBPmEiUog/XiEuB6CCAdppJpV11uCAhqE="}},"hash":"7yKje+laKUHqTGQ8YPqGdsqTF/7kFrs0A4jt5nZZafA=","text":"options.cacheoptions.cache\r\nConfigure how the request should interact with Next.js Data Cache. fetch(`https://...`, { cache: 'force-cache' | 'no-store' })\r\nforce-cacheforce-cache (default) - Next.js looks for a matching request in its Data Cache. If there is a match and it is fresh, it will be returned from the cache. If there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the\r\ndownloaded resource.no-storeno-store\r\n - Next.js fetches the resource from the remote server on every request without looking in the cache, and it will not\r\nupdate the cache with the downloaded resource. Good to know:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"179d826e-6e03-41d7-b85e-6b3c33cd8aff":{"id_":"179d826e-6e03-41d7-b85e-6b3c33cd8aff","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hm1d/8j6N9W3k8u6TYqxU7doGU2w9zkKun2w77Tbrl0=","metadata":{},"hash":"gG11/CNqLFUYgZz48VZdvztt4jQK7KkleDHSPdxwAUM="}},"hash":"yoeCo8AeVcT0vGQ4R5Fpb+N146fSmmni9Vk1canwew4=","text":"If you don’t provide a cache option, Next.js will default to force-cache, unless a dynamic function such as cookies() is\r\nused, in which case it will default to no-store. The no-cache option behaves the same way as no-store in Next.js. options.next.revalidateoptions.next.revalidate\r\nfetch(`https://...`, { next: { revalidate: false | 0 | number } })\r\nSet the cache lifetime of a resource (in seconds). falsefalse - Cache the resource indefinitely. Semantically equivalent to revalidate: Infinity. The HTTP cache may evict older\r\nresources over time.00\r\n - Prevent the resource from being cached. numbernumber - (in seconds) Specify the resource should have a cache lifetime of at most n seconds. Good to know:\r\nIf an individual fetch() request sets a revalidate number lower than the default revalidate of a route, the whole\r\nroute revalidation interval will be decreased. If two fetch requests with the same URL in the same route have different revalidate values, the lower value will be used. As a convenience, it is not necessary to set the cache option if revalidate is set to a number since 0 implies cache:\r\n'no-store' and a positive value implies cache: 'force-cache'. Conflicting options such as { revalidate: 0, cache: 'force-cache' } or { revalidate: 10, cache: 'no-\r\nstore' } will cause an error. options.next.tagsoptions.next.tags\r\nfetch(`https://...`, { next: { tags: ['collection'] } })\r\nSet the cache tags of a resource. Data can then be revalidated on-demand using revalidateTag. The max length for a custom tag is\r\n256 characters. Version History\r\nVersionChanges\r\nv13.0.0fetch introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3d8cff57-bf94-4fc8-8c3f-78fdf3520079":{"id_":"3d8cff57-bf94-4fc8-8c3f-78fdf3520079","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6kk2F+QCeUu/dleYN9scwZZPbFdeJw0DNQWd1r05Kac=","metadata":{},"hash":"tigSjeo/4wTgsoqg8PKzuNmkJgRXmx2ULmldvZLUSDE="}},"hash":"yz4fuMAFT0Pan73uB75zsDz80fMnYY9AQ34AYt4nafA=","text":"3.2.3.4 - generateImageMetadata\r\nDocumentation path: /02-app/02-api-reference/04-functions/generate-image-metadata\r\nDescription: Learn how to generate multiple images in a single Metadata API special file. Related:\r\nTitle: Next Steps\r\nRelated Description: View all the Metadata API options. Links:\r\napp/api-reference/file-conventions/metadata\r\napp/building-your-application/optimizing/metadata\r\nYou can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons. Parameters\r\ngenerateImageMetadata function accepts the following parameters:\r\nparamsparams (optional)\r\nAn object containing the dynamic route parameters object from the root segment down to the segment generateImageMetadata is\r\ncalled from. icon.tsx (tsx)export function generateImageMetadata({\r\n  params,\r\n}: {\r\n  params: { slug: string }\r\n}) {\r\n  // ... }\r\nicon.js (jsx)export function generateImageMetadata({ params }) {\r\n  // ... }\r\nRouteURLparamsparams\r\napp/shop/icon.js/shopundefined\r\napp/shop/[slug]/icon.js/shop/1{ slug: '1' }\r\napp/shop/[tag]/[item]/icon.js/shop/1/2{ tag: '1', item: '2' }\r\napp/shop/[...slug]/icon.js/shop/1/2{ slug: ['1', '2'] }\r\nReturns\r\nThe generateImageMetadata function should return an array of objects containing the image’s metadata such as alt and size. In\r\naddition, each item must include an id value which will be passed to the props of the image generating function. Image Metadata ObjectType\r\nidstring (required)\r\naltstring\r\nsize{ width: number; height: number }\r\ncontentTypestring\r\nicon.tsx (tsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9286b824-9fba-4657-b90e-d91f691a5d26":{"id_":"9286b824-9fba-4657-b90e-d91f691a5d26","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lKT9ZZXaBl6ssybyoWhYGLdNeks911rpZsF/k4aqmv8=","metadata":{},"hash":"a7Skgek5f83mjV7P4xcnIHP/xeZveiG/KblWtIhWP1E="}},"hash":"Df468qmNVNhxQdaa4k6nTTupzch5VIK8BbXFkzu/1ko=","text":"import { ImageResponse } from 'next/og'\r\nexport function generateImageMetadata() {\r\n  return [\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 48, height: 48 },\r\n      id: 'small',\r\n    },\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 72, height: 72 },\r\n      id: 'medium',\r\n    },\r\n  ]\r\n}\r\nexport default function Icon({ id }: { id: string }) {\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          fontSize: 88,\r\n          background: '#000',\r\n          color: '#fafafa',\r\n        }}\r\n      >\r\n        Icon {id}\r\n      </div>\r\n    )\r\n  )\r\n}\r\nicon.js (jsx)import { ImageResponse } from 'next/og'\r\nexport function generateImageMetadata() {\r\n  return [\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 48, height: 48 },\r\n      id: 'small',\r\n    },\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 72, height: 72 },\r\n      id: 'medium',\r\n    },\r\n  ]\r\n}\r\nexport default function Icon({ id }) {\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          fontSize: 88,\r\n          background: '#000',\r\n          color: '#fafafa',\r\n        }}\r\n      >\r\n        Icon {id}\r\n      </div>\r\n    )\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"257c09d9-3370-486c-9821-fe3beabceb0a":{"id_":"257c09d9-3370-486c-9821-fe3beabceb0a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LNKlKnXQsYmiUVwlpgWkvpF0pMPywqvlFP+4wH9TM+E=","metadata":{},"hash":"xCYp8wxeCKjElCBG1YQEflmEalWvZDP9QMcPpcEZ5Fg="}},"hash":"b8ZntWk89fUooTIUKZ4CxKrhyg5MdnY/gGQC9owCzFw=","text":"Examples\r\nUsing external data\r\nThis example uses the params object and external data to generate multiple Open Graph images for a route segment. app/products/[id]/opengraph-image.tsx (tsx)import { ImageResponse } from 'next/og'\r\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\r\nexport async function generateImageMetadata({\r\n  params,\r\n}: {\r\n  params: { id: string }\r\n}) {\r\n  const images = await getOGImages(params.id)\r\n  return images.map((image, idx) => ({\r\n    id: idx,\r\n    size: { width: 1200, height: 600 },\r\n    alt: image.text,\r\n    contentType: 'image/png',\r\n  }))\r\n}\r\nexport default async function Image({\r\n  params,\r\n  id,\r\n}: {\r\n  params: { id: string }\r\n  id: number\r\n}) {\r\n  const productId = params.id\r\n  const imageId = id\r\n  const text = await getCaptionForImage(productId, imageId)\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={\r\n          {\r\n            // ... }\r\n        }\r\n      >\r\n        {text}\r\n      </div>\r\n    )\r\n  )\r\n}\r\napp/products/[id]/opengraph-image.js (jsx)import { ImageResponse } from 'next/og'\r\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\r\nexport async function generateImageMetadata({ params }) {\r\n  const images = await getOGImages(params.id)\r\n  return images.map((image, idx) => ({\r\n    id: idx,\r\n    size: { width: 1200, height: 600 },\r\n    alt: image.text,\r\n    contentType: 'image/png',\r\n  }))\r\n}\r\nexport default async function Image({ params, id }) {\r\n  const productId = params.id\r\n  const imageId = id\r\n  const text = await getCaptionForImage(productId, imageId)\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={\r\n          {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1e05859-5b23-4014-a925-533d1a3f52f0":{"id_":"f1e05859-5b23-4014-a925-533d1a3f52f0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KbVpZKUxpu1ty1bE4En173xfKA+c0/4Lq0nAEV+ybmA=","metadata":{},"hash":"DYMx3+ofCO/5zbMcgjH9XwflJRw5owfQ+TS1Hyg6558="}},"hash":"iO38ORIxW1YSpkNlk7jh+8duPIxn36J6VGc7yAN72Vk=","text":"// ... }\r\n        }\r\n      >\r\n        {text}\r\n      </div>\r\n    )\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.3.0generateImageMetadata introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cf241956-7fef-4e7a-9361-d2a34255ad5e":{"id_":"cf241956-7fef-4e7a-9361-d2a34255ad5e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lxp2gcwADq2LD89uKd3+spk/2xrEKM9g9nBKi6tsLUc=","metadata":{},"hash":"BGWwOi72AqCYsyqsb+75yjUkts1BCYwx9UhBy6rRYY4="}},"hash":"8uxVO5yBItDdDmbcA6vR4HolUEHVFZcD4YDEfcCeoxQ=","text":"3.2.3.5 - Metadata Object and generateMetadata Options\r\nDocumentation path: /02-app/02-api-reference/04-functions/generate-metadata\r\nDescription: Learn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web\r\nshareability. Related:\r\nTitle: Next Steps\r\nRelated Description: View all the Metadata API options. Links:\r\napp/api-reference/file-conventions/metadata\r\napp/api-reference/functions/generate-viewport\r\napp/building-your-application/optimizing/metadata\r\nThis page covers all Config-based Metadata options with generateMetadata and the static metadata object. layout.tsx | page.tsx (tsx)import { Metadata } from 'next'\r\n// either Static metadata\r\nexport const metadata: Metadata = {\r\n  title: '...',\r\n}\r\n// or Dynamic metadata\r\nexport async function generateMetadata({ params }) {\r\n  return {\r\n    title: '...',\r\n  }\r\n}\r\nlayout.js | page.js (jsx)// either Static metadata\r\nexport const metadata = {\r\n  title: '...',\r\n}\r\n// or Dynamic metadata\r\nexport async function generateMetadata({ params }) {\r\n  return {\r\n    title: '...',\r\n  }\r\n}\r\nGood to know:\r\nThe metadata object and generateMetadata function exports are only supported in Server Components. You cannot export both the metadata object and generateMetadata function from the same route segment. The metadatametadata object\r\nTo define static metadata, export a Metadata object from a layout.js or page.js file. layout.tsx | page.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: '...',\r\n  description: '...',\r\n}\r\nexport default function Page() {}\r\nlayout.js | page.js (jsx)export const metadata = {\r\n  title: '...',\r\n  description: '...',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"36077915-6adf-4255-9776-cb2444089e91":{"id_":"36077915-6adf-4255-9776-cb2444089e91","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J1IoVQvjmoC8qsp5OSmnQdESRfSZSAZzEGe2RI+DQGo=","metadata":{},"hash":"Apvc+GstmJCQw+D49KxHJRvdDtTt3ReTWq1rN9M1jEE="}},"hash":"FN6/meiYPqv3+nO+0THYpWNhShCYdH6gQhRp/6zSQOQ=","text":"}\r\nexport default function Page() {}\r\nSee the Metadata Fields for a complete list of supported options.generateMetadatagenerateMetadata\r\n function\r\nDynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata in parent\r\nsegments, can be set by exporting a generateMetadata function that returns a Metadata object. app/products/[id]/page.tsx (tsx)import { Metadata, ResolvingMetadata } from 'next'\r\ntype Props = {\r\n  params: { id: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  // read route params\r\n  const id = params.id\r\n  // fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }: Props) {}\r\napp/products/[id]/page.js (jsx)export async function generateMetadata({ params, searchParams }, parent) {\r\n  // read route params\r\n  const id = params.id\r\n  // fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }) {}\r\nParameters\r\ngenerateMetadata function accepts the following parameters:\r\nprops - An object containing the parameters of the current route:\r\nparams - An object containing the dynamic route parameters object from the root segment down to the segment\r\ngenerateMetadata is called from. Examples:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ccaf8a07-3051-4335-8547-95a419d82ce5":{"id_":"ccaf8a07-3051-4335-8547-95a419d82ce5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vekStnstoBAvEAsAfn/Pk5yw9CDFP0kzJuTN0qWCuYk=","metadata":{},"hash":"SR+lNEFQ+9+SVMu6+7i00dsYi2nqnyCWAxoqyv9GBv0="}},"hash":"ELx2e/a9JetOtrqlxkAa1PdO8JjaUI9xXm1gGWJgeCw=","text":"RouteURLparamsparams\r\napp/shop/[slug]/page.js/shop/1{ slug: '1' }\r\napp/shop/[tag]/[item]/page.js/shop/1/2{ tag: '1', item: '2' }\r\napp/shop/[...slug]/page.js/shop/1/2{ slug: ['1', '2'] }\r\nsearchParams - An object containing the current URL’s search params. Examples:\r\nURLsearchParamssearchParams\r\n/shop?a=1{ a: '1' }\r\n/shop?a=1&b=2{ a: '1', b: '2' }\r\n/shop?a=1&a=2{ a: ['1', '2'] }\r\nparent - A promise of the resolved metadata from parent route segments. Returns\r\ngenerateMetadata should return a Metadata object containing one or more metadata fields. Good to know:\r\nIf metadata doesn’t depend on runtime information, it should be defined using the static metadata object rather than\r\ngenerateMetadata. fetch requests are automatically memoized for the same data across generateMetadata, generateStaticParams,\r\nLayouts, Pages, and Server Components. React cache can be used if fetch is unavailable. searchParams are only available in page.js segments. The redirect() and notFound() Next.js methods can also be used inside generateMetadata. Metadata Fields\r\ntitletitle\r\nThe title attribute is used to set the title of the document. It can be defined as a simple string or an optional template object. String\r\nlayout.js | page.js (jsx)export const metadata = {\r\n  title: 'Next.js',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n#### Template object\r\n<div class=\"code-header\"><i>app/layout.tsx (tsx)</i></div>\r\n```tsx\r\nimport { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '...',\r\n    default: '...',\r\n    absolute: '...',\r\n  },\r\n}\r\napp/layout.js (jsx)export const metadata = {\r\n  title: {\r\n    default: '...',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"38a7fda0-dfad-42ff-abd5-ec2ad9ebbbd9":{"id_":"38a7fda0-dfad-42ff-abd5-ec2ad9ebbbd9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kaaxqE+LErdj1WTnr8jQwlURaYbfNSDUfb5q5ICjjsQ=","metadata":{},"hash":"b0NHJEvVdZgjZzSmM8KXZWVixRt8BTL6ZMuchY2YvF8="}},"hash":"I2BrAY/rqt2WKu2yWZ8HYj1EDPlYiWqXXgxyyjAsJVg=","text":"template: '...',\r\n    absolute: '...',\r\n  },\r\n}\r\nDefault\r\ntitle.default can be used to provide a fallback title to child route segments that don’t define a title. app/layout.tsx (tsx)import type { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    default: 'Acme',\r\n  },\r\n}\r\napp/about/page.tsx (tsx)import type { Metadata } from 'next'\r\nexport const metadata: Metadata = {}\r\n// Output: <title>Acme</title>\r\nTemplate\r\ntitle.template can be used to add a prefix or a suffix to titles defined in child route segments. app/layout.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n    default: 'Acme', // a default is required when creating a template\r\n  },\r\n}\r\napp/layout.js (jsx)export const metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n    default: 'Acme', // a default is required when creating a template\r\n  },\r\n}\r\napp/about/page.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'About',\r\n}\r\n// Output: <title>About | Acme</title>\r\napp/about/page.js (jsx)export const metadata = {\r\n  title: 'About',\r\n}\r\n// Output: <title>About | Acme</title>\r\nGood to know:\r\ntitle.template applies to child route segments and not the segment it’s defined in. This means:\r\ntitle.default is required when you add a title.template. title.template defined in layout.js will not apply to a title defined in a page.js of the same route segment. title.template defined in page.js has no effect because a page is always the terminating segment (it doesn’t have any\r\nchildren route segments).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d5410eed-328c-4094-b50a-d236d947ca95":{"id_":"d5410eed-328c-4094-b50a-d236d947ca95","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bOIE9EgOyXVPLcWFFgm9Er8KIyLdaedZqmGnldGXamM=","metadata":{},"hash":"SPGEd2E6XCT0mqtLfFCpFgfZnzaAtc6a/e7/mu95FPs="}},"hash":"fVDM+HYaUxe8X7vHupuN5sWQhoZESzoh+ZKw4yaunYA=","text":"title.template has no effect if a route has not defined a title or title.default. Absolute\r\ntitle.absolute can be used to provide a title that ignores title.template set in parent segments. app/layout.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n  },\r\n}\r\napp/layout.js (jsx)export const metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n  },\r\n}\r\napp/about/page.tsx (tsx)import { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    absolute: 'About',\r\n  },\r\n}\r\n// Output: <title>About</title>\r\napp/about/page.js (jsx)export const metadata = {\r\n  title: {\r\n    absolute: 'About',\r\n  },\r\n}\r\n// Output: <title>About</title>\r\nGood to know:\r\nlayout.js\r\ntitle (string) and title.default define the default title for child segments (that do not define their own title). It will\r\naugment title.template from the closest parent segment if it exists. title.absolute defines the default title for child segments. It ignores title.template from parent segments. title.template defines a new title template for child segments. page.js\r\nIf a page does not define its own title the closest parents resolved title will be used.title\r\n (string) defines the routes title. It will augment title.template from the closest parent segment if it exists. title.absolute defines the route title. It ignores title.template from parent segments. title.template has no effect in page.js because a page is always the terminating segment of a route. descriptiondescription\r\nlayout.js | page.js (jsx)export const metadata = {\r\n  description: 'The React Framework for the Web',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### Basic Fields\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"494c836d-d827-4151-8767-19b5dca7b33f":{"id_":"494c836d-d827-4151-8767-19b5dca7b33f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NBxrNEcR62vGPlclD8uaMova4rwNHUP/GTfcM2ceBKU=","metadata":{},"hash":"30bUEbv6GMP9jMCSYo2Gf9jqYQXZrDk3OO7BlxiKkpk="},"NEXT":{"nodeId":"7e0726c3-115c-40ed-a273-5b2932d73b55","metadata":{},"hash":"PQkaIXUk+o8vPUOnWbAy8MkFGMd0ELoXCb8wZn/qD94="}},"hash":"4wJxbyDiqBM9JaM8poA2ctKM9d0cHiiwdDmQr42blK0=","text":"export const metadata = {\r\n  generator: 'Next.js',\r\n  applicationName: 'Next.js',\r\n  referrer: 'origin-when-cross-origin',\r\n  keywords: ['Next.js', 'React', 'JavaScript'],\r\n  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\r\n  creator: 'Jiachi Liu',\r\n  publisher: 'Sebastian Markbåge',\r\n  formatDetection: {\r\n    email: false,\r\n    address: false,\r\n    telephone: false,\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `metadataBase`\r\n`metadataBase` is a convenience option to set a base URL prefix for `metadata` fields that require a fully\r\n- `metadataBase` allows URL-based `metadata` fields defined in the **current route segment and below** to \r\n- The field's relative path will be composed with `metadataBase` to form a fully qualified URL. - If not configured, `metadataBase` is **automatically populated** with a [default value](#default-value). <div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n  alternates: {\r\n    canonical: '/',\r\n    languages: {\r\n      'en-US': '/en-US',\r\n      'de-DE': '/de-DE',\r\n    },\r\n  },\r\n  openGraph: {\r\n    images: '/og-image.png',\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n> **Good to know**:\r\n>\r\n> - `metadataBase` is typically set in root `app/layout.js` to apply to URL-based `metadata` fields across\r\n> - All URL-based `metadata` fields that require absolute URLs can be configured with a `metadataBase` option\r\n> - `metadataBase` can contain a subdomain e.g. `https://app.acme.com` or base path e.g. `https://acme.com/start/from/here`\r\n> - If a `metadata` field provides an absolute URL, `metadataBase` will be ignored. > - Using a relative path in a URL-based `metadata` field without configuring a `metadataBase` will cause \r\n> - Next.js will normalize duplicate slashes between `metadataBase` (e.g.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7e0726c3-115c-40ed-a273-5b2932d73b55":{"id_":"7e0726c3-115c-40ed-a273-5b2932d73b55","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NBxrNEcR62vGPlclD8uaMova4rwNHUP/GTfcM2ceBKU=","metadata":{},"hash":"30bUEbv6GMP9jMCSYo2Gf9jqYQXZrDk3OO7BlxiKkpk="},"PREVIOUS":{"nodeId":"494c836d-d827-4151-8767-19b5dca7b33f","metadata":{},"hash":"4wJxbyDiqBM9JaM8poA2ctKM9d0cHiiwdDmQr42blK0="}},"hash":"PQkaIXUk+o8vPUOnWbAy8MkFGMd0ELoXCb8wZn/qD94=","text":"`https://acme.com/`) and a relative\r\n#### Default value\r\nIf not configured, `metadataBase` has a **default value**\r\n- When [`VERCEL_URL`](https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables\r\n- When overriding the default, we recommend using environment variables to compute the URL. This allows configuring\r\n#### URL Composition\r\nURL composition favors developer intent over default directory traversal semantics. - Trailing slashes between `metadataBase` and `metadata` fields are normalized. - An \"absolute\" path in a `metadata` field (that typically would replace the whole URL path) is treated as\r\nFor example, given the following `metadataBase`:\r\n<div class=\"code-header\"><i>app/layout.tsx (tsx)</i></div>\r\n```tsx\r\nimport { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6fa7fb77-6aac-40ef-8652-c39322401438":{"id_":"6fa7fb77-6aac-40ef-8652-c39322401438","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SikV7GDZR6EbeTRzYFAivIxZ9ykoFm3Pfd+PcmAhSMk=","metadata":{},"hash":"BysDlgvP2MjoPFbmhbB1rz2S32SB6LKPHR/Rhf+dtCI="}},"hash":"Ipf00Bp/6BTrMNCJcSx9UJ7tUladkfdKfZmZBfPcIvQ=","text":"app/layout.js (jsx)export const metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n}\r\nAny metadata fields that inherit the above metadataBase and set their own value will be resolved as follows:\r\nmetadatametadata fieldResolved URL\r\n/https://acme.com\r\n./https://acme.com\r\npaymentshttps://acme.com/payments\r\n/paymentshttps://acme.com/payments\r\n./paymentshttps://acme.com/payments\r\n../paymentshttps://acme.com/payments\r\nhttps://beta.acme.com/paymentshttps://beta.acme.com/payments\r\nopenGraphopenGraph\r\nlayout.js | page.js (jsx)export const metadata = {\r\n  openGraph: {\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    url: 'https://nextjs.org',\r\n    siteName: 'Next.js',\r\n    images: [\r\n      {\r\n        url: 'https://nextjs.org/og.png',\r\n        width: 800,\r\n        height: 600,\r\n      },\r\n      {\r\n        url: 'https://nextjs.org/og-alt.png',\r\n        width: 1800,\r\n        height: 1600,\r\n        alt: 'My custom alt',\r\n      },\r\n    ],\r\n    locale: 'en_US',\r\n    type: 'website',\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  openGraph: {\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    type: 'article',\r\n    publishedTime: '2023-01-01T00:00:00.000Z',\r\n    authors: ['Seb', 'Josh'],\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n> **Good to know**:\r\n>\r\n> - It may be more convenient to use the [file-based Metadata API](/docs/app/api-reference/file-conventions\r\n### `robots`\r\n```tsx","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d931b89d-d8d8-4be2-9b50-0066e8815455":{"id_":"d931b89d-d8d8-4be2-9b50-0066e8815455","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LMf3vCNnfmkd+jk+5iqRlPPEn520zCLLGqm4LzmR/Ro=","metadata":{},"hash":"ndJ2kc2atsnRegjUTFAciWXqUtw8Ti2O8tgkpCFmWS0="}},"hash":"vlr8KKqaGDSn9HfmTONaDi6wNxmEg2314kTSEXcY6TA=","text":"import type { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  robots: {\r\n    index: false,\r\n    follow: true,\r\n    nocache: true,\r\n    googleBot: {\r\n      index: true,\r\n      follow: false,\r\n      noimageindex: true,\r\n      'max-video-preview': -1,\r\n      'max-image-preview': 'large',\r\n      'max-snippet': -1,\r\n    },\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `icons`\r\n> **Good to know**: We recommend using the [file-based Metadata API](/docs/app/api-reference/file-conventions\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  icons: {\r\n    icon: '/icon.png',\r\n    shortcut: '/shortcut-icon.png',\r\n    apple: '/apple-icon.png',\r\n    other: {\r\n      rel: 'apple-touch-icon-precomposed',\r\n      url: '/apple-touch-icon-precomposed.png',\r\n    },\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  icons: {\r\n    icon: [\r\n      { url: '/icon.png' },\r\n      new URL('/icon.png', 'https://example.com'),\r\n      { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' },\r\n    ],\r\n    shortcut: ['/shortcut-icon.png'],\r\n    apple: [\r\n      { url: '/apple-icon.png' },\r\n      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },\r\n    ],\r\n    other: [\r\n      {\r\n        rel: 'apple-touch-icon-precomposed',\r\n        url: '/apple-touch-icon-precomposed.png',\r\n      },\r\n    ],\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n> **Good to know**: The `msapplication-*` meta tags are no longer supported in Chromium builds of Microsoft\r\n### `themeColor`\r\n> **Deprecated**: The `themeColor` option in `metadata` is deprecated as of Next.js 14. Please use the [`viewport`\r\n### `manifest`\r\nA web application manifest, as defined in the [Web Application Manifest specification](https://developer.mozilla\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5fcc12a0-44ea-4f16-ab66-8454ec869004":{"id_":"5fcc12a0-44ea-4f16-ab66-8454ec869004","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PDK5V/Ail8McdlfPoXkkCIKMkXYIkw4qfqXPPXq1PHQ=","metadata":{},"hash":"bM4oOHws5Pz0apMQj0ic7USpfXchzdN3L47mikOmnOI="}},"hash":"3MYiVeHbBhTBLMqVVvfNR7lweFJ++V8YeumXxM57JyY=","text":"```jsx\r\nexport const metadata = {\r\n  manifest: 'https://nextjs.org/manifest.json',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `twitter`\r\nLearn more about the [Twitter Card markup reference](https://developer.twitter.com/en/docs/twitter-for-websites\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  twitter: {\r\n    card: 'summary_large_image',\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    siteId: '1467726470533754880',\r\n    creator: '@nextjs',\r\n    creatorId: '1467726470533754880',\r\n    images: ['https://nextjs.org/og.png'],\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  twitter: {\r\n    card: 'app',\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    siteId: '1467726470533754880',\r\n    creator: '@nextjs',\r\n    creatorId: '1467726470533754880',\r\n    images: {\r\n      url: 'https://nextjs.org/og.png',\r\n      alt: 'Next.js Logo',\r\n    },\r\n    app: {\r\n      name: 'twitter_app',\r\n      id: {\r\n        iphone: 'twitter_app://iphone',\r\n        ipad: 'twitter_app://ipad',\r\n        googleplay: 'twitter_app://googleplay',\r\n      },\r\n      url: {\r\n        iphone: 'https://iphone_url',\r\n        ipad: 'https://ipad_url',\r\n      },\r\n    },\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `viewport`\r\n> **Deprecated**: The `viewport` option in `metadata` is deprecated as of Next.js 14. Please use the [`viewport`\r\n### `verification`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  verification: {\r\n    google: 'google',\r\n    yandex: 'yandex',\r\n    yahoo: 'yahoo',\r\n    other: {\r\n      me: ['my-email', 'my-link'],\r\n    },\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bf4a6036-f18e-4ca8-bb3f-b124a5239160":{"id_":"bf4a6036-f18e-4ca8-bb3f-b124a5239160","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9jAGqa4mpYdFIHZ8YpBfQIiDHsnZgNXx9mFg0RXq4kw=","metadata":{},"hash":"svpjtK1ZhWzxO3UEQw41+DhYKh076Bsu62aPkBjncx8="},"NEXT":{"nodeId":"13cd3b22-d0a1-41d8-80db-401faf28dcde","metadata":{},"hash":"Lttlug32GEulbxWzH1tplBT8Q1BlPEHOhsOmH7Vje60="}},"hash":"uB7uIf4RXCO4ZH1qoNPBX1AWcwmJIv+F325SQq00Zqk=","text":"```html filename=” output” hideLineNumbers\r\n### `appleWebApp`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  itunes: {\r\n    appId: 'myAppStoreID',\r\n    appArgument: 'myAppArgument',\r\n  },\r\n  appleWebApp: {\r\n    title: 'Apple Web App',\r\n    statusBarStyle: 'black-translucent',\r\n    startupImage: [\r\n      '/assets/startup/apple-touch-startup-image-768x1004.png',\r\n      {\r\n        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',\r\n        media: '(device-width: 768px) and (device-height: 1024px)',\r\n      },\r\n    ],\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `alternates`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  alternates: {\r\n    canonical: 'https://nextjs.org',\r\n    languages: {\r\n      'en-US': 'https://nextjs.org/en-US',\r\n      'de-DE': 'https://nextjs.org/de-DE',\r\n    },\r\n    media: {\r\n      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\r\n    },\r\n    types: {\r\n      'application/rss+xml': 'https://nextjs.org/rss',\r\n    },\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `appLinks`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  appLinks: {\r\n    ios: {\r\n      url: 'https://nextjs.org/ios',\r\n      app_store_id: 'app_store_id',\r\n    },\r\n    android: {\r\n      package: 'com.example.android/package',\r\n      app_name: 'app_name_android',\r\n    },\r\n    web: {\r\n      url: 'https://nextjs.org/web',\r\n      should_fallback: true,\r\n    },\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `archives`\r\nDescribes a collection of records, documents, or other materials of historical interest ([source](https://www.w3.org/TR/2011/WD-html5-20110113/links.html#rel-archives)).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"13cd3b22-d0a1-41d8-80db-401faf28dcde":{"id_":"13cd3b22-d0a1-41d8-80db-401faf28dcde","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9jAGqa4mpYdFIHZ8YpBfQIiDHsnZgNXx9mFg0RXq4kw=","metadata":{},"hash":"svpjtK1ZhWzxO3UEQw41+DhYKh076Bsu62aPkBjncx8="},"PREVIOUS":{"nodeId":"bf4a6036-f18e-4ca8-bb3f-b124a5239160","metadata":{},"hash":"uB7uIf4RXCO4ZH1qoNPBX1AWcwmJIv+F325SQq00Zqk="}},"hash":"Lttlug32GEulbxWzH1tplBT8Q1BlPEHOhsOmH7Vje60=","text":"<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a5bdd795-9e65-4fe6-a3c9-16f6d8bff0eb":{"id_":"a5bdd795-9e65-4fe6-a3c9-16f6d8bff0eb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gkiQc4js9a76JWqiV1kWuLeN281gbBg1F4ISl6BBguE=","metadata":{},"hash":"LnwO9evau2Z+VKcQ32iFHJxjGDQvRZZwTa6WOBFIgpg="},"NEXT":{"nodeId":"595ee0df-753e-4816-a320-80fb0951513e","metadata":{},"hash":"A4eZ8g7tDWeHxN0Xcv3fk/eEpTB2Fii97HuHCZKVOgo="}},"hash":"8jithkK4CTky2ED0I/+bf06rbFjf6WH+HkJlcQCnsk8=","text":"```jsx\r\nexport const metadata = {\r\n  archives: ['https://nextjs.org/13'],\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `assets`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  assets: ['https://nextjs.org/assets'],\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `bookmarks`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  bookmarks: ['https://nextjs.org/13'],\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `category`\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  category: 'technology',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `other`\r\nAll metadata options should be covered using the built-in support. However, there may be custom metadata tags\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  other: {\r\n    custom: 'meta',\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\nIf you want to generate multiple same key meta tags you can use array value. <div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const metadata = {\r\n  other: {\r\n    custom: ['meta1', 'meta2'],\r\n  },\r\n}\r\n```html filename=” output” hideLineNumbers\r\n## Unsupported Metadata\r\nThe following metadata types do not currently have built-in support. However, they can still be rendered in\r\n| Metadata                      | Recommendation                                                                                                                                                                                                                                     \r\n| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n| `<meta http-equiv=\"...\">`     | Use appropriate HTTP Headers via [`redirect()`](/docs/app/api-reference/\r\n| `<base>`                      | Render the tag in the layout or page itself. | `<noscript>`                  | Render the tag in the layout or page itself.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"595ee0df-753e-4816-a320-80fb0951513e":{"id_":"595ee0df-753e-4816-a320-80fb0951513e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gkiQc4js9a76JWqiV1kWuLeN281gbBg1F4ISl6BBguE=","metadata":{},"hash":"LnwO9evau2Z+VKcQ32iFHJxjGDQvRZZwTa6WOBFIgpg="},"PREVIOUS":{"nodeId":"a5bdd795-9e65-4fe6-a3c9-16f6d8bff0eb","metadata":{},"hash":"8jithkK4CTky2ED0I/+bf06rbFjf6WH+HkJlcQCnsk8="}},"hash":"A4eZ8g7tDWeHxN0Xcv3fk/eEpTB2Fii97HuHCZKVOgo=","text":"| `<noscript>`                  | Render the tag in the layout or page itself. | `<style>`                     | Learn more about [styling in Next.js](/docs/app/building-your-application\r\n| `<script>`                    | Learn more about [using scripts](/docs/app/building-your-application/optimizing\r\n| `<link rel=\"stylesheet\" />`   | `import` stylesheets directly in the layout or page itself.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a62d90ad-8504-40b9-8618-4db58cedd869":{"id_":"a62d90ad-8504-40b9-8618-4db58cedd869","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BYfeEPNGbFzqpfbZK50kyR2V/wGavNrDp4oJJqTZI7A=","metadata":{},"hash":"ROYj04Fwj/UZQE0mL63G6bjVBQpuqjHXn8FNkcAhlBA="},"NEXT":{"nodeId":"3589b343-a662-4283-a4f5-210d514eaaa0","metadata":{},"hash":"2X9daMfVpIR0jAISA2ylkBbkeRIWxTJlRGk+RAc9uEs="}},"hash":"RcByfY6msCV4COMhYSmoYiSTItB2Qr9bbuo0ZH9nz6M=","text":"| `<link rel=\"preload />`       | Use [ReactDOM preload method](#link-relpreload)                                                                                                                                                                                                    |\r\n| `<link rel=\"preconnect\" />`   | Use [ReactDOM preconnect method](#link-relpreconnect)                                                                                                                                                                                              \r\n| `<link rel=\"dns-prefetch\" />` | Use [ReactDOM prefetchDNS method](#link-reldns-prefetch)                                                                                                                                                                                           \r\n### Resource hints\r\nThe `<link>` element has a number of `rel` keywords that can be used to hint to the browser that an external\r\nWhile the Metadata API doesn't directly support these hints, you can use new [`ReactDOM` methods](https://github.com/facebook/react/pull/26237) to safely insert them into the `<head>` of the document. <div class=\"code-header\"><i>app/preload-resources.tsx (tsx)</i></div>\r\n```tsx\r\n'use client'\r\nimport ReactDOM from 'react-dom'\r\nexport function PreloadResources() {\r\n  ReactDOM.preload('...', { as: '... ' })\r\n  ReactDOM.preconnect('...', { crossOrigin: '... ' })\r\n  ReactDOM.prefetchDNS('... ')\r\n  return null\r\n}\r\napp/preload-resources.js (jsx)'use client'\r\nimport ReactDOM from 'react-dom'\r\nexport function PreloadResources() {\r\n  ReactDOM.preload('...', { as: '... ' })\r\n  ReactDOM.preconnect('...', { crossOrigin: '... ' })\r\n  ReactDOM.prefetchDNS('... ')\r\n  return null\r\n}\r\n<link rel=\"preload\"><link rel=\"preload\">\r\nStart loading a resource early in the page rendering (browser) lifecycle. MDN Docs. ReactDOM.preload(href: string, options: { as: string })\r\n```html filename=” output” hideLineNumbers\r\n##### `<link rel=\"preconnect\">`\r\nPreemptively initiate a connection to an origin. [MDN Docs](https://developer.mozilla.org/docs/Web/HTML/Attributes/rel/preconnect). ```tsx\r\nReactDOM.preconnect(href: string, options?: { crossOrigin?: string })\r\n```html filename=” output” hideLineNumbers\r\n##### `<link rel=\"dns-prefetch\">`\r\nAttempt to resolve a domain name before resources get requested. [MDN Docs](https://developer.mozilla.org/docs/Web/HTML/Attributes/rel/dns-prefetch).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3589b343-a662-4283-a4f5-210d514eaaa0":{"id_":"3589b343-a662-4283-a4f5-210d514eaaa0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BYfeEPNGbFzqpfbZK50kyR2V/wGavNrDp4oJJqTZI7A=","metadata":{},"hash":"ROYj04Fwj/UZQE0mL63G6bjVBQpuqjHXn8FNkcAhlBA="},"PREVIOUS":{"nodeId":"a62d90ad-8504-40b9-8618-4db58cedd869","metadata":{},"hash":"RcByfY6msCV4COMhYSmoYiSTItB2Qr9bbuo0ZH9nz6M="}},"hash":"2X9daMfVpIR0jAISA2ylkBbkeRIWxTJlRGk+RAc9uEs=","text":"```tsx\r\nReactDOM.prefetchDNS(href: string)\r\n```html filename=” output” hideLineNumbers\r\n> **Good to know**:\r\n>\r\n> - These methods are currently only supported in Client Components, which are still Server Side Rendered \r\n> - Next.js in-built features such as `next/font`, `next/image` and `next/script` automatically handle relevant\r\n> - React 18.3 does not yet include type definitions for `ReactDOM.preload`, `ReactDOM.preconnect`, and `ReactDOM\r\n## Types\r\nYou can add type safety to your metadata by using the `Metadata` type. If you are using the [built-in TypeScript\r\n### `metadata` object","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6bfd5faa-8179-411d-835f-0a45eaeb54b2":{"id_":"6bfd5faa-8179-411d-835f-0a45eaeb54b2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ahyDZ0xuVVKPmyM6MrDM8F1Gjq2Tmbj+EozOS0eH+u8=","metadata":{},"hash":"pYtFpRCG1jBYYdgjgRdWYlb4qqJT42YeTNzRkXS9haQ="}},"hash":"AtSFzX5iPEi/HDKqWkuqZBqv+quQqTnebYf6AstLugE=","text":"```tsx\r\nimport type { Metadata } from 'next'\r\nexport const metadata: Metadata = {\r\n  title: 'Next.js',\r\n}\r\ngenerateMetadatagenerateMetadata function\r\nRegular function\r\nimport type { Metadata } from 'next'\r\nexport function generateMetadata(): Metadata {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}\r\nAsync function\r\nimport type { Metadata } from 'next'\r\nexport async function generateMetadata(): Promise<Metadata> {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}\r\nWith segment props\r\nimport type { Metadata } from 'next'\r\ntype Props = {\r\n  params: { id: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}\r\nexport function generateMetadata({ params, searchParams }: Props): Metadata {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }: Props) {}\r\nWith parent metadata\r\nimport type { Metadata, ResolvingMetadata } from 'next'\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}\r\nJavaScript Projects\r\nFor JavaScript projects, you can use JSDoc to add type safety. /** @type {import(\"next\").Metadata} */\r\nexport const metadata = {\r\n  title: 'Next.js',\r\n}\r\nVersion History","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2c053243-cde5-451f-9dff-c2b53e187c4f":{"id_":"2c053243-cde5-451f-9dff-c2b53e187c4f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"198VSQ+SXgs8ryXEoBJyFdrAbqf8Dq0arDJT9qaUacg=","metadata":{},"hash":"K8YSaakup0MRkTGokiSG1N3GPZrhdIXk2IIH1S8uMm0="}},"hash":"SwG+hCGbqMx06qQCW/d9Stc8+H4MjmvvG1jnOSc9/Ms=","text":"VersionChanges\r\nv13.2.0viewport, themeColor, and colorScheme deprecated in favor of the viewport configuration. v13.2.0metadata and generateMetadata introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5555e382-d873-44c0-85af-2e69cd64bd5f":{"id_":"5555e382-d873-44c0-85af-2e69cd64bd5f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i/rxhSLREzny3jISMe+E8sFDql6IkjFmKlrMBSjhHoI=","metadata":{},"hash":"1TIdxVfD/fE1DE/VUcbK4oIabWCrytfK7srRBqcfOlk="},"NEXT":{"nodeId":"64f0d6e1-5275-4d43-84e2-93d896ecfd2f","metadata":{},"hash":"mzhplqFhi3K7e5CrXrAn4MzRl6QGlCcIITLwiZnHXxM="}},"hash":"uxgbvwjXOjhzELvxRjc0SL3NKx/Hc25d8VNE0FXXG6Q=","text":"3.2.3.6 - generateSitemaps\r\nDocumentation path: /02-app/02-api-reference/04-functions/generate-sitemaps\r\nDescription: Learn how to use the generateSiteMaps function to create multiple sitemaps for your application. Related:\r\nTitle: Next Steps\r\nRelated Description: Learn how to create sitemaps for your Next.js application. Links:\r\napp/api-reference/file-conventions/metadata/sitemap\r\nYou can use the generateSiteMaps function to generate multiple sitemaps for your application. Returns\r\nThe generateSitemaps returns an array of objects with an id property. URLs\r\nIn production, your generated sitemaps will be available at /.../sitemap/[id].xml. For example, /product/sitemap/1.xml. In development, you can view the generated sitemap on /.../sitemap.xml/[id]. For example, /product/sitemap.xml/1. This\r\ndifference is temporary and will follow the production format. Example\r\nFor example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate\r\nthe unique sitemaps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"64f0d6e1-5275-4d43-84e2-93d896ecfd2f":{"id_":"64f0d6e1-5275-4d43-84e2-93d896ecfd2f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i/rxhSLREzny3jISMe+E8sFDql6IkjFmKlrMBSjhHoI=","metadata":{},"hash":"1TIdxVfD/fE1DE/VUcbK4oIabWCrytfK7srRBqcfOlk="},"PREVIOUS":{"nodeId":"5555e382-d873-44c0-85af-2e69cd64bd5f","metadata":{},"hash":"uxgbvwjXOjhzELvxRjc0SL3NKx/Hc25d8VNE0FXXG6Q="}},"hash":"mzhplqFhi3K7e5CrXrAn4MzRl6QGlCcIITLwiZnHXxM=","text":"Then, use the id to generate\r\nthe unique sitemaps. app/product/sitemap.ts (ts)import { BASE_URL } from '@/app/lib/constants'\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\nexport default async function sitemap({\r\n  id,\r\n}: {\r\n  id: number\r\n}): MetadataRoute.Sitemap {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${product.id}`\r\n    lastModified: product.date,\r\n  }))\r\n}\r\napp/product/sitemap.js (js)import { BASE_URL } from '@/app/lib/constants'\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\nexport default async function sitemap({ id }) {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d9de7724-631e-4426-a440-e17168082740":{"id_":"d9de7724-631e-4426-a440-e17168082740","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"N421bc1xikF428AqFX6BRw15N2wbyGoVW0qTPkVKD3M=","metadata":{},"hash":"NmLOmya4kbnGeOaB6LzLAFvkprkji75d+rKQ9RCXvxs="}},"hash":"gcJJiFPWaXwbfxm38CrmgZb9+yQbjzAadR1qbJeh3sU=","text":"`SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${id}`\r\n    lastModified: product.date,\r\n  }))\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cffb3dc0-2246-430d-a138-cff9fd05cb6d":{"id_":"cffb3dc0-2246-430d-a138-cff9fd05cb6d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"FoynIUkPQI/B31SpLugw73rDTG7sJnXU2mdCVsGaZEA=","metadata":{},"hash":"ImJ7u2NcQydU/J3yZsb397CtwJ/6fxB3Ztvd2Zw2VI4="},"NEXT":{"nodeId":"4f60cd47-93e6-4d8b-b1dd-a81c00bd8de5","metadata":{},"hash":"uJF35MkjhQ2KJSLWXdBAJ17EYYkf/VPHcMF8QZNLLss="}},"hash":"3NTsh+Raa9AuEr4rj92UrS4kSurl6hGl8Mo0fcgwiDc=","text":"3.2.3.7 - generateStaticParams\r\nDocumentation path: /02-app/02-api-reference/04-functions/generate-static-params\r\nDescription: API reference for the generateStaticParams function. The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build\r\ntime instead of on-demand at request time. app/blog/[slug]/page.js (jsx)// Return a list of `params` to populate the [slug] dynamic segment\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\n// Multiple versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\nexport default function Page({ params }) {\r\n  const { slug } = params\r\n  // ... }\r\nGood to know\r\nYou can use the dynamicParams segment config option to control what happens when a dynamic segment is visited that\r\nwas not generated with generateStaticParams. During next dev, generateStaticParams will be called when you navigate to a route. During next build, generateStaticParams runs before the corresponding Layouts or Pages are generated. During revalidation (ISR), generateStaticParams will not be called again. generateStaticParams replaces the getStaticPaths function in the Pages Router. Parameters\r\noptions.params (optional)\r\nIf multiple dynamic segments in a route use generateStaticParams, the child generateStaticParams function is executed once for\r\neach set of params the parent generates. The params object contains the populated params from the parent generateStaticParams, which can be used to generate the\r\nparams in a child segment. Returns\r\ngenerateStaticParams should return an array of objects where each object represents the populated dynamic segments of a single\r\nroute. Each property in the object is a dynamic segment to be filled in for the route. The properties name is the segment’s name, and the properties value is what that segment should be filled in with.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4f60cd47-93e6-4d8b-b1dd-a81c00bd8de5":{"id_":"4f60cd47-93e6-4d8b-b1dd-a81c00bd8de5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"FoynIUkPQI/B31SpLugw73rDTG7sJnXU2mdCVsGaZEA=","metadata":{},"hash":"ImJ7u2NcQydU/J3yZsb397CtwJ/6fxB3Ztvd2Zw2VI4="},"PREVIOUS":{"nodeId":"cffb3dc0-2246-430d-a138-cff9fd05cb6d","metadata":{},"hash":"3NTsh+Raa9AuEr4rj92UrS4kSurl6hGl8Mo0fcgwiDc="}},"hash":"uJF35MkjhQ2KJSLWXdBAJ17EYYkf/VPHcMF8QZNLLss=","text":"Example RoutegenerateStaticParamsgenerateStaticParams Return Type\r\n/product/[id]{ id: string }[]\r\n/products/[category]/[product]{ category: string, product: string }[]\r\n/products/[...slug]{ slug: string[] }[]\r\nSingle Dynamic Segment\r\napp/product/[id]/page.tsx (tsx)export function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dce8c347-47d0-43ae-a8f2-85cff50a8fa2":{"id_":"dce8c347-47d0-43ae-a8f2-85cff50a8fa2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"e+qJIqzzzx7+GrPQFYBpMUkWx/XbiO8nKigSkl6Kmfs=","metadata":{},"hash":"54cRXvUjptaAxdAY/0hnuwxKKSUPK7+TX7koMu/exT0="}},"hash":"28YN+kCSD40lyZT8eGlYuhatjsz0oBOmCdOg1couzsM=","text":"// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/1\r\n// - /product/2\r\n// - /product/3\r\nexport default function Page({ params }: { params: { id: string } }) {\r\n  const { id } = params\r\n  // ... }\r\napp/product/[id]/page.js (jsx)export function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\r\n}\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/1\r\n// - /product/2\r\n// - /product/3\r\nexport default function Page({ params }) {\r\n  const { id } = params\r\n  // ... }\r\nMultiple Dynamic Segments\r\napp/products/[category]/[product]/page.tsx (tsx)export function generateStaticParams() {\r\n  return [\r\n    { category: 'a', product: '1' },\r\n    { category: 'b', product: '2' },\r\n    { category: 'c', product: '3' },\r\n  ]\r\n}\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /products/a/1\r\n// - /products/b/2\r\n// - /products/c/3\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: { category: string; product: string }\r\n}) {\r\n  const { category, product } = params\r\n  // ... }\r\napp/products/[category]/[product]/page.js (jsx)export function generateStaticParams() {\r\n  return [\r\n    { category: 'a', product: '1' },\r\n    { category: 'b', product: '2' },\r\n    { category: 'c', product: '3' },\r\n  ]\r\n}\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /products/a/1\r\n// - /products/b/2\r\n// - /products/c/3\r\nexport default function Page({ params }) {\r\n  const { category, product } = params\r\n  // ... }\r\nCatch-all Dynamic Segment","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6bd38b3f-34a2-4e71-8fd2-85e9363a8fc0":{"id_":"6bd38b3f-34a2-4e71-8fd2-85e9363a8fc0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c7WPUpevw8q50zrLN9PaUYLZ0GYRz1AEnRThP6J31V8=","metadata":{},"hash":"p2BPH1wLqHjMPPrQgbZoTDtBpBAge9XOKsoWEJbG0WA="},"NEXT":{"nodeId":"ab6ee2c6-424f-421e-acce-62180c725d6c","metadata":{},"hash":"NKUsb55vpQe1BNZYCKU/4EoN+9QWnaMnbc7M//UUPFE="}},"hash":"vNoBJ5vgh5x3wc6qXSlr77LVmN+BJIyE8ocu+ppXozE=","text":"app/product/[...slug]/page.tsx (tsx)export function generateStaticParams() {\r\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\r\n}\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/a/1\r\n// - /product/b/2\r\n// - /product/c/3\r\nexport default function Page({ params }: { params: { slug: string[] } }) {\r\n  const { slug } = params\r\n  // ... }\r\napp/product/[...slug]/page.js (jsx)export function generateStaticParams() {\r\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\r\n}\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/a/1\r\n// - /product/b/2\r\n// - /product/c/3\r\nexport default function Page({ params }) {\r\n  const { slug } = params\r\n  // ... }\r\nExamples\r\nMultiple Dynamic Segments in a Route\r\nYou can generate params for dynamic segments above the current layout or page, but not below. For example, given theapp/products/[category]/[product]\r\n route:\r\napp/products/[category]/[product]/page.js can generate params for both [category] and [product]. app/products/[category]/layout.js can only generate params for [category]. There are two approaches to generating params for a route with multiple dynamic segments:\r\nGenerate params from the bottom up\r\nGenerate multiple dynamic segments from the child route segment. app/products/[category]/[product]/page.tsx (tsx)// Generate segments for both [category] and [product]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n    product: product.id,\r\n  }))\r\n}\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: { category: string; product: string }\r\n}) {\r\n  // ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ab6ee2c6-424f-421e-acce-62180c725d6c":{"id_":"ab6ee2c6-424f-421e-acce-62180c725d6c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c7WPUpevw8q50zrLN9PaUYLZ0GYRz1AEnRThP6J31V8=","metadata":{},"hash":"p2BPH1wLqHjMPPrQgbZoTDtBpBAge9XOKsoWEJbG0WA="},"PREVIOUS":{"nodeId":"6bd38b3f-34a2-4e71-8fd2-85e9363a8fc0","metadata":{},"hash":"vNoBJ5vgh5x3wc6qXSlr77LVmN+BJIyE8ocu+ppXozE="}},"hash":"NKUsb55vpQe1BNZYCKU/4EoN+9QWnaMnbc7M//UUPFE=","text":"}\r\napp/products/[category]/[product]/page.js (jsx)// Generate segments for both [category] and [product]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n  return products.map((product) => ({\r\n    category: product.category.slug,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7eaa3119-b27d-45d3-acc6-7cf769f17e2f":{"id_":"7eaa3119-b27d-45d3-acc6-7cf769f17e2f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3q4rq33EaLFudQyP2IUb5JDYG6HRgIbKSmPSCLnDigo=","metadata":{},"hash":"0Gr5oniyVRGlQ+1FVG0AhqH9tqeOuhiaoEQ02gIv0II="}},"hash":"98vUduMV2wnAWPLN+aCFlXxkzmIFvHgs2az7qoyOlaA=","text":"product: product.id,\r\n  }))\r\n}\r\nexport default function Page({ params }) {\r\n  // ... }\r\nGenerate params from the top down\r\nGenerate the parent segments first and use the result to generate the child segments. app/products/[category]/layout.tsx (tsx)// Generate segments for [category]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n  }))\r\n}\r\nexport default function Layout({ params }: { params: { category: string } }) {\r\n  // ... }\r\napp/products/[category]/layout.js (jsx)// Generate segments for [category]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n  }))\r\n}\r\nexport default function Layout({ params }) {\r\n  // ... }\r\nA child route segment’s generateStaticParams function is executed once for each segment a parent generateStaticParams\r\ngenerates. The child generateStaticParams function can use the params returned from the parent generateStaticParams function to\r\ndynamically generate its own segments. app/products/[category]/[product]/page.tsx (tsx)// Generate segments for [product] using the `params` passed from\r\n// the parent segment's `generateStaticParams` function\r\nexport async function generateStaticParams({\r\n  params: { category },\r\n}: {\r\n  params: { category: string }\r\n}) {\r\n  const products = await fetch(\r\n    `https://.../products?category=${category}`\r\n  ).then((res) => res.json())\r\n  return products.map((product) => ({\r\n    product: product.id,\r\n  }))\r\n}\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: { category: string; product: string }\r\n}) {\r\n  // ... }\r\napp/products/[category]/[product]/page.js (jsx)// Generate segments for [product] using the `params` passed from\r\n// the parent segment's `generateStaticParams` function","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c10e498f-650b-4339-85a6-b9eb8eb38fe1":{"id_":"c10e498f-650b-4339-85a6-b9eb8eb38fe1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"TKSOEa9CmI0/2XUp4pNOHQreRsBEV2LWINrO7fHXUsQ=","metadata":{},"hash":"MyE7gsYA2fh4zv65TsXKnMts+r190Bdw+nfyGhDJBR4="}},"hash":"eASe9vsH7SfGtqpvzfS4jHXa1ryG9nIAX4DaV+rquHg=","text":"export async function generateStaticParams({ params: { category } }) {\r\n  const products = await fetch(\r\n    `https://.../products?category=${category}`\r\n  ).then((res) => res.json())\r\n  return products.map((product) => ({\r\n    product: product.id,\r\n  }))\r\n}\r\nexport default function Page({ params }) {\r\n  // ... }\r\nGood to know: fetch requests are automatically memoized for the same data across all generate-prefixed functions,\r\nLayouts, Pages, and Server Components. React cache can be used if fetch is unavailable. Version History\r\nVersionChanges\r\nv13.0.0generateStaticParams introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"70f8cf2d-9c4b-4ce9-83e8-b0e5e1ea4b66":{"id_":"70f8cf2d-9c4b-4ce9-83e8-b0e5e1ea4b66","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hOQVhfrsOAWFxp4Tn6hYPXwpmpTIsFs1ROwSvb+jlyQ=","metadata":{},"hash":"eNYsHFduP40MmsY4iz4nscJHPqlINfT/mi7kE8fXC2I="}},"hash":"K/7q7CpAveF3kUuw1aXOR+Lvjs9UA7tys4Jf8UKwgKM=","text":"3.2.3.8 - generateViewport\r\nDocumentation path: /02-app/02-api-reference/04-functions/generate-viewport\r\nDescription: API Reference for the generateViewport function. Related:\r\nTitle: Next Steps\r\nRelated Description: View all the Metadata API options. Links:\r\napp/api-reference/file-conventions/metadata\r\napp/building-your-application/optimizing/metadata\r\nYou can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function. Good to know:\r\nThe viewport object and generateViewport function exports are only supported in Server Components. You cannot export both the viewport object and generateViewport function from the same route segment. If you’re coming from migrating metadata exports, you can use metadata-to-viewport-export codemod to update your\r\nchanges. The viewportviewport object\r\nTo define the viewport options, export a viewport object from a layout.js or page.js file. layout.tsx | page.tsx (tsx)import type { Viewport } from 'next'\r\nexport const viewport: Viewport = {\r\n  themeColor: 'black',\r\n}\r\nexport default function Page() {}\r\nlayout.js | page.js (jsx)export const viewport = {\r\n  themeColor: 'black',\r\n}\r\nexport default function Page() {}\r\ngenerateViewportgenerateViewport function\r\ngenerateViewport should return a Viewport object containing one or more viewport fields. layout.tsx | page.tsx (tsx)export function generateViewport({ params }) {\r\n  return {\r\n    themeColor: '...',\r\n  }\r\n}\r\nlayout.js | page.js (jsx)export function generateViewport({ params }) {\r\n  return {\r\n    themeColor: '...',\r\n  }\r\n}\r\nGood to know:\r\nIf the viewport doesn’t depend on runtime information, it should be defined using the static viewport object rather than\r\ngenerateMetadata.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"652742f7-36c6-471b-a61d-03bb1b62bd42":{"id_":"652742f7-36c6-471b-a61d-03bb1b62bd42","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yRHZSx913f+jdEuywm78+jzX8UY/VcfDrd/tfnEftvc=","metadata":{},"hash":"vxwKaX1jNcZciKv5Ob+a75xAnXsBRKQN/IFgfRkEXxs="}},"hash":"qpR4nbo1qN+SfKQndcIv8mGx/bbb+qj28d9e5RfEvI4=","text":"Viewport Fields\r\nthemeColorthemeColor\r\nLearn more about theme-color. Simple theme color\r\nlayout.js | page.js (jsx)export const viewport = {\r\n  themeColor: 'black',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n**With media attribute**\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const viewport = {\r\n  themeColor: [\r\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\r\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\r\n  ],\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `width`, `initialScale`, and `maximumScale`\r\n> **Good to know**: The `viewport` meta tag is automatically set with the following default values. Usually\r\n<div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const viewport = {\r\n  width: 'device-width',\r\n  initialScale: 1,\r\n  maximumScale: 1,\r\n  // Also supported by less commonly used\r\n  // interactiveWidget: 'resizes-visual',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n### `colorScheme`\r\nLearn more about [`color-scheme`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name#:~:text=color%2Dscheme%3A%20specifies,of%20the%20following%3A). <div class=\"code-header\"><i>layout.js | page.js (jsx)</i></div>\r\n```jsx\r\nexport const viewport = {\r\n  colorScheme: 'dark',\r\n}\r\n```html filename=” output” hideLineNumbers\r\n## Types\r\nYou can add type safety to your viewport object by using the `Viewport` type. If you are using the [built-\r\n### `viewport` object\r\n```tsx\r\nimport type { Viewport } from 'next'\r\nexport const viewport: Viewport = {\r\n  themeColor: 'black',\r\n}\r\ngenerateViewportgenerateViewport function\r\nRegular function\r\nimport type { Viewport } from 'next'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5e1f822e-ae63-4c3e-be5e-07e7f44e99e3":{"id_":"5e1f822e-ae63-4c3e-be5e-07e7f44e99e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ID9hhbpafSdzqvhVa/Iy9l3tMKd6HyYp/7aaQSMQuAI=","metadata":{},"hash":"UDT/pGzNt+y6baOG+T3nPPsgwzoVtIIWwUMz+jlBq70="}},"hash":"jvyyGYJGdOhWinQV34yeoeEZuKl+91EZ+lW69WoTpkE=","text":"export function generateViewport(): Viewport {\r\n  return {\r\n    themeColor: 'black',\r\n  }\r\n}\r\nWith segment props\r\nimport type { Viewport } from 'next'\r\ntype Props = {\r\n  params: { id: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}\r\nexport function generateViewport({ params, searchParams }: Props): Viewport {\r\n  return {\r\n    themeColor: 'black',\r\n  }\r\n}\r\nexport default function Page({ params, searchParams }: Props) {}\r\nJavaScript Projects\r\nFor JavaScript projects, you can use JSDoc to add type safety. /** @type {import(\"next\").Viewport} */\r\nexport const viewport = {\r\n  themeColor: 'black',\r\n}\r\nVersion History\r\nVersionChanges\r\nv14.0.0viewport and generateViewport introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fe2f3ee6-2f6f-4c1e-a78a-08a9475ad22f":{"id_":"fe2f3ee6-2f6f-4c1e-a78a-08a9475ad22f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uYJe0dyJ7kWCG7zgFPZj1DJOZ5Qg7Bg/RscvqEg/A2A=","metadata":{},"hash":"JIG6xfUyM91LNnbJt9Bq60SY7Z8mw7RC1G7NM6t83QE="}},"hash":"22ZhravjvOYB7P6UFi4culRh7xITdGUh4+C9ih4B94M=","text":"3.2.3.9 - headers\r\nDocumentation path: /02-app/02-api-reference/04-functions/headers\r\nDescription: API reference for the headers function. The headers function allows you to read the HTTP incoming request headers from a Server Component.headers()headers()\r\nThis API extends the Web Headers API. It is read-only, meaning you cannot set / delete the outgoing request headers. app/page.tsx (tsx)import { headers } from 'next/headers'\r\nexport default function Page() {\r\n  const headersList = headers()\r\n  const referer = headersList.get('referer')\r\n  return <div>Referer: {referer}</div>\r\n}\r\napp/page.js (jsx)import { headers } from 'next/headers'\r\nexport default function Page() {\r\n  const headersList = headers()\r\n  const referer = headersList.get('referer')\r\n  return <div>Referer: {referer}</div>\r\n}\r\nGood to know:\r\nheaders() is a Dynamic Function whose returned values cannot be known ahead of time. Using it in a layout or page will\r\nopt a route into dynamic rendering at request time. API Reference\r\nconst headersList = headers()\r\nParameters\r\nheaders does not take any parameters. Returns\r\nheaders returns a read-only Web Headers object. Headers.entries(): Returns an iterator allowing to go through all key/value pairs contained in this object. Headers.forEach(): Executes a provided function once for each key/value pair in this Headers object. Headers.get(): Returns a String sequence of all the values of a header within a Headers object with a given name. Headers.has(): Returns a boolean stating whether a Headers object contains a certain header. Headers.keys(): Returns an iterator allowing you to go through all keys of the key/value pairs contained in this object. Headers.values(): Returns an iterator allowing you to go through all values of the key/value pairs contained in this object. Examples\r\nUsage with Data Fetching\r\nheaders() can be used in combination with Suspense for Data Fetching. app/page.js (jsx)import { Suspense } from 'react'\r\nimport { headers } from 'next/headers'\r\nasync function User() {\r\n  const authorization = headers().get('authorization')","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7ee07ae7-be73-44e5-82de-638872d41527":{"id_":"7ee07ae7-be73-44e5-82de-638872d41527","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NtYwUH7Od8rSFh+sD8Dj02y+N/0vGZClZITgYrSgTgk=","metadata":{},"hash":"az2VjW5Ru6rJcu9+KAypslqBBU9qISsMwasNylBWUmw="}},"hash":"eBUBTlVa/F2q9KhEjUznvPJ5IK2FnSkXhi1XhtYwQIc=","text":"const res = await fetch('...', {\r\n    headers: { authorization }, // Forward the authorization header\r\n  })\r\n  const user = await res.json()\r\n  return <h1>{user.name}</h1>\r\n}\r\nexport default function Page() {\r\n  return (\r\n    <Suspense fallback={null}>\r\n      <User />\r\n    </Suspense>\r\n  )\r\n}\r\nIP Address\r\nheaders() can be used to get the IP address of the client. app/page.js (jsx)import { Suspense } from 'react'\r\nimport { headers } from 'next/headers'\r\nfunction IP() {\r\n  const FALLBACK_IP_ADDRESS = '0.0.0.0'\r\n  const forwardedFor = headers().get('x-forwarded-for')\r\n  if (forwardedFor) {\r\n    return forwardedFor.split(',')[0] ?? FALLBACK_IP_ADDRESS\r\n  }\r\n  return headers().get('x-real-ip') ?? FALLBACK_IP_ADDRESS\r\n}\r\nexport default function Page() {\r\n  return (\r\n    <Suspense fallback={null}>\r\n      <IP />\r\n    </Suspense>\r\n  )\r\n}\r\nIn addition to x-forwarded-for, headers() can also read:\r\nx-real-ip\r\nx-forwarded-host\r\nx-forwarded-port\r\nx-forwarded-proto\r\nVersion History\r\nVersionChanges\r\nv13.0.0headers introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c5ea3506-8663-419f-bc75-e9b7e8a5187d":{"id_":"c5ea3506-8663-419f-bc75-e9b7e8a5187d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"v1DLnfCQRxuYFOeHNedIa8eEYX7pjE0bnC0kDlwkKSw=","metadata":{},"hash":"f5DuV4DzGwrxtoR4pebqjt0zT2S6KIMQeqvkb5L1PbY="}},"hash":"RFARV9lcL0/tP+6JJ/8JVm1dxKR+xrZGntED5TbzobY=","text":"3.2.3.10 - ImageResponse\r\nDocumentation path: /02-app/02-api-reference/04-functions/image-response\r\nDescription: API Reference for the ImageResponse constructor. The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media\r\nimages such as Open Graph images, Twitter cards, and more. The following options are available for ImageResponse:\r\nimport { ImageResponse } from 'next/og'\r\nnew ImageResponse(\r\n  element: ReactElement,\r\n  options: {\r\n    width?: number = 1200\r\n    height?: number = 630\r\n    emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',\r\n    fonts?: {\r\n      name: string,\r\n      data: ArrayBuffer,\r\n      weight: number,\r\n      style: 'normal' | 'italic'\r\n    }[]\r\n    debug?: boolean = false\r\n    // Options that will be passed to the HTTP response\r\n    status?: number = 200\r\n    statusText?: string\r\n    headers?: Record<string, string>\r\n  },\r\n)\r\nSupported CSS Properties\r\nPlease refer to Satori’s documentation for a list of supported HTML and CSS features. Version History\r\nVersionChanges\r\nv14.0.0ImageResponse moved from next/server to next/og\r\nv13.3.0ImageResponse can be imported from next/server. v13.0.0ImageResponse introduced via @vercel/og package.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"99c3ccd4-3ba1-4b41-92e9-1d1475d9af78":{"id_":"99c3ccd4-3ba1-4b41-92e9-1d1475d9af78","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uCjgrp4LqqqMYwH1spC1cKRap4/ldhYEtTpJsvm5cjk=","metadata":{},"hash":"dJjGlfCH7VdCuk9SDk+f0Au6/jQ8/Q0JjEtx+3UBDgQ="}},"hash":"eNHrIKYubE45nVnmX84Bk6FelY/yjdKjLkOPGemMDfQ=","text":"3.2.3.11 - NextRequest\r\nDocumentation path: /02-app/02-api-reference/04-functions/next-request\r\nDescription: API Reference for NextRequest. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNextRequest extends the Web Request API with additional convenience methods.cookiescookies\r\nRead or mutate the Set-Cookie header of the request. set(name, value)set(name, value)\r\nGiven a name, set a cookie with the given value on the request. // Given incoming request /home\r\n// Set a cookie to hide the banner\r\n// request will have a `Set-Cookie:show-banner=false;path=/home` header\r\nrequest.cookies.set('show-banner', 'false')\r\nget(name)get(name)\r\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found,\r\nthe first one is returned. // Given incoming request /home\r\n// { name: 'show-banner', value: 'false', Path: '/home' }\r\nrequest.cookies.get('show-banner')\r\ngetAll()getAll()\r\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the request. // Given incoming request /home\r\n// [\r\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\r\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\r\n// ]\r\nrequest.cookies.getAll('experiments')\r\n// Alternatively, get all cookies for the request\r\nrequest.cookies.getAll()\r\ndelete(name)delete(name)\r\nGiven a cookie name, delete the cookie from the request. // Returns true for deleted, false is nothing is deleted\r\nrequest.cookies.delete('experiments')\r\nhas(name)has(name)\r\nGiven a cookie name, return true if the cookie exists on the request. // Returns true if cookie exists, false if it does not\r\nrequest.cookies.has('experiments')\r\nclear()clear()\r\nRemove the Set-Cookie header from the request. request.cookies.clear()\r\nnextUrlnextUrl","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1db22e6f-b7d4-4953-ad6b-794229aaee8f":{"id_":"1db22e6f-b7d4-4953-ad6b-794229aaee8f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XyADhwUdAH8OxXpUEWmQEiKFMYP4R79t1KImYaagwAU=","metadata":{},"hash":"faobua6YcWC7ObBVkh55nwQYa7gNqioResNTrY/ATAk="}},"hash":"ZWTa6JJEKGOqOt40Zwmrm2ASFsycv+HuCTc5MCtMpWQ=","text":"Extends the native URL API with additional convenience methods, including Next.js specific properties. // Given a request to /home, pathname is /home\r\nrequest.nextUrl.pathname\r\n// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }\r\nrequest.nextUrl.searchParams\r\nThe following options are available:\r\nPropertyTypeDescription\r\nbasePathstringThe base path of the URL. buildIdstring | undefinedThe build identifier of the Next.js application. Can be customized. defaultLocalestring | undefinedThe default locale for internationalization. domainLocale\r\n- defaultLocalestringThe default locale within a domain. - domainstringThe domain associated with a specific locale. - httpboolean | undefinedIndicates if the domain is using HTTP. localesstring[] | undefinedAn array of available locales. localestring | undefinedThe currently active locale. urlURLThe URL object. PropertyTypeDescription\r\nbasePathstringThe base path of the URL. buildIdstring | undefinedThe build identifier of the Next.js application. Can be customized. urlURLThe URL object. pathnamestringThe pathname of the URL. searchParamsObjectThe search parameters of the URL. Note: The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more\r\nabout internationalization with the App Router.ipip\r\nThe ip property is a string that contains the IP address of the request. This value can optionally be provided by your hosting platform. Good to know: On Vercel, this value is provided by default. On other platforms, you can use the X-Forwarded-For header to\r\nprovide the IP address. // Provided by Vercel\r\nrequest.ip\r\n// Self-hosting\r\nrequest.headers.get('X-Forwarded-For')\r\ngeogeo\r\nThe geo property is an object that contains the geographic information of the request. This value can optionally be provided by your\r\nhosting platform. Good to know: On Vercel, this value is provided by default. On other platforms, you can use the X-Forwarded-For header to\r\nprovide the IP address, then use a third-party service to lookup the geographic information. // Provided by Vercel\r\nrequest.geo.city","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"61a4ae21-01cd-4a9c-9a35-d06908b3bf9c":{"id_":"61a4ae21-01cd-4a9c-9a35-d06908b3bf9c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QiLFGHfqU557Z6I6nmjJTThrrK/SzZdkY/7FAA9x0ng=","metadata":{},"hash":"/J969lnuzXPJIhCcU5m9Zb4iUptNeq5t0FR1+1UuJfc="}},"hash":"rt3s+ok0VNFCNQvkuemIyzzMQO/bGDWDxzd1lU32cc8=","text":"request.geo.country\r\nrequest.geo.region\r\nrequest.geo.latitude\r\nrequest.geo.longitude\r\n// Self-hosting\r\nfunction getGeo(request) {\r\n  let ip = request.headers.get('X-Forwarded-For')\r\n  // Use a third-party service to lookup the geographic information\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.0.0useSearchParams introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"98daf481-a7a1-49e8-b16c-bcaf038d35d2":{"id_":"98daf481-a7a1-49e8-b16c-bcaf038d35d2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SHubTr24YGJDY6UUK0C0MSkbNCgi3ubmUIyO9VBHXzs=","metadata":{},"hash":"RmJg/AQjmKzPz0vSQOri+llLsa6jxJFZIYXNs3M4TDU="},"NEXT":{"nodeId":"5c90c0f9-4b50-4f48-874f-490c72e217b2","metadata":{},"hash":"aKy/tuRQtz6YJjGJFobvjEEkVyb+A99xh3RZ7VMODIY="}},"hash":"i7gEe11uL5QQsujAniEkKbHR/X4SZV6SZAmKUcMoCFY=","text":"3.2.3.12 - NextResponse\r\nDocumentation path: /02-app/02-api-reference/04-functions/next-response\r\nDescription: API Reference for NextResponse. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNextResponse extends the Web Response API with additional convenience methods.cookiescookies\r\nRead or mutate the Set-Cookie header of the response. set(name, value)set(name, value)\r\nGiven a name, set a cookie with the given value on the response. // Given incoming request /home\r\nlet response = NextResponse.next()\r\n// Set a cookie to hide the banner\r\nresponse.cookies.set('show-banner', 'false')\r\n// Response will have a `Set-Cookie:show-banner=false;path=/home` header\r\nreturn response\r\nget(name)get(name)\r\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found,\r\nthe first one is returned. // Given incoming request /home\r\nlet response = NextResponse.next()\r\n// { name: 'show-banner', value: 'false', Path: '/home' }\r\nresponse.cookies.get('show-banner')\r\ngetAll()getAll()\r\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the response. // Given incoming request /home\r\nlet response = NextResponse.next()\r\n// [\r\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\r\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\r\n// ]\r\nresponse.cookies.getAll('experiments')\r\n// Alternatively, get all cookies for the response\r\nresponse.cookies.getAll()\r\ndelete(name)delete(name)\r\nGiven a cookie name, delete the cookie from the response. // Given incoming request /home\r\nlet response = NextResponse.next()\r\n// Returns true for deleted, false is nothing is deleted\r\nresponse.cookies.delete('experiments')\r\njson()json()\r\nProduce a response with the given JSON body.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5c90c0f9-4b50-4f48-874f-490c72e217b2":{"id_":"5c90c0f9-4b50-4f48-874f-490c72e217b2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SHubTr24YGJDY6UUK0C0MSkbNCgi3ubmUIyO9VBHXzs=","metadata":{},"hash":"RmJg/AQjmKzPz0vSQOri+llLsa6jxJFZIYXNs3M4TDU="},"PREVIOUS":{"nodeId":"98daf481-a7a1-49e8-b16c-bcaf038d35d2","metadata":{},"hash":"i7gEe11uL5QQsujAniEkKbHR/X4SZV6SZAmKUcMoCFY="}},"hash":"aKy/tuRQtz6YJjGJFobvjEEkVyb+A99xh3RZ7VMODIY=","text":"app/api/route.ts (ts)import { NextResponse } from 'next/server'\r\nexport async function GET(request: Request) {\r\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ea878000-1ee9-403d-a4d9-e0f7ff3b2bbc":{"id_":"ea878000-1ee9-403d-a4d9-e0f7ff3b2bbc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"VVB7YwbKlbPHyo2FQsk1CFcVCWhEnkOKDvEY38fqJA0=","metadata":{},"hash":"DYCYwI0YIS7SONLTs/5Pzdna75Oq+WA25EQyINaubls="}},"hash":"DK2tMjnfMgIGEK6vzOWW67IpsdPgf4URbne9JyFP0+o=","text":"app/api/route.js (js)import { NextResponse } from 'next/server'\r\nexport async function GET(request) {\r\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\r\n}\r\nredirect()redirect()\r\nProduce a response that redirects to a URL. import { NextResponse } from 'next/server'\r\nreturn NextResponse.redirect(new URL('/new', request.url))\r\nThe URL can be created and modified before being used in the NextResponse.redirect() method. For example, you can use the\r\nrequest.nextUrl property to get the current URL, and then modify it to redirect to a different URL. import { NextResponse } from 'next/server'\r\n// Given an incoming request... const loginUrl = new URL('/login', request.url)\r\n// Add ?from=/incoming-url to the /login URL\r\nloginUrl.searchParams.set('from', request.nextUrl.pathname)\r\n// And redirect to the new URL\r\nreturn NextResponse.redirect(loginUrl)\r\nrewrite()rewrite()\r\nProduce a response that rewrites (proxies) the given URL while preserving the original URL. import { NextResponse } from 'next/server'\r\n// Incoming request: /about, browser shows /about\r\n// Rewritten request: /proxy, browser shows /about\r\nreturn NextResponse.rewrite(new URL('/proxy', request.url))\r\nnext()next()\r\nThe next() method is useful for Middleware, as it allows you to return early and continue routing. import { NextResponse } from 'next/server'\r\nreturn NextResponse.next()\r\nYou can also forward headers when producing the response:\r\nimport { NextResponse } from 'next/server'\r\n// Given an incoming request... const newHeaders = new Headers(request.headers)\r\n// Add a new header\r\nnewHeaders.set('x-version', '123')\r\n// And produce a response with the new headers\r\nreturn NextResponse.next({\r\n  request: {\r\n    // New request headers\r\n    headers: newHeaders,\r\n  },\r\n})","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b5595d14-e0eb-4474-b7d5-413a515e412c":{"id_":"b5595d14-e0eb-4474-b7d5-413a515e412c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qLX6vWtIaOBNIUN0SeeBGEIeVUl3VYG4ULL1+lIsJNo=","metadata":{},"hash":"UcbHsUnAlH24tIBWhcqTw8tMtX571F0QIJN7ZOxWI4w="}},"hash":"c1Iqo/1D5s5Y7J+seYTizNxHIyez1IqaaPmdyYLK6d0=","text":"3.2.3.13 - notFound\r\nDocumentation path: /02-app/02-api-reference/04-functions/not-found\r\nDescription: API Reference for the notFound function. The notFound function allows you to render the not-found file within a route segment as well as inject a <meta name=\"robots\"\r\ncontent=\"noindex\" /> tag. notFound()notFound()\r\nInvoking the notFound() function throws a NEXT_NOT_FOUND error and terminates rendering of the route segment in which it was\r\nthrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment. app/user/[id]/page.js (jsx)import { notFound } from 'next/navigation'\r\nasync function fetchUser(id) {\r\n  const res = await fetch('https://... ')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\nexport default async function Profile({ params }) {\r\n  const user = await fetchUser(params.id)\r\n  if (!user) {\r\n    notFound()\r\n  }\r\n  // ... }\r\nGood to know: notFound() does not require you to use return notFound() due to using the TypeScript never type. Version History\r\nVersionChanges\r\nv13.0.0notFound introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c1bda9ed-2d21-4489-914a-a89c25830669":{"id_":"c1bda9ed-2d21-4489-914a-a89c25830669","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ux/RV+J2A+YYG/6aJw7vKXHQZqFhLlc1VK2SHYAsKcw=","metadata":{},"hash":"YEgX/0z2EBoTSO8InYxkwc7WgY/ubsjDEmk/6H7zPng="}},"hash":"9EHzx0/7Tz1y++yUlAk5Ek9sxPEv2MmXX71pIVSz1o0=","text":"3.2.3.14 - permanentRedirect\r\nDocumentation path: /02-app/02-api-reference/04-functions/permanentRedirect\r\nDescription: API Reference for the permanentRedirect function. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/api-reference/functions/redirect\r\nThe permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server\r\nComponents, Client Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will\r\nserve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller. If a resource doesn’t exist, you can use the notFound function instead. Good to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use the redirect\r\nfunction instead. Parameters\r\nThe permanentRedirect function accepts two arguments:\r\npermanentRedirect(path, type)\r\nParameterTypeDescription\r\npathstringThe URL to redirect to. Can be a relative or absolute path. type'replace' (default) or 'push' (default in Server Actions)The type of redirect to perform. By default, permanentRedirect will use push (adding a new entry to the browser history stack) in Server Actions and replace\r\n(replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type\r\nparameter. The type parameter has no effect when used in Server Components. Returns\r\npermanentRedirect does not return any value. Example\r\nInvoking the permanentRedirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which\r\nit was thrown. app/team/[id]/page.js (jsx)import { permanentRedirect } from 'next/navigation'\r\nasync function fetchTeam(id) {\r\n  const res = await fetch('https://... ')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\nexport default async function Profile({ params }) {\r\n  const team = await fetchTeam(params.id)\r\n  if (!team) {\r\n    permanentRedirect('/login')\r\n  }\r\n  // ... }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ead5f341-e875-4538-be33-0a5168dbb8ba":{"id_":"ead5f341-e875-4538-be33-0a5168dbb8ba","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MLNPmzqeRQTwp0xMyoJfFub+p2a0kFAGQzyjmAyIA2A=","metadata":{},"hash":"4/K8UFt6mNxihA+MF9cAYDWp6+btBHjZWJh0UWSEMnw="}},"hash":"OR13ZSCW9SSXV3cub2lzaZF6LuXIYSe8sej1itntkHs=","text":"Good to know: permanentRedirect does not require you to use return permanentRedirect() as it uses the TypeScriptnever\r\n type.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a99deba4-d73b-47f5-9f8b-5760d0191550":{"id_":"a99deba4-d73b-47f5-9f8b-5760d0191550","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SX3OjkPnTL2u7UsHHlJTc/DuiIN+938MbJBixp3h/ZE=","metadata":{},"hash":"pZUhCi3dnhuYLfK6kMZIL17wvyujR8BqYM7FEexj2Bs="}},"hash":"nCoEcF6yFqkq7M+CvMCtUAtZQK5gc99j4oIWhRzSz50=","text":"3.2.3.15 - redirect\r\nDocumentation path: /02-app/02-api-reference/04-functions/redirect\r\nDescription: API Reference for the redirect function. Related:\r\nTitle: Related\r\nRelated Description: No related description\r\nLinks:\r\napp/api-reference/functions/permanentRedirect\r\nThe redirect function allows you to redirect the user to another URL. redirect can be used in Server Components, Client\r\nComponents, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will\r\nserve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller. If a resource doesn’t exist, you can use the notFound function instead. Good to know: If you prefer to return a 308 (Permanent) HTTP redirect instead of 307 (Temporary), you can use thepermanentRedirect\r\n function instead. Parameters\r\nThe redirect function accepts two arguments:\r\nredirect(path, type)\r\nParameterTypeDescription\r\npathstringThe URL to redirect to. Can be a relative or absolute path. type'replace' (default) or 'push' (default in Server Actions)The type of redirect to perform. By default, redirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the\r\ncurrent URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter. The type parameter has no effect when used in Server Components. Returns\r\nredirect does not return any value. Example\r\nInvoking the redirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was\r\nthrown. Good to know: If you need to programmatically redirect the user after a certain event in a Client Component, you can use theuseRouter\r\n hook. app/team/[id]/page.js (jsx)import { redirect } from 'next/navigation'\r\nasync function fetchTeam(id) {\r\n  const res = await fetch('https://... ')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\nexport default async function Profile({ params }) {\r\n  const team = await fetchTeam(params.id)\r\n  if (!team) {\r\n    redirect('/login')\r\n  }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2d63d057-10df-4aa3-8ba1-fa769a8efaea":{"id_":"2d63d057-10df-4aa3-8ba1-fa769a8efaea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4J83esfKWb3FChwA45cneGwAqHzxG9m3DL1/TO7wVOc=","metadata":{},"hash":"nfqrA+zf8g9NO7kb61NX4wZVuYr+TZrAjck6WyaouCo="}},"hash":"rlUc8j9+R59/C2hbPEusFCZfdHBY4JUO9dFjlN0LMUA=","text":"// ... }\r\nGood to know: redirect does not require you to use return redirect() as it uses the TypeScript never type. FAQ\r\nWhy does redirectredirect use 307 and 308? When using redirect() you may notice that the status codes used are 307 for a temporary redirect, and 308 for a permanent\r\nredirect. While traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, many browsers changed the\r\nrequest method of the redirect, from a POST to GET request when using a 302, regardless of the origins request method. Taking the following example of a redirect from /users to /people, if you make a POST request to /users to create a new user, and\r\nare conforming to a 302 temporary redirect, the request method will be changed from a POST to a GET request. This doesn’t make\r\nsense, as to create a new user, you should be making a POST request to /people, and not a GET request. The introduction of the 307 status code means that the request method is preserved as POST. 302 - Temporary redirect, will change the request method from POST to GET\r\n307 - Temporary redirect, will preserve the request method as POST\r\nThe redirect() method uses a 307 by default, instead of a 302 temporary redirect, meaning your requests will always be preserved as\r\nPOST requests. Learn more about HTTP Redirects. Version History\r\nVersionChanges\r\nv13.0.0redirect introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e70ebb4e-6d33-4c5d-b016-0290fd8e32bf":{"id_":"e70ebb4e-6d33-4c5d-b016-0290fd8e32bf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZDTkkSU69Nth4RaIjGnt51UStjMmlQVhyaMf8DUXFZc=","metadata":{},"hash":"iC0xmT3R020G6k3BjShNfI1MxkzzmI7LrOqmfxs+JoY="},"NEXT":{"nodeId":"95f7273e-4ae7-489d-83fd-b3dd61d761c9","metadata":{},"hash":"W1Jvtd7dRStyTsz1Y9xpUyCiqxOcyawwStIjySGnNVY="}},"hash":"fNmXe4uXrxBr0du/3GSH/ED74LGjA1X9g+9w69pDnXo=","text":"3.2.3.16 - revalidatePath\r\nDocumentation path: /02-app/02-api-reference/04-functions/revalidatePath\r\nDescription: API Reference for the revalidatePath function. revalidatePath allows you to purge cached data on-demand for a specific path. Good to know:\r\nrevalidatePath is available in both Node.js and Edge runtimes. revalidatePath only invalidates the cache when the included path is next visited. This means calling revalidatePath\r\nwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when\r\nthe path is next visited. Parameters\r\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\r\npath: Either a string representing the filesystem path associated with the data you want to revalidate (for example,\r\n/product/[slug]/page), or the literal route segment (for example, /product/123). Must be less than 1024 characters. type: (optional) 'page' or 'layout' string to change the type of path to revalidate. Returns\r\nrevalidatePath does not return any value. Examples\r\nRevalidating A Specific URL\r\nimport { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/post-1')\r\nThis will revalidate one specific URL on the next page visit. Revalidating A Page Path\r\nimport { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/[slug]', 'page')\r\n// or with route groups\r\nrevalidatePath('/(main)/post/[slug]', 'page')\r\nThis will revalidate any URL that matches the provided page file on the next page visit. This will not invalidate pages beneath the\r\nspecific page. For example, /blog/[slug] won’t invalidate /blog/[slug]/[author]. Revalidating A Layout Path\r\nimport { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/[slug]', 'layout')\r\n// or with route groups\r\nrevalidatePath('/(main)/post/[slug]', 'layout')\r\nThis will revalidate any URL that matches the provided layout file on the next page visit. This will cause pages beneath with the same\r\nlayout to revalidate on the next visit. For example, in the above case, /blog/[slug]/[another] would also revalidate on the next\r\nvisit.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"95f7273e-4ae7-489d-83fd-b3dd61d761c9":{"id_":"95f7273e-4ae7-489d-83fd-b3dd61d761c9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZDTkkSU69Nth4RaIjGnt51UStjMmlQVhyaMf8DUXFZc=","metadata":{},"hash":"iC0xmT3R020G6k3BjShNfI1MxkzzmI7LrOqmfxs+JoY="},"PREVIOUS":{"nodeId":"e70ebb4e-6d33-4c5d-b016-0290fd8e32bf","metadata":{},"hash":"fNmXe4uXrxBr0du/3GSH/ED74LGjA1X9g+9w69pDnXo="}},"hash":"W1Jvtd7dRStyTsz1Y9xpUyCiqxOcyawwStIjySGnNVY=","text":"Revalidating All Data\r\nimport { revalidatePath } from 'next/cache'\r\nrevalidatePath('/', 'layout')","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"80a19f74-d47d-448a-9c10-3450bddcd093":{"id_":"80a19f74-d47d-448a-9c10-3450bddcd093","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uiLW60gs17t5BiU8O2/e1yl2YQSd+pLOkBnIPcIHxxI=","metadata":{},"hash":"IC47znfFpJgdF55e/6nLuw/lrzR9CbPMXEPzvlPbDJI="}},"hash":"mY3Izx7DULlJZV8nI6NNQF+7abC4Tpbfx2URtXSmBPs=","text":"This will purge the Client-side Router Cache, and revalidate the Data Cache on the next page visit. Server Action\r\napp/actions.ts (ts)'use server'\r\nimport { revalidatePath } from 'next/cache'\r\nexport default async function submit() {\r\n  await submitForm()\r\n  revalidatePath('/')\r\n}\r\nRoute Handler\r\napp/api/revalidate/route.ts (ts)import { revalidatePath } from 'next/cache'\r\nimport { NextRequest } from 'next/server'\r\nexport async function GET(request: NextRequest) {\r\n  const path = request.nextUrl.searchParams.get('path')\r\n  if (path) {\r\n    revalidatePath(path)\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing path to revalidate',\r\n  })\r\n}\r\napp/api/revalidate/route.js (js)import { revalidatePath } from 'next/cache'\r\nexport async function GET(request) {\r\n  const path = request.nextUrl.searchParams.get('path')\r\n  if (path) {\r\n    revalidatePath(path)\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing path to revalidate',\r\n  })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1feb1a6d-5f6d-4d97-875c-a8895e2f2dfd":{"id_":"1feb1a6d-5f6d-4d97-875c-a8895e2f2dfd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fYeuPotGQFRGnXdqHFTRU1WZBgv7sgvAvPMONhQtUuI=","metadata":{},"hash":"s9uhkqvNENoV8IqAXsUiWpmZbRrZpqsljPCICdihHPU="}},"hash":"spgvC68XACBH2YxUTdQQ/tfOZcw0zpXmfPytrqVH/JY=","text":"3.2.3.17 - revalidateTag\r\nDocumentation path: /02-app/02-api-reference/04-functions/revalidateTag\r\nDescription: API Reference for the revalidateTag function. revalidateTag allows you to purge cached data on-demand for a specific cache tag. Good to know:\r\nrevalidateTag is available in both Node.js and Edge runtimes. revalidateTag only invalidates the cache when the path is next visited. This means calling revalidateTag with a\r\ndynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the\r\npath is next visited. Parameters\r\nrevalidateTag(tag: string): void;\r\ntag: A string representing the cache tag associated with the data you want to revalidate. Must be less than or equal to 256\r\ncharacters. You can add tags to fetch as follows:\r\nfetch(url, { next: { tags: [... ] } });\r\nReturns\r\nrevalidateTag does not return any value. Examples\r\nServer Action\r\napp/actions.ts (ts)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('posts')\r\n}\r\napp/actions.js (js)'use server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('posts')\r\n}\r\nRoute Handler\r\napp/api/revalidate/route.ts (ts)import { NextRequest } from 'next/server'\r\nimport { revalidateTag } from 'next/cache'\r\nexport async function GET(request: NextRequest) {\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n  revalidateTag(tag)\r\n  return Response.json({ revalidated: true, now: Date.now() })\r\n}\r\napp/api/revalidate/route.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7c6223ac-083b-4f9d-9911-96e8608af91b":{"id_":"7c6223ac-083b-4f9d-9911-96e8608af91b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LZUs3yUp/uh/ru2IxCZrMXV7ObLP6eweNRP+JUgghNM=","metadata":{},"hash":"W+kiJ1azOVq1KH4X71pUG3x+qA1jDWBecOuMthNPr6c="}},"hash":"+PZHqmDXbILMf97Jcw577ddJ/f0Lz8FAt5xnQWkfzo8=","text":"import { revalidateTag } from 'next/cache'\r\nexport async function GET(request) {\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n  revalidateTag(tag)\r\n  return Response.json({ revalidated: true, now: Date.now() })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"87e5ab7c-ed04-4f5e-817e-80ac140d4840":{"id_":"87e5ab7c-ed04-4f5e-817e-80ac140d4840","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BA8TcLTWdFjcl2wfRGRm5hWEJkyiacr63MZXfqjjc40=","metadata":{},"hash":"jOZoJUa3L2gdysA3tEAysdpOTDu8ROWlrINhSOvS6ZY="}},"hash":"uExolMqQVsxJVodGRfe/o44PhvkolaNUyIXjpscaaxk=","text":"3.2.3.18 - unstable_cache\r\nDocumentation path: /02-app/02-api-reference/04-functions/unstable_cache\r\nDescription: API Reference for the unstable_cache function. unstable_cache allows you to cache the results of expensive operations, like database queries, and reuse them across multiple\r\nrequests. import { getUser } from './data';\r\nimport { unstable_cache } from 'next/cache';\r\nconst getCachedUser = unstable_cache(\r\n  async (id) => getUser(id),\r\n  ['my-app-user']\r\n);\r\nexport default async function Component({ userID }) {\r\n  const user = await getCachedUser(userID);\r\n  ... }\r\nWarning: This API is unstable and may change in the future. We will provide migration documentation and codemods, if\r\nneeded, as this API stabilizes. Parameters\r\nconst data = unstable_cache(fetchData, keyParts, options)()\r\nfetchData: This is an asynchronous function that fetches the data you want to cache. It must be a function that returns a Promise. keyParts: This is an array that identifies the cached key. It must contain globally unique values that together identify the key of the\r\ndata being cached. The cache key also includes the arguments passed to the function.options\r\n: This is an object that controls how the cache behaves. It can contain the following properties:\r\ntags: An array of tags that can be used to control cache invalidation. revalidate: The number of seconds after which the cache should be revalidated. Returns\r\nunstable_cache returns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the\r\ncache, the provided function will be invoked, and its result will be cached and returned. Version History\r\nVersionChanges\r\nv14.0.0unstable_cache introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"26275051-3777-4974-9241-841ef597e340":{"id_":"26275051-3777-4974-9241-841ef597e340","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xsl9DoTHCRMB3eueCtLeBJr3JP2ysJIOJb2mupnTxlc=","metadata":{},"hash":"6V9lm28uv6taqmxHrdt/elsPAYC3H2PUKmtkchJpRcU="}},"hash":"XwijkZsXAx5Mg5KmQ2WPXFKraKhRf0jFa4AACMhRSyA=","text":"3.2.3.19 - unstable_noStore\r\nDocumentation path: /02-app/02-api-reference/04-functions/unstable_noStore\r\nDescription: API Reference for the unstable_noStore function. unstable_noStore can be used to declaratively opt out of static rendering and indicate a particular component should not be cached. import { unstable_noStore as noStore } from 'next/cache';\r\nexport default async function Component() {\r\n  noStore();\r\n  const result = await db.query(...);\r\n  ... }\r\nGood to know:\r\nunstable_noStore is equivalent to cache: 'no-store' on a fetch\r\nunstable_noStore is preferred over export const dynamic = 'force-dynamic' as it is more granular and can be\r\nused on a per-component basis\r\nUsing unstable_noStore inside unstable_cache will not opt out of static generation. Instead, it will defer to the cache\r\nconfiguration to determine whether to cache the result or not. Usage\r\nIf you prefer not to pass additional options to fetch, like cache: 'no-store' or next: { revalidate: 0 }, you can use\r\nnoStore() as a replacement for all of these use cases. import { unstable_noStore as noStore } from 'next/cache';\r\nexport default async function Component() {\r\n  noStore();\r\n  const result = await db.query(...);\r\n  ... }\r\nVersion History\r\nVersionChanges\r\nv14.0.0unstable_noStore introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"af2080bd-0d42-490f-862b-87e62da6a694":{"id_":"af2080bd-0d42-490f-862b-87e62da6a694","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vuU1WEDvZMl0H358s1Usqnb2Y7LYmNrLLTIF0AOjujA=","metadata":{},"hash":"mPrUPaS9P75eKyMj7nS8r9TebW4+Hv2St+0xudXmuqM="}},"hash":"NXB4D8JiJaqMKihaEJg18rqYYD+4StwGf++9Pz0AZfI=","text":"3.2.3.20 - useParams\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-params\r\nDescription: API Reference for the useParams hook. useParams is a Client Component hook that lets you read a route’s dynamic params filled in by the current URL. app/example-client-component.tsx (tsx)'use client'\r\nimport { useParams } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const params = useParams<{ tag: string; item: string }>()\r\n  // Route -> /shop/[tag]/[item]\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  console.log(params)\r\n  return <></>\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { useParams } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const params = useParams()\r\n  // Route -> /shop/[tag]/[item]\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  console.log(params)\r\n  return <></>\r\n}\r\nParameters\r\nconst params = useParams()\r\nuseParams does not take any parameters. Returns\r\nuseParams returns an object containing the current route’s filled in dynamic parameters. Each property in the object is an active dynamic segment. The properties name is the segment’s name, and the properties value is what the segment is filled in with. The properties value will either be a string or array of string’s depending on the type of dynamic segment. If the route contains no dynamic parameters, useParams returns an empty object. If used in pages, useParams will return null. For example:\r\nRouteURLuseParams()useParams()\r\napp/shop/page.js/shopnull\r\napp/shop/[slug]/page.js/shop/1{ slug: '1' }\r\napp/shop/[tag]/[item]/page.js/shop/1/2{ tag: '1', item: '2' }\r\napp/shop/[...slug]/page.js/shop/1/2{ slug: ['1', '2'] }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"78454096-b36e-4b32-a810-43173be044fa":{"id_":"78454096-b36e-4b32-a810-43173be044fa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CpvcGLiI214eung3ssIQRdEXLKVh2OS8BlctZPSl9kg=","metadata":{},"hash":"GY8dRXs3pUMkC6OLyZCfkUCKKZU79+ZCoL0Gktu6Sfc="}},"hash":"k347yQccKunIjJjWJc1I+khFrdJPdTRAl+HekU4ikCU=","text":"Version History\r\nVersionChanges\r\nv13.3.0useParams introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3768249b-32e7-48ba-a67f-dda5e6ccdd3f":{"id_":"3768249b-32e7-48ba-a67f-dda5e6ccdd3f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KxKaQgNzUm5R9XGJUSZQxActbq0gajUUNH8Ac7QRgXg=","metadata":{},"hash":"pLBSJ+Hvgt9WzX4KzUqaMCurtDFbwWABy2ZHngSuanM="}},"hash":"1Dk8ZJB0SpSHYEmyiM507uU2+nHMHQWMEYAUP8xFkFY=","text":"3.2.3.21 - usePathname\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-pathname\r\nDescription: API Reference for the usePathname hook. usePathname is a Client Component hook that lets you read the current URL’s pathname. app/example-client-component.tsx (tsx)'use client'\r\nimport { usePathname } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  return <p>Current pathname: {pathname}</p>\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { usePathname } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  return <p>Current pathname: {pathname}</p>\r\n}\r\nusePathname intentionally requires using a Client Component. It’s important to note Client Components are not a de-optimization. They are an integral part of the Server Components architecture. For example, a Client Component with usePathname will be rendered into HTML on the initial page load. When navigating to a new\r\nroute, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and\r\nre-renders based on the current state. Good to know:\r\nReading the current URL from a Server Component is not supported. This design is intentional to support layout state being\r\npreserved across page navigations. Compatibility mode:usePathname\r\n can return null when a fallback route is being rendered or when a pages directory page has been\r\nautomatically statically optimized by Next.js and the router is not ready. Next.js will automatically update your types if it detects both an app and pages directory in your project. Parameters\r\nconst pathname = usePathname()\r\nusePathname does not take any parameters. Returns\r\nusePathname returns a string of the current URL’s pathname. For example:\r\nURLReturned value\r\n/'/'\r\n/dashboard'/dashboard'\r\n/dashboard?v=2'/dashboard'\r\n/blog/hello-world'/blog/hello-world'\r\nExamples\r\nDo something in response to a route change","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3194e678-616e-4229-a21f-8ecf77678b5c":{"id_":"3194e678-616e-4229-a21f-8ecf77678b5c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ilXWOUA/qE4eRxxWow5UmeqtR1GWOfcgt8LFTdxGy2k=","metadata":{},"hash":"bxu5mWt3QCIlFj5R6CCH/6WpaTN7YM/lnE2yvDbC4JU="}},"hash":"PbZM+x3jV3dbxCYzF7GD9D73TTtLdDCq8V2n4HSZWGk=","text":"app/example-client-component.tsx (tsx)'use client'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\nfunction ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    // Do something here... }, [pathname, searchParams])\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\nfunction ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    // Do something here... }, [pathname, searchParams])\r\n}\r\nVersionChanges\r\nv13.0.0usePathname introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1caf04d3-f08b-493e-9c0d-547d5a6b1982":{"id_":"1caf04d3-f08b-493e-9c0d-547d5a6b1982","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"q3n7mjapguT0od4x8sSVnWKdK6aWPoF2yiM3LkfCnhg=","metadata":{},"hash":"M2p65b9bCCw5yb6dlx4fxoHC/QWoKidwi45B+KCq/FQ="},"NEXT":{"nodeId":"4515c674-9ce4-49a2-b871-c0e24e55684f","metadata":{},"hash":"Mo/cLQem8zbAvbQ4bQA0Xn5CEZ/UUeYEzuN+41M4Vto="}},"hash":"PIuV/Es0BMB5bB/5yC+mFgmy4i/zZgzgkCCBlEhVF30=","text":"3.2.3.22 - useReportWebVitals\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-report-web-vitals\r\nDescription: API Reference for the useReportWebVitals function. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThe useReportWebVitals hook allows you to report Core Web Vitals, and can be used in combination with your analytics service. pages/_app.js (jsx)import { useReportWebVitals } from 'next/web-vitals'\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n  return <Component {...pageProps} />\r\n}\r\napp/_components/web-vitals.js (jsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n}\r\napp/layout.js (jsx)import { WebVitals } from './_components/web-vitals'\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <WebVitals />\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\nSince the useReportWebVitals hook requires the \"use client\" directive, the most performant approach is to create a\r\nseparate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component. useReportWebVitals\r\nThe metric object passed as the hook’s argument consists of a number of properties:\r\nid: Unique identifier for the metric in the context of the current page load\r\nname: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific\r\nto a web application.delta\r\n: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and\r\nrepresents the change in the metric’s value over time.entries\r\n: An array of Performance Entries associated with the metric.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4515c674-9ce4-49a2-b871-c0e24e55684f":{"id_":"4515c674-9ce4-49a2-b871-c0e24e55684f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"q3n7mjapguT0od4x8sSVnWKdK6aWPoF2yiM3LkfCnhg=","metadata":{},"hash":"M2p65b9bCCw5yb6dlx4fxoHC/QWoKidwi45B+KCq/FQ="},"PREVIOUS":{"nodeId":"1caf04d3-f08b-493e-9c0d-547d5a6b1982","metadata":{},"hash":"PIuV/Es0BMB5bB/5yC+mFgmy4i/zZgzgkCCBlEhVF30="}},"hash":"Mo/cLQem8zbAvbQ4bQA0Xn5CEZ/UUeYEzuN+41M4Vto=","text":"These entries provide detailed information about the\r\nperformance events related to the metric.navigationType\r\n: Indicates the type of navigation that triggered the metric collection. Possible values include \"navigate\",\r\n\"reload\", \"back_forward\", and \"prerender\". rating: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are \"good\", \"needs-\r\nimprovement\", and \"poor\". The rating is typically determined by comparing the metric value against predefined thresholds that\r\nindicate acceptable or suboptimal performance.value\r\n: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure\r\nof the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3a97e9b3-c876-4786-bc2a-d4b494097790":{"id_":"3a97e9b3-c876-4786-bc2a-d4b494097790","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YpbAYA+8UP23GjD2yH9Z+/Hm313nery3LTRTEThmU50=","metadata":{},"hash":"cwSJ4orB4nxgsHsnaO2wkBJAHO4NH04I2hu2p1uX3CM="}},"hash":"K6o8E7sXVo9EPuutiMsP/7eT1+v5XfiotYK2JG4gueg=","text":"can come from various Performance APIs. Web Vitals\r\nWeb Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:\r\nTime to First Byte (TTFB)\r\nFirst Contentful Paint (FCP)\r\nLargest Contentful Paint (LCP)\r\nFirst Input Delay (FID)\r\nCumulative Layout Shift (CLS)\r\nInteraction to Next Paint (INP)\r\nYou can handle all the results of these metrics using the name property. pages/_app.js (jsx)import { useReportWebVitals } from 'next/web-vitals'\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n  return <Component {...pageProps} />\r\n}\r\napp/components/web-vitals.tsx (tsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n}\r\napp/components/web-vitals.js (jsx)'use client'\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ... }\r\n  })\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8a406778-d7b8-45c1-ab5f-f791c7946cb1":{"id_":"8a406778-d7b8-45c1-ab5f-f791c7946cb1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iOfiuiq5jM9spD28ESc72QoQpwDqxHKRovUMx98a6Ew=","metadata":{},"hash":"7yAHY9YD7KefEnjsqTBDmaRRdQIKG1Q6IgqJBTJh/+Q="},"NEXT":{"nodeId":"6debede7-2dba-4470-9631-92bc804e1d67","metadata":{},"hash":"3K/b2kemctLYh6KFkvYIsoG01qhPuQK916FNHq4CJDI="}},"hash":"GDXA1hUnpuG5r6MqrcgIn1q1OT+YxdWpIe5bfqN85zA=","text":"Custom Metrics\r\nIn addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to\r\nhydrate and render:\r\nNext.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms)\r\nNext.js-route-change-to-render: Length of time it takes for a page to start rendering after a route change (in ms)\r\nNext.js-render: Length of time it takes for a page to finish render after a route change (in ms)\r\nYou can handle all the results of these metrics separately:\r\nexport function reportWebVitals(metric) {\r\n  switch (metric.name) {\r\n    case 'Next.js-hydration':\r\n      // handle hydration results\r\n      break\r\n    case 'Next.js-route-change-to-render':\r\n      // handle route-change to render results\r\n      break\r\n    case 'Next.js-render':\r\n      // handle render results\r\n      break\r\n    default:\r\n      break\r\n  }\r\n}\r\nThese metrics work in all browsers that support the User Timing API. Usage on Vercel\r\nVercel Speed Insights are automatically configured on Vercel deployments, and don’t require the use of useReportWebVitals. This\r\nhook is useful in local development, or if you’re using a different analytics service. Sending results to external systems\r\nYou can send results to any endpoint to measure and track real user performance on your site. For example:\r\nuseReportWebVitals((metric) => {\r\n  const body = JSON.stringify(metric)\r\n  const url = 'https://example.com/analytics'\r\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`. if (navigator.sendBeacon) {\r\n    navigator.sendBeacon(url, body)\r\n  } else {\r\n    fetch(url, { body, method: 'POST', keepalive: true })\r\n  }\r\n})\r\nGood to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to\r\ncalculate percentiles, etc. )\r\njs useReportWebVitals(metric => { // Use `window.gtag` if you initialized Google Analytics as this\r\nexample: // https://github.com/vercel/next.js/blob/canary/examples/with-google-\r\nanalytics/pages/_app.js window.gtag('event', metric.name, { value: Math.round(metric.name === 'CLS'\r\n?","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6debede7-2dba-4470-9631-92bc804e1d67":{"id_":"6debede7-2dba-4470-9631-92bc804e1d67","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iOfiuiq5jM9spD28ESc72QoQpwDqxHKRovUMx98a6Ew=","metadata":{},"hash":"7yAHY9YD7KefEnjsqTBDmaRRdQIKG1Q6IgqJBTJh/+Q="},"PREVIOUS":{"nodeId":"8a406778-d7b8-45c1-ab5f-f791c7946cb1","metadata":{},"hash":"GDXA1hUnpuG5r6MqrcgIn1q1OT+YxdWpIe5bfqN85zA="}},"hash":"3K/b2kemctLYh6KFkvYIsoG01qhPuQK916FNHq4CJDI=","text":"metric.value * 1000 : metric.value), // values must be integers event_label: metric.id, // id\r\nunique to current page load non_interaction: true, // avoids affecting bounce rate. }); }\r\nRead more about sending results to Google Analytics.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"95774e7d-8832-488e-a91d-18ee6fec28da":{"id_":"95774e7d-8832-488e-a91d-18ee6fec28da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CONZXiNVxBNUiaj9VucJJ/DNZQqFNXHSh6OaVZGlMnk=","metadata":{},"hash":"JwIBwpXunxH2cWodnc7G5bRhCiWXdcj7DrP1y74GnHE="},"NEXT":{"nodeId":"afc989b9-1855-4f71-aee0-5588e0ae314a","metadata":{},"hash":"ro7Bf1laSQMH/XSlmFcE/xPGJvApO74kAMgOy/RrrhY="}},"hash":"rN47MnqTLG3gt5S7v2SpU0o8rsnd3BXC+Qk6fs0b7pg=","text":"3.2.3.23 - useRouter\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-router\r\nDescription: API reference for the useRouter hook. The useRouter hook allows you to programmatically change routes inside Client Components. Recommendation: Use the <Link> component for navigation unless you have a specific requirement for using useRouter. app/example-client-component.tsx (tsx)'use client'\r\nimport { useRouter } from 'next/navigation'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { useRouter } from 'next/navigation'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}\r\nuseRouter()useRouter()\r\nrouter.push(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route. Adds a new\r\nentry into the browser’s history stack.router.replace(href: string, { scroll: boolean })\r\n: Perform a client-side navigation to the provided route without\r\nadding a new entry into the browser’s history stack.router.refresh()\r\n: Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering\r\nServer Components. The client will merge the updated React Server Component payload without losing unaffected client-side React\r\n(e.g. useState) or browser state (e.g. scroll position). router.prefetch(href: string): Prefetch the provided route for faster client-side transitions. router.back(): Navigate back to the previous route in the browser’s history stack. router.forward(): Navigate forwards to the next page in the browser’s history stack. Good to know:\r\nThe <Link> component automatically prefetch routes as they become visible in the viewport. refresh() could re-produce the same result if fetch requests are cached. Other dynamic functions like cookies and\r\nheaders could also change the response. Migrating from next/routernext/router\r\nThe useRouter hook should be imported from next/navigation and not next/router when using the App Router\r\nThe pathname string has been removed and is replaced by usePathname()\r\nThe query object has been removed and is replaced by useSearchParams()\r\nrouter.events has been replaced. See below.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"afc989b9-1855-4f71-aee0-5588e0ae314a":{"id_":"afc989b9-1855-4f71-aee0-5588e0ae314a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CONZXiNVxBNUiaj9VucJJ/DNZQqFNXHSh6OaVZGlMnk=","metadata":{},"hash":"JwIBwpXunxH2cWodnc7G5bRhCiWXdcj7DrP1y74GnHE="},"PREVIOUS":{"nodeId":"95774e7d-8832-488e-a91d-18ee6fec28da","metadata":{},"hash":"rN47MnqTLG3gt5S7v2SpU0o8rsnd3BXC+Qk6fs0b7pg="}},"hash":"ro7Bf1laSQMH/XSlmFcE/xPGJvApO74kAMgOy/RrrhY=","text":"See below. View the full migration guide.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"243a7b6b-851f-46e0-8df1-ee2e9ccd8e02":{"id_":"243a7b6b-851f-46e0-8df1-ee2e9ccd8e02","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SyB/DUaIdaop8VoP/vi1L8we+U48Hi8AvA+xIRR9LJA=","metadata":{},"hash":"4MJ2qnKN9vBQBFVLwscRy3NnWG94gFJjMANTifpXiQA="}},"hash":"aZuiqOJIE6NJFKjZZx4EZaH3Pm2mRLxHnJbjifNK3OQ=","text":"Examples\r\nRouter events\r\nYou can listen for page changes by composing other Client Component hooks like usePathname and useSearchParams. app/components/navigation-events.js (jsx)'use client'\r\nimport { useEffect } from 'react'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\nexport function NavigationEvents() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    const url = `${pathname}?${searchParams}`\r\n    console.log(url)\r\n    // You can now use the current URL\r\n    // ... }, [pathname, searchParams])\r\n  return null\r\n}\r\nWhich can be imported into a layout. ```jsx filename=”app/layout.js” highlight={2,10-12} import { Suspense } from ‘react’ import { NavigationEvents } from\r\n‘./components/navigation-events’\r\nexport default function Layout({ children }) { return (\r\n    <Suspense fallback={null}>\r\n      <NavigationEvents />\r\n    </Suspense>\r\n  </body>\r\n</html>\r\n) }\r\n> **Good to know**: `<NavigationEvents>` is wrapped in a [`Suspense` boundary](/docs/app/building-your-application\r\n### Disabling scroll restoration\r\nBy default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this\r\n<div class=\"code-header\"><i>app/example-client-component.tsx (tsx)</i></div>\r\n```tsx\r\n'use client'\r\nimport { useRouter } from 'next/navigation'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => router.push('/dashboard', { scroll: false })}\r\n    >\r\n      Dashboard\r\n    </button>\r\n  )\r\n}\r\napp/example-client-component.jsx (jsx)'use client'\r\nimport { useRouter } from 'next/navigation'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fb2070a9-d918-40f9-8881-975365c25943":{"id_":"fb2070a9-d918-40f9-8881-975365c25943","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"laAp/N/Nt7XGEIa8V43RhOBimX7RRQYjVQ5fo8d7t14=","metadata":{},"hash":"fhjWtGbuBkKkpuGuPYrKRQvPHpWMRfHexBVPt2AQbpI="}},"hash":"hiOGJMctO38k8I8cx9YkdmINpJfBFwrTpXPvtjRvj3s=","text":"type=\"button\"\r\n      onClick={() => router.push('/dashboard', { scroll: false })}\r\n    >\r\n      Dashboard\r\n    </button>\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.0.0useRouter from next/navigation introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f6c447f1-a215-4520-9923-ee6da59d0289":{"id_":"f6c447f1-a215-4520-9923-ee6da59d0289","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c/9uxtgJ2fYu+9MJxQtmhV9zzvT+Ue52oZHvtcxK4Cw=","metadata":{},"hash":"mXDSi/Cq76NHyF7sCMkEn3AM+yMOKE7M0mkIjGAIYso="}},"hash":"CdFMFXhrCKOusfLhbge+wxwrq1xH6KO/L8lHNCeI+0Y=","text":"3.2.3.24 - useSearchParams\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-search-params\r\nDescription: API Reference for the useSearchParams hook. useSearchParams is a Client Component hook that lets you read the current URL’s query string. useSearchParams returns a read-only version of the URLSearchParams interface. app/dashboard/search-bar.tsx (tsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')\r\n  // URL -> `/dashboard?search=my-project`\r\n  // `search` -> 'my-project'\r\n  return <>Search: {search}</>\r\n}\r\napp/dashboard/search-bar.js (jsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')\r\n  // URL -> `/dashboard?search=my-project`\r\n  // `search` -> 'my-project'\r\n  return <>Search: {search}</>\r\n}\r\nParameters\r\nconst searchParams = useSearchParams()\r\nuseSearchParams does not take any parameters. Returns\r\nuseSearchParams returns a read-only version of the URLSearchParams interface, which includes utility methods for reading the\r\nURL’s query string:\r\nURLSearchParams.get(): Returns the first value associated with the search parameter. For example:\r\nURLsearchParams.get(\"a\")searchParams.get(\"a\")\r\n/dashboard?a=1'1'\r\n/dashboard?a=''\r\n/dashboard?b=3null\r\n/dashboard?a=1&a=2'1' - use getAll() to get all values\r\nURLSearchParams.has(): Returns a boolean value indicating if the given parameter exists. For example:\r\nURLsearchParams.has(\"a\")searchParams.has(\"a\")\r\n/dashboard?a=1true","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"353fb0c0-b33a-4005-83fb-1aaab5008cfa":{"id_":"353fb0c0-b33a-4005-83fb-1aaab5008cfa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"v8HwvTaOG4i0S7+HQ6DwkAf/menrgcL6E9eQ+il3vIY=","metadata":{},"hash":"XownYpiSk6NHefxQOalfZEgPcNsWi5J4WqSLIV9RafI="}},"hash":"cUTPTlP6z1fnGj2j9dsQdgbpBSUvshLWRdcTUv7kbE8=","text":"/dashboard?b=3false\r\nURLsearchParams.has(\"a\")searchParams.has(\"a\")\r\nLearn more about other read-only methods of URLSearchParams, including the getAll(), keys(), values(), entries(),\r\nforEach(), and toString(). Good to know:\r\nuseSearchParams is a Client Component hook and is not supported in Server Components to prevent stale values during\r\npartial rendering. If an application includes the /pages directory, useSearchParams will return ReadonlyURLSearchParams | null. The\r\nnull value is for compatibility during migration since search params cannot be known during pre-rendering of a page that\r\ndoesn’t use getServerSideProps\r\nBehavior\r\nStatic Rendering\r\nIf a route is statically rendered, calling useSearchParams() will cause the tree up to the closest Suspense boundary to be client-side\r\nrendered. This allows a part of the page to be statically rendered while the dynamic part that uses searchParams is client-side rendered. You can reduce the portion of the route that is client-side rendered by wrapping the component that uses useSearchParams in a\r\nSuspense boundary. For example:\r\napp/dashboard/search-bar.tsx (tsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')\r\n  // This will not be logged on the server when using static rendering\r\n  console.log(search)\r\n  return <>Search: {search}</>\r\n}\r\napp/dashboard/search-bar.js (jsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')\r\n  // This will not be logged on the server when using static rendering\r\n  console.log(search)\r\n  return <>Search: {search}</>\r\n}\r\napp/dashboard/page.tsx (tsx)import { Suspense } from 'react'\r\nimport SearchBar from './search-bar'\r\n// This component passed as a fallback to the Suspense boundary\r\n// will be rendered in place of the search bar in the initial HTML. // When the value is available during React hydration the fallback\r\n// will be replaced with the `<SearchBar>` component. function SearchBarFallback() {\r\n  return <>placeholder</>\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b9882071-fd5e-4acc-b66f-705670de1baf":{"id_":"b9882071-fd5e-4acc-b66f-705670de1baf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jQWikHXsYZScFfMyZ2Y6oAaNUf3Ydw0/kXW7C1RKXZg=","metadata":{},"hash":"6ZNTqvNEa+JbdZITg1bGAkBdnLfYQsI3gUXVDhtQ4ac="}},"hash":"peh1md85IAajBrsQbhtQLz3I3dEhyd8NyoWL3OD7wkg=","text":"export default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}\r\napp/dashboard/page.js (jsx)import { Suspense } from 'react'\r\nimport SearchBar from './search-bar'\r\n// This component passed as a fallback to the Suspense boundary\r\n// will be rendered in place of the search bar in the initial HTML. // When the value is available during React hydration the fallback\r\n// will be replaced with the `<SearchBar>` component. function SearchBarFallback() {\r\n  return <>placeholder</>\r\n}\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}\r\nDynamic Rendering\r\nIf a route is dynamically rendered, useSearchParams will be available on the server during the initial server render of the Client\r\nComponent. Good to know: Setting the dynamic route segment config option to force-dynamic can be used to force dynamic rendering. For example:\r\napp/dashboard/search-bar.tsx (tsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')\r\n  // This will be logged on the server during the initial render\r\n  // and on the client on subsequent navigations. console.log(search)\r\n  return <>Search: {search}</>\r\n}\r\napp/dashboard/search-bar.js (jsx)'use client'\r\nimport { useSearchParams } from 'next/navigation'\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n  const search = searchParams.get('search')","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1552db2a-d7db-489f-b9e5-41b063ad93b6":{"id_":"1552db2a-d7db-489f-b9e5-41b063ad93b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"5eksZSW1dxHKLT6Oin7TA21YQIy9UDRyvPYMuZkfDfI=","metadata":{},"hash":"sRN4P9JncaSdWO4T89ceG3f0xSl1Hq1I3viZcZMfApY="}},"hash":"+WtMofrZGy0Uc6cyHrTDBH7dJiV53r8mupOgLjdmO74=","text":"// This will be logged on the server during the initial render\r\n  // and on the client on subsequent navigations. console.log(search)\r\n  return <>Search: {search}</>\r\n}\r\napp/dashboard/page.tsx (tsx)import SearchBar from './search-bar'\r\nexport const dynamic = 'force-dynamic'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <SearchBar />\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}\r\napp/dashboard/page.js (jsx)import SearchBar from './search-bar'\r\nexport const dynamic = 'force-dynamic'\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <SearchBar />\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}\r\nServer Components\r\nPages\r\nTo access search params in Pages (Server Components), use the searchParams prop. Layouts\r\nUnlike Pages, Layouts (Server Components) do not receive the searchParams prop. This is because a shared layout is not re-rendered\r\nduring navigation which could lead to stale searchParams between navigations. View detailed explanation. Instead, use the Page searchParams prop or the useSearchParams hook in a Client Component, which is re-rendered on the client\r\nwith the latest searchParams. Examples\r\nUpdating searchParamssearchParams\r\nYou can use useRouter or Link to set new searchParams. After a navigation is performed, the current page.js will receive an\r\nupdated searchParams prop. app/example-client-component.tsx (tsx)export default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()! // Get a new searchParams string by merging the current\r\n  // searchParams with a provided key/value pair\r\n  const createQueryString = useCallback(\r\n    (name: string, value: string) => {\r\n      const params = new URLSearchParams(searchParams)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a6de6a40-3fe1-4625-b2d0-1165fe14e7bb":{"id_":"a6de6a40-3fe1-4625-b2d0-1165fe14e7bb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kpo4a9jfAGc6q5He3UgnEJDuf/036GWF55SrczgYdtk=","metadata":{},"hash":"m6IjgSM8F91hKMPkNNABhvH0FpBuknhFHDKaF1Ns1VQ="}},"hash":"9MasSsCT4JFiXXkbmE28ZCg1bvefE0f6pCd9stHr0p4=","text":"params.set(name, value)\r\n      return params.toString()\r\n    },\r\n    [searchParams]\r\n  )\r\n  return (\r\n    <>\r\n      <p>Sort By</p>\r\n      {/* using useRouter */}\r\n      <button\r\n        onClick={() => {\r\n          // <pathname>?sort=asc\r\n          router.push(pathname + '? ' + createQueryString('sort', 'asc'))\r\n        }}\r\n      >\r\n        ASC\r\n      </button>\r\n      {/* using <Link> */}\r\n      <Link\r\n        href={\r\n          // <pathname>?sort=desc\r\n          pathname + '? ' + createQueryString('sort', 'desc')\r\n        }\r\n      >\r\n        DESC\r\n      </Link>\r\n    </>\r\n  )\r\n}\r\napp/example-client-component.js (jsx)export default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  // Get a new searchParams string by merging the current\r\n  // searchParams with a provided key/value pair\r\n  const createQueryString = useCallback(\r\n    (name, value) => {\r\n      const params = new URLSearchParams(searchParams)\r\n      params.set(name, value)\r\n      return params.toString()\r\n    },\r\n    [searchParams]\r\n  )\r\n  return (\r\n    <>\r\n      <p>Sort By</p>\r\n      {/* using useRouter */}\r\n      <button\r\n        onClick={() => {\r\n          // <pathname>?sort=asc\r\n          router.push(pathname + '? ' + createQueryString('sort', 'asc'))\r\n        }}\r\n      >\r\n        ASC\r\n      </button>\r\n      {/* using <Link> */}\r\n      <Link\r\n        href={\r\n          // <pathname>?sort=desc\r\n          pathname + '? ' + createQueryString('sort', 'desc')\r\n        }\r\n      >\r\n        DESC\r\n      </Link>\r\n    </>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ef87bda7-a17d-4fbb-bee4-1df8acbdd611":{"id_":"ef87bda7-a17d-4fbb-bee4-1df8acbdd611","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1LoNIS0c0iR9VQGHUDmwLDYgiG+7pLcNfFBhcHXG6mE=","metadata":{},"hash":"vozL1jVrQAO8TrVOAr/V3AMnK0Zl/oCzrjmKFlV09J4="}},"hash":"AzxM47hBk43E2MTi9lsmgpfhGPRk0NQFlnutLrcMlg8=","text":")\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.0.0useSearchParams introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ef6c4495-fbee-4b9a-976a-a53636baf6ac":{"id_":"ef6c4495-fbee-4b9a-976a-a53636baf6ac","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kYr+99JPC8b/mU7KZjB572uzX5QqdvWGGzSmd45vA+U=","metadata":{},"hash":"S8GaItMy4zIdjX3EYaCuPj2gHW6MYft+WreFgsVYtIo="}},"hash":"2+9dNU86A4vzxS3OeDaXjW9sUcANzQ6kY9tJ6zIkg/I=","text":"3.2.3.25 - useSelectedLayoutSegment\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-selected-layout-segment\r\nDescription: API Reference for the useSelectedLayoutSegment hook. useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it\r\nis called from. It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment. app/example-client-component.tsx (tsx)'use client'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const segment = useSelectedLayoutSegment()\r\n  return <p>Active segment: {segment}</p>\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const segment = useSelectedLayoutSegment()\r\n  return <p>Active segment: {segment}</p>\r\n}\r\nGood to know:\r\nSince useSelectedLayoutSegment is a Client Component hook, and Layouts are Server Components by default,\r\nuseSelectedLayoutSegment is usually called via a Client Component that is imported into a Layout. useSelectedLayoutSegment only returns the segment one level down. To return all active segments, see\r\nuseSelectedLayoutSegments\r\nParameters\r\nconst segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\r\nuseSelectedLayoutSegment optionally accepts a parallelRoutesKey, which allows you to read the active route segment within\r\nthat slot. Returns\r\nuseSelectedLayoutSegment returns a string of the active segment or null if one doesn’t exist. For example, given the Layouts and URLs below, the returned segment would be:\r\nLayoutVisited URLReturned Segment\r\napp/layout.js/null\r\napp/layout.js/dashboard'dashboard'\r\napp/dashboard/layout.js/dashboardnull\r\napp/dashboard/layout.js/dashboard/settings'settings'\r\napp/dashboard/layout.js/dashboard/analytics'analytics'\r\napp/dashboard/layout.js/dashboard/analytics/monthly'analytics'\r\nExamples","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3312918b-2ba6-44bc-8063-591f452df5e3":{"id_":"3312918b-2ba6-44bc-8063-591f452df5e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lCUHhkay0KhgkAXmjrlypBs3BgziH1TJA97kQ6bRGxI=","metadata":{},"hash":"nmbTF69JnpAFJLr6303Wn6vKUOfVCK6AR60LCajem1E="}},"hash":"46eMXnqbg78cvb1jmITyV05pKhaz5aNHn9OI1HBmHLs=","text":"Creating an active link component\r\nYou can use useSelectedLayoutSegment to create an active link component that changes style depending on the active segment. For\r\nexample, a featured posts list in the sidebar of a blog:\r\napp/blog/blog-nav-link.tsx (tsx)'use client'\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n// This *client* component will be imported into a blog layout\r\nexport default function BlogNavLink({\r\n  slug,\r\n  children,\r\n}: {\r\n  slug: string\r\n  children: React.ReactNode\r\n}) {\r\n  // Navigating to `/blog/hello-world` will return 'hello-world'\r\n  // for the selected layout segment\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      // Change style depending on whether the link is active\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}\r\napp/blog/blog-nav-link.js (jsx)'use client'\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n// This *client* component will be imported into a blog layout\r\nexport default function BlogNavLink({ slug, children }) {\r\n  // Navigating to `/blog/hello-world` will return 'hello-world'\r\n  // for the selected layout segment\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      // Change style depending on whether the link is active\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}\r\napp/blog/layout.tsx (tsx)// Import the Client Component into a parent Layout (Server Component)\r\nimport { BlogNavLink } from './blog-nav-link'\r\nimport getFeaturedPosts from './get-featured-posts'\r\nexport default async function Layout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const featuredPosts = await getFeaturedPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5577334e-14c9-463a-9089-3b50b927807e":{"id_":"5577334e-14c9-463a-9089-3b50b927807e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tZlciWj2ddN9JGpZkvl8XDNuc0B43cS6tcCy/SXxSs4=","metadata":{},"hash":"0HTCX2PuzQkaAj1+usDB/IgeyZ/DeXYGKG0ToSbVFLg="}},"hash":"cK930MS6060YZAxuYqN/0H0fIU8Z1kuXA4TA6K6KE0g=","text":"</div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}\r\napp/blog/layout.js (jsx)// Import the Client Component into a parent Layout (Server Component)\r\nimport { BlogNavLink } from './blog-nav-link'\r\nimport getFeaturedPosts from './get-featured-posts'\r\nexport default async function Layout({ children }) {\r\n  const featuredPosts = await getFeaturedPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\r\n        </div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.0.0useSelectedLayoutSegment introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a0cb6209-200f-4ea6-a286-a428fca3c91e":{"id_":"a0cb6209-200f-4ea6-a286-a428fca3c91e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pTotquwP3Ew+CLGJx1duTuf98BnwltTa0svEbTLpwJc=","metadata":{},"hash":"J6xKirvgKQ4uwGm+Ltdal4z+py7jrGQJdHKlpnWkvZ4="}},"hash":"is8AkTDUo8oGe5K9Y9hzYeeKN1LSt9tB5F6UKxm+bFA=","text":"3.2.3.26 - useSelectedLayoutSegments\r\nDocumentation path: /02-app/02-api-reference/04-functions/use-selected-layout-segments\r\nDescription: API Reference for the useSelectedLayoutSegments hook. useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called\r\nfrom. It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs. app/example-client-component.tsx (tsx)'use client'\r\nimport { useSelectedLayoutSegments } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const segments = useSelectedLayoutSegments()\r\n  return (\r\n    <ul>\r\n      {segments.map((segment, index) => (\r\n        <li key={index}>{segment}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\napp/example-client-component.js (jsx)'use client'\r\nimport { useSelectedLayoutSegments } from 'next/navigation'\r\nexport default function ExampleClientComponent() {\r\n  const segments = useSelectedLayoutSegments()\r\n  return (\r\n    <ul>\r\n      {segments.map((segment, index) => (\r\n        <li key={index}>{segment}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nGood to know:\r\nSince useSelectedLayoutSegments is a Client Component hook, and Layouts are Server Components by default,\r\nuseSelectedLayoutSegments is usually called via a Client Component that is imported into a Layout. The returned segments include Route Groups, which you might not want to be included in your UI. You can use thefilter()\r\n array method to remove items that start with a bracket. Parameters\r\nconst segments = useSelectedLayoutSegments(parallelRoutesKey?: string)\r\nuseSelectedLayoutSegments optionally accepts a parallelRoutesKey, which allows you to read the active route segment within\r\nthat slot. Returns\r\nuseSelectedLayoutSegments returns an array of strings containing the active segments one level down from the layout the hook\r\nwas called from. Or an empty array if none exist. For example, given the Layouts and URLs below, the returned segments would be:\r\nLayoutVisited URLReturned Segments\r\napp/layout.js/[]","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e2815c48-a1c0-4d6c-a2dd-cf8b011b4b92":{"id_":"e2815c48-a1c0-4d6c-a2dd-cf8b011b4b92","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"eUyeEV37PoN6MMiwcjhFQjTeVd0d3AvSMT4Tcyq/P6Q=","metadata":{},"hash":"ZAxPCteJ7x978Zh9okqc/0AQ/v+NGrs85kk7Eb3ZLkg="}},"hash":"c/I+KNpNaLUcsELhxqRqdUImvsubUcPdSugoV3XO22A=","text":"app/layout.js/dashboard['dashboard']\r\napp/layout.js/dashboard/settings['dashboard', 'settings']\r\napp/dashboard/layout.js/dashboard[]\r\napp/dashboard/layout.js/dashboard/settings['settings']\r\nLayoutVisited URLReturned Segments\r\nVersion History\r\nVersionChanges\r\nv13.0.0useSelectedLayoutSegments introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b03fb0c1-da9f-4c47-bbc7-ebf0646368e3":{"id_":"b03fb0c1-da9f-4c47-bbc7-ebf0646368e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WgOsuVG6bSWTuy7dU0lHBy1U7Olw3SAVd+1avaMm2dw=","metadata":{},"hash":"tBpVAvqRGUoMsGU5LoOT1QQqdMEWZoJZ2JIAE4Dz8/w="},"NEXT":{"nodeId":"9aa4aabc-6cc9-46db-881f-0f0a31d67818","metadata":{},"hash":"6FYYO75h82QDJxtIfuBew1womPMtqNsuJFvWF/SLbpU="}},"hash":"wB2LsmL5I2Hx/SXhjoEvwVf6+yfuZASuX0WvS9l4vbg=","text":"3.2.3.27 - userAgent\r\nDocumentation path: /02-app/02-api-reference/04-functions/userAgent\r\nDescription: The userAgent helper extends the Web Request API with additional properties and methods to interact with the user\r\nagent object from the request. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThe userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object\r\nfrom the request. middleware.ts (ts)import { NextRequest, NextResponse, userAgent } from 'next/server'\r\nexport function middleware(request: NextRequest) {\r\n  const url = request.nextUrl\r\n  const { device } = userAgent(request)\r\n  const viewport = device.type === 'mobile' ? 'mobile' : 'desktop'\r\n  url.searchParams.set('viewport', viewport)\r\n  return NextResponse.rewrite(url)\r\n}\r\nmiddleware.js (js)import { NextResponse, userAgent } from 'next/server'\r\nexport function middleware(request) {\r\n  const url = request.nextUrl\r\n  const { device } = userAgent(request)\r\n  const viewport = device.type === 'mobile' ? 'mobile' : 'desktop'\r\n  url.searchParams.set('viewport', viewport)\r\n  return NextResponse.rewrite(url)\r\n}\r\nisBotisBot\r\nA boolean indicating whether the request comes from a known bot.browserbrowser\r\nAn object containing information about the browser used in the request. name: A string representing the browser’s name, or undefined if not identifiable. version: A string representing the browser’s version, or undefined. devicedevice\r\nAn object containing information about the device used in the request. model: A string representing the model of the device, or undefined. type: A string representing the type of the device, such as console, mobile, tablet, smarttv, wearable, embedded, or\r\nundefined. vendor: A string representing the vendor of the device, or undefined. engineengine\r\nAn object containing information about the browser’s engine. name: A string representing the engine’s name.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9aa4aabc-6cc9-46db-881f-0f0a31d67818":{"id_":"9aa4aabc-6cc9-46db-881f-0f0a31d67818","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WgOsuVG6bSWTuy7dU0lHBy1U7Olw3SAVd+1avaMm2dw=","metadata":{},"hash":"tBpVAvqRGUoMsGU5LoOT1QQqdMEWZoJZ2JIAE4Dz8/w="},"PREVIOUS":{"nodeId":"b03fb0c1-da9f-4c47-bbc7-ebf0646368e3","metadata":{},"hash":"wB2LsmL5I2Hx/SXhjoEvwVf6+yfuZASuX0WvS9l4vbg="}},"hash":"6FYYO75h82QDJxtIfuBew1womPMtqNsuJFvWF/SLbpU=","text":"name: A string representing the engine’s name. Possible values include: Amaya, Blink, EdgeHTML, Flow, Gecko, Goanna, iCab,\r\nKHTML, Links, Lynx, NetFront, NetSurf, Presto, Tasman, Trident, w3m, WebKit or undefined. version: A string representing the engine’s version, or undefined. osos","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e6c48109-1215-4722-92a9-9b6d4bf0da08":{"id_":"e6c48109-1215-4722-92a9-9b6d4bf0da08","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AO9tKkvsNp2ObPF1M45K1RS96lUjwhFmX4lygfRfHlo=","metadata":{},"hash":"6ScRzGevMW0dzzTAQyLrO3lPAlv+kXRV7AGQeFvFxHE="}},"hash":"bMIjyTIQ870ECc7+V6ERqOIap9tzMgY4ZsxuutLFrs0=","text":"An object containing information about the operating system. name: A string representing the name of the OS, or undefined. version: A string representing the version of the OS, or undefined. cpucpu\r\nAn object containing information about the CPU architecture. architecture: A string representing the architecture of the CPU. Possible values include: 68k, amd64, arm, arm64, armhf, avr,\r\nia32, ia64, irix, irix64, mips, mips64, pa-risc, ppc, sparc, sparc64 or undefined","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bc7019ba-21ec-40de-b826-5b389e8cae13":{"id_":"bc7019ba-21ec-40de-b826-5b389e8cae13","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JTRjztj6FFL+yIUKHR0HQZ3QPs7Po/LNu60joGiiXC8=","metadata":{},"hash":"JIH+pwGec3OrFJmpyysiegGqJEYMGaN7iI4tCBIaunk="}},"hash":"cJ4OCccfdWqLPAT4VKeFFHzaXkwV1g854x8tUZtxaXI=","text":"3.2.4 - next.config.js Options\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/index\r\nDescription: Learn how to configure your application with next.config.js. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json). next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\nmodule.exports = nextConfig\r\nnext.config.js is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it’s not included\r\nin the browser build. If you need ECMAScript modules, you can use next.config.mjs:\r\nnext.config.mjs (js)/**\r\n * @type {import('next').NextConfig}\r\n */\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\nexport default nextConfig\r\nYou can also use a function:\r\nnext.config.mjs (js)export default (phase, { defaultConfig }) => {\r\n  /**\r\n   * @type {import('next').NextConfig}\r\n   */\r\n  const nextConfig = {\r\n    /* config options here */\r\n  }\r\n  return nextConfig\r\n}\r\nSince Next.js 12.1.0, you can use an async function:\r\nnext.config.js (js)module.exports = async (phase, { defaultConfig }) => {\r\n  /**\r\n   * @type {import('next').NextConfig}\r\n   */\r\n  const nextConfig = {\r\n    /* config options here */\r\n  }\r\n  return nextConfig\r\n}\r\nphase is the current context in which the configuration is loaded. You can see the available phases. Phases can be imported from\r\nnext/constants:\r\nconst { PHASE_DEVELOPMENT_SERVER } = require('next/constants')\r\nmodule.exports = (phase, { defaultConfig }) => {\r\n  if (phase === PHASE_DEVELOPMENT_SERVER) {\r\n    return {\r\n      /* development only config options here */\r\n    }\r\n  }\r\n  return {\r\n    /* config options for all phases except development here */","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"16fd086f-9a74-4799-b6bd-2b1b717e30b6":{"id_":"16fd086f-9a74-4799-b6bd-2b1b717e30b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4lRGkkrL3mqQQr2KxV84v7mOzzRYx6ch0kiThLdMnRM=","metadata":{},"hash":"gGA5MiR6ymy9RfYI2ZYBwY9pfcqY6USpdGwuayDGm7g="}},"hash":"I38FeRMCR07x3wiimzyZzIgmtochuNwWVgvIprFJjsQ=","text":"}\r\n}\r\nThe commented lines are the place where you can put the configs allowed by next.config.js, which are defined in this file. However, none of the configs are required, and it’s not necessary to understand what each config does. Instead, search for the features\r\nyou need to enable or modify in this section and they will show you what to do. Avoid using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by\r\nWebpack, Babel or TypeScript. This page documents all the available configuration options:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dc88f9ea-697f-4a81-94ce-ef56f554a6a1":{"id_":"dc88f9ea-697f-4a81-94ce-ef56f554a6a1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QnPV371WkbMq2eOKA5xKD2emvLj/OjLGAJNFsRxpHYU=","metadata":{},"hash":"ZSwue2LzQMYGe0cYwIEy2Pvbk2qSyaPkWo8U/RgploE="}},"hash":"afb9HhwMAonAvQ4eWRXJCltG4098fZiEDd6KgZDFHSo=","text":"3.2.4.1 - appDir\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/appDir\r\nDescription: Enable the App Router to use layouts, streaming, and more. Good to know: This option is no longer needed as of Next.js 13.4. The App Router is now stable. The App Router (app directory) enables support for layouts, Server Components, streaming, and colocated data fetching. Using the app directory will automatically enable React Strict Mode. Learn how to incrementally adopt app.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d1b71d01-413e-4272-a8b6-5430fddc7108":{"id_":"d1b71d01-413e-4272-a8b6-5430fddc7108","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"epYIDkR8+9vAQ1Kdcrz5GrcuQ28NU3EGZ9VsRZqJ1Zo=","metadata":{},"hash":"7xsS/2wF4voS/C3cnOL32sp1LAJ/qgL4EfCfderZ+Cg="},"NEXT":{"nodeId":"e66bbe66-203b-4ab7-ad98-1f1ebbc88c0c","metadata":{},"hash":"E86f6rNkzKkq5eqqazWM+oiqs+aHWoC+u2o2NV9mrBU="}},"hash":"TUPnDTb1XvXQlNKnXNAy7jwtTlvnSl7R7gukdZlFUZw=","text":"3.2.4.2 - assetPrefix\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/assetPrefix\r\nDescription: Learn how to use the assetPrefix config option to configure your CDN. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nAttention: Deploying to Vercel automatically configures a global CDN for your Next.js project. You do not need to manually\r\nsetup an Asset Prefix. Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. You do not need to manually\r\nsetup an Asset Prefix. Good to know: Next.js 9.5+ added support for a customizable Base Path, which is better suited for hosting your application on\r\na sub-path like /docs. We do not suggest you use a custom Asset Prefix for this use case. To set up a CDN, you can set up an asset prefix and configure your CDN’s origin to resolve to the domain that Next.js is hosted on. Open next.config.js and add the assetPrefix config:\r\nnext.config.js (js)const isProd = process.env.NODE_ENV === 'production'\r\nmodule.exports = {\r\n  // Use the CDN in production and localhost for development. assetPrefix: isProd ? 'https://cdn.mydomain.com' : undefined,\r\n}\r\nNext.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the /_next/ path (.next/static/ folder). For example, with the above configuration, the following request for a JS chunk:\r\n/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js\r\nWould instead become:\r\nhttps://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js\r\nThe exact configuration for uploading your files to a given CDN will depend on your CDN of choice.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e66bbe66-203b-4ab7-ad98-1f1ebbc88c0c":{"id_":"e66bbe66-203b-4ab7-ad98-1f1ebbc88c0c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"epYIDkR8+9vAQ1Kdcrz5GrcuQ28NU3EGZ9VsRZqJ1Zo=","metadata":{},"hash":"7xsS/2wF4voS/C3cnOL32sp1LAJ/qgL4EfCfderZ+Cg="},"PREVIOUS":{"nodeId":"d1b71d01-413e-4272-a8b6-5430fddc7108","metadata":{},"hash":"TUPnDTb1XvXQlNKnXNAy7jwtTlvnSl7R7gukdZlFUZw="}},"hash":"E86f6rNkzKkq5eqqazWM+oiqs+aHWoC+u2o2NV9mrBU=","text":"The only folder you need to host on\r\nyour CDN is the contents of .next/static/, which should be uploaded as _next/static/ as the above URL request indicates. Do\r\nnot upload the rest of your .next/.next/ folder, as you should not expose your server code and other configuration to the public. While assetPrefix covers requests to _next/static, it does not influence the following paths:\r\nFiles in the public folder; if you want to serve those assets over a CDN, you’ll have to introduce the prefix yourself\r\nFiles in the public folder; if you want to serve those assets over a CDN, you’ll have to introduce the prefix yourself/_next/data/\r\n requests for getServerSideProps pages. These requests will always be made against the main domain since\r\nthey’re not static./_next/data/\r\n requests for getStaticProps pages. These requests will always be made against the main domain to support\r\nIncremental Static Generation, even if you’re not using it (for consistency).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2772e28a-5c91-4021-969d-d8ed4d6aeee7":{"id_":"2772e28a-5c91-4021-969d-d8ed4d6aeee7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2twlPqr6XqUSTSBnWEuaQdfgXSrzxHm4r9Al6AxmtZA=","metadata":{},"hash":"f/EsKfwmYs0GtZsG0Uu6vpkfFbSSf/ntNiZSQEITTu8="}},"hash":"2UyiQM/spfLiTt5HBYmY2m02vOxyIqqkCY310pzp+RA=","text":"3.2.4.3 - basePath\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/basePath\r\nDescription: Use `basePath` to deploy a Next.js application under a sub-path of a domain. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nTo deploy a Next.js application under a sub-path of a domain you can use the basePath config option. basePath allows you to set a path prefix for the application. For example, to use /docs instead of '' (an empty string, the default),\r\nopen next.config.js and add the basePath config:\r\nnext.config.js (js)module.exports = {\r\n  basePath: '/docs',\r\n}\r\nGood to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the\r\nclient-side bundles. Links\r\nWhen linking to other pages using next/link and next/router the basePath will be automatically applied. For example, using /about will automatically become /docs/about when basePath is set to /docs. export default function HomePage() {\r\n  return (\r\n    <>\r\n      <Link href=\"/about\">About Page</Link>\r\n    </>\r\n  )\r\n}\r\nOutput html:\r\n<a href=\"/docs/about\">About Page</a>\r\nThis makes sure that you don’t have to change all links in your application when changing the basePath value. Images\r\nWhen using the next/image component, you will need to add the basePath in front of src. When using the next/image component, you will need to add the basePath in front of src. For example, using /docs/me.png will properly serve your image when basePath is set to /docs. import Image from 'next/image'\r\nfunction Home() {\r\n  return (\r\n    <>\r\n      <h1>My Homepage</h1>\r\n      <Image\r\n        src=\"/docs/me.png\"\r\n        alt=\"Picture of the author\"\r\n        width={500}\r\n        height={500}\r\n      />\r\n      <p>Welcome to my homepage!</p>\r\n    </>\r\n  )\r\n}\r\nexport default Home","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"04924af0-3e36-446f-8c68-2271b12bf850":{"id_":"04924af0-3e36-446f-8c68-2271b12bf850","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CFgs+6U4GsWju6oLIoH5Z+sAGFDPyDiYJkLW4sIYd8E=","metadata":{},"hash":"U8T9YUwb4COi6tEkv77oSDXTY/LPVkDZnWuvKFRu4Y8="}},"hash":"9W+6G4JwZy+S/jrlA2siOvXLnT/mQ81qLk0INHeguOo=","text":"3.2.4.4 - compress\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/compress\r\nDescription: Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js provides gzip compression to compress rendered content and static files. In general you will want to enable compression on a\r\nHTTP proxy like nginx, to offload load from the Node.js process. To disable compression, open next.config.js and disable the compress config:\r\nnext.config.js (js)module.exports = {\r\n  compress: false,\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ff20b5f4-2b49-4673-a0ea-c84fadb71142":{"id_":"ff20b5f4-2b49-4673-a0ea-c84fadb71142","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"paM2lqrNCuAzz/FcRutaAjqgPFcXO0ssubrDlE+kfwo=","metadata":{},"hash":"S/PAGAu36hCBo0wnHFNlxSMKtVAKmGAzBBDLfpAsc3g="}},"hash":"aUOYkGO+C7s9RUOheRnjbAGJ71qVMfQhfnOjlJBDYk4=","text":"3.2.4.5 - devIndicators\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/devIndicators\r\nDescription: Optimized pages include an indicator to let you know if it's being statically optimized. You can opt-out of it here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nWhen you edit your code, and Next.js is compiling the application, a compilation indicator appears in the bottom right corner of the\r\npage. Good to know: This indicator is only present in development mode and will not appear when building and running the app in\r\nproduction mode. In some cases this indicator can be misplaced on your page, for example, when conflicting with a chat launcher. To change its position,\r\nopen next.config.js and set the buildActivityPosition in the devIndicators object to bottom-right (default), bottom-\r\nleft, top-right or top-left:\r\nnext.config.js (js)module.exports = {\r\n  devIndicators: {\r\n    buildActivityPosition: 'bottom-right',\r\n  },\r\n}\r\nIn some cases this indicator might not be useful for you. To remove it, open next.config.js and disable the buildActivity config\r\nin devIndicators object:\r\nnext.config.js (js)module.exports = {\r\n  devIndicators: {\r\n    buildActivity: false,\r\n  },\r\n}\r\nGood to know: This indicator was removed in Next.js version 10.0.1. We recommend upgrading to the latest version of Next.js. When a page qualifies for Automatic Static Optimization we show an indicator to let you know. This is helpful since automatic static optimization can be very beneficial and knowing immediately in development if the page qualifies\r\ncan be useful. In some cases this indicator might not be useful, like when working on electron applications. To remove it open next.config.js and\r\ndisable the autoPrerender config in devIndicators:\r\nnext.config.js (js)module.exports = {\r\n  devIndicators: {\r\n    autoPrerender: false,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4af6633c-d70a-4ad3-b58a-608715ae1172":{"id_":"4af6633c-d70a-4ad3-b58a-608715ae1172","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"enqmQNGvRDiuHHuuUFqAOkNLBo8aTN7iIodi7BfXXYY=","metadata":{},"hash":"5qN4HFECwRQcsaE/OHMmOBX0LdxgT9MSATDpx71HXoQ="}},"hash":"BWoDiRph0m8WPR+sbp8+3EOWsEWVMtc6BHaIB97ZO2Q=","text":"3.2.4.6 - distDir\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/distDir\r\nDescription: Set a custom build directory to use instead of the default .next directory. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nYou can specify a name to use for a custom build directory to use instead of .next. Open next.config.js and add the distDir config:\r\nnext.config.js (js)module.exports = {\r\n  distDir: 'build',\r\n}\r\nNow if you run next build Next.js will use build instead of the default .next folder. distDir should not leave your project directory. For example, ../build is an invalid directory.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"84824cdc-a3fd-4c68-a7f5-05d433b7e0b5":{"id_":"84824cdc-a3fd-4c68-a7f5-05d433b7e0b5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xWPxh0ctw1LJxQZ912ELiQ3e+mSniBC+ZsvZVdWhMok=","metadata":{},"hash":"QuOnphS8myx/QXqTSseTVpEpd/4Gpxi9m9+ytzK8RLU="}},"hash":"ZPJxp0tJ8KChq430cW43sEx6RR8zFie7+B0Md7bfQ7c=","text":"3.2.4.7 - env\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/env\r\nDescription: Learn to add and access environment variables in your Next.js application at build time. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nSince the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give\r\nit a try! Since the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give\r\nit a try! Good to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the\r\nenvironment variable name with NEXT_PUBLIC_ only has an effect when specifying them through the environment or .env files. Good to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the\r\nenvironment variable name with NEXT_PUBLIC_ only has an effect when specifying them through the environment or .env files. To add environment variables to the JavaScript bundle, open next.config.js and add the env config:\r\nnext.config.js (js)module.exports = {\r\n  env: {\r\n    customKey: 'my-value',\r\n  },\r\n}\r\nNow you can access process.env.customKey in your code. For example:\r\nfunction Page() {\r\n  return <h1>The value of customKey is: {process.env.customKey}</h1>\r\n}\r\nexport default Page\r\nNext.js will replace process.env.customKey with 'my-value' at build time. Trying to destructure process.env variables won’t\r\nwork due to the nature of webpack DefinePlugin. For example, the following line:\r\nreturn <h1>The value of customKey is: {process.env.customKey}</h1>\r\nWill end up being:\r\nreturn <h1>The value of customKey is: {'my-value'}</h1>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f98e9104-71d9-405d-9146-7bb5edceca23":{"id_":"f98e9104-71d9-405d-9146-7bb5edceca23","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7q21T6g7ofUAmR51uEKkUsbC2leKUieho5cEOuJ63TM=","metadata":{},"hash":"P9ZsVLHfLXj7vECt8FQrz8Opz6f0Ops/5HbwN/ALmeo="}},"hash":"fsNpWLgmS/5E8WwMYw/OSJpobGDj5zca1m7bU/eLlLk=","text":"3.2.4.8 - eslint\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/eslint\r\nDescription: Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nWhen ESLint is detected in your project, Next.js fails your production build (next build) when errors are present. If you’d like Next.js to produce production code even when your application has ESLint errors, you can disable the built-in linting step\r\ncompletely. This is not recommended unless you already have ESLint configured to run in a separate part of your workflow (for\r\nexample, in CI or a pre-commit hook). Open next.config.js and enable the ignoreDuringBuilds option in the eslint config:\r\nnext.config.js (js)module.exports = {\r\n  eslint: {\r\n    // Warning: This allows production builds to successfully complete even if\r\n    // your project has ESLint errors. ignoreDuringBuilds: true,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e40ec2e5-1ef5-4f46-8078-60cec5aeea74":{"id_":"e40ec2e5-1ef5-4f46-8078-60cec5aeea74","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"easOeClv0CA3IRCAxvSh7l3rVuV48hMUdWKilN1iFMo=","metadata":{},"hash":"97FnHBURQsI9KCOEVtSjRYW6OF5fCzuhs9AQYlX0cs0="},"NEXT":{"nodeId":"75934e58-061e-4482-ace4-afa326ce7a04","metadata":{},"hash":"IHP/n8S8PaDDtax7jO6zYvClDnK0ZJCqf/nYiCglkTE="}},"hash":"hqqTWcLaFtTIbq+/n1tq8PXLac2l/6u1OgWwZGah72A=","text":"3.2.4.9 - exportPathMap (Deprecated)\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/exportPathMap\r\nDescription: Customize the pages that will be exported as HTML files when using `next export`. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThis feature is exclusive to next export and currently deprecated in favor of getStaticPaths with pages or\r\ngenerateStaticParams with app. Examples\r\nexportPathMap allows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined in\r\nexportPathMap will also be available when using next dev. Let’s start with an example, to create a custom exportPathMap for an app with the following pages:\r\npages/index.js\r\npages/about.js\r\npages/post.js\r\nOpen next.config.js and add the following exportPathMap config:\r\nnext.config.js (js)module.exports = {\r\n  exportPathMap: async function (\r\n    defaultPathMap,\r\n    { dev, dir, outDir, distDir, buildId }\r\n  ) {\r\n    return {\r\n      '/': { page: '/' },\r\n      '/about': { page: '/about' },\r\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\r\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\r\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },\r\n    }\r\n  },\r\n}\r\nGood to know: the query field in exportPathMap cannot be used with automatically statically optimized pages orgetStaticProps\r\n pages as they are rendered to HTML files at build-time and additional query information cannot be provided\r\nduring next export. The pages will then be exported as HTML files, for example, /about will become /about.html. exportPathMap is an async function that receives 2 arguments: the first one is defaultPathMap, which is the default map used by\r\nNext.js. The second argument is an object with:\r\ndev - true when exportPathMap is being called in development. false when running next export.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"75934e58-061e-4482-ace4-afa326ce7a04":{"id_":"75934e58-061e-4482-ace4-afa326ce7a04","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"easOeClv0CA3IRCAxvSh7l3rVuV48hMUdWKilN1iFMo=","metadata":{},"hash":"97FnHBURQsI9KCOEVtSjRYW6OF5fCzuhs9AQYlX0cs0="},"PREVIOUS":{"nodeId":"e40ec2e5-1ef5-4f46-8078-60cec5aeea74","metadata":{},"hash":"hqqTWcLaFtTIbq+/n1tq8PXLac2l/6u1OgWwZGah72A="}},"hash":"IHP/n8S8PaDDtax7jO6zYvClDnK0ZJCqf/nYiCglkTE=","text":"false when running next export. In development\r\nexportPathMap is used to define routes. dir - Absolute path to the project directory\r\noutDir - Absolute path to the out/ directory (configurable with -o). When dev is true the value of outDir will be null. distDir - Absolute path to the .next/ directory (configurable with the distDir config)\r\nbuildId - The generated build id\r\nThe returned object is a map of pages where the key is the pathname and the value is an object that accepts the following fields:\r\npage: String - the page inside the pages directory to render\r\nquery: Object - the query object passed to getInitialProps when prerendering. Defaults to {}\r\nThe exported pathname can also be a filename (for example, /readme.md), but you may need to set the Content-Type header\r\nto text/html when serving its content if it is different than .html. Adding a trailing slash\r\nIt is possible to configure Next.js to export pages as index.html files and require trailing slashes, /about becomes","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"962334af-3dda-42ec-a032-dd0866bc8794":{"id_":"962334af-3dda-42ec-a032-dd0866bc8794","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"l7/oqd3Su2f9AkDDmaxAa/FqBxW1yK1fbkVQPJm1pvs=","metadata":{},"hash":"HPK+P84Wp2cjrL4DeupbHq88zfO5vJv7+IYAXx0j0hQ="}},"hash":"sMUdmv6BKHVjucWMiUSj5uA00wmiEtg2UE/eiQ32NUU=","text":"/about/index.html and is routable via /about/. This was the default behavior prior to Next.js 9. To switch back and add a trailing slash, open next.config.js and enable the trailingSlash config:\r\nnext.config.js (js)module.exports = {\r\n  trailingSlash: true,\r\n}\r\nCustomizing the output directory\r\nnext export will use out as the default output directory, you can customize this using the -o argument, like so:\r\nnext export will use out as the default output directory, you can customize this using the -o argument, like so:\r\nTerminal (bash)next export -o outdir\r\nWarning: Using exportPathMap is deprecated and is overridden by getStaticPaths inside pages. We don’t recommend\r\nusing them together.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1edb0a54-fbe6-4623-8c0c-d435ed7e02e9":{"id_":"1edb0a54-fbe6-4623-8c0c-d435ed7e02e9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iTuWYrNtyaePhyKFOIg4Sr0bd4ZUVcOMnq/m6wFPY4c=","metadata":{},"hash":"ddvQ874Cy5TBI0J77ojIiIzffbRs132rIUvlne2i0tw="}},"hash":"EdqgZhJgdWwC1THoQiWgL/hjRQR/DBNEPAL9dEKz6Pw=","text":"3.2.4.10 - generateBuildId\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/generateBuildId\r\nDescription: Configure the build id, which is used to identify the current build in which your application is being served. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js generates an ID during next build to identify which version of your application is being served. The same build should be used\r\nand boot up multiple containers. If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use\r\nthe generateBuildId command in next.config.js:\r\nnext.config.js (jsx)module.exports = {\r\n  generateBuildId: async () => {\r\n    // This could be anything, using the latest git hash\r\n    return process.env.GIT_HASH\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3cba2cca-bf4f-431d-86b9-8638e98ccb31":{"id_":"3cba2cca-bf4f-431d-86b9-8638e98ccb31","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rXVjWoHnynt3n5EfsBS7o8HIea4bGxY2wsS1hm2z2ko=","metadata":{},"hash":"AslPFhFlnuHM9XF1RbAv2GpGpjlXRokJF/4pAdsa5z8="}},"hash":"R0Fl+30h4HNE6+DGkO7u+Xy4Y+FUYdRjlzD0IzIeLRw=","text":"3.2.4.11 - generateEtags\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/generateEtags\r\nDescription: Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js will generate etags for every page by default. You may want to disable etag generation for HTML pages depending on your\r\ncache strategy. Open next.config.js and disable the generateEtags option:\r\nnext.config.js (js)module.exports = {\r\n  generateEtags: false,\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"eb112b23-1211-460b-bd49-b8f18d5df46f":{"id_":"eb112b23-1211-460b-bd49-b8f18d5df46f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hMmfFrD6FYa9gCo0cm4c8UNASD8gO3JnGqOdpfIAVxc=","metadata":{},"hash":"FybWTbvAGOsY/HKeDJ7a/STB0wX5y2OClHcZwss7oZ8="}},"hash":"AVZYn+z41brOeuWPDdb9LXty3cBfEgzIqAjiVMb2y0M=","text":"3.2.4.12 - headers\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/headers\r\nDescription: Add custom HTTP headers to your Next.js app. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nHeaders allow you to set custom HTTP headers on the response to an incoming request on a given path. To set custom HTTP headers you can use the headers key in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        headers: [\r\n          {\r\n            key: 'x-custom-header',\r\n            value: 'my custom header value',\r\n          },\r\n          {\r\n            key: 'x-another-custom-header',\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nheaders is an async function that expects an array to be returned holding objects with source and headers properties:\r\nsource is the incoming request path pattern. headers is an array of response header objects, with key and value properties. basePath: false or undefined - if false the basePath won’t be included when matching, can be used for external rewrites only. locale: false or undefined - whether the locale should not be included when matching. has is an array of has objects with the type, key and value properties. missing is an array of missing objects with the type, key and value properties. Headers are checked before the filesystem which includes pages and /public files. Header Overriding Behavior\r\nIf two headers match the same path and set the same header key, the last header key will override the first. Using the below headers,\r\nthe path /hello will result in the header x-hello being world due to the last header value set being world. next.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/:path*',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'there',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        source: '/hello',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"70466fdc-bb8d-431e-adf9-d2e8107f26eb":{"id_":"70466fdc-bb8d-431e-adf9-d2e8107f26eb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"t2SkDOvVBmYtecAPvVGnEO9rJyo/NgspLxhd/a+lhZQ=","metadata":{},"hash":"V6xabTGCKD9PM+jfLXAznoHbj50UdgF+Pi5Yx7V+TyM="}},"hash":"6T7GHH0q7KE92HbNH+SnY4nqxrKCmwCPaBAdkCPbUMI=","text":"]\r\n  },\r\n}\r\nPath Matching\r\nPath matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths):\r\nnext.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug',\r\n        headers: [\r\n          {\r\n            key: 'x-slug',\r\n            value: ':slug', // Matched parameters can be used in the value\r\n          },\r\n          {\r\n            key: 'x-slug-:slug', // Matched parameters can be used in the key\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nWildcard Path Matching\r\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\r\nnext.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        headers: [\r\n          {\r\n            key: 'x-slug',\r\n            value: ':slug*', // Matched parameters can be used in the value\r\n          },\r\n          {\r\n            key: 'x-slug-:slug*', // Matched parameters can be used in the key\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nRegex Path Matching\r\nTo match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match\r\n/blog/123 but not /blog/abc:\r\nnext.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:post(\\\\d{1,})',\r\n        headers: [\r\n          {\r\n            key: 'x-post',\r\n            value: ':post',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"585c468f-6d6e-4fb3-a830-8693d9004b3e":{"id_":"585c468f-6d6e-4fb3-a830-8693d9004b3e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZN0WhTjwSdyF2pots9XaCpEHcgTWIqFdWoGnAYmCKNw=","metadata":{},"hash":"v/j2BGzGSZKU62WspRo5l2cz7fDNsUEnkyRlIGOYxb4="}},"hash":"I06yj1zEhnX6PtRYszVavsNt9QDouA4j5J7B9C7O6XQ=","text":"}\r\nThe following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they\r\nmust be escaped by adding \\\\ before them:\r\nnext.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        // this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        headers: [\r\n          {\r\n            key: 'x-header',\r\n            value: 'value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nHeader, Cookie, and Query Matching\r\nTo only apply a header when header, cookie, or query values also match the has field or don’t match the missing field can be used. Both the source and all has items must match and all missing items must not match for the header to be applied. has and missing items can have the following fields:\r\ntype: String - must be either header, cookie, host, or query. key: String - the key from the selected type to match against. value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture\r\na specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in\r\nthe destination with :paramName. next.config.js (js)module.exports = {\r\n  async headers() {\r\n    return [\r\n      // if the header `x-add-header` is present,\r\n      // the `x-another-header` header will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-add-header',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: 'hello',\r\n          },\r\n        ],\r\n      },\r\n      // if the header `x-no-header` is not present,\r\n      // the `x-another-header` header will be applied\r\n      {\r\n        source: '/:path*',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-no-header',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: 'hello',\r\n          },\r\n        ],","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"db28ca15-8a70-4079-ba89-d0045c891921":{"id_":"db28ca15-8a70-4079-ba89-d0045c891921","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NLAZbLcr0y0C3Y4vk1cPZViQsLUs7nR7ReifmQOxSEE=","metadata":{},"hash":"C0rLgrIk3rWgfPSEQ3cpLgtKOG3RxvWWgXCnBYHbV1Y="}},"hash":"gwpPQCRoFOzy7VjBQ7q3Djupgd0ZpzVVLKlSYjQF5m0=","text":"},\r\n      // if the source, query, and cookie are matched,\r\n      // the `x-authorized` header will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // header key/values since value is provided and\r\n            // doesn't use a named capture group e.g. (?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-authorized',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, the `x-another-header` will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n      // if the host is `example.com`,\r\n      // this header will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nHeaders with basePath support\r\nWhen leveraging basePath support with headers each source is automatically prefixed with the basePath unless you add basePath:\r\nfalse to the header:\r\nnext.config.js (js)module.exports = {\r\n  basePath: '/docs',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f74e26d0-406e-4663-b126-775c93aa5abe":{"id_":"f74e26d0-406e-4663-b126-775c93aa5abe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Vht7e3q6DH/tbf37sOXxotxswbbf8FjdtXUbBhADwyg=","metadata":{},"hash":"6oGgupYcnWCvDFImFnJ7YGs8/5mn9puGbxbnma3IVGI="}},"hash":"N8ARJXFYQMpziELdoOwPcnHJ63M92KIT/2ifE/casAg=","text":"async headers() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // becomes /docs/with-basePath\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        source: '/without-basePath', // is not modified since basePath: false is set\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n        basePath: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nHeaders with i18n support\r\nWhen leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add\r\nlocale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly. When leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add\r\nlocale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly. next.config.js (js)module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        locale: false,\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        locale: false,\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"89551873-3ff2-4804-beb2-bbaffb518ce5":{"id_":"89551873-3ff2-4804-beb2-bbaffb518ce5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LiWb3Myrg8CCNJy4b9Cm9jT11OOQWsXIQQ5pJHKDGlQ=","metadata":{},"hash":"KYwdLgJMz1i2f349mhw+yEbTMHDzHDIOczp6CUQ6ub4="},"NEXT":{"nodeId":"e82573b7-fd78-4b10-bad3-4ee420b8d690","metadata":{},"hash":"iuwYXwbS59nxacRsAufuo/bhwDSx7hZiUz0uVCR98Is="}},"hash":"e6sOxeFE7K6WMHqL114ARTtWbsEgjhNXgryIHcyLYMs=","text":"// `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}\r\nCache-Control\r\nYou cannot set Cache-Control headers in next.config.js for pages or assets, as these headers will be overwritten in production to\r\nensure that responses and static assets are cached effectively. Learn more about caching with the App Router. If you need to revalidate the cache of a page that has been statically generated, you can do so by setting the revalidate prop in the\r\npage’s getStaticProps function. You can set the Cache-Control header in your API Routes by using the res.setHeader method:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\ntype ResponseData = {\r\n  message: string\r\n}\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.setHeader('Cache-Control', 's-maxage=86400')\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\npages/api/hello.js (js)export default function handler(req, res) {\r\n  res.setHeader('Cache-Control', 's-maxage=86400')\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\nOptions\r\nX-DNS-Prefetch-Control\r\nThis header controls DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images,\r\nCSS, JavaScript, and more. This prefetching is performed in the background, so the DNS is more likely to be resolved by the time the\r\nreferenced items are needed. This reduces latency when the user clicks a link. {\r\n  key: 'X-DNS-Prefetch-Control',\r\n  value: 'on'\r\n}\r\nStrict-Transport-Security\r\nThis header informs browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present\r\nand future subdomains will use HTTPS for a max-age of 2 years. This blocks access to pages or subdomains that can only be served\r\nover HTTP. If you’re deploying to Vercel, this header is not necessary as it’s automatically added to all deployments unless you declare headers in\r\nyour next.config.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e82573b7-fd78-4b10-bad3-4ee420b8d690":{"id_":"e82573b7-fd78-4b10-bad3-4ee420b8d690","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LiWb3Myrg8CCNJy4b9Cm9jT11OOQWsXIQQ5pJHKDGlQ=","metadata":{},"hash":"KYwdLgJMz1i2f349mhw+yEbTMHDzHDIOczp6CUQ6ub4="},"PREVIOUS":{"nodeId":"89551873-3ff2-4804-beb2-bbaffb518ce5","metadata":{},"hash":"e6sOxeFE7K6WMHqL114ARTtWbsEgjhNXgryIHcyLYMs="}},"hash":"iuwYXwbS59nxacRsAufuo/bhwDSx7hZiUz0uVCR98Is=","text":"{\r\n  key: 'Strict-Transport-Security',\r\n  value: 'max-age=63072000; includeSubDomains; preload'\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"38caf444-6630-4c75-ba26-5c33bf7f75d1":{"id_":"38caf444-6630-4c75-ba26-5c33bf7f75d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"L01qz13sNnuJdsATHcniEwqb1Dj8ilDNg85y7x/f86Q=","metadata":{},"hash":"hkJA3AilQsWTB6NFfqLX3ugWZ0Kqax/USpwCxHgH0us="}},"hash":"gniyR144AQxJ9onCvTfXrelMxWcoonFum90dk1JruVI=","text":"X-Frame-Options\r\nThis header indicates whether the site should be allowed to be displayed within an iframe. This can prevent against clickjacking\r\nattacks. This header has been superseded by CSP’s frame-ancestorsframe-ancestors option, which has better support in modern browsers. {\r\n  key: 'X-Frame-Options',\r\n  value: 'SAMEORIGIN'\r\n}\r\nPermissions-Policy\r\nThis header allows you to control which features and APIs can be used in the browser. It was previously named Feature-Policy. {\r\n  key: 'Permissions-Policy',\r\n  value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'\r\n}\r\nX-Content-Type-Options\r\nThis header prevents the browser from attempting to guess the type of content if the Content-Type header is not explicitly set. This\r\ncan prevent XSS exploits for websites that allow users to upload and share files. For example, a user trying to download an image, but having it treated as a different Content-Type like an executable, which could be\r\nmalicious. This header also applies to downloading browser extensions. The only valid value for this header is nosniff. {\r\n  key: 'X-Content-Type-Options',\r\n  value: 'nosniff'\r\n}\r\nReferrer-Policy\r\nThis header controls how much information the browser includes when navigating from the current website (origin) to another. {\r\n  key: 'Referrer-Policy',\r\n  value: 'origin-when-cross-origin'\r\n}\r\nContent-Security-Policy\r\nLearn more about adding a Content Security Policy to your application. Version History\r\nVersionChanges\r\nv13.3.0missing added. v10.2.0has added. v9.5.0Headers added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6943c765-fba4-470c-a114-8e4eb0a11bba":{"id_":"6943c765-fba4-470c-a114-8e4eb0a11bba","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"w+zy+Hd90smizX9nshVd35ZJg9ZTKCNwlR9CciIVAk0=","metadata":{},"hash":"tVSlug7F0cB55sCQCeq2yOtzO6S9GUE+s17gUyxNUSQ="}},"hash":"bwmDXiB0AedtRDqayfYNa7dPDrkpxZ2j6z2i4Xbo/7c=","text":"3.2.4.13 - httpAgentOptions\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/httpAgentOptions\r\nDescription: Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nIn Node.js versions prior to 18, Next.js automatically polyfills fetch() with undici and enables HTTP Keep-Alive by default. To disable HTTP Keep-Alive for all fetch() calls on the server-side, open next.config.js and add the httpAgentOptions config:\r\nnext.config.js (js)module.exports = {\r\n  httpAgentOptions: {\r\n    keepAlive: false,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"11e2d552-294b-47a1-8484-14fe2a72004f":{"id_":"11e2d552-294b-47a1-8484-14fe2a72004f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/H7W/ikwpFOfINSQiP4Iq9oHOZj6QKAbuVlXQJcxs+4=","metadata":{},"hash":"4y9JbLWxJqPYBjdJFmVRexqwtcX/CdoGlEXC8s3Ns7g="},"NEXT":{"nodeId":"542a4b0d-e05a-43fe-a862-e85276d79363","metadata":{},"hash":"txCRi5pPeg4xXV7uwcOucEhu1W7sqIN/nF92T/sU4Ao="}},"hash":"dEH20dtczcCZD7PQVjKx78gbEvAO4+rygH2+5UBOwBE=","text":"3.2.4.14 - images\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/images\r\nDescription: Custom configuration for the next/image loader\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configurenext.config.js\r\n with the following:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my/image/loader.js',\r\n  },\r\n}\r\nThis loaderFile must point to a file relative to the root of your Next.js application. The file must export a default function that returns\r\na string, for example:\r\nexport default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\nAlternatively, you can use the loader prop to pass the function to each instance of next/image. Alternatively, you can use the loader prop to pass the function to each instance of next/image.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"542a4b0d-e05a-43fe-a862-e85276d79363":{"id_":"542a4b0d-e05a-43fe-a862-e85276d79363","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/H7W/ikwpFOfINSQiP4Iq9oHOZj6QKAbuVlXQJcxs+4=","metadata":{},"hash":"4y9JbLWxJqPYBjdJFmVRexqwtcX/CdoGlEXC8s3Ns7g="},"PREVIOUS":{"nodeId":"11e2d552-294b-47a1-8484-14fe2a72004f","metadata":{},"hash":"dEH20dtczcCZD7PQVjKx78gbEvAO4+rygH2+5UBOwBE="}},"hash":"txCRi5pPeg4xXV7uwcOucEhu1W7sqIN/nF92T/sU4Ao=","text":"Alternatively, you can use the loader prop to pass the function to each instance of next/image. Example Loader Configuration\r\nAkamai\r\nCloudinary\r\nCloudflare\r\nContentful\r\nFastly\r\nGumlet\r\nImageEngine\r\nImgix\r\nThumbor\r\nSanity\r\nSirv\r\nSupabase\r\nAkamai\r\n// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand\r\nexport default function akamaiLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?imwidth=${width}`\r\n}\r\nCloudinary\r\n// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\r\nexport default function cloudinaryLoader({ src, width, quality }) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://example.com/${params.join(',')}${src}`\r\n}\r\nCloudflare\r\n// Docs: https://developers.cloudflare.com/images/url-format\r\nexport default function cloudflareLoader({ src, width, quality }) {\r\n  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']\r\n  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"64a68214-e185-4086-b7d0-038ea83b98fe":{"id_":"64a68214-e185-4086-b7d0-038ea83b98fe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8fAyk0fZvqePTjdPtdj6QZsFjVoa0jJFt2PDIRlW1uA=","metadata":{},"hash":"0VKbkeVcDYg9W2xyXWkdoDAX+DTtyLmx86VF//6P9M8="}},"hash":"zEx9V9+e/Cf9dOiyhGtCL5a/L2HZ1w4IRwlXQaNq3VM=","text":"Contentful\r\n// Docs: https://www.contentful.com/developers/docs/references/images-api/\r\nexport default function contentfulLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('fm', 'webp')\r\n  url.searchParams.set('w', width.toString())\r\n  url.searchParams.set('q', (quality || 75).toString())\r\n  return url.href\r\n}\r\nFastly\r\n// Docs: https://developer.fastly.com/reference/io/\r\nexport default function fastlyLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('auto', 'webp')\r\n  url.searchParams.set('width', width.toString())\r\n  url.searchParams.set('quality', (quality || 75).toString())\r\n  return url.href\r\n}\r\nGumlet\r\n// Docs: https://docs.gumlet.com/reference/image-transform-size\r\nexport default function gumletLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('format', 'auto')\r\n  url.searchParams.set('w', width.toString())\r\n  url.searchParams.set('q', (quality || 75).toString())\r\n  return url.href\r\n}\r\nImageEngine\r\n// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives\r\nexport default function imageengineLoader({ src, width, quality }) {\r\n  const compression = 100 - (quality || 50)\r\n  const params = [`w_${width}`, `cmpr_${compression}`)]\r\n  return `https://example.com${src}?imgeng=/${params.join('/')`\r\n}\r\nImgix\r\n// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300\r\nexport default function imgixLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  const params = url.searchParams\r\n  params.set('auto', params.getAll('auto').join(',') || 'format')\r\n  params.set('fit', params.get('fit') || 'max')\r\n  params.set('w', params.get('w') || width.toString())\r\n  params.set('q', (quality || 50).toString())\r\n  return url.href\r\n}\r\nThumbor\r\n// Docs: https://thumbor.readthedocs.io/en/latest/\r\nexport default function thumborLoader({ src, width, quality }) {\r\n  const params = [`${width}x0`, `filters:quality(${quality || 75})`]\r\n  return `https://example.com${params.join('/')}${src}`\r\n}\r\nSanity\r\n// Docs: https://www.sanity.io/docs/image-urls\r\nexport default function sanityLoader({ src, width, quality }) {\r\n  const prj = 'zp7mbokg'\r\n  const dataset = 'production'\r\n  const url = new URL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8302e624-f71a-4089-8f10-9ec6af00c96e":{"id_":"8302e624-f71a-4089-8f10-9ec6af00c96e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XtYDUnET5K+mdVWUxgzneGu8dVpZsgVxayMt41rQ7oo=","metadata":{},"hash":"P/uUWtrKX/5BJjSYNOGut8qAFAluxg7vdc47PX2BnfY="}},"hash":"dkVcsm8lYdyWO07S5YMcPbIBVM7D461+k8ZL77fMkhc=","text":"url.searchParams.set('auto', 'format')\r\n  url.searchParams.set('fit', 'max')\r\n  url.searchParams.set('w', width.toString())\r\n  if (quality) {\r\n    url.searchParams.set('q', quality.toString())\r\n  }\r\n  return url.href\r\n}\r\nSirv\r\n// Docs: https://sirv.com/help/articles/dynamic-imaging/\r\nexport default function sirvLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  const params = url.searchParams\r\n  params.set('format', params.getAll('format').join(',') || 'optimal')\r\n  params.set('w', params.get('w') || width.toString())\r\n  params.set('q', (quality || 85).toString())\r\n  return url.href\r\n}\r\nSupabase\r\n// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loader\r\nexport default function supabaseLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('width', width.toString())\r\n  url.searchParams.set('quality', (quality || 75).toString())\r\n  return url.href\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a52dfd2a-42ff-40d4-93fd-0b0c7324aa08":{"id_":"a52dfd2a-42ff-40d4-93fd-0b0c7324aa08","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NHHM08enq1AghxgrBB+Tmskh/HYRBIkyBnIe6TVcUOc=","metadata":{},"hash":"pkoR32FqwKRFUlbPsodiXvA1D4vI7Mki6dplpgEfKFk="}},"hash":"3iOrDb7/j/kvreZQ/mOewtIBiJxEQ6HkzbQYW0dHFUc=","text":"3.2.4.15 - incrementalCacheHandlerPath\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/incrementalCacheHandlerPath\r\nDescription: Configure the Next.js cache used for storing and revalidating data. In Next.js, the default cache handler uses the filesystem cache. This requires no configuration, however, you can customize the cache\r\nhandler by using the incrementalCacheHandlerPath field in next.config.js. next.config.js (js)module.exports = {\r\n  experimental: {\r\n    incrementalCacheHandlerPath: require.resolve('./cache-handler.js'),\r\n  },\r\n}\r\nHere’s an example of a custom cache handler:\r\ncache-handler.js (js)const cache = new Map()\r\nmodule.exports = class CacheHandler {\r\n  constructor(options) {\r\n    this.options = options\r\n    this.cache = {}\r\n  }\r\n  async get(key) {\r\n    return cache.get(key)\r\n  }\r\n  async set(key, data) {\r\n    cache.set(key, {\r\n      value: data,\r\n      lastModified: Date.now(),\r\n    })\r\n  }\r\n}\r\nAPI Reference\r\nThe cache handler can implement the following methods: get, set, and revalidateTag. get()get()\r\nParameterTypeDescription\r\nkeystringThe key to the cached value. Returns the cached value or null if not found. set()set()\r\nParameterTypeDescription\r\nkeystringThe key to store the data under. dataData or nullThe data to be cached. Returns Promise<void>. revalidateTag()revalidateTag()\r\nParameterTypeDescription\r\ntagstringThe cache tag to revalidate.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"17536e4f-4704-4436-90bd-c0d2c75c5fb4":{"id_":"17536e4f-4704-4436-90bd-c0d2c75c5fb4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8m/aotVrEaOaKeui8e9JJtUPSKda4XDyC18xHKmSKbY=","metadata":{},"hash":"khrd67BohnTiJXXlKP4zrxMLarsd/BRFfS3c2osbLFA="}},"hash":"MadBv7EX+9c6if82VWoHBJXrh15BYuZXfNOIMw6I+kk=","text":"Returns Promise<void>. Learn more about revalidating data or the revalidateTag() function.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2314326c-fd91-414a-94e9-ef45e3749336":{"id_":"2314326c-fd91-414a-94e9-ef45e3749336","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"LEVwKlm9g0QQavAnxEj2hcYDeNjVD5FTPPmYko7+EIc=","metadata":{},"hash":"9KCkKNTFTvF+h7Gyw61E3bIJX8guNLsF4FGXcDby0is="}},"hash":"znTYUK1aRrPbAKO184BuvaUGRcpa2Vo2dgvibeR6n0A=","text":"3.2.4.16 - logging\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/logging\r\nDescription: Configure how data fetches are logged to the console when running Next.js in development mode. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nYou can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode. Currently, logging only applies to data fetching using the fetch API. It does not yet apply to other logs inside of Next.js. next.config.js (js)module.exports = {\r\n  logging: {\r\n    fetches: {\r\n      fullUrl: true,\r\n    },\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ca8e3f59-3972-4430-ab57-2c0adfcb1c25":{"id_":"ca8e3f59-3972-4430-ab57-2c0adfcb1c25","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UqbmuYv2UqMfP38US3F9xfvsd6WEEK552pwil4xYmt0=","metadata":{},"hash":"HrHDv8ppw6vLzRFCjPYA3WTq1kltupn4E2mMCtKHek8="}},"hash":"yfpsO/NudH5L/LeFPCMt0Ys15cOe37TuOD/Xg6NawrE=","text":"3.2.4.17 - mdxRs\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/mdxRs\r\nDescription: Use the new Rust compiler to compile MDX files in the App Router. For use with @next/mdx. Compile MDX files using the new Rust compiler. next.config.js (js)const withMDX = require('@next/mdx')()\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  pageExtensions: ['ts', 'tsx', 'mdx'],\r\n  experimental: {\r\n    mdxRs: true,\r\n  },\r\n}\r\nmodule.exports = withMDX(nextConfig)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cbb09d0a-a22b-45c7-8521-8756c1e05e10":{"id_":"cbb09d0a-a22b-45c7-8521-8756c1e05e10","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JlaBNtatS8IzWlJw0ZXFoIc/FCx9Payta6kBWbWd27M=","metadata":{},"hash":"cCRQZPhtBgYvWSCd2FosQgCZU7jhW5G/8ADJSfRqlDE="}},"hash":"yLHqcSPfoCl/0+QidFAW1qeSWWcIPgCY8ag/sVH0gik=","text":"3.2.4.18 - onDemandEntries\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/onDemandEntries\r\nDescription: Configure how Next.js will dispose and keep in memory pages created in development. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in\r\ndevelopment. To change the defaults, open next.config.js and add the onDemandEntries config:\r\nnext.config.js (js)module.exports = {\r\n  onDemandEntries: {\r\n    // period (in ms) where the server will keep pages in the buffer\r\n    maxInactiveAge: 25 * 1000,\r\n    // number of pages that should be kept simultaneously without being disposed\r\n    pagesBufferLength: 2,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"46887d75-1aa7-4827-b2d3-aa7dc66d9534":{"id_":"46887d75-1aa7-4827-b2d3-aa7dc66d9534","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CZRxl+1CDsDM/PD1SD2YPthY0SOsVT6yo8WaojTxrps=","metadata":{},"hash":"VQxb0gEx4w58sY/tDd53ejpEOH+gb0epm4KL6XyslyU="}},"hash":"ROMIh1DWNkmCoTxxpRo5vQtsmblbB7ZJy6ZWJh5lp3w=","text":"3.2.4.19 - optimizePackageImports\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/optimizePackageImports\r\nDescription: API Reference for optmizedPackageImports Next.js Config Option\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nSome packages can export hundreds or thousands of modules, which can cause performance issues in development and production. Adding a package to experimental.optimizePackageImports will only load the modules you are actually using, while still giving\r\nyou the convenience of writing import statements with many named exports. next.config.js (js)module.exports = {\r\n  experimental: {\r\n    optimizePackageImports: ['package-name'],\r\n  },\r\n}\r\nLibraries like @mui/icons-material, @mui/material, date-fns, lodash, lodash-es, react-bootstrap, @headlessui/react,\r\n@heroicons/react, and lucide-react are already optimized by default.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5aa0edaa-6aac-4dd2-93eb-26013324cd1f":{"id_":"5aa0edaa-6aac-4dd2-93eb-26013324cd1f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qZB1gAAC76rq3eKbuwTp+T9tLp9zHfAwDlztPJ2lSts=","metadata":{},"hash":"35WZPv1ziX3UBG5UADikGRgywjPjNRGvvJWIYyYHlmg="},"NEXT":{"nodeId":"f0abe669-3349-41ab-980e-53f63622c427","metadata":{},"hash":"3KV+BW6LE66tFgrH4rbeR78CgOwwfXszCnAIRzf3ctM="}},"hash":"j6DQ4ZZKnLtqCR4bbKpFa9zwJOtfGjr3IvKlYJ3r0qU=","text":"3.2.4.20 - output\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/output\r\nDescription: Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn\r\nhow it works here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nDuring a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for\r\ndeploying a production version of your application. This feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files\r\nfrom your package’s dependencies installed to run next start. Starting with Next.js 12, you can leverage Output File Tracing in the\r\n.next/ directory to only include the necessary files. Furthermore, this removes the need for the deprecated serverless target which can cause various issues and also creates\r\nunnecessary duplication. How it Works\r\nDuring next build, Next.js will use @vercel/nft to statically analyze import, require, and fs usage to determine all files that a\r\npage might load. Next.js’ production server is also traced for its needed files and output at .next/next-server.js.nft.json which can be leveraged\r\nin production. To leverage the .nft.json files emitted to the .next output directory, you can read the list of files in each trace that are relative to\r\nthe .nft.json file and then copy them to your deployment location. Automatically Copying Traced Files\r\nNext.js can automatically create a standalone folder that copies only the necessary files for a production deployment including select\r\nfiles in node_modules. To leverage this automatic copying you can enable it in your next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  output: 'standalone',\r\n}\r\nThis will create a folder at .next/standalone which can then be deployed on its own without installing node_modules. Additionally, a minimal server.js file is also output which can be used instead of next start.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f0abe669-3349-41ab-980e-53f63622c427":{"id_":"f0abe669-3349-41ab-980e-53f63622c427","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qZB1gAAC76rq3eKbuwTp+T9tLp9zHfAwDlztPJ2lSts=","metadata":{},"hash":"35WZPv1ziX3UBG5UADikGRgywjPjNRGvvJWIYyYHlmg="},"PREVIOUS":{"nodeId":"5aa0edaa-6aac-4dd2-93eb-26013324cd1f","metadata":{},"hash":"j6DQ4ZZKnLtqCR4bbKpFa9zwJOtfGjr3IvKlYJ3r0qU="}},"hash":"3KV+BW6LE66tFgrH4rbeR78CgOwwfXszCnAIRzf3ctM=","text":"Additionally, a minimal server.js file is also output which can be used instead of next start. This minimal server does not copy the\r\npublic or .next/static folders by default as these should ideally be handled by a CDN instead, although these folders can be copied\r\nto the standalone/public and standalone/.next/static folders manually, after which server.js file will serve these\r\nautomatically. Good to know:\r\nIf your project needs to listen to a specific port or hostname, you can define PORT or HOSTNAME environment variables\r\nbefore running server.js. For example, run PORT=8080 HOSTNAME=0.0.0.0 node server.js to start the server on\r\nhttp://0.0.0.0:8080. If your project uses Image Optimization with the default loader, you must install sharp as a dependency:\r\nGood to know:\r\nnext.config.js is read during next build and serialized into the server.js output file. If the legacy\r\nserverRuntimeConfig or publicRuntimeConfig options are being used, the values will be specific to values at build\r\ntime. If your project needs to listen to a specific port or hostname, you can define PORT or HOSTNAME environment variables\r\nbefore running server.js. For example, run PORT=8080 HOSTNAME=0.0.0.0 node server.js to start the server on\r\nhttp://0.0.0.0:8080. If your project uses Image Optimization with the default loader, you must install sharp as a dependency:\r\nTerminal (bash)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0b7f4445-6be3-4d92-9eb5-ac840f07b135":{"id_":"0b7f4445-6be3-4d92-9eb5-ac840f07b135","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JkF+epx6b0LolyZTwIc3DkXJSzomK+OQqkmANTOAyWs=","metadata":{},"hash":"Hw+PD1l5AxX9K95rwkjWAClPjqcvmDGQfuFu89CfY70="},"NEXT":{"nodeId":"1cee27fe-0a92-42a9-9fbe-10af90a2d7ea","metadata":{},"hash":"PXJKrO7Ou/KF/By8ut3NzZab/5Fyw8SDZTJX7jTFWrA="}},"hash":"abDDyxxuP1QP+naCmTTegAqF7/k5ymNen2KflBjC2GQ=","text":"npm i sharp\r\nTerminal (bash)yarn add sharp\r\nTerminal (bash)pnpm add sharp\r\nTerminal (bash)bun add sharp\r\nCaveats\r\nWhile tracing in monorepo setups, the project directory is used for tracing by default. For next build packages/web-app,\r\npackages/web-app would be the tracing root and any files outside of that folder will not be included. To include files outside of\r\nthis folder you can set experimental.outputFileTracingRoot in your next.config.js. packages/web-app/next.config.js (js)module.exports = {\r\n  experimental: {\r\n    // this includes files from the monorepo base two directories up\r\n    outputFileTracingRoot: path.join(__dirname, '../../'),\r\n  },\r\n}\r\nThere are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases,\r\nyou can leverage experimental.outputFileTracingExcludes and experimental.outputFileTracingIncludes\r\nrespectively in next.config.js. Each config accepts an object with minimatch globs for the key to match specific pages and a\r\nvalue of an array with globs relative to the project’s root to either include or exclude in the trace. next.config.js (js)module.exports = {\r\n  experimental: {\r\n    outputFileTracingExcludes: {\r\n      '/api/hello': ['./un-necessary-folder/**/*'],\r\n    },\r\n    outputFileTracingIncludes: {\r\n      '/api/another': ['./necessary-folder/**/*'],\r\n    },\r\n  },\r\n}\r\nCurrently, Next.js does not do anything with the emitted .nft.json files. The files must be read by your deployment platform, for\r\nexample Vercel, to create a minimal deployment. In a future release, a new command is planned to utilize these .nft.json files. Experimental turbotraceturbotrace\r\nTracing dependencies can be slow because it requires very complex computations and analysis. We created turbotrace in Rust as a\r\nfaster and smarter alternative to the JavaScript implementation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1cee27fe-0a92-42a9-9fbe-10af90a2d7ea":{"id_":"1cee27fe-0a92-42a9-9fbe-10af90a2d7ea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JkF+epx6b0LolyZTwIc3DkXJSzomK+OQqkmANTOAyWs=","metadata":{},"hash":"Hw+PD1l5AxX9K95rwkjWAClPjqcvmDGQfuFu89CfY70="},"PREVIOUS":{"nodeId":"0b7f4445-6be3-4d92-9eb5-ac840f07b135","metadata":{},"hash":"abDDyxxuP1QP+naCmTTegAqF7/k5ymNen2KflBjC2GQ="}},"hash":"PXJKrO7Ou/KF/By8ut3NzZab/5Fyw8SDZTJX7jTFWrA=","text":"We created turbotrace in Rust as a\r\nfaster and smarter alternative to the JavaScript implementation. To enable it, you can add the following configuration to your next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    turbotrace: {\r\n      // control the log level of the turbotrace, default is `error`\r\n      logLevel?:\r\n      | 'bug'\r\n      | 'fatal'\r\n      | 'error'\r\n      | 'warning'\r\n      | 'hint'\r\n      | 'note'\r\n      | 'suggestions'\r\n      | 'info',\r\n      // control if the log of turbotrace should contain the details of the analysis, default is `false`\r\n      logDetail?: boolean","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dc86641c-36e1-49c4-b295-60384512788a":{"id_":"dc86641c-36e1-49c4-b295-60384512788a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MJxldLdH31vmRzbK6xVR1nr/s6b6OAkXVji2bNpjjtY=","metadata":{},"hash":"3I1NUrGLn5FP9pB35Pvtt3kHsY4xb3nDVDLz1pQizWg="}},"hash":"H57kL9bwdtsUcDWx4zaDFxmHPthEe3batNn1kxF6i30=","text":"// show all log messages without limit\r\n      // turbotrace only show 1 log message for each categories by default\r\n      logAll?: boolean\r\n      // control the context directory of the turbotrace\r\n      // files outside of the context directory will not be traced\r\n      // set the `experimental.outputFileTracingRoot` has the same effect\r\n      // if the `experimental.outputFileTracingRoot` and this option are both set, the `experimental.turbotrace.contextDirectory` will be used\r\n      contextDirectory?: string\r\n      // if there is `process.cwd()` expression in your code, you can set this option to tell `turbotrace` the value of `process.cwd()` while tracing. // for example the require(process.cwd() + '/package.json') will be traced as require('/path/to/cwd/package.json')\r\n      processCwd?: string\r\n      // control the maximum memory usage of the `turbotrace`, in `MB`, default is `6000`. memoryLimit?: number\r\n    },\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e8858d6c-7459-4e85-8a2e-e837253e88de":{"id_":"e8858d6c-7459-4e85-8a2e-e837253e88de","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1er+wC/n5j/5d5S0pMrPKHB3U8iS6jtT1J6sCUAZErQ=","metadata":{},"hash":"lW1DUJZkg/Qf01DptQJU10+61+fSDuboWAhoTsqfWAo="}},"hash":"9MAwSsgKvSLglCGtfYUHcNwO+p56nVoeLFaBFkRDEJc=","text":"3.2.4.21 - pageExtensions\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/pageExtensions\r\nDescription: Extend the default page extensions used by Next.js when resolving pages in the Pages Router. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nBy default, Next.js accepts files with the following extensions: .tsx, .ts, .jsx, .js. This can be modified to allow other extensions like\r\nmarkdown (.md, .mdx). next.config.js (js)const withMDX = require('@next/mdx')()\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  pageExtensions: ['ts', 'tsx', 'mdx'],\r\n  experimental: {\r\n    mdxRs: true,\r\n  },\r\n}\r\nmodule.exports = withMDX(nextConfig)\r\nYou can extend the default Page extensions (.tsx, .ts, .jsx, .js) used by Next.js. Inside next.config.js, add the pageExtensions\r\nconfig:\r\nnext.config.js (js)module.exports = {\r\n  pageExtensions: ['mdx', 'md', 'jsx', 'js', 'tsx', 'ts'],\r\n}\r\nChanging these values affects all Next.js pages, including the following:\r\nmiddleware.js\r\ninstrumentation.js\r\npages/_document.js\r\npages/_app.js\r\npages/api/\r\nFor example, if you reconfigure .ts page extensions to .page.ts, you would need to rename pages like middleware.page.ts,\r\ninstrumentation.page.ts, _app.page.ts. Including non-page files in the pagespages directory\r\nYou can colocate test files or other files used by components in the pages directory. Inside next.config.js, add the\r\npageExtensions config:\r\nnext.config.js (js)module.exports = {\r\n  pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],\r\n}\r\nThen, rename your pages to have a file extension that includes .page (e.g. rename MyPage.tsx to MyPage.page.tsx). Ensure you\r\nrename all Next.js pages, including the files mentioned above.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a322b04d-11b2-4baa-8cd0-1244e204ec3b":{"id_":"a322b04d-11b2-4baa-8cd0-1244e204ec3b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rauiSpUiUOpb/5UR9EL6Ce/4aQo4LNyBcZ29YRKuHxI=","metadata":{},"hash":"O7CNt8az/YlXLs0EpNyolAbcfkUpp2zsXHif4t/k2OM="}},"hash":"/1j5j4Shmv14SkApWeqzMveRotKixcKhuout4ZyoiJ4=","text":"3.2.4.22 - Partial Prerendering (experimental)\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/partial-prerendering\r\nDescription: Learn how to enable Partial Prerendering (experimental) in Next.js 14. Warning: Partial Prerendering is an experimental feature and is currently not suitable for production environments. Partial Prerendering is an experimental feature that allows static portions of a route to be prerendered and served from the cache with\r\ndynamic holes streamed in, all in a single HTTP request. Partial Prerendering is available in next@canary:\r\nTerminal (bash)npm install next@canary\r\nYou can enable Partial Prerendering by setting the experimental ppr flag:\r\nnext.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    ppr: true,\r\n  },\r\n}\r\nmodule.exports = nextConfig\r\nGood to know:\r\nPartial Prerendering does not yet apply to client-side navigations. We are actively working on this. Partial Prerendering is designed for the Node.js runtime only. Using the subset of the Node.js runtime is not needed when\r\nyou can instantly serve the static shell. Learn more about Partial Prerendering in the Next.js Learn course.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d2dc92b3-e668-4e64-a7ba-83245a8df10b":{"id_":"d2dc92b3-e668-4e64-a7ba-83245a8df10b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"K7cAVxyl/ekPmpoRkrVVnQD0iCCWytKXePDlVIrpjbg=","metadata":{},"hash":"MeLEgcXf3U8LV35QXq8bfZnKfvGs84JKhg6DJT2n3Kk="}},"hash":"AGXmYBYywfK2XBYejNzrSizVRpwH/2Lwe9mgLpPJ6No=","text":"3.2.4.23 - poweredByHeader\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/poweredByHeader\r\nDescription: Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nBy default Next.js will add the x-powered-by header. To opt-out of it, open next.config.js and disable the poweredByHeader\r\nconfig:\r\nnext.config.js (js)module.exports = {\r\n  poweredByHeader: false,\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"373fadea-b037-479d-81e1-d2d047bb1989":{"id_":"373fadea-b037-479d-81e1-d2d047bb1989","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7Y4KfzYVX2EAJhEYaGQmDDbqerESBw/x4gB68N05qfs=","metadata":{},"hash":"UGpCBjxc+yfEFKap37YybIZr18R+rBUhk6gVN9zt31o="}},"hash":"n5sDF8teFwOSWupjuptS+4qCDb1+tWqzT1Nw7kd974Y=","text":"3.2.4.24 - productionBrowserSourceMaps\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/productionBrowserSourceMaps\r\nDescription: Enables browser source map generation during the production build. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nSource Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your\r\nsource on the client, unless you specifically opt-in with the configuration flag. Next.js provides a configuration flag you can use to enable browser source map generation during the production build:\r\nnext.config.js (js)module.exports = {\r\n  productionBrowserSourceMaps: true,\r\n}\r\nWhen the productionBrowserSourceMaps option is enabled, the source maps will be output in the same directory as the JavaScript\r\nfiles. Next.js will automatically serve these files when requested. Adding source maps can increase next build time\r\nIncreases memory usage during next build","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ffe41476-21ae-4292-85fd-e05145e791a0":{"id_":"ffe41476-21ae-4292-85fd-e05145e791a0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0n8svgyGS6h/rPjdfwdLhkzRcLMmnTt+ebrtvB9Xo4o=","metadata":{},"hash":"1wNoarQJoK9S3aG5bMsYLkgTLQemPt7UFq+c5ZYC3Pg="}},"hash":"gHBU+4l/UWeymFqeDGQ2eKojRmSc4j2zhThHdPwzFhc=","text":"3.2.4.25 - reactStrictMode\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/reactStrictMode\r\nDescription: The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nGood to know: Since Next.js 13.4, Strict Mode is true by default with app router, so the above configuration is only necessary\r\nfor pages. You can still disable Strict Mode by setting reactStrictMode: false. Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the\r\nfuture of React. React’s Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe\r\nlifecycles, legacy API usage, and a number of other features. The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in your next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  reactStrictMode: true,\r\n}\r\nIf you or your team are not ready to use Strict Mode in your entire application, that’s OK! You can incrementally migrate on a page-by-\r\npage basis using <React.StrictMode>.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c8cabe85-c192-4857-9840-57b68a47084b":{"id_":"c8cabe85-c192-4857-9840-57b68a47084b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bbq59YjdBaPVoSb90uDrw2TUPeqhqs3TQQlet8lOEe4=","metadata":{},"hash":"K8gvAfl9hUoHr9JQfJvPPYoNCg3GbSSai3S1zJ7ajKE="},"NEXT":{"nodeId":"e3631c6e-0664-451d-8554-0414789fd7c5","metadata":{},"hash":"1AS/7NuoW/7pOFAAz8rsjyF8ZB2SOlTDWoOReA3c0Og="}},"hash":"utjimtvRVB7skjbSrG7OKQYVbuO5BiYnhxUSNxfmxeo=","text":"3.2.4.26 - redirects\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/redirects\r\nDescription: Add redirects to your Next.js app. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nRedirects allow you to redirect an incoming request path to a different destination path. To use redirects you can use the redirects key in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}\r\nredirects is an async function that expects an array to be returned holding objects with source, destination, and permanent\r\nproperties:\r\nsource is the incoming request path pattern. destination is the path you want to route to. permanent true or false - if true will use the 308 status code which instructs clients/search engines to cache the redirect\r\nforever, if false will use the 307 status code which is temporary and is not cached. Why does Next.js use 307 and 308? Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent\r\nredirect, but many browsers changed the request method of the redirect to GET, regardless of the original method. For\r\nexample, if the browser made a request to POST /v1/users which returned status code 302 with location /v2/users, the\r\nsubsequent request might be GET /v2/users instead of the expected POST /v2/users. Next.js uses the 307 temporary\r\nredirect, and 308 permanent redirect status codes to explicitly preserve the request method used. basePath: false or undefined - if false the basePath won’t be included when matching, can be used for external redirects only. locale: false or undefined - whether the locale should not be included when matching. has is an array of has objects with the type, key and value properties. missing is an array of missing objects with the type, key and value properties. Redirects are checked before the filesystem which includes pages and /public files. Redirects are not applied to client-side routing (Link, router.push), unless Middleware is present and matches the path.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e3631c6e-0664-451d-8554-0414789fd7c5":{"id_":"e3631c6e-0664-451d-8554-0414789fd7c5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bbq59YjdBaPVoSb90uDrw2TUPeqhqs3TQQlet8lOEe4=","metadata":{},"hash":"K8gvAfl9hUoHr9JQfJvPPYoNCg3GbSSai3S1zJ7ajKE="},"PREVIOUS":{"nodeId":"c8cabe85-c192-4857-9840-57b68a47084b","metadata":{},"hash":"utjimtvRVB7skjbSrG7OKQYVbuO5BiYnhxUSNxfmxeo="}},"hash":"1AS/7NuoW/7pOFAAz8rsjyF8ZB2SOlTDWoOReA3c0Og=","text":"When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example,\r\nsee the following redirect configuration:\r\n{\r\n  source: '/old-blog/:path*',\r\n  destination: '/blog/:path*',\r\n  permanent: false\r\n}\r\nWhen /old-blog/post-1?hello=world is requested, the client will be redirected to /blog/post-1?hello=world. Path Matching\r\nPath matches are allowed, for example /old-blog/:slug will match /old-blog/hello-world (no nested paths):\r\nnext.config.js (js)module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/old-blog/:slug',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"695f2dd7-a641-4f86-8607-e26a3d8889c6":{"id_":"695f2dd7-a641-4f86-8607-e26a3d8889c6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nwIH+62oZ0sczSkPXWbAqc8BvPaZxIoqQa6YItkFow0=","metadata":{},"hash":"D+EFGb6RbYkyc32tBrMlD5m4FDWathnx8ePpawJbrQo="}},"hash":"VwJeG7ghRhBvLhDlEsDyRr87it8HfTEgjZNFdiC7tgs=","text":"permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}\r\nWildcard Path Matching\r\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\r\nnext.config.js (js)module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}\r\nRegex Path Matching\r\nTo match a regex path you can wrap the regex in parentheses after a parameter, for example /post/:slug(\\\\d{1,}) will match\r\n/post/123 but not /post/abc:\r\nnext.config.js (js)module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/post/:slug(\\\\d{1,})',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nThe following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they\r\nmust be escaped by adding \\\\ before them:\r\nnext.config.js (js)module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        // this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        destination: '/en-us/:slug',\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nHeader, Cookie, and Query Matching\r\nTo only match a redirect when header, cookie, or query values also match the has field or don’t match the missing field can be used. Both the source and all has items must match and all missing items must not match for the redirect to be applied. has and missing items can have the following fields:\r\ntype: String - must be either header, cookie, host, or query. key: String - the key from the selected type to match against. value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture\r\na specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in\r\nthe destination with :paramName. next.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cc5a465b-e864-41a2-99f8-9e83670e744c":{"id_":"cc5a465b-e864-41a2-99f8-9e83670e744c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YaCoojVmcLyvxI7SHp5FO4OAW97fMh67fmW514uBdbA=","metadata":{},"hash":"+irGEqJY0xHx7flLoDRJfEPlYxnWq45/9CY0nUz53rY="}},"hash":"8sFyNBbH1jRGbsSUUfZUqzcca74/TbiTpgoKnrCiY+A=","text":"module.exports = {\r\n  async redirects() {\r\n    return [\r\n      // if the header `x-redirect-me` is present,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-redirect-me',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',\r\n      },\r\n      // if the header `x-dont-redirect` is present,\r\n      // this redirect will NOT be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-do-not-redirect',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',\r\n      },\r\n      // if the source, query, and cookie are matched,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // destination since value is provided and doesn't\r\n            // use a named capture group e.g. (?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another/:path*',\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, this redirect will be applied\r\n      {\r\n        source: '/',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/home?authorized=:authorized',\r\n      },\r\n      // if the host is `example.com`,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0f6aca1f-cea8-49b9-8287-01f3c35c043f":{"id_":"0f6aca1f-cea8-49b9-8287-01f3c35c043f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p+2mj8LtqEksFu+JEZH46o17TVCdXVbCtTLIsd6MfD0=","metadata":{},"hash":"UPWTPYcBi+w9Qqze0RQTE6j3y3j02ffgBw9zMV1UJ+o="}},"hash":"4u4sMPkn5HFThQ0KcNI0ilgJ3GYWj/3phfs+0Zqu3PM=","text":"},\r\n    ]\r\n  },\r\n}\r\nRedirects with basePath support\r\nWhen leveraging basePath support with redirects each source and destination is automatically prefixed with the basePath unless\r\nyou add basePath: false to the redirect:\r\nnext.config.js (js)module.exports = {\r\n  basePath: '/docs',\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\r\n        destination: '/another', // automatically becomes /docs/another\r\n        permanent: false,\r\n      },\r\n      {\r\n        // does not add /docs since basePath: false is set\r\n        source: '/without-basePath',\r\n        destination: 'https://example.com',\r\n        basePath: false,\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nRedirects with i18n support\r\nWhen leveraging i18n support with redirects each source and destination is automatically prefixed to handle the configured\r\nlocales unless you add locale: false to the redirect. If locale: false is used you must prefix the source and destination\r\nwith a locale for it to be matched correctly. When leveraging i18n support with redirects each source and destination is automatically prefixed to handle the configured\r\nlocales unless you add locale: false to the redirect. If locale: false is used you must prefix the source and destination\r\nwith a locale for it to be matched correctly. next.config.js (js)module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        destination: '/another', // automatically passes the locale on\r\n        permanent: false,\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        destination: '/nl/another',\r\n        locale: false,\r\n        permanent: false,\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        destination: '/en/another',\r\n        locale: false,\r\n        permanent: false,\r\n      },\r\n      // it's possible to match all locales even when locale: false is set\r\n      {\r\n        source: '/:locale/page',\r\n        destination: '/en/newpage',","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9fa2ad05-10ec-4e50-96b8-8c713be6834a":{"id_":"9fa2ad05-10ec-4e50-96b8-8c713be6834a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"n+ifNaOnarnrCj3+7nwHaPyXHSrF29A4dBlqd9RFGaw=","metadata":{},"hash":"lS1z7AxSYfMXG6ExUxo9ZVfJYdRpPyz9dD68/azKqxw="}},"hash":"IanILOqon3syJ+/hQqr/RhJsgXf8G7gRUytuqCrZchA=","text":"permanent: false,\r\n        locale: false,\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\r\n        // `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        destination: '/another',\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nIn some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can\r\nuse the statusCode property instead of the permanent property, but not both. To to ensure IE11 compatibility, a Refresh header is\r\nautomatically added for the 308 status code. Other Redirects\r\nInside API Routes and Route Handlers, you can redirect based on the incoming request. Inside getStaticProps and getServerSideProps, you can redirect specific pages at request-time. Version History\r\nVersionChanges\r\nv13.3.0missing added. v10.2.0has added. v9.5.0redirects added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b2567016-b1a7-40cf-a955-7b473a31dfc2":{"id_":"b2567016-b1a7-40cf-a955-7b473a31dfc2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yPE1FFDCex1wL5H7395lrMoykZJNfac7GMJ4lo60gSk=","metadata":{},"hash":"gywVlE4srQo7h3V2BvwUV0EgUPlfrIV86oM3g9UNZXY="},"NEXT":{"nodeId":"b7cd3804-8936-4a2f-8b2a-bf9f38338902","metadata":{},"hash":"h53cvF4ZUDw/ImjEzGRoXaq7AnNSEn9rVdEoNomIOUU="}},"hash":"fhb4UTYY7C9VOxHvOkhoRsR5fy6a4EvOCPl7zIFDv7c=","text":"3.2.4.27 - rewrites\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/rewrites\r\nDescription: Add rewrites to your Next.js app. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nRewrites allow you to map an incoming request path to a different destination path. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn’t changed their location on the site. In\r\ncontrast, redirects will reroute to a new page and show the URL changes. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn’t changed their location on the site. In\r\ncontrast, redirects will reroute to a new page and show the URL changes. To use rewrites you can use the rewrites key in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n      },\r\n    ]\r\n  },\r\n}\r\nRewrites are applied to client-side routing, a <Link href=\"/about\"> will have the rewrite applied in the above example. rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and\r\ndestination properties:\r\nsource: String - is the incoming request path pattern. destination: String is the path you want to route to. basePath: false or undefined - if false the basePath won’t be included when matching, can be used for external rewrites only. locale: false or undefined - whether the locale should not be included when matching. has is an array of has objects with the type, key and value properties. missing is an array of missing objects with the type, key and value properties. When the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before\r\ndynamic routes.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b7cd3804-8936-4a2f-8b2a-bf9f38338902":{"id_":"b7cd3804-8936-4a2f-8b2a-bf9f38338902","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yPE1FFDCex1wL5H7395lrMoykZJNfac7GMJ4lo60gSk=","metadata":{},"hash":"gywVlE4srQo7h3V2BvwUV0EgUPlfrIV86oM3g9UNZXY="},"PREVIOUS":{"nodeId":"b2567016-b1a7-40cf-a955-7b473a31dfc2","metadata":{},"hash":"fhb4UTYY7C9VOxHvOkhoRsR5fy6a4EvOCPl7zIFDv7c="}},"hash":"h53cvF4ZUDw/ImjEzGRoXaq7AnNSEn9rVdEoNomIOUU=","text":"When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more\r\nfinely controlled, as of v10.1 of Next.js:\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return {\r\n      beforeFiles: [\r\n        // These rewrites are checked after headers/redirects\r\n        // and before all files including _next/public files which\r\n        // allows overriding page files\r\n        {\r\n          source: '/some-page',\r\n          destination: '/somewhere-else',\r\n          has: [{ type: 'query', key: 'overrideMe' }],\r\n        },\r\n      ],\r\n      afterFiles: [\r\n        // These rewrites are checked after pages/public files\r\n        // are checked but before dynamic routes\r\n        {\r\n          source: '/non-existent',\r\n          destination: '/somewhere-else',\r\n        },\r\n      ],\r\n      fallback: [\r\n        // These rewrites are checked after both pages/public files\r\n        // and dynamic routes are checked\r\n        {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9992878f-fe80-40bf-9b4b-a473526f925a":{"id_":"9992878f-fe80-40bf-9b4b-a473526f925a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nYPs8VjMnptHvExf+xtp4tE0cYUzav7ovX4aWVJ/L8E=","metadata":{},"hash":"PienQ16qFS+Ty+FNwjWawuCUiQFXMp7CnoXyMb4JMNM="},"NEXT":{"nodeId":"55d5d689-435c-4ba8-91ad-17141b9df1b6","metadata":{},"hash":"IUl9S0fCBKBPbHUDIofqNKKPnpCcdm9HYJe0svPlkNs="}},"hash":"z3AexD9cSCLZ/dXIfl9+Uedfs408izMjiIiGmaSwydg=","text":"source: '/:path*',\r\n          destination: `https://my-old-site.com/:path*`,\r\n        },\r\n      ],\r\n    }\r\n  },\r\n}\r\nGood to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source,\r\nthey continue until all beforeFiles have been checked. The order Next.js routes are checked is:\r\n1. headers are checked/applied\r\n2. redirects are checked/applied\r\n3. beforeFiles rewrites are checked/applied\r\n4. static files from the public directory, _next/static files, and non-dynamic pages are checked/served\r\n5. afterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each\r\nmatch\r\n6. fallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets\r\nhave been checked. If you use fallback: true/’blocking’ in getStaticPaths, the fallback rewrites defined in your\r\nnext.config.js will not be run. 1. headers are checked/applied\r\n2. redirects are checked/applied\r\n3. beforeFiles rewrites are checked/applied\r\n4. static files from the public directory, _next/static files, and non-dynamic pages are checked/served\r\n5. afterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each\r\nmatch\r\n6. fallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets\r\nhave been checked. If you use fallback: true/’blocking’ in getStaticPaths, the fallback rewrites defined in your\r\nnext.config.js will not be run. Rewrite parameters\r\nWhen using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in thedestination\r\n. next.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/old-about/:path*',\r\n        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query\r\n      },\r\n    ]\r\n  },\r\n}\r\nIf a parameter is used in the destination none of the parameters will be automatically passed in the query.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"55d5d689-435c-4ba8-91ad-17141b9df1b6":{"id_":"55d5d689-435c-4ba8-91ad-17141b9df1b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nYPs8VjMnptHvExf+xtp4tE0cYUzav7ovX4aWVJ/L8E=","metadata":{},"hash":"PienQ16qFS+Ty+FNwjWawuCUiQFXMp7CnoXyMb4JMNM="},"PREVIOUS":{"nodeId":"9992878f-fe80-40bf-9b4b-a473526f925a","metadata":{},"hash":"z3AexD9cSCLZ/dXIfl9+Uedfs408izMjiIiGmaSwydg="}},"hash":"IUl9S0fCBKBPbHUDIofqNKKPnpCcdm9HYJe0svPlkNs=","text":"next.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/docs/:path*',\r\n        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query\r\n      },\r\n    ]\r\n  },\r\n}\r\nYou can still pass the parameters manually in the query if one is already used in the destination by specifying the query in thedestination\r\n. next.config.js (js)module.exports = {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2c1d015f-f2d3-4313-b412-22a8bb15f21d":{"id_":"2c1d015f-f2d3-4313-b412-22a8bb15f21d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NqDHR5RCEueUknXptDEctvlvhYnjYxHidecWXlos6Oo=","metadata":{},"hash":"X96Nirt0HMvz4QOd7qukF7qBEgQ4l68+XugPPQrbyGw="}},"hash":"lK0iB/BQFJ4WF4o29Hl0NPncMfAcyMRtTsDU5fBYJVo=","text":"async rewrites() {\r\n    return [\r\n      {\r\n        source: '/:first/:second',\r\n        destination: '/:first?second=:second',\r\n        // Since the :first parameter is used in the destination the :second parameter\r\n        // will not automatically be added in the query although we can manually add it\r\n        // as shown above\r\n      },\r\n    ]\r\n  },\r\n}\r\nGood to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the\r\nclient after hydration and provided in the query. Path Matching\r\nPath matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths):\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}\r\nWildcard Path Matching\r\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}\r\nRegex Path Matching\r\nTo match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match\r\n/blog/123 but not /blog/abc:\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/old-blog/:post(\\\\d{1,})',\r\n        destination: '/blog/:post', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}\r\nThe following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they\r\nmust be escaped by adding \\\\ before them:\r\nnext.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"47a488bb-d130-4eb1-8425-8d76ea0133b4":{"id_":"47a488bb-d130-4eb1-8425-8d76ea0133b4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3DR1H//v2q99Q+m1csyMfMbveYkNpiidpw6hVquKGuM=","metadata":{},"hash":"dtGn4uGiE4Iby+TzpD0RKCUNw0sF5b5Q22JkBRfSb0U="},"NEXT":{"nodeId":"a94b3291-f17f-40ed-ba0c-233298c7bbbb","metadata":{},"hash":"GlsEYycUaGlHDZp+Vq5RZ404LyeHFsVjtopc1Ed02U0="}},"hash":"CX1d+EQFfKH2TPv1zv08HQdnwYgPDO+XOTFy028VN5U=","text":"// this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        destination: '/en-us/:slug',\r\n      },\r\n    ]\r\n  },\r\n}\r\nHeader, Cookie, and Query Matching\r\nTo only match a rewrite when header, cookie, or query values also match the has field or don’t match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied. has and missing items can have the following fields:\r\ntype: String - must be either header, cookie, host, or query. key: String - the key from the selected type to match against. value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture\r\na specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in\r\nthe destination with :paramName. next.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      // if the header `x-rewrite-me` is present,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-rewrite-me',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n      // if the header `x-rewrite-me` is not present,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-rewrite-me',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n      // if the source, query, and cookie are matched,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // destination since value is provided and doesn't\r\n            // use a named capture group e.g.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a94b3291-f17f-40ed-ba0c-233298c7bbbb":{"id_":"a94b3291-f17f-40ed-ba0c-233298c7bbbb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3DR1H//v2q99Q+m1csyMfMbveYkNpiidpw6hVquKGuM=","metadata":{},"hash":"dtGn4uGiE4Iby+TzpD0RKCUNw0sF5b5Q22JkBRfSb0U="},"PREVIOUS":{"nodeId":"47a488bb-d130-4eb1-8425-8d76ea0133b4","metadata":{},"hash":"CX1d+EQFfKH2TPv1zv08HQdnwYgPDO+XOTFy028VN5U="}},"hash":"GlsEYycUaGlHDZp+Vq5RZ404LyeHFsVjtopc1Ed02U0=","text":"(?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        destination: '/:path*/home',\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, this rewrite will be applied\r\n      {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a3fefccc-d2b5-4837-8ee8-ee068c62a244":{"id_":"a3fefccc-d2b5-4837-8ee8-ee068c62a244","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"L8lu8NB+UF2dX+dggKD8gWjVnzd6rb4Yvrepr7eHsrE=","metadata":{},"hash":"EMON0ZA0sPTI2YNLA0MbsJUj1fYL4rqzDcrk4a1/UYQ="}},"hash":"wjy+C5k/oQ5nKdTCnZCzcz8w98OCh8xaRmiZvmw8u2g=","text":"source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        destination: '/home?authorized=:authorized',\r\n      },\r\n      // if the host is `example.com`,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n    ]\r\n  },\r\n}\r\nRewriting to an external URL\r\nExamples\r\nRewrites allow you to rewrite to an external url. This is especially useful for incrementally adopting Next.js. The following is an example\r\nrewrite for redirecting the /blog route of your main app to an external site. next.config.js (js)module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog',\r\n        destination: 'https://example.com/blog',\r\n      },\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}\r\nIf you’re using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also\r\nexpecting a trailing slash it should be included in the destination parameter as well. next.config.js (js)module.exports = {\r\n  trailingSlash: true,\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/',\r\n        destination: 'https://example.com/blog/',\r\n      },\r\n      {\r\n        source: '/blog/:path*/',\r\n        destination: 'https://example.com/blog/:path*/',\r\n      },\r\n    ]\r\n  },\r\n}\r\nIncremental adoption of Next.js\r\nYou can also have Next.js fall back to proxying to an existing website after checking all Next.js routes. This way you don’t have to change the rewrites configuration when migrating more pages to Next.js\r\nnext.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9daa3865-9c0d-4e06-b59b-e9be57adc630":{"id_":"9daa3865-9c0d-4e06-b59b-e9be57adc630","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pFJJ/wLWgFNvLXplKa+oXmXM1kDZC9ZwoxBiwW3ZC18=","metadata":{},"hash":"ZzGWw0yI0UHUsUUZM8Imj53HLwv5dqopnA83qI503bA="}},"hash":"bK1Bqwi8WYznj/rDft5uMX1kjXyR+36ykZzo9Ucdrqc=","text":"module.exports = {\r\n  async rewrites() {\r\n    return {\r\n      fallback: [\r\n        {\r\n          source: '/:path*',\r\n          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,\r\n        },\r\n      ],\r\n    }\r\n  },\r\n}\r\nRewrites with basePath support\r\nWhen leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless\r\nyou add basePath: false to the rewrite:\r\nnext.config.js (js)module.exports = {\r\n  basePath: '/docs',\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\r\n        destination: '/another', // automatically becomes /docs/another\r\n      },\r\n      {\r\n        // does not add /docs to /without-basePath since basePath: false is set\r\n        // Note: this can not be used for internal rewrites e.g. `destination: '/another'`\r\n        source: '/without-basePath',\r\n        destination: 'https://example.com',\r\n        basePath: false,\r\n      },\r\n    ]\r\n  },\r\n}\r\nRewrites with i18n support\r\nWhen leveraging i18n support with rewrites each source and destination is automatically prefixed to handle the configured\r\nlocales unless you add locale: false to the rewrite. If locale: false is used you must prefix the source and destination with\r\na locale for it to be matched correctly. When leveraging i18n support with rewrites each source and destination is automatically prefixed to handle the configured\r\nlocales unless you add locale: false to the rewrite. If locale: false is used you must prefix the source and destination with\r\na locale for it to be matched correctly. next.config.js (js)module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        destination: '/another', // automatically passes the locale on\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        destination: '/nl/another',\r\n        locale: false,\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        destination: '/en/another',\r\n        locale: false,\r\n      },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3eec77f3-75bf-4ca4-bfbd-dba2c8c3486c":{"id_":"3eec77f3-75bf-4ca4-bfbd-dba2c8c3486c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"5LqPDUzwwukS1HA98YLPoZy6bYp8wsUtT0Pz+BmmZPA=","metadata":{},"hash":"bhpa0NX2tbGi0ZW5MrcXp1dCHyKrUryimkaYHar0LJg="}},"hash":"ia1EQivm7NZ2/8K0nGw583jCqPO9v9Hvzic951nFxDE=","text":"{\r\n        // it's possible to match all locales even when locale: false is set\r\n        source: '/:locale/api-alias/:path*',\r\n        destination: '/api/:path*',\r\n        locale: false,\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\r\n        // `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        destination: '/another',\r\n      },\r\n    ]\r\n  },\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.3.0missing added. v10.2.0has added. v9.5.0Headers added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0e108b99-b96b-4586-a520-e6189a1da075":{"id_":"0e108b99-b96b-4586-a520-e6189a1da075","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3KA5kXcFbYrYtnqjtVkh+ZbT3wrUbRsVRiaCYU2x2YY=","metadata":{},"hash":"lZJXNA3d/EcNKRZ7GfEAd7xSz4pCjNHrilj71TBdwPE="}},"hash":"Ll/AIK6h/6noqU8MBo/A21GATPdFUlDqjb9+nJd4nE4=","text":"3.2.4.28 - serverActions\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/serverActions\r\nDescription: Configure Server Actions behavior in your Next.js application. Options for configuring Server Actions behavior in your Next.js application.allowedOriginsallowedOrigins\r\nA list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of a Server Action request\r\nwith the host domain, ensuring they match to prevent CSRF attacks. If not provided, only the same origin is allowed. next.config.js (js)/** @type {import('next').NextConfig} */\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\r\n    },\r\n  },\r\n}\r\nbodySizeLimitbodySizeLimit\r\nBy default, the maximum size of the request body sent to a Server Action is 1MB, to prevent the consumption of excessive server\r\nresources in parsing large amounts of data, as well as potential DDoS attacks. However, you can configure this limit using the serverActions.bodySizeLimit option. It can take the number of bytes or any string\r\nformat supported by bytes, for example 1000, '500kb' or '3mb'. next.config.js (js)/** @type {import('next').NextConfig} */\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      bodySizeLimit: '2mb',\r\n    },\r\n  },\r\n}\r\nEnabling Server Actions (v13)\r\nServer Actions became a stable feature in Next.js 14, and are enabled by default. However, if you are using an earlier version of Next.js,\r\nyou can enable them by setting experimental.serverActions to true. next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst config = {\r\n  experimental: {\r\n    serverActions: true,\r\n  },\r\n}\r\nmodule.exports = config","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"74182dbe-0aa8-43d5-90d3-5486c5d1a8e8":{"id_":"74182dbe-0aa8-43d5-90d3-5486c5d1a8e8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"dEX2+z1TEwZ33kjnuh9hGILbfJ6vdhZdNlFA+oX23W8=","metadata":{},"hash":"V9WJQsMjx+kjYDmisrRXJOIjTC7VzHIEEWTescTXEJk="}},"hash":"GPUXwgFjsIEBB1F+bE68J057/J+jqrwtYH56NV+qJzg=","text":"3.2.4.29 - serverComponentsExternalPackages\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/serverComponentsExternalPackages\r\nDescription: Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. Dependencies used inside Server Components and Route Handlers will automatically be bundled by Next.js. If a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components\r\nbundling and use native Node.js require. next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    serverComponentsExternalPackages: ['@acme/ui'],\r\n  },\r\n}\r\nmodule.exports = nextConfig\r\nNext.js includes a short list of popular packages that currently are working on compatibility and automatically opt-ed out:\r\n@aws-sdk/client-s3\r\n@aws-sdk/s3-presigned-post\r\n@blockfrost/blockfrost-js\r\n@libsql/client\r\n@jpg-store/lucid-cardano\r\n@mikro-orm/core\r\n@mikro-orm/knex\r\n@prisma/client\r\n@sentry/nextjs\r\n@sentry/node\r\n@swc/core\r\nargon2\r\nautoprefixer\r\naws-crt\r\nbcrypt\r\nbetter-sqlite3\r\ncanvas\r\ncpu-features\r\ncypress\r\neslint\r\nexpress\r\nfirebase-admin\r\njest\r\njsdom\r\nlibsql\r\nlodash\r\nmdx-bundler\r\nmongodb\r\nmongoose\r\nnext-mdx-remote\r\nnext-seo\r\npayload\r\npg\r\nplaywright\r\npostcss\r\nprettier\r\nprisma\r\npuppeteer\r\nrimraf","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"84de98ab-85d8-48dd-94ee-2fa2b67300f1":{"id_":"84de98ab-85d8-48dd-94ee-2fa2b67300f1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tR5IdzXziU4kE/94ptYDWQBN9uuv6GouW9ee3VnFuJE=","metadata":{},"hash":"mLQqoaXsIWOnMwqV2wqsVH/H+DFZs6bbrF1W/IGu5d8="}},"hash":"5SZIT5ml0DH+7D4wxlxNMAjaZVtyz8dIcap2UxrIfk8=","text":"sharp\r\nshiki\r\nsqlite3\r\ntailwindcss\r\nts-node\r\ntypescript\r\nvscode-oniguruma\r\nwebpack","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"957c2470-e33b-46a8-9300-3dc18a31201e":{"id_":"957c2470-e33b-46a8-9300-3dc18a31201e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ABz9YtViDvi4NlM/ll09E8QpkBFfeUcwXDNmNLK5kTU=","metadata":{},"hash":"8UJZipcrhkgbft1wFhSawqh/Q9UYCDCddPSMtSEByDQ="}},"hash":"iTNYQKciUHj0xIG/1yVpY6pz+FYNHc1z6iu/Z0Gqoa4=","text":"3.2.4.30 - trailingSlash\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/trailingSlash\r\nDescription: Configure Next.js pages to resolve with or without a trailing slash. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nBy default Next.js will redirect urls with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect\r\nto /about. You can configure this behavior to act the opposite way, where urls without trailing slashes are redirected to their\r\ncounterparts with trailing slashes. Open next.config.js and add the trailingSlash config:\r\nnext.config.js (js)module.exports = {\r\n  trailingSlash: true,\r\n}\r\nWith this option set, urls like /about will redirect to /about/. Version History\r\nVersionChanges\r\nv9.5.0trailingSlash added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5ea033f7-d95a-45d5-ac1e-cbc935f0ec46":{"id_":"5ea033f7-d95a-45d5-ac1e-cbc935f0ec46","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"gO33af5EnN23SKedve3h+7G9jbk/Fe09H6HvpJzRsvY=","metadata":{},"hash":"8qDGLoAV1tHhYaDFFwHQvQO4L8Ku3GY+jkXYlpKhz6Q="}},"hash":"hUIxrHs2kIlM5wFnrtXsks/cDPlCOCDOFe4bnJPGsZg=","text":"3.2.4.31 - transpilePackages\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/transpilePackages\r\nDescription: Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies\r\n(`node_modules`). {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies\r\n(node_modules). This replaces the next-transpile-modules package. next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  transpilePackages: ['@acme/ui', 'lodash-es'],\r\n}\r\nmodule.exports = nextConfig\r\nVersion History\r\nVersionChanges\r\nv13.0.0transpilePackages added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a13087c3-fa3d-465f-a6e6-0a0df0a5f4ea":{"id_":"a13087c3-fa3d-465f-a6e6-0a0df0a5f4ea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Yys4ULaPN4m53T0g+791p98E40f8lcPBffB1VuJ2FRA=","metadata":{},"hash":"yefK3UnMwhh5uLkr/h23EXL06inyWJdtHlHZSuKzVeo="}},"hash":"DW426srlLClD6xf0p04ZFpfCpZUMjHB9RlraQMGTCRI=","text":"3.2.4.32 - turbo (Experimental)\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/turbo\r\nDescription: Configure Next.js with Turbopack-specific options\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nWarning: These features are experimental and will only work with next --turbo. webpack loaders\r\nCurrently, Turbopack supports a subset of webpack’s loader API, allowing you to use some webpack loaders to transform code in\r\nTurbopack. To configure loaders, add the names of the loaders you’ve installed and any options in next.config.js, mapping file extensions to a\r\nlist of loaders:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    turbo: {\r\n      rules: {\r\n        // Option format\r\n        '*.md': [\r\n          {\r\n            loader: '@mdx-js/loader',\r\n            options: {\r\n              format: 'md',\r\n            },\r\n          },\r\n        ],\r\n        // Option-less format\r\n        '*.mdx': ['@mdx-js/loader'],\r\n      },\r\n    },\r\n  },\r\n}\r\nThen, given the above configuration, you can use transformed code from your app:\r\nimport MyDoc from './my-doc.mdx'\r\nexport default function Home() {\r\n  return <MyDoc />\r\n}\r\nResolve Alias\r\nThrough next.config.js, Turbopack can be configured to modify module resolution through aliases, similar to webpack’s\r\nresolve.alias configuration. To configure resolve aliases, map imported patterns to their new destination in next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    turbo: {\r\n      resolveAlias: {\r\n        underscore: 'lodash',\r\n        mocha: { browser: 'mocha/browser-entry.js' },\r\n      },\r\n    },\r\n  },\r\n}\r\nThis aliases imports of the underscore package to the lodash package. In other words, import underscore from 'underscore'\r\nwill load the lodash module instead of underscore. Turbopack also supports conditional aliasing through this field, similar to Node.js’s conditional exports. At the moment only the","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9a5cbd6e-2aed-44f7-bcfe-4fbccaf8e63b":{"id_":"9a5cbd6e-2aed-44f7-bcfe-4fbccaf8e63b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vJP6mU4tfDMs7WYUEDtsSteedgJZFu2ofGyoYqRMEUk=","metadata":{},"hash":"vDfxOH7eTO8XBSv+zXJXAgZPd8J0M18RwfpJDAWumt4="}},"hash":"/56FFPm06gdb9cSMxxWNiavSzk3UrBpnJOwuGb/tUW8=","text":"browser condition is supported. In the case above, imports of the mocha module will be aliased to mocha/browser-entry.js when\r\nTurbopack targets browser environments. For more information and guidance for how to migrate your app to Turbopack from webpack, see Turbopack’s documentation on\r\nwebpack compatibility.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d85cb80c-6917-463b-8241-140411aaccb1":{"id_":"d85cb80c-6917-463b-8241-140411aaccb1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"oI8exyplI+jRDxkqnNmf15cumoSGfpOipjrtdmmMq1k=","metadata":{},"hash":"N87Jp6kEo/vqvrukOmykqcJdFxuZFh1iIQBnOZHO82Q="}},"hash":"TIueGZIKsDDCQC7ChUzcRarq/aVqMwdu5MZPjjgIpYY=","text":"3.2.4.33 - typedRoutes (experimental)\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/typedRoutes\r\nDescription: Enable experimental support for statically typed links. Experimental support for statically typed links. This feature requires using the App Router as well as TypeScript in your project. next.config.js (js)/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    typedRoutes: true,\r\n  },\r\n}\r\nmodule.exports = nextConfig","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4ba1064d-a0b6-4bc8-966a-30eab060669d":{"id_":"4ba1064d-a0b6-4bc8-966a-30eab060669d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zOGcbsWriNl+2luqIgPtGzLIhw4cw0CttPfEwF2pvLc=","metadata":{},"hash":"I1RFaaVwyyqhC18L55Llo87xihkCLk+5uM7jFo9KcJc="}},"hash":"a40j03JndTtt976qphGD6AWtg0IEdqkMyzsG5Tp1Jws=","text":"3.2.4.34 - typescript\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/typescript\r\nDescription: Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nNext.js fails your production build (next build) when TypeScript errors are present in your project. If you’d like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type\r\nchecking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.js and enable the ignoreBuildErrors option in the typescript config:\r\nnext.config.js (js)module.exports = {\r\n  typescript: {\r\n    // !! WARN !! // Dangerously allow production builds to successfully complete even if\r\n    // your project has type errors. // !! WARN !! ignoreBuildErrors: true,\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f430ac0c-a897-4ee2-86f9-c0e3c38b5055":{"id_":"f430ac0c-a897-4ee2-86f9-c0e3c38b5055","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"m5PX7Mf+0xKETmQ8BESM38iSGiKTBLeNk3rC5cyfnRY=","metadata":{},"hash":"rxs59jCTBdLTbY8uiTYLxbnwOqVWu/K/skKNJv5RxeY="},"NEXT":{"nodeId":"8adad40a-268c-4ee4-8d12-91a67b0559c7","metadata":{},"hash":"Dt6AIVyErm3kW5sypBPkx//d9eSkrRv5RKOK02y+gfI="}},"hash":"257GXL8O9qLO+bkaTmNQU0GBiXMnzmQN38xoQOmY1qU=","text":"3.2.4.35 - urlImports\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/urlImports\r\nDescription: Configure Next.js to allow importing modules from external URLs (experimental). {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nURL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local\r\ndisk). Warning: This feature is experimental. Only use domains that you trust to download and execute on your machine. Please\r\nexercise discretion, and caution until the feature is flagged as stable. To opt-in, add the allowed URL prefixes inside next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],\r\n  },\r\n}\r\nThen, you can import modules directly from URLs:\r\nimport { a, b, c } from 'https://example.com/assets/some/module.js'\r\nURL Imports can be used everywhere normal package imports can be used. Security Model\r\nThis feature is being designed with security as the top priority. To start, we added an experimental flag forcing you to explicitly allow\r\nthe domains you accept URL imports from. We’re working to take this further by limiting URL imports to execute in the browser\r\nsandbox using the Edge Runtime. Lockfile\r\nWhen using URL imports, Next.js will create a next.lock directory containing a lockfile and fetched assets. This directory must be\r\ncommitted to Git, not ignored by .gitignore. When running next dev, Next.js will download and add all newly discovered URL Imports to your lockfile\r\nWhen running next build, Next.js will use only the lockfile to build the application for production\r\nTypically, no network requests are needed and any outdated lockfile will cause the build to fail. One exception is resources that\r\nrespond with Cache-Control: no-cache. These resources will have a no-cache entry in the lockfile and will always be fetched from\r\nthe network on each build.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8adad40a-268c-4ee4-8d12-91a67b0559c7":{"id_":"8adad40a-268c-4ee4-8d12-91a67b0559c7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"m5PX7Mf+0xKETmQ8BESM38iSGiKTBLeNk3rC5cyfnRY=","metadata":{},"hash":"rxs59jCTBdLTbY8uiTYLxbnwOqVWu/K/skKNJv5RxeY="},"PREVIOUS":{"nodeId":"f430ac0c-a897-4ee2-86f9-c0e3c38b5055","metadata":{},"hash":"257GXL8O9qLO+bkaTmNQU0GBiXMnzmQN38xoQOmY1qU="}},"hash":"Dt6AIVyErm3kW5sypBPkx//d9eSkrRv5RKOK02y+gfI=","text":"Examples\r\nSkypack\r\nimport confetti from 'https://cdn.skypack.dev/canvas-confetti'\r\nimport { useEffect } from 'react'\r\nexport default () => {\r\n  useEffect(() => {\r\n    confetti()\r\n  })\r\n  return <p>Hello</p>\r\n}\r\nStatic Image Imports\r\nimport Image from 'next/image'\r\nimport logo from 'https://example.com/assets/logo.png'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"803f6c01-73ec-4804-9049-72121750893c":{"id_":"803f6c01-73ec-4804-9049-72121750893c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AY0JViHioY84Btd4Rl+udFESkyh0EOdLsFdK7j2Nrcs=","metadata":{},"hash":"mUoDRR3j+Fga82UmJHUQmrln5TEPp3Xi2dULsGb1Y2Y="}},"hash":"nbSp9alX++sTqaLRFEBh+ccIZ1fZ0zIcE27LxDVgwLQ=","text":"export default () => (\r\n  <div>\r\n    <Image src={logo} placeholder=\"blur\" />\r\n  </div>\r\n)\r\nURLs in CSS\r\n.className {\r\n  background: url('https://example.com/assets/hero.jpg');\r\n}\r\nAsset Imports\r\nconst logo = new URL('https://example.com/assets/file.txt', import.meta.url)\r\nconsole.log(logo.pathname)\r\n// prints \"/_next/static/media/file.a9727b5d.txt\"","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4b01586e-ba23-4d49-82eb-ff8e75525327":{"id_":"4b01586e-ba23-4d49-82eb-ff8e75525327","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KWTZewwsuFBC4qXD3oRghg3eKHgnWN9yrUIYsQ38FWA=","metadata":{},"hash":"auFH+v2Yi8cHc+Wa850Uhr4+oNWkxTMyFPn2hEBPtK8="}},"hash":"3AdO0qD3KJpvnviqVKg9WzkjY38gu0ZQyglr5PUtRjk=","text":"3.2.4.36 - webVitalsAttribution\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/webVitalsAttribution\r\nDescription: Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nWhen debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem. For example, in the case\r\nof Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred. Or,\r\nin the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page. If the LCP\r\nelement is an image, knowing the URL of the image resource can help us locate the asset we need to optimize. Pinpointing the biggest contributor to the Web Vitals score, aka attribution, allows us to obtain more in-depth information like entries\r\nfor PerformanceEventTiming, PerformanceNavigationTiming and PerformanceResourceTiming. Attribution is disabled by default in Next.js but can be enabled per metric by specifying the following in next.config.js. next.config.js (js)experimental: {\r\n  webVitalsAttribution: ['CLS', 'LCP']\r\n}\r\nValid attribution values are all web-vitals metrics specified in the NextWebVitalsMetric type.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0ebccb41-a845-4e0f-bc39-39d450642f00":{"id_":"0ebccb41-a845-4e0f-bc39-39d450642f00","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rKcYGZf2FTbACSX6N/aJdmwq0kpbH9VpfgGe8AXMfhY=","metadata":{},"hash":"hmyGb8X/JRU4ZO5LYlq7yWGFTsNO36lXdlD/To0Eo2U="},"NEXT":{"nodeId":"97f4dc5c-36d0-44b7-8066-777989289046","metadata":{},"hash":"kyJRTZxVYwqk5s5LzpEbwxJNCFmTy9Gs8QQa1we44QU="}},"hash":"TqKO/kEF1Bs/rpgRtsn3iB2ZO3ERRHFPSf6Aq3cjo2A=","text":"3.2.4.37 - Custom Webpack Config\r\nDocumentation path: /02-app/02-api-reference/05-next-config-js/webpack\r\nDescription: Learn how to customize the webpack config used by Next.js\r\n{/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nGood to know: changes to webpack config are not covered by semver so proceed at your own risk\r\nBefore continuing to add custom webpack configuration to your application make sure Next.js doesn’t already support your use-case:\r\nCSS imports\r\nCSS modules\r\nSass/SCSS imports\r\nSass/SCSS modules\r\nCSS imports\r\nCSS modules\r\nSass/SCSS imports\r\nSass/SCSS modules\r\nCustomizing babel configuration\r\nSome commonly asked for features are available as plugins:\r\n@next/mdx\r\n@next/bundle-analyzer\r\nIn order to extend our usage of webpack, you can define a function that extends its config inside next.config.js, like so:\r\nnext.config.js (js)module.exports = {\r\n  webpack: (\r\n    config,\r\n    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }\r\n  ) => {\r\n    // Important: return the modified config\r\n    return config\r\n  },\r\n}\r\nThe webpack function is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows\r\nyou to distinguish between client and server configuration using the isServer property.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"97f4dc5c-36d0-44b7-8066-777989289046":{"id_":"97f4dc5c-36d0-44b7-8066-777989289046","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rKcYGZf2FTbACSX6N/aJdmwq0kpbH9VpfgGe8AXMfhY=","metadata":{},"hash":"hmyGb8X/JRU4ZO5LYlq7yWGFTsNO36lXdlD/To0Eo2U="},"PREVIOUS":{"nodeId":"0ebccb41-a845-4e0f-bc39-39d450642f00","metadata":{},"hash":"TqKO/kEF1Bs/rpgRtsn3iB2ZO3ERRHFPSf6Aq3cjo2A="}},"hash":"kyJRTZxVYwqk5s5LzpEbwxJNCFmTy9Gs8QQa1we44QU=","text":"This allows\r\nyou to distinguish between client and server configuration using the isServer property. The second argument to the webpack function is an object with the following properties:\r\nbuildId: String - The build id, used as a unique identifier between builds\r\ndev: Boolean - Indicates if the compilation will be done in development\r\nisServer: Boolean - It’s true for server-side compilation, and false for client-side compilation\r\nnextRuntime: String | undefined - The target runtime for server-side compilation; either \"edge\" or \"nodejs\", it’s undefined\r\nfor client-side compilation.defaultLoaders\r\n: Object - Default loaders used internally by Next.js:\r\nbabel: Object - Default babel-loader configuration\r\nExample usage of defaultLoaders.babel:\r\n// Example config for adding a loader that depends on babel-loader\r\n// This source was taken from the @next/mdx plugin source:\r\n// https://github.com/vercel/next.js/tree/canary/packages/next-mdx\r\nmodule.exports = {\r\n  webpack: (config, options) => {\r\n    config.module.rules.push({\r\n      test: /\\.mdx/,\r\n      use: [\r\n        options.defaultLoaders.babel,\r\n        {\r\n          loader: '@mdx-js/loader',\r\n          options: pluginOptions.options,\r\n        },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ff1f2bcc-0145-43e5-8c28-b7258325b915":{"id_":"ff1f2bcc-0145-43e5-8c28-b7258325b915","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1LI4YxR1xN87zVo5lAtyDxV1nkQ87b/9KVUCm94zTSg=","metadata":{},"hash":"9tLSaxhEqDizx144dWkl0nRrRMWM7emG5plZzcHlCnA="}},"hash":"Qs2YnrYX8vUqrBw3uYds+3CsxdxQLhQLCS5KodFKpWs=","text":"],\r\n    })\r\n    return config\r\n  },\r\n}\r\nnextRuntimenextRuntime\r\nNotice that isServer is true when nextRuntime is \"edge\" or \"nodejs\", nextRuntime “edge” is currently for middleware and Server\r\nComponents in edge runtime only.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bb75e9ba-6fd9-4a04-9f0b-b508d4401745":{"id_":"bb75e9ba-6fd9-4a04-9f0b-b508d4401745","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hN43DV5GUD5k0oB5duNRkAtoDnuggT2uelWnUR6hr50=","metadata":{},"hash":"soDI/TxEe0twCnwsbeipwubUR1C6jaMWkOJ92Zz6eDw="}},"hash":"o/gQH0csrfdIF/hGvyX1nBfVDPcLnbmmBzgxv/DxawA=","text":"3.2.5 - create-next-app\r\nDocumentation path: /02-app/02-api-reference/06-create-next-app\r\nDescription: Create Next.js apps in one command with create-next-app. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThe easiest way to get started with Next.js is by using create-next-app. This CLI tool enables you to quickly start building a new\r\nNext.js application, with everything set up for you. You can create a new app using the default Next.js template, or by using one of the official Next.js examples. Interactive\r\nYou can create a new project interactively by running:\r\nTerminal (bash)npx create-next-app@latest\r\nTerminal (bash)yarn create next-app\r\nTerminal (bash)pnpm create next-app\r\nTerminal (bash)bunx create-next-app\r\nYou will then be asked the following prompts:\r\nTerminal (txt)What is your project named? my-app\r\nWould you like to use TypeScript? No / Yes\r\nWould you like to use ESLint? No / Yes\r\nWould you like to use Tailwind CSS? No / Yes\r\nWould you like to use `src/` directory? No / Yes\r\nWould you like to use App Router? (recommended)  No / Yes\r\nWould you like to customize the default import alias (@/*)? No / Yes\r\nOnce you’ve answered the prompts, a new project will be created with the correct configuration depending on your answers. Non-interactive\r\nYou can also pass command line arguments to set up a new project non-interactively. Further, you can negate default options by prefixing them with --no- (e.g. --no-eslint). See create-next-app --help:\r\nTerminal (bash)Usage: create-next-app <project-directory> [options]\r\nOptions:\r\n  -V, --version                        output the version number\r\n  --ts, --typescript\r\n    Initialize as a TypeScript project. (default)\r\n  --js, --javascript\r\n    Initialize as a JavaScript project. --tailwind\r\n    Initialize with Tailwind CSS config. (default)\r\n  --eslint\r\n    Initialize with ESLint config. --app","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f6a1e032-06e0-4a9f-8dab-b1297c75ddec":{"id_":"f6a1e032-06e0-4a9f-8dab-b1297c75ddec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uJmY5znYf0+KhR4HoCtm0ZL2fo0s+vROE14XAVLGOsA=","metadata":{},"hash":"jYTU+prDYlr/Fs/3/xmO4nhNpQbIqw9KmOc/guh259Y="}},"hash":"c0uvQIFEe29Hp/TCoLrprVwQMAORu6FNIkVCJgdLrxE=","text":"Initialize as an App Router project. --src-dir\r\n    Initialize inside a `src/` directory. --import-alias <alias-to-configure>\r\n    Specify import alias to use (default \"@/*\"). --use-npm\r\n    Explicitly tell the CLI to bootstrap the app using npm\r\n  --use-pnpm\r\n    Explicitly tell the CLI to bootstrap the app using pnpm\r\n  --use-yarn\r\n    Explicitly tell the CLI to bootstrap the app using Yarn\r\n  --use-bun\r\n    Explicitly tell the CLI to bootstrap the app using Bun\r\n  -e, --example [name]|[github-url]\r\n    An example to bootstrap the app with. You can use an example name\r\n    from the official Next.js repo or a public GitHub URL. The URL can use\r\n    any branch and/or subdirectory\r\n  --example-path <path-to-example>\r\n    In a rare case, your GitHub URL might contain a branch name with\r\n    a slash (e.g. bug/fix-1) and the path to the example (e.g. foo/bar). In this case, you must specify the path to the example separately:\r\n    --example-path foo/bar\r\n  --reset-preferences\r\n    Explicitly tell the CLI to reset any stored preferences\r\n  -h, --help                           output usage information\r\nWhy use Create Next App? create-next-app allows you to create a new Next.js app within seconds. It is officially maintained by the creators of Next.js, and\r\nincludes a number of benefits:\r\nInteractive Experience: Running npx create-next-app@latest (with no arguments) launches an interactive experience that\r\nguides you through setting up a project. Zero Dependencies: Initializing a project is as quick as one second. Create Next App has zero dependencies. Offline Support: Create Next App will automatically detect if you’re offline and bootstrap your project using your local package\r\ncache. Support for Examples: Create Next App can bootstrap your application using an example from the Next.js examples collection\r\n(e.g. npx create-next-app --example api-routes) or any public GitHub repository. Tested: The package is part of the Next.js monorepo and tested using the same integration test suite as Next.js itself, ensuring it\r\nworks as expected with every release.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7f7eb129-5bd2-48c5-b375-1167795c4d76":{"id_":"7f7eb129-5bd2-48c5-b375-1167795c4d76","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bmHz1yRSh2gHD0PzAuNu+SgPScaogWxxivxt46OHvwk=","metadata":{},"hash":"f9q4WK08fXR0OFkB11nMY34nfZt7ElLgt3BEj+bqgSw="}},"hash":"GEqTJ6b279Sjl2xm98PJp2xFqYG0DN1wM88jgOuZxtQ=","text":"3.2.6 - Edge Runtime\r\nDocumentation path: /02-app/02-api-reference/07-edge\r\nDescription: API Reference for the Edge Runtime. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThe Next.js Edge Runtime is based on standard Web APIs, it supports the following APIs:\r\nNetwork APIs\r\nAPIDescription\r\nBlobRepresents a blob\r\nfetchFetches a resource\r\nFetchEventRepresents a fetch event\r\nFileRepresents a file\r\nFormDataRepresents form data\r\nHeadersRepresents HTTP headers\r\nRequestRepresents an HTTP request\r\nResponseRepresents an HTTP response\r\nURLSearchParamsRepresents URL search parameters\r\nWebSocketRepresents a websocket connection\r\nEncoding APIs\r\nAPIDescription\r\natobDecodes a base-64 encoded string\r\nbtoaEncodes a string in base-64\r\nTextDecoderDecodes a Uint8Array into a string\r\nTextDecoderStreamChainable decoder for streams\r\nTextEncoderEncodes a string into a Uint8Array\r\nTextEncoderStreamChainable encoder for streams\r\nStream APIs\r\nAPIDescription\r\nReadableStreamRepresents a readable stream\r\nReadableStreamBYOBReaderRepresents a reader of a ReadableStream\r\nReadableStreamDefaultReaderRepresents a reader of a ReadableStream\r\nTransformStreamRepresents a transform stream\r\nWritableStreamRepresents a writable stream\r\nWritableStreamDefaultWriterRepresents a writer of a WritableStream\r\nCrypto APIs","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8d3606d7-b977-4bb5-8aa4-455299d38497":{"id_":"8d3606d7-b977-4bb5-8aa4-455299d38497","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"h+1a7JUvMZViz1OvyivPWnu+i2Fgp6yBaaXKLaFucm8=","metadata":{},"hash":"vnX/hFfEMbBYC480g2U036hp4rBl2l/OhrHc4BVBUjw="}},"hash":"Wig8yNrTuh2JrA+5K33l5KO2nTB+7eL6L6mjmfCc1bY=","text":"APIDescription\r\ncryptoProvides access to the cryptographic functionality of the platform\r\nCryptoKeyRepresents a cryptographic key\r\nSubtleCryptoProvides access to common cryptographic primitives, like hashing, signing, encryption or decryption\r\nWeb Standard APIs\r\nAPIDescription\r\nAbortControllerAllows you to abort one or more DOM requests as and when desired\r\nArrayRepresents an array of values\r\nArrayBufferRepresents a generic, fixed-length raw binary data buffer\r\nAtomicsProvides atomic operations as static methods\r\nBigIntRepresents a whole number with arbitrary precision\r\nBigInt64ArrayRepresents a typed array of 64-bit signed integers\r\nBigUint64ArrayRepresents a typed array of 64-bit unsigned integers\r\nBooleanRepresents a logical entity and can have two values: true and false\r\nclearIntervalCancels a timed, repeating action which was previously established by a call to setInterval()\r\nclearTimeoutCancels a timed, repeating action which was previously established by a call to setTimeout()\r\nconsoleProvides access to the browser’s debugging console\r\nDataViewRepresents a generic view of an ArrayBuffer\r\nDateRepresents a single moment in time in a platform-independent format\r\ndecodeURIDecodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine\r\ndecodeURIComponentDecodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a\r\nsimilar routine\r\nDOMExceptionRepresents an error that occurs in the DOM\r\nencodeURIEncodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two,\r\nthree, or four escape sequences representing the UTF-8 encoding of the character\r\nencodeURIComponentEncodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by\r\none, two, three, or four escape sequences representing the UTF-8 encoding of the character\r\nErrorRepresents an error when trying to execute a statement or accessing a property\r\nEvalErrorRepresents an error that occurs regarding the global function eval()\r\nFloat32ArrayRepresents a typed array of 32-bit floating point numbers\r\nFloat64ArrayRepresents a typed array of 64-bit floating point numbers\r\nFunctionRepresents a function\r\nInfinityRepresents the mathematical Infinity value\r\nInt8ArrayRepresents a typed array of 8-bit signed integers\r\nInt16ArrayRepresents a typed array of 16-bit signed integers\r\nInt32ArrayRepresents a typed array of 32-bit signed integers\r\nIntlProvides access to internationalization and localization functionality\r\nisFiniteDetermines whether a value is a finite number\r\nisNaNDetermines whether a value is NaN or not","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a375cd57-f28d-48b4-af6a-d45d23bd62d8":{"id_":"a375cd57-f28d-48b4-af6a-d45d23bd62d8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cO0R3Yt0Tha9yaPmvDc4nvQUIFRxQW6Wdn7cABNRi2o=","metadata":{},"hash":"DnJ/HESnL5+0m2v9ukjXZMXkr82p2KvQV7pBthveXwI="}},"hash":"uf9jUdA6bvaRkybphlpZ0IKYkPRLvK5nKhpw9tO/uq0=","text":"JSONProvides functionality to convert JavaScript values to and from the JSON format\r\nMapRepresents a collection of values, where each value may occur only once\r\nMathProvides access to mathematical functions and constants\r\nNumberRepresents a numeric value\r\nObjectRepresents the object that is the base of all JavaScript objects\r\nparseFloatParses a string argument and returns a floating point number\r\nparseIntParses a string argument and returns an integer of the specified radix\r\nPromiseRepresents the eventual completion (or failure) of an asynchronous operation, and its resulting value\r\nProxyRepresents an object that is used to define custom behavior for fundamental operations (e.g. property\r\nlookup, assignment, enumeration, function invocation, etc)\r\nqueueMicrotaskQueues a microtask to be executed\r\nRangeErrorRepresents an error when a value is not in the set or range of allowed values\r\nReferenceErrorRepresents an error when a non-existent variable is referenced\r\nReflectProvides methods for interceptable JavaScript operations\r\nRegExpRepresents a regular expression, allowing you to match combinations of characters\r\nSetRepresents a collection of values, where each value may occur only once\r\nsetIntervalRepeatedly calls a function, with a fixed time delay between each call\r\nsetTimeoutCalls a function or evaluates an expression after a specified number of milliseconds\r\nSharedArrayBufferRepresents a generic, fixed-length raw binary data buffer\r\nStringRepresents a sequence of characters\r\nstructuredCloneCreates a deep copy of a value\r\nSymbolRepresents a unique and immutable data type that is used as the key of an object property\r\nSyntaxErrorRepresents an error when trying to interpret syntactically invalid code\r\nTypeErrorRepresents an error when a value is not of the expected type\r\nUint8ArrayRepresents a typed array of 8-bit unsigned integers\r\nUint8ClampedArrayRepresents a typed array of 8-bit unsigned integers clamped to 0-255\r\nUint32ArrayRepresents a typed array of 32-bit unsigned integers\r\nURIErrorRepresents an error when a global URI handling function was used in a wrong way\r\nURLRepresents an object providing static methods used for creating object URLs\r\nURLPatternRepresents a URL pattern\r\nURLSearchParamsRepresents a collection of key/value pairs\r\nWeakMapRepresents a collection of key/value pairs in which the keys are weakly referenced\r\nWeakSetRepresents a collection of objects in which each object may occur only once\r\nWebAssemblyProvides access to WebAssembly\r\nAPIDescription\r\nNext.js Specific Polyfills\r\nAsyncLocalStorage\r\nEnvironment Variables","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a637c3e8-fa29-4291-a218-194c801b0dfd":{"id_":"a637c3e8-fa29-4291-a218-194c801b0dfd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NnWDyQNO2rgNv/0JQi99yLr6HLcFhFo/+aydt0yoozQ=","metadata":{},"hash":"5BC4PQVnKYd4Npa7xOlQBYQPPIvG70AzpxIgvym5MqE="}},"hash":"qzl4yIZL0i0FRsg/VI7/dbpXbB+pysvafyybEYlIL68=","text":"You can use process.env to access Environment Variables for both next dev and next build. Unsupported APIs\r\nThe Edge Runtime has some restrictions including:\r\nNative Node.js APIs are not supported. For example, you can’t read or write to the filesystem.node_modules\r\n can be used, as long as they implement ES Modules and do not use native Node.js APIs. Calling require directly is not allowed. Use ES Modules instead. The following JavaScript language features are disabled, and will not work:\r\nAPIDescription\r\nevalEvaluates JavaScript code represented as a string\r\nnew Function(evalString)Creates a new function with the code provided as an argument\r\nWebAssembly.compileCompiles a WebAssembly module from a buffer source\r\nWebAssembly.instantiateCompiles and instantiates a WebAssembly module from a buffer source\r\nIn rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and\r\nwhich can not be removed by treeshaking. You can relax the check to allow specific files with your Middleware or Edge API Route\r\nexported configuration:\r\nexport const config = {\r\n  runtime: 'edge', // for Edge API Routes only\r\n  unstable_allowDynamic: [\r\n    // allows a single file\r\n    '/lib/utilities.js',\r\n    // use a glob to allow anything in the function-bind 3rd party module\r\n    '/node_modules/function-bind/**',\r\n  ],\r\n}\r\nunstable_allowDynamic is a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to\r\nyour application root folder. Be warned that if these statements are executed on the Edge, they will throw and cause a runtime error.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1f79fc1-2969-442f-982c-bbbe6dfaab6b":{"id_":"f1f79fc1-2969-442f-982c-bbbe6dfaab6b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4JRuaEKourqkDHuNvBcYyzAhMY5O2RAcJ29QGeoTiw0=","metadata":{},"hash":"gDpLjFCs7NaHZDz/PQh0GP/Kp9nJ8gbvke9dbrfi9sY="},"NEXT":{"nodeId":"dd108e1c-6b82-402e-9842-68877d07c6c9","metadata":{},"hash":"f6ohMvqc/q6DzeFcEZAsbOzpubyt6E8CLfHM4h59Eww="}},"hash":"Q41nbQXWDixwyY51Pv3HjXlhnqAbM244jYFUcAgyTmA=","text":"3.2.7 - Next.js CLI\r\nDocumentation path: /02-app/02-api-reference/08-next-cli\r\nDescription: The Next.js CLI allows you to start, build, and export your application. Learn more about it here. {/ The content of this doc is shared between the app and pages router. You can use the <PagesOnly>Content</PagesOnly> component\r\nto add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. /}\r\nThe Next.js CLI allows you to start, build, and export your application. To get a list of the available CLI commands, run the following command inside your project directory:\r\nTerminal (bash)npx next -h\r\n(npx comes with npm 5.2+ and higher)\r\nThe output should look like this:\r\nTerminal (bash)Usage\r\n  $ next <command>\r\nAvailable commands\r\n  build, start, export, dev, lint, telemetry, info\r\nOptions\r\n  --version, -v   Version number\r\n  --help, -h      Displays this message\r\nFor more information run a command with the --help flag\r\n  $ next build --help\r\nYou can pass any node arguments to next commands:\r\nTerminal (bash)NODE_OPTIONS='--throw-deprecation' next\r\nNODE_OPTIONS='-r esm' next\r\nNODE_OPTIONS='--inspect' next\r\nGood to know: Running next without a command is the same as running next dev\r\nBuild\r\nnext build creates an optimized production build of your application. The output displays information about each route. Size – The number of assets downloaded when navigating to the page client-side. The size for each route only includes its\r\ndependencies. First Load JS – The number of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown\r\nas a separate metric. Both of these values are compressed with gzip. The first load is indicated by green, yellow, or red. Aim for green for performant\r\napplications. You can enable production profiling for React with the --profile flag in next build. This requires Next.js 9.5:\r\nTerminal (bash)next build --profile\r\nAfter that, you can use the profiler in the same way as you would in development. You can enable more verbose build output with the --debug flag in next build.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dd108e1c-6b82-402e-9842-68877d07c6c9":{"id_":"dd108e1c-6b82-402e-9842-68877d07c6c9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4JRuaEKourqkDHuNvBcYyzAhMY5O2RAcJ29QGeoTiw0=","metadata":{},"hash":"gDpLjFCs7NaHZDz/PQh0GP/Kp9nJ8gbvke9dbrfi9sY="},"PREVIOUS":{"nodeId":"f1f79fc1-2969-442f-982c-bbbe6dfaab6b","metadata":{},"hash":"Q41nbQXWDixwyY51Pv3HjXlhnqAbM244jYFUcAgyTmA="}},"hash":"f6ohMvqc/q6DzeFcEZAsbOzpubyt6E8CLfHM4h59Eww=","text":"You can enable more verbose build output with the --debug flag in next build. This requires Next.js 9.5.3:\r\nTerminal (bash)next build --debug\r\nWith this flag enabled additional build output like rewrites, redirects, and headers will be shown. Development\r\nnext dev starts the application in development mode with hot-code reloading, error reporting, and more:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ee96a917-5703-4e5c-b38a-78efd637907b":{"id_":"ee96a917-5703-4e5c-b38a-78efd637907b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HM1wlXk8I4ISHM9rtUtqwH5gLpeEFvScauucV0QS7W8=","metadata":{},"hash":"+4RAJU6czFStoRx+9hThn4MxmWwLkpplPlHuUz39QS0="},"NEXT":{"nodeId":"280b31bc-4a59-4656-8813-a3d30cdfe73e","metadata":{},"hash":"KN3+6Oq1ww+DlINGhQ9whFLO8I8BUGa/io/evrKbRwo="}},"hash":"oQHuU79bXlKDDAHm1dJnyfrDq36mqvxsGmr6LHfMVfk=","text":"The application will start at http://localhost:3000 by default. The default port can be changed with -p, like so:\r\nTerminal (bash)npx next dev -p 4000\r\nOr using the PORT environment variable:\r\nTerminal (bash)PORT=4000 npx next dev\r\nGood to know: PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized. You can also set the hostname to be different from the default of 0.0.0.0, this can be useful for making the application available for\r\nother devices on the network. The default hostname can be changed with -H, like so:\r\nTerminal (bash)npx next dev -H 192.168.1.2\r\nProduction\r\nnext start starts the application in production mode. The application should be compiled with next build first. The application will start at http://localhost:3000 by default. The default port can be changed with -p, like so:\r\nTerminal (bash)npx next start -p 4000\r\nOr using the PORT environment variable:\r\nTerminal (bash)PORT=4000 npx next start\r\nGood to know:\r\n-PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized. next start cannot be used with output: 'standalone' or output: 'export'. Keep Alive Timeout\r\nWhen deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB) it’s important to configure Next’s\r\nunderlying HTTP server with keep-alive timeouts that are larger than the downstream proxy’s timeouts. Otherwise, once a keep-alive\r\ntimeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream\r\nproxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated. To configure the timeout values for the production Next.js server, pass --keepAliveTimeout (in milliseconds) to next start, like so:\r\nTerminal (bash)npx next start --keepAliveTimeout 70000\r\nLint\r\nnext lint runs ESLint for all files in the pages/, app/, components/, lib/, and src/ directories. It also provides a guided setup to\r\ninstall any required dependencies if ESLint is not already configured in your application.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"280b31bc-4a59-4656-8813-a3d30cdfe73e":{"id_":"280b31bc-4a59-4656-8813-a3d30cdfe73e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HM1wlXk8I4ISHM9rtUtqwH5gLpeEFvScauucV0QS7W8=","metadata":{},"hash":"+4RAJU6czFStoRx+9hThn4MxmWwLkpplPlHuUz39QS0="},"PREVIOUS":{"nodeId":"ee96a917-5703-4e5c-b38a-78efd637907b","metadata":{},"hash":"oQHuU79bXlKDDAHm1dJnyfrDq36mqvxsGmr6LHfMVfk="}},"hash":"KN3+6Oq1ww+DlINGhQ9whFLO8I8BUGa/io/evrKbRwo=","text":"If you have other directories that you would like to lint, you can specify them using the --dir flag:\r\nTerminal (bash)next lint --dir utils\r\nTelemetry\r\nNext.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and\r\nyou may opt-out if you’d not like to share any information. To learn more about Telemetry, please read this document. Next Info\r\nnext info prints relevant details about the current system which can be used to report Next.js bugs. This information includes","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d6367b40-1900-4ab5-add0-eef18571f9cf":{"id_":"d6367b40-1900-4ab5-add0-eef18571f9cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sdOIC1BWGbUHy86OQ4051jRyqQeBGTdfRgUoC2+pjBU=","metadata":{},"hash":"Ih26wKDZUHpYxNJ8Cvnh318lxLnwIlO/mbg4Vtjfomc="}},"hash":"VT0/FvedL0vz+l7dIkrmLrTYpTkZOcXsKpALcRqo3v4=","text":"Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm) and npm package versions (next, react, react-dom). Running the following in your project’s root directory:\r\nTerminal (bash)next info\r\nwill give you information like this example:\r\nTerminal (bash)Operating System:\r\n  Platform: linux\r\n  Arch: x64\r\n  Version: #22-Ubuntu SMP Fri Nov 5 13:21:36 UTC 2021\r\nBinaries:\r\n  Node: 16.13.0\r\n  npm: 8.1.0\r\n  Yarn: 1.22.17\r\n  pnpm: 6.24.2\r\nRelevant packages:\r\n  next: 12.0.8\r\n  react: 17.0.2\r\n  react-dom: 17.0.2\r\nThis information should then be pasted into GitHub Issues. In order to diagnose installation issues, you can run next info --verbose to print additional information about system and the\r\ninstallation of next-related packages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2dafdd1f-51af-4e2c-9e45-f2dd9057f7b2":{"id_":"2dafdd1f-51af-4e2c-9e45-f2dd9057f7b2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"30txn0JdPsQ3sXlrPanTvRCKLbt+o3APUytpt7eyR7U=","metadata":{},"hash":"pWd3NNZuwgHjRdQQgG9GovngRHy6vRYvo10s+WNApoc="}},"hash":"ABjX2g9349Elap8jvwbgxAkfZqLnN0C0KhMUyMgRMXE=","text":"4 - Pages Router\r\nDocumentation path: /03-pages/index\r\nDescription: Before Next.js 13, the Pages Router was the main way to create routes in Next.js with an intuitive file-system router. Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It used an intuitive file-system router to map each file\r\nto a route. The Pages Router is still supported in newer versions of Next.js, but we recommend migrating to the new App Router to\r\nleverage React’s latest features. Use this section of the documentation for existing applications that use the Pages Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d4861349-c90e-4536-b213-b150859e0328":{"id_":"d4861349-c90e-4536-b213-b150859e0328","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fWh374KrElZ6WynTnexPRlYu5q8Fw49h3ZOtPBm/lZA=","metadata":{},"hash":"+Wqx2AJfrN59T2SdSEDX3/bVIkQqBVkhGdX5rZmbnHM="}},"hash":"+3ujxEV7ZaFePu6T6oIB8zwvjexL5iu56CuuhvJAaX0=","text":"4.1 - Building Your Application\r\nDocumentation path: /03-pages/01-building-your-application/index\r\nDescription: Learn how to use Next.js features to build your application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"314ccac2-9a04-42df-9f05-5b2e153ee43e":{"id_":"314ccac2-9a04-42df-9f05-5b2e153ee43e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/AufmwS4e54mEzxYYalDjP/Sc/YQ33Sha/SXMY4b+4A=","metadata":{},"hash":"eOD8g3kh1SSwRoqht465wTSrJZPlejo9jq01F+bMZj0="}},"hash":"oKCjGWsgw3N6BBr4Z6NopiLvd3VfFMBskBFRmNJ8Drs=","text":"4.1.1 - Routing\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/index\r\nDescription: Learn the fundamentals of routing for front-end applications with the Pages Router. The Pages Router has a file-system based router built on concepts of pages. When a file is added to the pages directory it’s\r\nautomatically available as a route. Learn more about routing in the Pages Router:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"78d74aa0-62ba-4fb0-915b-56725c349879":{"id_":"78d74aa0-62ba-4fb0-915b-56725c349879","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"74irFtb3uhFG87iHAzzCphks7lbio8CS+LzxxUg96QM=","metadata":{},"hash":"7BC+gmQ7lutsft/HbL7+ubusJjxj1AJxT6xuQzX5ynQ="}},"hash":"ZEUSkYn4k/MjnrLqI5K9P5neZFDUVLZf/pJq15as8eA=","text":"4.1.1.1 - Pages and Layouts\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/01-pages-and-layouts\r\nDescription: Create your first page and shared layout with the Pages Router. The Pages Router has a file-system based router built on the concept of pages. When a file is added to the pages directory, it’s automatically available as a route. In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated\r\nwith a route based on its file name. Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about. export default function About() {\r\n  return <div>About</div>\r\n}\r\nIndex routes\r\nThe router will automatically route files named index to the root of the directory. pages/index.js → /\r\npages/blog/index.js → /blog\r\nNested routes\r\nThe router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still. pages/blog/first-post.js → /blog/first-post\r\npages/dashboard/settings/username.js → /dashboard/settings/username\r\nPages with Dynamic Routes\r\nNext.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible\r\nat posts/1, posts/2, etc. To learn more about dynamic routing, check the Dynamic Routing documentation. Layout Pattern\r\nThe React model allows us to deconstruct a page into a series of components. Many of these components are often reused between\r\npages. For example, you might have the same navigation bar and footer on every page. components/layout.js (jsx)import Navbar from './navbar'\r\nimport Footer from './footer'\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Navbar />\r\n      <main>{children}</main>\r\n      <Footer />\r\n    </>\r\n  )\r\n}\r\nExamples\r\nSingle Shared Layout with Custom App\r\nIf you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since\r\nthe <Layout /> component is re-used when changing pages, its component state will be preserved (e.g. input values). pages/_app.js (jsx)import Layout from '../components/layout'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"220eeaff-f8c4-46a5-aab6-f296866ad00a":{"id_":"220eeaff-f8c4-46a5-aab6-f296866ad00a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"e9jo/xhOPiehwf36ndAlRP4Kk58YaHiycBKJtCQz6BA=","metadata":{},"hash":"ADS6U0JJ9HaK3YYK1NY321BOaXfkC9HCAFIz8pmF0rA="}},"hash":"+bpe3w9QWeQdhSVyBE7G7JYVD8OfF5g7BFDwPNsMiY0=","text":"export default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <Layout>\r\n      <Component {...pageProps} />\r\n    </Layout>\r\n  )\r\n}\r\nPer-Page Layouts\r\nIf you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we’re returning a function, we can have complex nested layouts if\r\ndesired. pages/index.js (jsx)import Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\nexport default function Page() {\r\n  return (\r\n    /** Your content */\r\n  )\r\n}\r\nPage.getLayout = function getLayout(page) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}\r\npages/_app.js (jsx)export default function MyApp({ Component, pageProps }) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout || ((page) => page)\r\n  return getLayout(<Component {...pageProps} />)\r\n}\r\nWhen navigating between pages, we want to persist page state (input values, scroll position, etc. ) for a Single-Page Application (SPA)\r\nexperience. This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the\r\ncomponent tree, React can understand which elements have changed to preserve state. Good to know: This process is called reconciliation, which is how React understands which elements have changed. With TypeScript\r\nWhen using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a\r\nnew type for your AppProps which overrides the Component property to use the previously created type. pages/index.tsx (tsx)import type { ReactElement } from 'react'\r\nimport Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\nimport type { NextPageWithLayout } from './_app'\r\nconst Page: NextPageWithLayout = () => {\r\n  return <p>hello world</p>\r\n}\r\nPage.getLayout = function getLayout(page: ReactElement) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}\r\nexport default Page","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8f413253-5548-4968-b9c7-3103f54d15bb":{"id_":"8f413253-5548-4968-b9c7-3103f54d15bb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"MIlw0TCbfkOSyCzSgBNIw3PTwSTQZ+nF+pyXP1lIaac=","metadata":{},"hash":"JuqIplBdgD+hSTw0xxuku4PFgeNs/uNiDB1OxOee3tE="}},"hash":"ZhpGN8EKZCKS6wPCVl213xhFAI4j5wBp8ZyZRufqe4w=","text":"pages/index.js (jsx)import Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\nconst Page = () => {\r\n  return <p>hello world</p>\r\n}\r\nPage.getLayout = function getLayout(page) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}\r\nexport default Page\r\npages/_app.tsx (tsx)import type { ReactElement, ReactNode } from 'react'\r\nimport type { NextPage } from 'next'\r\nimport type { AppProps } from 'next/app'\r\nexport type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {\r\n  getLayout?: (page: ReactElement) => ReactNode\r\n}\r\ntype AppPropsWithLayout = AppProps & {\r\n  Component: NextPageWithLayout\r\n}\r\nexport default function MyApp({ Component, pageProps }: AppPropsWithLayout) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout ?? ((page) => page)\r\n  return getLayout(<Component {...pageProps} />)\r\n}\r\npages/_app.js (jsx)export default function MyApp({ Component, pageProps }) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout ?? ((page) => page)\r\n  return getLayout(<Component {...pageProps} />)\r\n}\r\nData Fetching\r\nInside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you\r\ncannot use getStaticProps or getServerSideProps currently. components/layout.js (jsx)import useSWR from 'swr'\r\nimport Navbar from './navbar'\r\nimport Footer from './footer'\r\nexport default function Layout({ children }) {\r\n  const { data, error } = useSWR('/api/navigation', fetcher)\r\n  if (error) return <div>Failed to load</div>\r\n  if (!data) return <div>Loading...</div>\r\n  return (\r\n    <>\r\n      <Navbar links={data.links} />\r\n      <main>{children}</main>\r\n      <Footer />\r\n    </>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"10195424-beed-47c2-9102-fbbd0e26fc77":{"id_":"10195424-beed-47c2-9102-fbbd0e26fc77","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ohjdjuak4tDQneKgmozSsZHG4GujaeJi3LIt8bDAwks=","metadata":{},"hash":"Ww2g/iHkhWAPbO9wk94TijnGYW7hObFzlKk6O4O/mbg="},"NEXT":{"nodeId":"84fa7934-44f7-4f7c-a981-dd4a105e469a","metadata":{},"hash":"TT0pfSR4L+weXxZ/bXjwdBE/uAxMO0hlf8iUEm8FU2Q="}},"hash":"tNcb8fu3eE+ruY8+aB0dbULnykWCvUFkDf8BK4KSABw=","text":"4.1.1.2 - Dynamic Routes\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/02-dynamic-routes\r\nDescription: Dynamic Routes are pages that allow you to add custom params to your URLs. Start creating Dynamic Routes and learn\r\nmore here. Related:\r\nTitle: Next Steps\r\nRelated Description: For more information on what to do next, we recommend the following sections\r\nLinks:\r\npages/building-your-application/routing/linking-and-navigating\r\npages/api-reference/functions/use-router\r\nWhen you don’t know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic\r\nSegments that are filled in at request time or prerendered at build time. Convention\r\nA Dynamic Segment can be created by wrapping a file or folder name in square brackets: [segmentName]. For example, [id] or\r\n[slug]. Dynamic Segments can be accessed from useRouter. Example\r\nFor example, a blog could include the following route pages/blog/[slug].js where [slug] is the Dynamic Segment for blog posts. import { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return <p>Post: {router.query.slug}</p>\r\n}\r\nRouteExample URLparamsparams\r\npages/blog/[slug].js/blog/a{ slug: 'a' }\r\npages/blog/[slug].js/blog/b{ slug: 'b' }\r\npages/blog/[slug].js/blog/c{ slug: 'c' }\r\nCatch-all Segments\r\nDynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...segmentName]. For example, pages/shop/[...slug].js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-\r\nshirts, and so on. RouteExample URLparamsparams\r\npages/shop/[...slug].js/shop/a{ slug: ['a'] }\r\npages/shop/[...slug].js/shop/a/b{ slug: ['a', 'b'] }\r\npages/shop/[...slug].js/shop/a/b/c{ slug: ['a', 'b', 'c'] }\r\nOptional Catch-all Segments\r\nCatch-all Segments can be made optional by including the parameter in double square brackets: [[...segmentName]].","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"84fa7934-44f7-4f7c-a981-dd4a105e469a":{"id_":"84fa7934-44f7-4f7c-a981-dd4a105e469a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ohjdjuak4tDQneKgmozSsZHG4GujaeJi3LIt8bDAwks=","metadata":{},"hash":"Ww2g/iHkhWAPbO9wk94TijnGYW7hObFzlKk6O4O/mbg="},"PREVIOUS":{"nodeId":"10195424-beed-47c2-9102-fbbd0e26fc77","metadata":{},"hash":"tNcb8fu3eE+ruY8+aB0dbULnykWCvUFkDf8BK4KSABw="}},"hash":"TT0pfSR4L+weXxZ/bXjwdBE/uAxMO0hlf8iUEm8FU2Q=","text":"For example, pages/shop/[[...slug]].js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops,\r\n/shop/clothes/tops/t-shirts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"069da66d-2bdb-48d1-a310-5c89ec78cf0f":{"id_":"069da66d-2bdb-48d1-a310-5c89ec78cf0f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"IuSFYWZew0Hp5LAcv9vRwLXzNbdvRmGSvzVPsFj0sGU=","metadata":{},"hash":"gLWg/bdqvFNYtDSyGMhc/+g6efhBd3Q3iphr9KAUYEk="}},"hash":"o0Zb/zKakujJpUz7I726aDeJRM+jGasu8a1eNVRoefA=","text":"The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also\r\nmatched (/shop in the example above). RouteExample URLparamsparams\r\npages/shop/[[...slug]].js/shop{ slug: [] }\r\npages/shop/[[...slug]].js/shop/a{ slug: ['a'] }\r\npages/shop/[[...slug]].js/shop/a/b{ slug: ['a', 'b'] }\r\npages/shop/[[...slug]].js/shop/a/b/c{ slug: ['a', 'b', 'c'] }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a87e042-7c34-4291-9cde-e17fb52660a1":{"id_":"2a87e042-7c34-4291-9cde-e17fb52660a1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vLXPSZyEYH4n3D2ovsrg5BVrZPC0QhJCtcEutLY49ao=","metadata":{},"hash":"uJ23UMEsSlqI3EsQaLNKzz2yoDTwSZlWbIDUp+6B+t8="}},"hash":"8es3/Ki7vEF+Iif8S8vM8eqASQ6xIH8GF0slgPzxek0=","text":"4.1.1.3 - Linking and Navigating\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/03-linking-and-navigating\r\nDescription: Learn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook. The Next.js router allows you to do client-side route transitions between pages, similar to a single-page application. A React component called Link is provided to do this client-side route transition. import Link from 'next/link'\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link href=\"/\">Home</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/about\">About Us</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/blog/hello-world\">Blog Post</Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\nexport default Home\r\nThe example above uses multiple links. Each one maps a path (href) to a known page:\r\n/ → pages/index.js\r\n/about → pages/about.js\r\n/blog/hello-world → pages/blog/[slug].js\r\nAny <Link /> in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages\r\nusing Static Generation. The corresponding data for server-rendered routes is fetched only when the <Link /> is clicked. Linking to dynamic paths\r\nYou can also use interpolation to create the path, which comes in handy for dynamic route segments. For example, to show a list of\r\nposts which have been passed to the component as a prop:\r\nimport Link from 'next/link'\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${encodeURIComponent(post.slug)}`}>\r\n            {post.title}\r\n          </Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nexport default Posts\r\nencodeURIComponent is used in the example to keep the path utf-8 compatible. Alternatively, using a URL Object:\r\nimport Link from 'next/link'\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1bfd4f67-25b5-4bc6-b048-7bfc56769160":{"id_":"1bfd4f67-25b5-4bc6-b048-7bfc56769160","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OFmvjZlfU5jdzKFZaIaS5PiR8OvAvkrHoisu9exKoMw=","metadata":{},"hash":"KZF/wksI1PcP+d7ZXP5o2xoSBKOuUi4Gm0lSE2NMy+c="}},"hash":"3kAtEbtUwX5h52MjxpS6P8BF7oSl8LlkvB2xOl7+wMY=","text":"<li key={post.id}>\r\n          <Link\r\n            href={{\r\n              pathname: '/blog/[slug]',\r\n              query: { slug: post.slug },\r\n            }}\r\n          >\r\n            {post.title}\r\n          </Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nexport default Posts\r\nNow, instead of using interpolation to create the path, we use a URL object in href where:\r\npathname is the name of the page in the pages directory. /blog/[slug] in this case. query is an object with the dynamic segment. slug in this case. Injecting the router\r\nExamples\r\nTo access the router object in a React component you can use useRouter or withRouter. In general we recommend using useRouter. Imperative Routing\r\nnext/link should be able to cover most of your routing needs, but you can also do client-side navigations without it, take a look at the\r\ndocumentation for next/router. The following example shows how to do basic page navigations with useRouter:\r\nimport { useRouter } from 'next/router'\r\nexport default function ReadMore() {\r\n  const router = useRouter()\r\n  return (\r\n    <button onClick={() => router.push('/about')}>\r\n      Click here to read more\r\n    </button>\r\n  )\r\n}\r\nShallow Routing\r\nExamples\r\nShallow routing allows you to change the URL without running data fetching methods again, that includes getServerSideProps,\r\ngetStaticProps, and getInitialProps. You’ll receive the updated pathname and the query via the router object (added by useRouter or withRouter), without losing state. To enable shallow routing, set the shallow option to true. Consider the following example:\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n// Current URL is '/'\r\nfunction Page() {\r\n  const router = useRouter()\r\n  useEffect(() => {\r\n    // Always do navigations after the first render\r\n    router.push('/?counter=10', undefined, { shallow: true })\r\n  }, [])\r\n  useEffect(() => {\r\n    // The counter changed!","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"631b9251-0b21-4e20-946d-b69e8a1d4517":{"id_":"631b9251-0b21-4e20-946d-b69e8a1d4517","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"M1BQNcBIfIKMXEqpLntAB/7PXJazcfjy8gCBopnkHjY=","metadata":{},"hash":"sJ96cmxGADvcYIHjl2p6pNX84HLh1vTxqASmPP5ixS0="}},"hash":"h0YJRmsksc+sHSRQ9eTZNYECm9Sfp+VsSJr/e8K0J8Y=","text":"}, [router.query.counter])\r\n}\r\nexport default Page\r\nThe URL will get updated to /?counter=10 and the page won’t get replaced, only the state of the route is changed. You can also watch for URL changes via componentDidUpdate as shown below:\r\ncomponentDidUpdate(prevProps) {\r\n  const { pathname, query } = this.props.router\r\n  // verify props have changed to avoid an infinite loop\r\n  if (query.counter !== prevProps.router.query.counter) {\r\n    // fetch data based on the new query\r\n  }\r\n}\r\nCaveats\r\nShallow routing only works for URL changes in the current page. For example, let’s assume we have another page calledpages/about.js\r\n, and you run this:\r\nrouter.push('/?counter=10', '/about?counter=10', { shallow: true })\r\nSince that’s a new page, it’ll unload the current page, load the new one and wait for data fetching even though we asked to do shallow\r\nrouting. When shallow routing is used with middleware it will not ensure the new page matches the current page like previously done without\r\nmiddleware. This is due to middleware being able to rewrite dynamically and can’t be verified client-side without a data fetch which is\r\nskipped with shallow, so a shallow route change must always be treated as shallow.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e2729222-381b-4c66-950d-46b6c944a29e":{"id_":"e2729222-381b-4c66-950d-46b6c944a29e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"P7m5JNs3O8ufGlmvewnkGdVSnChpWzG9mgvl9orjgXw=","metadata":{},"hash":"R0r4gGDnUH+TnfPQ/ZH85qggZZ6MOd+5w7M5TJwqi2E="}},"hash":"NTY0v1zk0AHsi0hX1KbPVDECBieQsZ9Hcke8A9iaP3Q=","text":"4.1.1.4 - Custom App\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/04-custom-app\r\nDescription: Control page initialization and add a layout that persists for all pages by overriding the default App component used by\r\nNext.js. Next.js uses the App component to initialize pages. You can override it and control the page initialization and:\r\nCreate a shared layout between page changes\r\nInject additional data into pages\r\nAdd global CSS\r\nUsage\r\nTo override the default App, create the file pages/_app as shown below:\r\npages/_app.tsx (tsx)import type { AppProps } from 'next/app'\r\nexport default function MyApp({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}\r\npages/_app.jsx (jsx)export default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}\r\nThe Component prop is the active page, so whenever you navigate between routes, Component will change to the new page. Therefore,\r\nany props you send to Component will be received by the page. pageProps is an object with the initial props that were preloaded for your page by one of our data fetching methods, otherwise it’s an\r\nempty object. Good to know\r\nIf your app is running and you added a custom App, you’ll need to restart the development server. Only required if\r\npages/_app.js didn’t exist before. App does not support Next.js Data Fetching methods like getStaticProps or getServerSideProps. getInitialPropsgetInitialProps with AppApp\r\nUsing getInitialProps in App will disable Automatic Static Optimization for pages without getStaticProps. We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily\r\nfetch data for pages and layouts. pages/_app.tsx (tsx)import App, { AppContext, AppInitialProps, AppProps } from 'next/app'\r\ntype AppOwnProps = { example: string }\r\nexport default function MyApp({\r\n  Component,\r\n  pageProps,\r\n  example,\r\n}: AppProps & AppOwnProps) {\r\n  return (\r\n    <>\r\n      <p>Data: {example}</p>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\nMyApp.getInitialProps = async (\r\n  context: AppContext\r\n): Promise<AppOwnProps & AppInitialProps> => {\r\n  const ctx = await App.getInitialProps(context)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3a310cca-7155-41cb-8215-a9184af657d3":{"id_":"3a310cca-7155-41cb-8215-a9184af657d3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"8U3FhDL985QfS2YFmQd3ecJ90Ewc7J5xM4KSciQbIJQ=","metadata":{},"hash":"CjWGrXpe/Ezdm9GUUpp/Xq+U7O8vlYYKMnxInSSHjhY="}},"hash":"GMA90GjopeRdxPIy3unKQMNUC6KpnnLWLUA1KMZHd2Q=","text":"return { ...ctx, example: 'data' }\r\n}\r\npages/_app.jsx (jsx)import App from 'next/app'\r\nexport default function MyApp({ Component, pageProps, example }) {\r\n  return (\r\n    <>\r\n      <p>Data: {example}</p>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\nMyApp.getInitialProps = async (context) => {\r\n  const ctx = await App.getInitialProps(context)\r\n  return { ...ctx, example: 'data' }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a9d01ca3-0545-4044-a1a9-1359b1107a1f":{"id_":"a9d01ca3-0545-4044-a1a9-1359b1107a1f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cBdBG4PE1rKy6zg0rFrVwqpTk0LRC0XZDAQf4/CVd+I=","metadata":{},"hash":"BBKhDuceNAx71JXWW975NFFYA+Num6UotRma5wEH/Eo="},"NEXT":{"nodeId":"312d229e-6fd0-4ee0-bae3-2428c4018beb","metadata":{},"hash":"Ka23ZPM0M5JHKaCJkWYlPY6vg2tFpNzAj34EqmUrhvo="}},"hash":"dSgMxx6lLD40rqzRi6XJWyX5ZAK+vH46mxI1VSOi4rg=","text":"4.1.1.5 - Custom Document\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/05-custom-document\r\nDescription: Extend the default document markup added by Next.js. A custom Document can update the <html> and <body> tags used to render a Page. To override the default Document, create the file pages/_document as shown below:\r\npages/_document.tsx (tsx)import { Html, Head, Main, NextScript } from 'next/document'\r\nexport default function Document() {\r\n  return (\r\n    <Html lang=\"en\">\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}\r\npages/_document.jsx (jsx)import { Html, Head, Main, NextScript } from 'next/document'\r\nexport default function Document() {\r\n  return (\r\n    <Html lang=\"en\">\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}\r\nGood to know\r\n_document is only rendered on the server, so event handlers like onClick cannot be used in this file. <Html>, <Head />, <Main /> and <NextScript /> are required for the page to be properly rendered. Caveats\r\nThe <Head /> component used in _document is not the same as next/head. The <Head /> component used here should only be\r\nused for any <head> code that is common for all pages. For all other cases, such as <title> tags, we recommend using\r\nnext/head in your pages or components. React components outside of <Main /> will not be initialized by the browser. Do not add application logic here or custom CSS (like\r\nstyled-jsx). If you need shared components in all your pages (like a menu or a toolbar), read Layouts instead. Document currently does not support Next.js Data Fetching methods like getStaticProps or getServerSideProps. Customizing renderPagerenderPage\r\nCustomizing renderPage is advanced and only needed for libraries like CSS-in-JS to support server-side rendering. This is not needed\r\nfor built-in styled-jsx support. We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily\r\nfetch data for pages and layouts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"312d229e-6fd0-4ee0-bae3-2428c4018beb":{"id_":"312d229e-6fd0-4ee0-bae3-2428c4018beb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cBdBG4PE1rKy6zg0rFrVwqpTk0LRC0XZDAQf4/CVd+I=","metadata":{},"hash":"BBKhDuceNAx71JXWW975NFFYA+Num6UotRma5wEH/Eo="},"PREVIOUS":{"nodeId":"a9d01ca3-0545-4044-a1a9-1359b1107a1f","metadata":{},"hash":"dSgMxx6lLD40rqzRi6XJWyX5ZAK+vH46mxI1VSOi4rg="}},"hash":"Ka23ZPM0M5JHKaCJkWYlPY6vg2tFpNzAj34EqmUrhvo=","text":"pages/_document.tsx (tsx)import Document, {\r\n  Html,\r\n  Head,\r\n  Main,\r\n  NextScript,\r\n  DocumentContext,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"60c8a82c-f543-4dde-aa83-43ec0ff50b82":{"id_":"60c8a82c-f543-4dde-aa83-43ec0ff50b82","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Z7Z2Q757OcnRxs+/ZxiOK84vIGEDNXp6/q9d51Vu8qI=","metadata":{},"hash":"wZqSYlUTH9MpxbciAOlpXhXjkTnL28Sf5w7D0M4qOgg="}},"hash":"CK1ePDrHqRZBtYX0tzuToYWVIOexE+SY45HNoazJ/8M=","text":"DocumentInitialProps,\r\n} from 'next/document'\r\nclass MyDocument extends Document {\r\n  static async getInitialProps(\r\n    ctx: DocumentContext\r\n  ): Promise<DocumentInitialProps> {\r\n    const originalRenderPage = ctx.renderPage\r\n    // Run the React rendering logic synchronously\r\n    ctx.renderPage = () =>\r\n      originalRenderPage({\r\n        // Useful for wrapping the whole react tree\r\n        enhanceApp: (App) => App,\r\n        // Useful for wrapping in a per-page basis\r\n        enhanceComponent: (Component) => Component,\r\n      })\r\n    // Run the parent `getInitialProps`, it now includes the custom `renderPage`\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n    return initialProps\r\n  }\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head />\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\nexport default MyDocument\r\npages/_document.jsx (jsx)import Document, { Html, Head, Main, NextScript } from 'next/document'\r\nclass MyDocument extends Document {\r\n  static async getInitialProps(ctx) {\r\n    const originalRenderPage = ctx.renderPage\r\n    // Run the React rendering logic synchronously\r\n    ctx.renderPage = () =>\r\n      originalRenderPage({\r\n        // Useful for wrapping the whole react tree\r\n        enhanceApp: (App) => App,\r\n        // Useful for wrapping in a per-page basis\r\n        enhanceComponent: (Component) => Component,\r\n      })\r\n    // Run the parent `getInitialProps`, it now includes the custom `renderPage`\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n    return initialProps\r\n  }\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head />\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\nexport default MyDocument","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5009e086-35ab-4031-9819-8f17478173b0":{"id_":"5009e086-35ab-4031-9819-8f17478173b0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GZ6Lu0cR+nVqufOdUrAIlzg6KyDij8VahMwCmeyQ93E=","metadata":{},"hash":"0B9TP/18FZ4bW0vcyQALwjJzTlOrqFOQYPz31ywn3dU="}},"hash":"Yzq0S62Kz0lQg7CpAyhh0DelqzpmhVAccQg2BMDW838=","text":"Good to know\r\ngetInitialProps in _document is not called during client-side transitions. The ctx object for _document is equivalent to the one received in getInitialProps, with the addition of renderPage.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5eb9fffb-6c6a-41aa-9c94-3dce88d48c54":{"id_":"5eb9fffb-6c6a-41aa-9c94-3dce88d48c54","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"65eUtKl9GzYD1jiGEHxbtynInhSI2bJTY6sc8KUC1rM=","metadata":{},"hash":"qijfzyd00uV6olcL3hc3Eo3kX76VgFSHW8xMbYvF+AA="},"NEXT":{"nodeId":"fb587c61-7437-4dac-bca0-e58a16fcafc5","metadata":{},"hash":"fdt7S/qOlDwkDX1D5Ec7Hz3UhJ9h5vl+NS9nng7Ze9U="}},"hash":"uYCaGH3U9QJZpmIeI/a1Dk6XMge/2XnIiZkQpJgkKss=","text":"4.1.1.6 - Custom Errors\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/06-custom-error\r\nDescription: Override and extend the built-in Error page to handle custom errors. 404 Page\r\nA 404 page may be accessed very often. Server-rendering an error page for every visit increases the load of the Next.js server. This can\r\nresult in increased costs and slow experiences. To avoid the above pitfalls, Next.js provides a static 404 page by default without having to add any additional files. Customizing The 404 Page\r\nTo create a custom 404 page you can create a pages/404.js file. This file is statically generated at build time. pages/404.js (jsx)export default function Custom404() {\r\n  return <h1>404 - Page Not Found</h1>\r\n}\r\nGood to know: You can use getStaticProps inside this page if you need to fetch data at build time. 500 Page\r\nServer-rendering an error page for every visit adds complexity to responding to errors. To help users get responses to errors as fast as\r\npossible, Next.js provides a static 500 page by default without having to add any additional files. Customizing The 500 Page\r\nTo customize the 500 page you can create a pages/500.js file. This file is statically generated at build time. pages/500.js (jsx)export default function Custom500() {\r\n  return <h1>500 - Server-side error occurred</h1>\r\n}\r\nGood to know: You can use getStaticProps inside this page if you need to fetch data at build time. More Advanced Error Page Customizing\r\n500 errors are handled both client-side and server-side by the Error component. If you wish to override it, define the file\r\npages/_error.js and add the following code:\r\nfunction Error({ statusCode }) {\r\n  return (\r\n    <p>\r\n      {statusCode\r\n        ? `An error ${statusCode} occurred on server`\r\n        : 'An error occurred on client'}\r\n    </p>\r\n  )\r\n}\r\nError.getInitialProps = ({ res, err }) => {\r\n  const statusCode = res ? res.statusCode : err ? err.statusCode : 404\r\n  return { statusCode }\r\n}\r\nexport default Error\r\npages/_error.js is only used in production. In development you’ll get an error with the call stack to know where the error\r\noriginated from.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fb587c61-7437-4dac-bca0-e58a16fcafc5":{"id_":"fb587c61-7437-4dac-bca0-e58a16fcafc5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"65eUtKl9GzYD1jiGEHxbtynInhSI2bJTY6sc8KUC1rM=","metadata":{},"hash":"qijfzyd00uV6olcL3hc3Eo3kX76VgFSHW8xMbYvF+AA="},"PREVIOUS":{"nodeId":"5eb9fffb-6c6a-41aa-9c94-3dce88d48c54","metadata":{},"hash":"uYCaGH3U9QJZpmIeI/a1Dk6XMge/2XnIiZkQpJgkKss="}},"hash":"fdt7S/qOlDwkDX1D5Ec7Hz3UhJ9h5vl+NS9nng7Ze9U=","text":"Reusing the built-in error page\r\nIf you want to render the built-in error page you can by importing the Error component:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3b13819d-0fec-471a-a167-b8e31a60fbc8":{"id_":"3b13819d-0fec-471a-a167-b8e31a60fbc8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6WeZLjdqaapsHcWhusImrPAUaeg11YHyfqBIdWYCsy0=","metadata":{},"hash":"G+6VI/jX0LvA0Nrl79E/T2SoM+VAlhy+t5wvVQKip5k="}},"hash":"Po56lGOnncSIiT1CMwKReWpHIhLoIQ3kdAY0jCiFJr4=","text":"import Error from 'next/error'\r\nexport async function getServerSideProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const errorCode = res.ok ? false : res.status\r\n  const json = await res.json()\r\n  return {\r\n    props: { errorCode, stars: json.stargazers_count },\r\n  }\r\n}\r\nexport default function Page({ errorCode, stars }) {\r\n  if (errorCode) {\r\n    return <Error statusCode={errorCode} />\r\n  }\r\n  return <div>Next stars: {stars}</div>\r\n}\r\nThe Error component also takes title as a property if you want to pass in a text message along with a statusCode. If you have a custom Error component be sure to import that one instead. next/error exports the default component used by\r\nNext.js. Caveats\r\nError does not currently support Next.js Data Fetching methods like getStaticProps or getServerSideProps. _error, like _app, is a reserved pathname. _error is used to define the customized layouts and behaviors of the error pages. /_error will render 404 when accessed directly via routing or rendering in a custom server.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2861b427-7d61-422f-a265-ce58beaf27b3":{"id_":"2861b427-7d61-422f-a265-ce58beaf27b3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ih+R0HcFa/uZJWVZgzuGjJmyufmI4zWziR70BQZkCJU=","metadata":{},"hash":"ZgzfFd8Cw7neVT3BNTa5lrT3kcZD/HANWWvGzR23oYk="}},"hash":"OewtWw7XQg6LOUbHBmI/iZ3i81KW+vmFczXIsGuF2PM=","text":"4.1.1.7 - API Routes\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/07-api-routes\r\nDescription: Next.js supports API Routes, which allow you to build your API without leaving your Next.js app. Learn how it works here. Examples\r\nGood to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes. API routes provide a solution to build a public API with Next.js. Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-\r\nside only bundles and won’t increase your client-side bundle size. For example, the following API route returns a JSON response with a status code of 200:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\ntype ResponseData = {\r\n  message: string\r\n}\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\npages/api/hello.js (js)export default function handler(req, res) {\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\nGood to know:\r\nAPI Routes do not specify CORS headers, meaning they are same-origin only by default. You can customize such behavior\r\nby wrapping the request handler with the CORS request helpers. API Routes can’t be used with static exports. However, Route Handlers in the App Router can. API Routes will be affected by pageExtensions configuration in next.config.js. Parameters\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  // ... }\r\nreq: An instance of http.IncomingMessage\r\nres: An instance of http.ServerResponse\r\nHTTP Methods\r\nTo handle different HTTP methods in an API route, you can use req.method in your request handler, like so:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  if (req.method === 'POST') {\r\n    // Process a POST request\r\n  } else {\r\n    // Handle any other HTTP method\r\n  }\r\n}\r\npages/api/hello.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"998a4cbe-1461-4d60-a750-398a5f809fd2":{"id_":"998a4cbe-1461-4d60-a750-398a5f809fd2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"t8EcsbrpeZe/tkTRn8qeiAE6PuqQdhxDiTR0dSkDkXU=","metadata":{},"hash":"IU57nEGV4nrqCbKX0EPwexew7WoBr41I5dwPEoeGPc8="}},"hash":"AMf7+/aBAonqOHungiq09THUrm/K7+9luv8dO5heN0k=","text":"export default function handler(req, res) {\r\n  if (req.method === 'POST') {\r\n    // Process a POST request\r\n  } else {\r\n    // Handle any other HTTP method\r\n  }\r\n}\r\nRequest Helpers\r\nAPI Routes provide built-in request helpers which parse the incoming request (req):\r\nreq.cookies - An object containing the cookies sent by the request. Defaults to {}\r\nreq.query - An object containing the query string. Defaults to {}\r\nreq.body - An object containing the body parsed by content-type, or null if no body was sent\r\nCustom config\r\nEvery API Route can export a config object to change the default configuration, which is the following:\r\nexport const config = {\r\n  api: {\r\n    bodyParser: {\r\n      sizeLimit: '1mb',\r\n    },\r\n  },\r\n  // Specifies the maximum allowed duration for this function to execute (in seconds)\r\n  maxDuration: 5,\r\n}\r\nbodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false. One use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from\r\nGitHub. export const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n}\r\nbodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so:\r\nexport const config = {\r\n  api: {\r\n    bodyParser: {\r\n      sizeLimit: '500kb',\r\n    },\r\n  },\r\n}\r\nexternalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or\r\nconnect. Enabling this option disables warnings for unresolved requests. export const config = {\r\n  api: {\r\n    externalResolver: true,\r\n  },\r\n}\r\nresponseLimit is automatically enabled, warning when an API Routes’ response body is over 4MB. If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated\r\nmedia host, you can set this limit to false. export const config = {\r\n  api: {\r\n    responseLimit: false,\r\n  },\r\n}\r\nresponseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d0219e51-5415-4d1c-b8c5-bdbaeeb8c111":{"id_":"d0219e51-5415-4d1c-b8c5-bdbaeeb8c111","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Yn59W2j9q4Hc80KyMLiXxfs8jBEhSx5jPpkgOiGNEGA=","metadata":{},"hash":"EWx/jQnEBWjDWWM/VtT6F5AMZpEtXWV4MVF9kIKFIpk="},"NEXT":{"nodeId":"33be7464-bd29-4e41-bccb-65b9ef165919","metadata":{},"hash":"WglDvCIq/GBOj+KUerMdsLpb2V7FseujSBB7OnI+Mgw="}},"hash":"GEBk5acYx7HF2heDkPv0b3yZFCR6SACK897uJE1J4cM=","text":"This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)\r\nexport const config = {\r\n  api: {\r\n    responseLimit: '8mb',\r\n  },\r\n}\r\nResponse Helpers\r\nThe Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer\r\nexperience and increase the speed of creating new API endpoints. The included helpers are:\r\nres.status(code) - A function to set the status code. code must be a valid HTTP status code\r\nres.json(body) - Sends a JSON response. body must be a serializable object\r\nres.send(body) - Sends the HTTP response. body can be a string, an object or a Buffer\r\nres.redirect([status,] path) - Redirects to a specified path or URL. status must be a valid HTTP status code. If not\r\nspecified, status defaults to “307” “Temporary redirect”. res.revalidate(urlPath) - Revalidate a page on demand using getStaticProps. urlPath must be a string. Setting the status code of a response\r\nWhen sending a response back to the client, you can set the status code of the response. The following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from\r\nNext.js! as a JSON response:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\ntype ResponseData = {\r\n  message: string\r\n}\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\npages/api/hello.js (js)export default function handler(req, res) {\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\nSending a JSON response\r\nWhen sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application\r\nyou might want to let the client know the status of the request depending on the result of the requested endpoint. The following example sends a JSON response with the status code 200 (OK) and the result of the async operation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"33be7464-bd29-4e41-bccb-65b9ef165919":{"id_":"33be7464-bd29-4e41-bccb-65b9ef165919","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Yn59W2j9q4Hc80KyMLiXxfs8jBEhSx5jPpkgOiGNEGA=","metadata":{},"hash":"EWx/jQnEBWjDWWM/VtT6F5AMZpEtXWV4MVF9kIKFIpk="},"PREVIOUS":{"nodeId":"d0219e51-5415-4d1c-b8c5-bdbaeeb8c111","metadata":{},"hash":"GEBk5acYx7HF2heDkPv0b3yZFCR6SACK897uJE1J4cM="}},"hash":"WglDvCIq/GBOj+KUerMdsLpb2V7FseujSBB7OnI+Mgw=","text":"It’s contained in a try\r\ncatch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the\r\nclient:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).json({ result })\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'failed to load data' })\r\n  }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4f1909d1-13e2-402b-81fc-fe1127a69492":{"id_":"4f1909d1-13e2-402b-81fc-fe1127a69492","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WUgzBpDhGrHpHexaVYG7cMxkMMnW8lTmub+9YPGzT1o=","metadata":{},"hash":"mN7IzlF/W9BThNt4HiI3JKHvON+mM+734VSL2VuGWjg="},"NEXT":{"nodeId":"557dbf32-b219-4b7f-8f1b-b82a33eace80","metadata":{},"hash":"fh07uuv3TyXWFu2Q06TIiNKiwcWs4DHkVDwJlHvlUqg="}},"hash":"vZ8bXYkmHUSds8U5YL8s/hpgxk/oaBLvA4kHcTaZ6KA=","text":"pages/api/hello.js (js)export default async function handler(req, res) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).json({ result })\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'failed to load data' })\r\n  }\r\n}\r\nSending a HTTP response\r\nSending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be\r\na string, an object or a Buffer. The following example sends a HTTP response with the status code 200 (OK) and the result of the async operation. pages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).send({ result })\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })\r\n  }\r\n}\r\npages/api/hello.js (js)export default async function handler(req, res) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).send({ result })\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })\r\n  }\r\n}\r\nRedirects to a specified path or URL\r\nTaking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"557dbf32-b219-4b7f-8f1b-b82a33eace80":{"id_":"557dbf32-b219-4b7f-8f1b-b82a33eace80","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WUgzBpDhGrHpHexaVYG7cMxkMMnW8lTmub+9YPGzT1o=","metadata":{},"hash":"mN7IzlF/W9BThNt4HiI3JKHvON+mM+734VSL2VuGWjg="},"PREVIOUS":{"nodeId":"4f1909d1-13e2-402b-81fc-fe1127a69492","metadata":{},"hash":"vZ8bXYkmHUSds8U5YL8s/hpgxk/oaBLvA4kHcTaZ6KA="}},"hash":"fh07uuv3TyXWFu2Q06TIiNKiwcWs4DHkVDwJlHvlUqg=","text":"The following example redirects the client to the / path if the form is successfully submitted:\r\npages/api/hello.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const { name, message } = req.body\r\n  try {\r\n    await handleFormInputAsync({ name, message })\r\n    res.redirect(307, '/')\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'Failed to fetch data' })\r\n  }\r\n}\r\npages/api/hello.js (js)export default async function handler(req, res) {\r\n  const { name, message } = req.body\r\n  try {\r\n    await handleFormInputAsync({ name, message })\r\n    res.redirect(307, '/')\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a8d0afa0-8cec-458c-a593-2c73188458b5":{"id_":"a8d0afa0-8cec-458c-a593-2c73188458b5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aBJNQAlzkKv+EsIX6xSYSH2RdfGbp60VLdOHdkEgTSI=","metadata":{},"hash":"KV3J19G2QwlYcTDlvCaC1H0yAo9MEVVwYHVlfYZ+MY4="},"NEXT":{"nodeId":"e9e841da-8661-4166-9089-b8c30ae52559","metadata":{},"hash":"6Xaf0kF64nv2sYYOVU+IzY1+hzR8qrgikE0FdSLBOko="}},"hash":"dcbffuKRflKn2Lti3UXm5mrAiU06Tfk40T6tbQKq0Io=","text":"}\r\n}\r\nAdding TypeScript types\r\nYou can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition\r\nto those, you can also type your response data:\r\nimport type { NextApiRequest, NextApiResponse } from 'next'\r\ntype ResponseData = {\r\n  message: string\r\n}\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js! ' })\r\n}\r\nGood to know: The body of NextApiRequest is any because the client may include any payload. You should validate the\r\ntype/shape of the body at runtime before using it. Dynamic API Routes\r\nAPI Routes support dynamic routes, and follow the same file naming rules used for pages/. pages/api/post/[pid].ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const { pid } = req.query\r\n  res.end(`Post: ${pid}`)\r\n}\r\npages/api/post/[pid].js (js)export default function handler(req, res) {\r\n  const { pid } = req.query\r\n  res.end(`Post: ${pid}`)\r\n}\r\nNow, a request to /api/post/abc will respond with the text: Post: abc. Catch all API routes\r\nAPI Routes can be extended to catch all paths by adding three dots (... ) inside the brackets. For example:\r\npages/api/post/[...slug].js matches /api/post/a, but also /api/post/a/b, /api/post/a/b/c and so on.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e9e841da-8661-4166-9089-b8c30ae52559":{"id_":"e9e841da-8661-4166-9089-b8c30ae52559","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"aBJNQAlzkKv+EsIX6xSYSH2RdfGbp60VLdOHdkEgTSI=","metadata":{},"hash":"KV3J19G2QwlYcTDlvCaC1H0yAo9MEVVwYHVlfYZ+MY4="},"PREVIOUS":{"nodeId":"a8d0afa0-8cec-458c-a593-2c73188458b5","metadata":{},"hash":"dcbffuKRflKn2Lti3UXm5mrAiU06Tfk40T6tbQKq0Io="}},"hash":"6Xaf0kF64nv2sYYOVU+IzY1+hzR8qrgikE0FdSLBOko=","text":"Good to know: You can use names other than slug, such as: [...param]\r\nMatched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path\r\n/api/post/a will have the following query object:\r\n{ \"slug\": [\"a\"] }\r\nAnd in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so:\r\n{ \"slug\": [\"a\", \"b\"] }\r\nFor example:\r\npages/api/post/[...slug].ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const { slug } = req.query\r\n  res.end(`Post: ${slug.join(', ')}`)\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c2e46939-64b8-4f4a-ac01-f8320e1fb04a":{"id_":"c2e46939-64b8-4f4a-ac01-f8320e1fb04a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rSHTi1okZTIpJ+MTuf8C3E1bxFRhK3QPL0HFN13tiPQ=","metadata":{},"hash":"/oGC0m9TzrC+pR6Xc51ztdpdfLrByMRLIPdAlkl1juo="}},"hash":"+Gb3Mpg6dByXpTHhqzZ68lBBkf4feQP0v1puD95hmqw=","text":"pages/api/post/[...slug].js (js)export default function handler(req, res) {\r\n  const { slug } = req.query\r\n  res.end(`Post: ${slug.join(', ')}`)\r\n}\r\nNow, a request to /api/post/a/b/c will respond with the text: Post: a, b, c. Optional catch all API routes\r\nCatch all routes can be made optional by including the parameter in double brackets ([[...slug]]). For example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on. The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also\r\nmatched (/api/post in the example above). The query objects are as follows:\r\n{ } // GET `/api/post` (empty object)\r\n{ \"slug\": [\"a\"] } // `GET /api/post/a` (single-element array)\r\n{ \"slug\": [\"a\", \"b\"] } // `GET /api/post/a/b` (multi-element array)\r\nCaveats\r\nPredefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at\r\nthe following examples:pages/api/post/create.js\r\n - Will match /api/post/create\r\npages/api/post/[pid].js - Will match /api/post/1, /api/post/abc, etc. But not /api/post/create\r\npages/api/post/[...slug].js - Will match /api/post/1/2, /api/post/a/b/c, etc. But not /api/post/create,\r\n/api/post/abc\r\nEdge API Routes\r\nIf you would like to use API Routes with the Edge Runtime, we recommend incrementally adopting the App Router and using Route\r\nHandlers instead. The Route Handlers function signature is isomorphic, meaning you can use the same function for both Edge and Node.js runtimes.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3eeb24e1-8e55-459f-8fc2-607956a7d851":{"id_":"3eeb24e1-8e55-459f-8fc2-607956a7d851","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"faTlphiFaOlMvxEOZx8Ao2tNVrF+apX27/SjypeR3HE=","metadata":{},"hash":"weiPlwExNxx8kAaZGyrhtB4yMJ6z0cdbxfTEyJZd3js="},"NEXT":{"nodeId":"b043a077-b788-45a8-8647-6ed04698b323","metadata":{},"hash":"QQ0nQGPpoDQRTMVaZQH89oXy1ecFWvIJIylLQKJh5Qo="}},"hash":"RoV26a/8oudgDqtOL9GmlRHrUChEWb6iYA17/b/XZ0I=","text":"4.1.1.8 - Internationalization (i18n) Routing\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/08-internationalization\r\nDescription: Next.js has built-in support for internationalized routing and language detection. Learn more here. Examples\r\nNext.js has built-in support for internationalized (i18n) routing since v10.0.0. You can provide a list of locales, the default locale, and\r\ndomain-specific locales and Next.js will automatically handle the routing. The i18n routing support is currently meant to complement existing i18n library solutions like react-intl, react-i18next, lingui,\r\nrosetta, next-intl, next-translate, next-multilingual, tolgee, and others by streamlining the routes and locale parsing. Getting started\r\nTo get started, add the i18n config to your next.config.js file. Locales are UTS Locale Identifiers, a standardized format for defining locales. Generally a Locale Identifier is made up of a language, region, and script separated by a dash: language-region-script. The region\r\nand script are optional. An example:\r\nen-US - English as spoken in the United States\r\nnl-NL - Dutch as spoken in the Netherlands\r\nnl - Dutch, no specific region\r\nIf user locale is nl-BE and it is not listed in your configuration, they will be redirected to nl if available, or to the default locale\r\notherwise. If you don’t plan to support all regions of a country, it is therefore a good practice to include country locales that will act as\r\nfallbacks. next.config.js (js)module.exports = {\r\n  i18n: {\r\n    // These are all the locales you want to support in\r\n    // your application\r\n    locales: ['en-US', 'fr', 'nl-NL'],\r\n    // This is the default locale you want to be used when visiting\r\n    // a non-locale prefixed path e.g. `/hello`\r\n    defaultLocale: 'en-US',\r\n    // This is a list of locale domains and the default locale they\r\n    // should handle (these are only required when setting up domain routing)\r\n    // Note: subdomains must be included in the domain value to be matched e.g. \"fr.example.com\".","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b043a077-b788-45a8-8647-6ed04698b323":{"id_":"b043a077-b788-45a8-8647-6ed04698b323","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"faTlphiFaOlMvxEOZx8Ao2tNVrF+apX27/SjypeR3HE=","metadata":{},"hash":"weiPlwExNxx8kAaZGyrhtB4yMJ6z0cdbxfTEyJZd3js="},"PREVIOUS":{"nodeId":"3eeb24e1-8e55-459f-8fc2-607956a7d851","metadata":{},"hash":"RoV26a/8oudgDqtOL9GmlRHrUChEWb6iYA17/b/XZ0I="}},"hash":"QQ0nQGPpoDQRTMVaZQH89oXy1ecFWvIJIylLQKJh5Qo=","text":"\"fr.example.com\". domains: [\r\n      {\r\n        domain: 'example.com',\r\n        defaultLocale: 'en-US',\r\n      },\r\n      {\r\n        domain: 'example.nl',\r\n        defaultLocale: 'nl-NL',\r\n      },\r\n      {\r\n        domain: 'example.fr',\r\n        defaultLocale: 'fr',\r\n        // an optional http field can also be used to test\r\n        // locale domains locally with http instead of https\r\n        http: true,\r\n      },\r\n    ],\r\n  },\r\n}\r\nLocale Strategies\r\nThere are two locale handling strategies: Sub-path Routing and Domain Routing. Sub-path Routing\r\nSub-path Routing puts the locale in the url path. next.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d64c5eb2-638a-43c6-b598-e8265d7d8275":{"id_":"d64c5eb2-638a-43c6-b598-e8265d7d8275","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Jjhc88XR+0hsAjjGdgsxGKYXf+68/JeY6IdtUfz5RA0=","metadata":{},"hash":"3PoVLJZgMNFGraTJHY6k7LL1p3SwqRTgKri244kg6fk="}},"hash":"uXg91d6RkY0q0qaXBMIUcxCQs6H2cjTK9yWNBiiUGGo=","text":"module.exports = {\r\n  i18n: {\r\n    locales: ['en-US', 'fr', 'nl-NL'],\r\n    defaultLocale: 'en-US',\r\n  },\r\n}\r\nWith the above configuration en-US, fr, and nl-NL will be available to be routed to, and en-US is the default locale. If you have a\r\npages/blog.js the following urls would be available:\r\n/blog\r\n/fr/blog\r\n/nl-nl/blog\r\nThe default locale does not have a prefix. Domain Routing\r\nBy using domain routing you can configure locales to be served from different domains:\r\nnext.config.js (js)module.exports = {\r\n  i18n: {\r\n    locales: ['en-US', 'fr', 'nl-NL', 'nl-BE'],\r\n    defaultLocale: 'en-US',\r\n    domains: [\r\n      {\r\n        // Note: subdomains must be included in the domain value to be matched\r\n        // e.g. www.example.com should be used if that is the expected hostname\r\n        domain: 'example.com',\r\n        defaultLocale: 'en-US',\r\n      },\r\n      {\r\n        domain: 'example.fr',\r\n        defaultLocale: 'fr',\r\n      },\r\n      {\r\n        domain: 'example.nl',\r\n        defaultLocale: 'nl-NL',\r\n        // specify other locales that should be redirected\r\n        // to this domain\r\n        locales: ['nl-BE'],\r\n      },\r\n    ],\r\n  },\r\n}\r\nFor example if you have pages/blog.js the following urls will be available:\r\nexample.com/blog\r\nwww.example.com/blog\r\nexample.fr/blog\r\nexample.nl/blog\r\nexample.nl/nl-BE/blog\r\nAutomatic Locale Detection\r\nWhen a user visits the application root (generally /), Next.js will try to automatically detect which locale the user prefers based on the\r\nAccept-Language header and the current domain. If a locale other than the default locale is detected, the user will be redirected to either:\r\nWhen using Sub-path Routing: The locale prefixed path\r\nWhen using Domain Routing: The domain with that locale specified as the default\r\nWhen using Domain Routing, if a user with the Accept-Language header fr;q=0.9 visits example.com, they will be redirected to\r\nexample.fr since that domain handles the fr locale by default. When using Sub-path Routing, the user would be redirected to /fr.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ab7b2b3a-a9e4-4642-9fc6-dbbb3868bc11":{"id_":"ab7b2b3a-a9e4-4642-9fc6-dbbb3868bc11","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"OXaXBrrzrbSxC1rREqzta/EiSXcL5ltU7hg24ds4tog=","metadata":{},"hash":"1EtDvVG+E5aDm/x0qDiLA6SrZGuJgdxLfAP08szYDUQ="}},"hash":"vtg9s/5CfemCUGs992KaJvdHJsXoAoLg8XXLg04g9EM=","text":"Prefixing the Default Locale\r\nWith Next.js 12 and Middleware, we can add a prefix to the default locale with a workaround. For example, here’s a next.config.js file with support for a few languages. Note the \"default\" locale has been added intentionally. next.config.js (js)module.exports = {\r\n  i18n: {\r\n    locales: ['default', 'en', 'de', 'fr'],\r\n    defaultLocale: 'default',\r\n    localeDetection: false,\r\n  },\r\n  trailingSlash: true,\r\n}\r\nNext, we can use Middleware to add custom routing rules:\r\nmiddleware.ts (ts)import { NextRequest, NextResponse } from 'next/server'\r\nconst PUBLIC_FILE = /\\.(.*)$/\r\nexport async function middleware(req: NextRequest) {\r\n  if (\r\n    req.nextUrl.pathname.startsWith('/_next') ||\r\n    req.nextUrl.pathname.includes('/api/') ||\r\n    PUBLIC_FILE.test(req.nextUrl.pathname)\r\n  ) {\r\n    return\r\n  }\r\n  if (req.nextUrl.locale === 'default') {\r\n    const locale = req.cookies.get('NEXT_LOCALE')?.value || 'en'\r\n    return NextResponse.redirect(\r\n      new URL(`/${locale}${req.nextUrl.pathname}${req.nextUrl.search}`, req.url)\r\n    )\r\n  }\r\n}\r\nThis Middleware skips adding the default prefix to API Routes and public files like fonts or images. If a request is made to the default\r\nlocale, we redirect to our prefix /en. Disabling Automatic Locale Detection\r\nThe automatic locale detection can be disabled with:\r\nnext.config.js (js)module.exports = {\r\n  i18n: {\r\n    localeDetection: false,\r\n  },\r\n}\r\nWhen localeDetection is set to false Next.js will no longer automatically redirect based on the user’s preferred locale and will only\r\nprovide locale information detected from either the locale based domain or locale path as described above. Accessing the locale information\r\nYou can access the locale information via the Next.js router. For example, using the useRouter() hook the following properties are\r\navailable:\r\nlocale contains the currently active locale. locales contains all configured locales. defaultLocale contains the configured default locale. When pre-rendering pages with getStaticProps or getServerSideProps, the locale information is provided in the context provided\r\nto the function. When leveraging getStaticPaths, the configured locales are provided in the context parameter of the function under locales and\r\nthe configured defaultLocale under defaultLocale.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e6169ffa-71bd-4610-be9f-d5d43e2cecc3":{"id_":"e6169ffa-71bd-4610-be9f-d5d43e2cecc3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"l1PLIx6HKAzPzhpFX0tlhO0i7t3U076ww7LnsaWg3+0=","metadata":{},"hash":"wV+hMWOm1NkeTrMd6KbzJn9JzlYDa+Fnt4zDEmr6tjk="},"NEXT":{"nodeId":"b61e63a4-5534-4315-bbbd-8ef60dd1ba40","metadata":{},"hash":"1LFMsUBLQpRKwm2jfSYYBMVDb1dY0J0N2OsfZN6mngs="}},"hash":"unPQTy7YBGt1DGqMYhyiv1K+1CsV576nfpMianhN3EY=","text":"Transition between locales\r\nYou can use next/link or next/router to transition between locales. For next/link, a locale prop can be provided to transition to a different locale from the currently active one. If no locale prop is\r\nprovided, the currently active locale is used during client-transitions. For example:\r\nimport Link from 'next/link'\r\nexport default function IndexPage(props) {\r\n  return (\r\n    <Link href=\"/another\" locale=\"fr\">\r\n      To /fr/another\r\n    </Link>\r\n  )\r\n}\r\nWhen using the next/router methods directly, you can specify the locale that should be used via the transition options. For\r\nexample:\r\nimport { useRouter } from 'next/router'\r\nexport default function IndexPage(props) {\r\n  const router = useRouter()\r\n  return (\r\n    <div\r\n      onClick={() => {\r\n        router.push('/another', '/another', { locale: 'fr' })\r\n      }}\r\n    >\r\n      to /fr/another\r\n    </div>\r\n  )\r\n}\r\nNote that to handle switching only the locale while preserving all routing information such as dynamic route query values or hidden\r\nhref query values, you can provide the href parameter as an object:\r\nimport { useRouter } from 'next/router'\r\nconst router = useRouter()\r\nconst { pathname, asPath, query } = router\r\n// change just the locale and maintain all other route information including href's query\r\nrouter.push({ pathname, query }, asPath, { locale: nextLocale })\r\nSee here for more information on the object structure for router.push. If you have a href that already includes the locale you can opt-out of automatically handling the locale prefixing:\r\nimport Link from 'next/link'\r\nexport default function IndexPage(props) {\r\n  return (\r\n    <Link href=\"/fr/another\" locale={false}>\r\n      To /fr/another\r\n    </Link>\r\n  )\r\n}\r\nLeveraging the NEXT_LOCALENEXT_LOCALE cookie\r\nNext.js supports overriding the accept-language header with a NEXT_LOCALE=the-locale cookie. This cookie can be set using a\r\nlanguage switcher and then when a user comes back to the site it will leverage the locale specified in the cookie when redirecting from/\r\n to the correct locale location. For example, if a user prefers the locale fr in their accept-language header but a NEXT_LOCALE=en cookie is set the en locale when\r\nvisiting / the user will be redirected to the en locale location until the cookie is removed or expired.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b61e63a4-5534-4315-bbbd-8ef60dd1ba40":{"id_":"b61e63a4-5534-4315-bbbd-8ef60dd1ba40","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"l1PLIx6HKAzPzhpFX0tlhO0i7t3U076ww7LnsaWg3+0=","metadata":{},"hash":"wV+hMWOm1NkeTrMd6KbzJn9JzlYDa+Fnt4zDEmr6tjk="},"PREVIOUS":{"nodeId":"e6169ffa-71bd-4610-be9f-d5d43e2cecc3","metadata":{},"hash":"unPQTy7YBGt1DGqMYhyiv1K+1CsV576nfpMianhN3EY="}},"hash":"1LFMsUBLQpRKwm2jfSYYBMVDb1dY0J0N2OsfZN6mngs=","text":"Search Engine Optimization\r\nSince Next.js knows what language the user is visiting it will automatically add the lang attribute to the <html> tag.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f1df7966-bb2a-4a06-82fa-428968d5bec8":{"id_":"f1df7966-bb2a-4a06-82fa-428968d5bec8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mW+TUwzZW0DpM8ggrwCcL94881iFiopvYlg3muAC7PA=","metadata":{},"hash":"ZV8B9gn42gw1qPZtzq/rDi8ucTmSOcyubazkjnCyIY8="},"NEXT":{"nodeId":"869daf92-798b-4d8d-8df4-4468b0195b24","metadata":{},"hash":"7SmwUpqEXuAtQWNnDWg7Yo7oJcXkbXGHy90s2j9VyeE="}},"hash":"wIuwQovbMlG3Aw1vfnUPx9FQroLNPbJxLQcYE9pHxoc=","text":"Next.js doesn’t know about variants of a page so it’s up to you to add the hreflang meta tags using next/head. You can learn more\r\nabout hreflang in the Google Webmasters documentation. How does this work with Static Generation? Note that Internationalized Routing does not integrate with output: 'export' as it does not leverage the Next.js routing\r\nlayer. Hybrid Next.js applications that do not use output: 'export' are fully supported. Dynamic Routes and getStaticPropsgetStaticProps Pages\r\nFor pages using getStaticProps with Dynamic Routes, all locale variants of the page desired to be prerendered need to be returned\r\nfrom getStaticPaths. Along with the params object returned for paths, you can also return a locale field specifying which locale\r\nyou want to render. For example:\r\npages/blog/[slug].js (jsx)export const getStaticPaths = ({ locales }) => {\r\n  return {\r\n    paths: [\r\n      // if no `locale` is provided only the defaultLocale will be generated\r\n      { params: { slug: 'post-1' }, locale: 'en-US' },\r\n      { params: { slug: 'post-1' }, locale: 'fr' },\r\n    ],\r\n    fallback: true,\r\n  }\r\n}\r\nFor Automatically Statically Optimized and non-dynamic getStaticProps pages, a version of the page will be generated for each\r\nlocale. This is important to consider because it can increase build times depending on how many locales are configured insidegetStaticProps\r\n. For example, if you have 50 locales configured with 10 non-dynamic pages using getStaticProps, this means getStaticProps will\r\nbe called 500 times. 50 versions of the 10 pages will be generated during each build. To decrease the build time of dynamic pages with getStaticProps, use a fallback mode. This allows you to return only the most\r\npopular paths and locales from getStaticPaths for prerendering during the build. Then, Next.js will build the remaining pages at\r\nruntime as they are requested. Automatically Statically Optimized Pages\r\nFor pages that are automatically statically optimized, a version of the page will be generated for each locale. Non-dynamic getStaticProps Pages\r\nFor non-dynamic getStaticProps pages, a version is generated for each locale like above. getStaticProps is called with each\r\nlocale that is being rendered.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"869daf92-798b-4d8d-8df4-4468b0195b24":{"id_":"869daf92-798b-4d8d-8df4-4468b0195b24","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"mW+TUwzZW0DpM8ggrwCcL94881iFiopvYlg3muAC7PA=","metadata":{},"hash":"ZV8B9gn42gw1qPZtzq/rDi8ucTmSOcyubazkjnCyIY8="},"PREVIOUS":{"nodeId":"f1df7966-bb2a-4a06-82fa-428968d5bec8","metadata":{},"hash":"wIuwQovbMlG3Aw1vfnUPx9FQroLNPbJxLQcYE9pHxoc="}},"hash":"7SmwUpqEXuAtQWNnDWg7Yo7oJcXkbXGHy90s2j9VyeE=","text":"getStaticProps is called with each\r\nlocale that is being rendered. If you would like to opt-out of a certain locale from being pre-rendered, you can return notFound:\r\ntrue from getStaticProps and this variant of the page will not be generated. export async function getStaticProps({ locale }) {\r\n  // Call an external API endpoint to get posts. // You can use any data fetching library\r\n  const res = await fetch(`https://.../posts?locale=${locale}`)\r\n  const posts = await res.json()\r\n  if (posts.length === 0) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n  // By returning { props: posts }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}\r\nLimits for the i18n config","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"03aa4f8e-db05-4574-b938-b9f1540e03fe":{"id_":"03aa4f8e-db05-4574-b938-b9f1540e03fe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"236dAqFSZ0R1QXQKoPPNHzISCVb/hpGMxC7cZzRICIY=","metadata":{},"hash":"+zYdbG2Gm83hJ+gOkL6b7C3nTACCmo74H1Ja1mTnYe4="}},"hash":"iOJV8RU28tpvdKI5lcEu0wyG8L8ymV4hGl3tEW2Qdso=","text":"locales: 100 total locales\r\ndomains: 100 total locale domain items\r\nGood to know: These limits have been added initially to prevent potential performance issues at build time. You can\r\nworkaround these limits with custom routing using Middleware in Next.js 12.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6c9e0eea-f723-44e5-b6b2-13fae2b65e66":{"id_":"6c9e0eea-f723-44e5-b6b2-13fae2b65e66","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Fbn3mK3Rdkl5bRU+lOqwaUadsE+jfyTt0JfAS3EaqOA=","metadata":{},"hash":"BW2WDNB1UiyiODJoyuxotyVnAIGplJXZHrEwXugp2QQ="},"NEXT":{"nodeId":"18fcd7f8-74a4-4eea-9ae2-7854a9639cca","metadata":{},"hash":"fNEepLjMlebOyds85jOJ8VB+0pq8ivKsj4WMFRsWpOo="}},"hash":"h7NZGu85bj0otPR7rV3IyCSUy8Rc6W5cDRdwxVHKy98=","text":"4.1.1.9 - Authenticating\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/09-authenticating\r\nDescription: Learn about authentication patterns in Next.js apps and explore a few examples. Authentication verifies who a user is, while authorization controls what a user can access. Next.js supports multiple authentication\r\npatterns, each designed for different use cases. This page will go through each case so that you can choose based on your constraints. Authentication Patterns\r\nThe first step to identifying which authentication pattern you need is understanding the data-fetching strategy you want. We can then\r\ndetermine which authentication providers support this strategy. There are two main patterns:\r\nUse static generation to server-render a loading state, followed by fetching user data client-side. Fetch user data server-side to eliminate a flash of unauthenticated content. Authenticating Statically Generated Pages\r\nNext.js automatically determines that a page is static if there are no blocking data requirements. This means the absence ofgetServerSideProps\r\n and getInitialProps in the page. Instead, your page can render a loading state from the server, followed by\r\nfetching the user client-side. One advantage of this pattern is it allows pages to be served from a global CDN and preloaded using next/link. In practice, this\r\nresults in a faster TTI (Time to Interactive). Let’s look at an example for a profile page. This will initially render a loading skeleton. Once the request for a user has finished, it will\r\nshow the user’s name:\r\npages/profile.js (jsx)import useUser from '../lib/useUser'\r\nimport Layout from '../components/Layout'\r\nconst Profile = () => {\r\n  // Fetch the user client-side\r\n  const { user } = useUser({ redirectTo: '/login' })\r\n  // Server-render loading state\r\n  if (!user || user.isLoggedIn === false) {\r\n    return <Layout>Loading...</Layout>\r\n  }\r\n  // Once the user request finishes, show the user\r\n  return (\r\n    <Layout>\r\n      <h1>Your Profile</h1>\r\n      <pre>{JSON.stringify(user, null, 2)}</pre>\r\n    </Layout>\r\n  )\r\n}\r\nexport default Profile\r\nYou can view this example in action. Check out the with-iron-session example to see how it works.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"18fcd7f8-74a4-4eea-9ae2-7854a9639cca":{"id_":"18fcd7f8-74a4-4eea-9ae2-7854a9639cca","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Fbn3mK3Rdkl5bRU+lOqwaUadsE+jfyTt0JfAS3EaqOA=","metadata":{},"hash":"BW2WDNB1UiyiODJoyuxotyVnAIGplJXZHrEwXugp2QQ="},"PREVIOUS":{"nodeId":"6c9e0eea-f723-44e5-b6b2-13fae2b65e66","metadata":{},"hash":"h7NZGu85bj0otPR7rV3IyCSUy8Rc6W5cDRdwxVHKy98="}},"hash":"fNEepLjMlebOyds85jOJ8VB+0pq8ivKsj4WMFRsWpOo=","text":"Check out the with-iron-session example to see how it works. Authenticating Server-Rendered Pages\r\nIf you export an async function called getServerSideProps from a page, Next.js will pre-render this page on each request using the\r\ndata returned by getServerSideProps. export async function getServerSideProps(context) {\r\n  return {\r\n    props: {}, // Will be passed to the page component as props\r\n  }\r\n}\r\nLet’s transform the profile example to use server-side rendering. If there’s a session, return user as a prop to the Profile component\r\nin the page. Notice there is not a loading skeleton in this example. pages/profile.js (jsx)import withSession from '../lib/session'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dd629af9-3d0d-4aa5-9ea4-a3ab27ab9b7f":{"id_":"dd629af9-3d0d-4aa5-9ea4-a3ab27ab9b7f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p9LKtUXSS4Esiso+hy054BQI42Ic4IQjUAG+sndc0lY=","metadata":{},"hash":"FdHK/IcYTEjvBlxMBYFs62YNtPZE82sNfpdDu1sraH4="},"NEXT":{"nodeId":"124f800f-9f2b-4468-bda8-ca587f0f3e56","metadata":{},"hash":"vY4aK9pJl3nvth2mROJk6GyngCJ4WYbmyEPgW0coKY4="}},"hash":"1H7WmSPOt0eAltWKNfidGoP3D6FPy9/RTjOjJ7mrhoA=","text":"import Layout from '../components/Layout'\r\nexport const getServerSideProps = withSession(async function ({ req, res }) {\r\n  const { user } = req.session\r\n  if (!user) {\r\n    return {\r\n      redirect: {\r\n        destination: '/login',\r\n        permanent: false,\r\n      },\r\n    }\r\n  }\r\n  return {\r\n    props: { user },\r\n  }\r\n})\r\nconst Profile = ({ user }) => {\r\n  // Show the user. No loading state is required\r\n  return (\r\n    <Layout>\r\n      <h1>Your Profile</h1>\r\n      <pre>{JSON.stringify(user, null, 2)}</pre>\r\n    </Layout>\r\n  )\r\n}\r\nexport default Profile\r\nAn advantage of this pattern is preventing a flash of unauthenticated content before redirecting. It’s important to note fetching user\r\ndata in getServerSideProps will block rendering until the request to your authentication provider resolves. To prevent creating a\r\nbottleneck and increasing your TTFB (Time to First Byte), you should ensure your authentication lookup is fast. Otherwise, consider\r\nstatic generation. Authentication Providers\r\nNow that we’ve discussed authentication patterns, let’s look at specific providers and explore how they’re used with Next.js. Bring Your Own Database\r\nExamples\r\n- [with-iron-session](https://github.com/vercel/next.js/tree/canary/examples/with-iron-session) - [next-auth-example]\r\n(https://github.com/nextauthjs/next-auth-example)\r\nIf you have an existing database with user data, you’ll likely want to utilize an open-source solution that’s provider agnostic. If you want a low-level, encrypted, and stateless session utility use iron-session. If you want a full-featured authentication system with built-in providers (Google, Facebook, GitHub...), JWT, JWE, email/password,\r\nmagic links and more... use next-auth. Both of these libraries support either authentication pattern. If you’re interested in Passport, we also have examples for it using secure\r\nand encrypted cookies:\r\nwith-passport\r\nwith-passport-and-next-connect\r\nOther Providers\r\nTo see examples with other authentication providers, check out the examples folder.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"124f800f-9f2b-4468-bda8-ca587f0f3e56":{"id_":"124f800f-9f2b-4468-bda8-ca587f0f3e56","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"p9LKtUXSS4Esiso+hy054BQI42Ic4IQjUAG+sndc0lY=","metadata":{},"hash":"FdHK/IcYTEjvBlxMBYFs62YNtPZE82sNfpdDu1sraH4="},"PREVIOUS":{"nodeId":"dd629af9-3d0d-4aa5-9ea4-a3ab27ab9b7f","metadata":{},"hash":"1H7WmSPOt0eAltWKNfidGoP3D6FPy9/RTjOjJ7mrhoA="}},"hash":"vY4aK9pJl3nvth2mROJk6GyngCJ4WYbmyEPgW0coKY4=","text":"Examples\r\n- [Auth0](https://github.com/vercel/next.js/tree/canary/examples/auth0) - [Clerk]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-clerk) - [Firebase]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-firebase) - [Magic]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-magic) - [Nhost]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-nhost-auth-realtime-graphql) - [Ory]\r\n(https://github.com/vercel/examples/tree/main/solutions/auth-with-ory) - [Supabase]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-supabase) - [Supertokens]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-supertokens) - [Userbase]\r\n(https://github.com/vercel/next.js/tree/canary/examples/with-userbase)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"171d559f-4646-4221-b86b-6f6b36438acc":{"id_":"171d559f-4646-4221-b86b-6f6b36438acc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2F5QBxVSKIDo1LAye5XkVDxYlS3HzMJSxcb0cMl+deU=","metadata":{},"hash":"FNC2Gd2QTub5JG5Aalt0PP9ZHLec0UwcmNSEMJHdryI="}},"hash":"2CTr1treYJSCxkjdoApBi8kTy3XZT0VElXK05VSUo9Y=","text":"4.1.1.10 - Middleware\r\nDocumentation path: /03-pages/01-building-your-application/01-routing/10-middleware\r\nDescription: Learn how to use Middleware to run code before a request is completed. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"89fa5aaa-e2cd-4568-88c2-c729721f20ec":{"id_":"89fa5aaa-e2cd-4568-88c2-c729721f20ec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"B0ngwLxxsu76QYRszsDDuaVjRWbh86LSMSV6BPbJfEA=","metadata":{},"hash":"By3vOx/tNFoAUSFeJicpPSA85wKaap14Y8Gaip8i/qE="}},"hash":"8Nwmr0Yf9XbNqG9kw5z9WmrsRbKnUrzjqLdFeKkZW9k=","text":"4.1.2 - Rendering\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/index\r\nDescription: Learn the fundamentals of rendering in React and Next.js. By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all\r\ndone by client-side JavaScript. Pre-rendering can result in better performance and SEO. Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its\r\nJavaScript code runs and makes the page fully interactive (this process is called hydration in React). Pre-rendering\r\nNext.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the\r\nHTML for a page. Static Generation: The HTML is generated at build time and will be reused on each request. Server-side Rendering: The HTML is generated on each request. Importantly, Next.js lets you choose which pre-rendering form you’d like to use for each page. You can create a “hybrid” Next.js app by\r\nusing Static Generation for most pages and using Server-side Rendering for others. We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached\r\nby CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option. You can also use client-side data fetching along with Static Generation or Server-side Rendering. That means some parts of a page can\r\nbe rendered entirely by clientside JavaScript. To learn more, take a look at the Data Fetching documentation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ef4ba30d-1a6f-496c-a007-40e6f123185f":{"id_":"ef4ba30d-1a6f-496c-a007-40e6f123185f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i1Q2aKNi0qzc3x/rciUCX26y3EdNEUYhzpelDQ+Gv4s=","metadata":{},"hash":"Ohzsw6cnyrzNu0jiJETPMcz2O5OO3tXrGp5A74EPk0A="}},"hash":"p5SWSa1EhNOkayHnmqoWFzW1jzkcIFEAneW1QIRE66I=","text":"4.1.2.1 - Server-side Rendering (SSR)\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/01-server-side-rendering\r\nDescription: Use Server-side Rendering to render pages on each request. Also referred to as “SSR” or “Dynamic Rendering”. If a page uses Server-side Rendering, the page HTML is generated on each request. To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be\r\ncalled by the server on every request. For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can writegetServerSideProps\r\n which fetches this data and passes it to Page like below:\r\nexport default function Page({ data }) {\r\n  // Render data... }\r\n// This gets called on every request\r\nexport async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { data } }\r\n}\r\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every\r\nrequest instead of on build time. To learn more about how getServerSideProps works, check out our Data Fetching documentation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cd1c7e33-ece8-45f6-a794-5519979b438c":{"id_":"cd1c7e33-ece8-45f6-a794-5519979b438c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4pBJJhMZq7YglhjWBu3inaQurH+GTFARjKLqIuUlAOk=","metadata":{},"hash":"EkAG7RrVM/ejVreFBAaT312jaf8MteQPnaWybERY5zE="},"NEXT":{"nodeId":"39d64593-f0d2-4dde-a74b-53a8ff42ba80","metadata":{},"hash":"CDNOafwnyx1x5OuhsPXj/DV1z61o9Uylic27MHn58Js="}},"hash":"EYb8U/UKjqpdHKWrLU2bVWA8fZxlrZTEg3sxoWJOYec=","text":"4.1.2.2 - Static Site Generation (SSG)\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/02-static-site-generation\r\nDescription: Use Static Site Generation (SSG) to pre-render pages at build time. Examples\r\nIf a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated\r\nwhen you run next build. This HTML will then be reused on each request. It can be cached by a CDN. In Next.js, you can statically generate pages with or without data. Let’s take a look at each case. Static Generation without data\r\nBy default, Next.js pre-renders pages using Static Generation without fetching data. Here’s an example:\r\nfunction About() {\r\n  return <div>About</div>\r\n}\r\nexport default About\r\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file\r\nper page during build time. Static Generation with data\r\nSome pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you\r\ncan use these functions that Next.js provides:\r\n1. Your page content depends on external data: Use getStaticProps. 2. Your page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps). Scenario 1: Your page content depends on external data\r\nExample: Your blog page might need to fetch the list of blog posts from a CMS (content management system). // TODO: Need to fetch `posts` (by calling some API endpoint)\r\n//       before this page can be pre-rendered. export default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This\r\nfunction gets called at build time and lets you pass fetched data to the page’s props on pre-render. export default function Blog({ posts }) {\r\n  // Render posts...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"39d64593-f0d2-4dde-a74b-53a8ff42ba80":{"id_":"39d64593-f0d2-4dde-a74b-53a8ff42ba80","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4pBJJhMZq7YglhjWBu3inaQurH+GTFARjKLqIuUlAOk=","metadata":{},"hash":"EkAG7RrVM/ejVreFBAaT312jaf8MteQPnaWybERY5zE="},"PREVIOUS":{"nodeId":"cd1c7e33-ece8-45f6-a794-5519979b438c","metadata":{},"hash":"EYb8U/UKjqpdHKWrLU2bVWA8fZxlrZTEg3sxoWJOYec="}},"hash":"CDNOafwnyx1x5OuhsPXj/DV1z61o9Uylic27MHn58Js=","text":"export default function Blog({ posts }) {\r\n  // Render posts... }\r\n// This function gets called at build time\r\nexport async function getStaticProps() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}\r\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9882ea4e-571f-4760-89fc-8e8508186f3f":{"id_":"9882ea4e-571f-4760-89fc-8e8508186f3f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ebt4AV5mzo7Zna38Fa1xYajcWb3+a3LJty2dHlQKvPE=","metadata":{},"hash":"A5BnxpCEn6O+dAbWSAtAM7py3M33zfik+fNcSjEaJ88="},"NEXT":{"nodeId":"ffbb4893-1091-4ac6-ba4f-9e2725c466a9","metadata":{},"hash":"2BnsQZ50SOosAy/8TGL/oysuobMNkRERKz72nA3Df7o="}},"hash":"n3iCjOYveRXFidCIMBMgV9bPtPGIZvaO3ry4yffy/f8=","text":"Scenario 2: Your page paths depend on external data\r\nNext.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a\r\nsingle blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1. To learn more about dynamic routing, check the Dynamic Routing documentation. However, which id you want to pre-render at build time might depend on external data. Example: suppose that you’ve only added one blog post (with id: 1) to the database. In this case, you’d only want to pre-renderposts/1\r\n at build time. Later, you might add the second post with id: 2. Then you’d want to pre-render posts/2 as well. So your page paths that are pre-rendered depend on external data. To handle this, Next.js lets you export an async function called\r\ngetStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you\r\nspecify which paths you want to pre-render. // This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // Get the paths we want to pre-render based on posts\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n  // We'll pre-render only these paths at build time. // { fallback: false } means other routes should 404. return { paths, fallback: false }\r\n}\r\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and\r\nuse it to pre-render the page:\r\nexport default function Post({ post }) {\r\n  // Render post... }\r\nexport async function getStaticPaths() {\r\n  // ... }\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ffbb4893-1091-4ac6-ba4f-9e2725c466a9":{"id_":"ffbb4893-1091-4ac6-ba4f-9e2725c466a9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ebt4AV5mzo7Zna38Fa1xYajcWb3+a3LJty2dHlQKvPE=","metadata":{},"hash":"A5BnxpCEn6O+dAbWSAtAM7py3M33zfik+fNcSjEaJ88="},"PREVIOUS":{"nodeId":"9882ea4e-571f-4760-89fc-8e8508186f3f","metadata":{},"hash":"n3iCjOYveRXFidCIMBMgV9bPtPGIZvaO3ry4yffy/f8="}},"hash":"2BnsQZ50SOosAy/8TGL/oysuobMNkRERKz72nA3Df7o=","text":"// If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n  // Pass post data to the page via props\r\n  return { props: { post } }\r\n}\r\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation. When should I use Static Generation? We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by\r\nCDN, which makes it much faster than having a server render the page on every request. You can use Static Generation for many types of pages, including:\r\nMarketing pages\r\nBlog posts and portfolios\r\nE-commerce product listings\r\nHelp and documentation\r\nYou should ask yourself: “Can I pre-render this page ahead of a user’s request? ” If the answer is yes, then you should choose Static\r\nGeneration. On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user’s request. Maybe your page\r\nshows frequently updated data, and the page content changes on every request.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"854fec9f-ed77-4262-a2f7-6b1233dbdd10":{"id_":"854fec9f-ed77-4262-a2f7-6b1233dbdd10","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2jNRazFQuI5kvBAraeuBvMAd8VXUMnyceYxNHpNMD3k=","metadata":{},"hash":"HPwO6B3UzRKsaL8+EujJ4b9FHzxji2v7ZgkwrIOLt/0="}},"hash":"9O9cKfkRjcjQsFW5e+eWgH82PefQbiIf1rvmURpVIu0=","text":"In cases like this, you can do one of the following:\r\nUse Static Generation with Client-side data fetching: You can skip pre-rendering some parts of a page and then use client-side\r\nJavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation. Use Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a\r\nCDN, but the pre-rendered page will always be up-to-date. We’ll talk about this approach below.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d82121ab-d461-4730-93fd-c322b5cdc7b3":{"id_":"d82121ab-d461-4730-93fd-c322b5cdc7b3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"w5B9O8V0VIt/OS5dBIGVvJPnF/dixGLLDxl4miqbAvw=","metadata":{},"hash":"9zqnjygFM8qoIqEXcHVVwHmTgXs8o9pApL0/T519avw="},"NEXT":{"nodeId":"c5cd0d1f-f09c-4d56-9540-23d878fbbedf","metadata":{},"hash":"raW4Xg7BpuF2hATotfNfdznhnjdTn/iDoB5STYMwK70="}},"hash":"a3MPzX/HvYRHPI0fnCUtEEqTJF7sWSEvpEhztOm+IC4=","text":"4.1.2.3 - Automatic Static Optimization\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/04-automatic-static-optimization\r\nDescription: Next.js automatically optimizes your app to be static HTML whenever possible. Learn how it works here. Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination\r\nis made by the absence of getServerSideProps and getInitialProps in the page. This feature allows Next.js to emit hybrid applications that contain both server-rendered and statically generated pages. Statically generated pages are still reactive: Next.js will hydrate your application client-side to give it full interactivity. One of the main benefits of this feature is that optimized pages require no server-side computation, and can be instantly streamed to\r\nthe end-user from multiple CDN locations. The result is an ultra fast loading experience for your users. How it works\r\nIf getServerSideProps or getInitialProps is present in a page, Next.js will switch to render the page on-demand, per-request\r\n(meaning Server-Side Rendering). If the above is not the case, Next.js will statically optimize your page automatically by prerendering the page to static HTML. During prerendering, the router’s query object will be empty since we do not have query information to provide during this phase. After hydration, Next.js will trigger an update to your application to provide the route parameters in the query object. The cases where the query will be updated after hydration triggering another render are:\r\nThe page is a dynamic-route. The page has query values in the URL. Rewrites are configured in your next.config.js since these can have parameters that may need to be parsed and provided in the\r\nquery. To be able to distinguish if the query is fully updated and ready for use, you can leverage the isReady field on next/router. Good to know: Parameters added with dynamic routes to a page that’s using getStaticProps will always be available inside\r\nthe query object. next build will emit .html files for statically optimized pages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c5cd0d1f-f09c-4d56-9540-23d878fbbedf":{"id_":"c5cd0d1f-f09c-4d56-9540-23d878fbbedf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"w5B9O8V0VIt/OS5dBIGVvJPnF/dixGLLDxl4miqbAvw=","metadata":{},"hash":"9zqnjygFM8qoIqEXcHVVwHmTgXs8o9pApL0/T519avw="},"PREVIOUS":{"nodeId":"d82121ab-d461-4730-93fd-c322b5cdc7b3","metadata":{},"hash":"a3MPzX/HvYRHPI0fnCUtEEqTJF7sWSEvpEhztOm+IC4="}},"hash":"raW4Xg7BpuF2hATotfNfdznhnjdTn/iDoB5STYMwK70=","text":"next build will emit .html files for statically optimized pages. For example, the result for the page pages/about.js would be:\r\nTerminal (bash).next/server/pages/about.html\r\nAnd if you add getServerSideProps to the page, it will then be JavaScript, like so:\r\nTerminal (bash).next/server/pages/about.js\r\nCaveats\r\nIf you have a custom App with getInitialProps then this optimization will be turned off in pages without Static Generation. If you have a custom Document with getInitialProps be sure you check if ctx.req is defined before assuming the page is\r\nserver-side rendered. ctx.req will be undefined for pages that are prerendered. Avoid using the asPath value on next/router in the rendering tree until the router’s isReady field is true. Statically optimized\r\npages only know asPath on the client and not the server, so using it as a prop may lead to mismatch errors. The active-class-\r\nname example demonstrates one way to use asPath as a prop.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"01063003-1794-404c-ab57-9c6ee9cc552d":{"id_":"01063003-1794-404c-ab57-9c6ee9cc552d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a5d3hK5GYh3tMpC8xgbBCS9oYo1r1bItY7rS0jTSfxE=","metadata":{},"hash":"GBHkBcJhqUCDzwozBgx+wgZvLfONmdcWKFxmmK/GR+k="},"NEXT":{"nodeId":"8cb72ad1-4585-4614-9693-b0f4a6e4bbdb","metadata":{},"hash":"rXpRFYn6h6QsCVGHv25chGU/kJqej2r2LuezTyNVPgw="}},"hash":"fLQGTv9k06ehgjcxf25mrtjG9b4PWLCprhRKDpJnEOE=","text":"4.1.2.4 - Client-side Rendering (CSR)\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/05-client-side-rendering\r\nDescription: Learn how to implement client-side rendering in the Pages Router. Related:\r\nTitle: Related\r\nRelated Description: Learn about the alternative rendering methods in Next.js. Links:\r\npages/building-your-application/rendering/server-side-rendering\r\npages/building-your-application/rendering/static-site-generation\r\npages/building-your-application/data-fetching/incremental-static-regeneration\r\napp/building-your-application/routing/loading-ui-and-streaming\r\nIn Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The\r\nJavaScript is then used to update the DOM and render the page. When the application is first loaded, the user may notice a slight delay\r\nbefore they can see the full page, this is because the page isn’t fully rendered until all the JavaScript is downloaded, parsed, and\r\nexecuted. After the page has been loaded for the first time, navigating to other pages on the same website is typically faster, as only necessary\r\ndata needs to be fetched, and JavaScript can re-render parts of the page without requiring a full page refresh. In Next.js, there are two ways you can implement client-side rendering:\r\n1. Using React’s useEffect() hook inside your pages instead of the server-side rendering methods (getStaticProps and\r\ngetServerSideProps). 2. Using a data fetching library like SWR or TanStack Query to fetch data on the client (recommended). Here’s an example of using useEffect() inside a Next.js page:\r\npages/index.js (jsx)import React, { useState, useEffect } from 'react'\r\nexport function Page() {\r\n  const [data, setData] = useState(null)\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      const response = await fetch('https://api.example.com/data')\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`)\r\n      }\r\n      const result = await response.json()\r\n      setData(result)\r\n    }\r\n    fetchData().catch((e) => {\r\n      // handle the error as needed\r\n      console.error('An error occurred while fetching the data: ', e)\r\n    })\r\n  }, [])\r\n  return <p>{data ?","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8cb72ad1-4585-4614-9693-b0f4a6e4bbdb":{"id_":"8cb72ad1-4585-4614-9693-b0f4a6e4bbdb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"a5d3hK5GYh3tMpC8xgbBCS9oYo1r1bItY7rS0jTSfxE=","metadata":{},"hash":"GBHkBcJhqUCDzwozBgx+wgZvLfONmdcWKFxmmK/GR+k="},"PREVIOUS":{"nodeId":"01063003-1794-404c-ab57-9c6ee9cc552d","metadata":{},"hash":"fLQGTv9k06ehgjcxf25mrtjG9b4PWLCprhRKDpJnEOE="}},"hash":"rXpRFYn6h6QsCVGHv25chGU/kJqej2r2LuezTyNVPgw=","text":"`Your data: ${data}` : 'Loading...'}</p>\r\n}\r\nIn the example above, the component starts by rendering Loading.... Then, once the data is fetched, it re-renders and displays the\r\ndata. Although fetching data in a useEffect is a pattern you may see in older React Applications, we recommend using a data-fetching\r\nlibrary for better performance, caching, optimistic updates, and more. Here’s a minimum example using SWR to fetch data on the\r\nclient:\r\npages/index.js (jsx)import useSWR from 'swr'\r\nexport function Page() {\r\n  const { data, error, isLoading } = useSWR(\r\n    'https://api.example.com/data',\r\n    fetcher\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9fcfcd67-c2f5-4e8e-92b7-6b31da973d81":{"id_":"9fcfcd67-c2f5-4e8e-92b7-6b31da973d81","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R3geNmP22mW2vit/6MnqJ6wBiRTjSzP+Wco434hbDO8=","metadata":{},"hash":"MwxJJduPO5b+ahiOIAeH5Xit6m1fU3hCPZLd8+GA2+w="}},"hash":"jRwuaM8h+n7hFHeurLYgXGAMwa+E7WN7RHOnHWRqKyQ=","text":"if (error) return <p>Failed to load.</p>\r\n  if (isLoading) return <p>Loading...</p>\r\n  return <p>Your Data: {data}</p>\r\n}\r\nGood to know:\r\nKeep in mind that CSR can impact SEO. Some search engine crawlers might not execute JavaScript and therefore only see the\r\ninitial empty or loading state of your application. It can also lead to performance issues for users with slower internet\r\nconnections or devices, as they need to wait for all the JavaScript to load and run before they can see the full page. Next.js\r\npromotes a hybrid approach that allows you to use a combination of server-side rendering, static site generation, and client-\r\nside rendering, depending on the needs of each page in your application. In the App Router, you can also use Loading UI with\r\nSuspense to show a loading indicator while the page is being rendered.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bb1b6a8f-3603-4b82-bdd4-32960622408b":{"id_":"bb1b6a8f-3603-4b82-bdd4-32960622408b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"i6RpzY+DwD2PriE0I+nqcXYs4QgPh50+elQ/e6vfidw=","metadata":{},"hash":"JiLJdYFuxD1V3XCKpoo4QHzuWxPCweDPJQ8a0KTgo8w="}},"hash":"86pODhv2li0tb3mx3w1HMr9c+b9od2PDJggOQTurJE0=","text":"4.1.2.5 - Edge and Node.js Runtimes\r\nDocumentation path: /03-pages/01-building-your-application/02-rendering/06-edge-and-nodejs-runtimes\r\nDescription: Learn more about the switchable runtimes (Edge and Node.js) in Next.js. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d4b2a094-a911-45a3-a472-b7209d0516da":{"id_":"d4b2a094-a911-45a3-a472-b7209d0516da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZfpIVAAVwFLFo1Cu+r9o8cCgyD9IO6dg0m2QM+cakMQ=","metadata":{},"hash":"JWFdDyDyBuywKtGGm+29wTeB2AsxSJYksr/LlXUd2kY="}},"hash":"ohWBZpFcUAWvt0N9/g6ddPLquVuUf93d2R9rsK6n77g=","text":"4.1.3 - Data Fetching\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/index\r\nDescription: Next.js allows you to fetch data in multiple ways, with pre-rendering, server-side rendering or static-site generation, and\r\nincremental static regeneration. Learn how to manage your application data in Next.js. Data fetching in Next.js allows you to render your content in different ways, depending on your application’s use case. These include\r\npre-rendering with Server-side Rendering or Static Generation, and updating or creating content at runtime with Incremental\r\nStatic Regeneration. Examples\r\nWordPress Example(Demo)\r\nBlog Starter using markdown files (Demo)\r\nDatoCMS Example (Demo)\r\nTakeShape Example (Demo)\r\nSanity Example (Demo)\r\nPrismic Example (Demo)\r\nContentful Example (Demo)\r\nStrapi Example (Demo)\r\nPrepr Example (Demo)\r\nAgility CMS Example (Demo)\r\nCosmic Example (Demo)\r\nButterCMS Example (Demo)\r\nStoryblok Example (Demo)\r\nGraphCMS Example (Demo)\r\nKontent Example (Demo)\r\nStatic Tweet Demo\r\nEnterspeed Example (Demo)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1eeb7fae-b65f-4487-8601-7e6baaa071a7":{"id_":"1eeb7fae-b65f-4487-8601-7e6baaa071a7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"b+lvJ7Lztd1F8F21LZSwKp6KqQCBLcn0BjCxzAD+rR0=","metadata":{},"hash":"1CGwTLk1y2AEWyFg7weI5GmVaT6I6kmLwGlxC7sSIKg="},"NEXT":{"nodeId":"49102eb0-df2e-479c-9b50-7016bc702166","metadata":{},"hash":"lfFG1k74VkNb4XvH43R8ptW86fK+3mWSi1+dAv0Bgw4="}},"hash":"IagqNAEsUmPtEi7Nj6/kS8u+k7zVzktu6RNt26ntuTA=","text":"4.1.3.1 - getStaticProps\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/01-get-static-props\r\nDescription: Fetch data and generate static pages with `getStaticProps`. Learn more about this API for data fetching in Next.js. If you export a function called getStaticProps (Static Site Generation) from a page, Next.js will pre-render this page at build time\r\nusing the props returned by getStaticProps. pages/index.tsx (tsx)import type { InferGetStaticPropsType, GetStaticProps } from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}\r\npages/index.js (jsx)export async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}\r\nNote that irrespective of rendering type, any props will be passed to the page component and can be viewed on the client-side\r\nin the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don’t pass any sensitive information\r\nthat shouldn’t be available on the client in props. When should I use getStaticProps? You should use getStaticProps if:\r\nThe data required to render the page is available at build time ahead of a user’s request\r\nThe data comes from a headless CMS\r\nThe page must be pre-rendered (for SEO) and be very fast — getStaticProps generates HTML and JSON files, both of which can be\r\ncached by a CDN for performance\r\nThe data can be publicly cached (not user-specific). This condition can be bypassed in certain specific situation by using a\r\nMiddleware to rewrite the path. When does getStaticProps run\r\ngetStaticProps always runs on the server and never on the client.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"49102eb0-df2e-479c-9b50-7016bc702166":{"id_":"49102eb0-df2e-479c-9b50-7016bc702166","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"b+lvJ7Lztd1F8F21LZSwKp6KqQCBLcn0BjCxzAD+rR0=","metadata":{},"hash":"1CGwTLk1y2AEWyFg7weI5GmVaT6I6kmLwGlxC7sSIKg="},"PREVIOUS":{"nodeId":"1eeb7fae-b65f-4487-8601-7e6baaa071a7","metadata":{},"hash":"IagqNAEsUmPtEi7Nj6/kS8u+k7zVzktu6RNt26ntuTA="}},"hash":"lfFG1k74VkNb4XvH43R8ptW86fK+3mWSi1+dAv0Bgw4=","text":"You can validate code written inside getStaticProps is removed\r\nfrom the client-side bundle with this tool. getStaticProps always runs during next build\r\ngetStaticProps runs in the background when using fallback: true\r\ngetStaticProps is called before initial render when using fallback: blocking\r\ngetStaticProps runs in the background when using revalidate\r\ngetStaticProps runs on-demand in the background when using revalidate()","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3fa394e7-f1ff-4e3d-9871-3db6d6673aa9":{"id_":"3fa394e7-f1ff-4e3d-9871-3db6d6673aa9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZW7Cam0/NOSncYzzTI3ljb0Jn7MAIpfAmRhUqt/jXIs=","metadata":{},"hash":"mjZ+Qii9e4kiDU+AyWUuPGqzHsLuO4GxWBBWR7LED+E="},"NEXT":{"nodeId":"ec60fa7c-5b99-42f0-9413-d7ca28928357","metadata":{},"hash":"RITEXZN2pdmHaAl05SC+pp8FTso8WxnvnRtrc+EvvV8="}},"hash":"ODfS9R0PsURE7WPvXzZp1ceKy7M47sLhDUvYQVKGW/k=","text":"When combined with Incremental Static Regeneration, getStaticProps will run in the background while the stale page is being\r\nrevalidated, and the fresh page served to the browser. getStaticProps does not have access to the incoming request (such as query parameters or HTTP headers) as it generates static\r\nHTML. If you need access to the request for your page, consider using Middleware in addition to getStaticProps. Using getStaticProps to fetch data from a CMS\r\nThe following example shows how you can fetch a list of blog posts from a CMS. pages/blog.tsx (tsx)// posts will be populated at build time by getStaticProps()\r\nexport default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n// This function gets called at build time on server-side. // It won't be called on client-side, so you can even do\r\n// direct database queries. export async function getStaticProps() {\r\n  // Call an external API endpoint to get posts. // You can use any data fetching library\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}\r\npages/blog.js (jsx)// posts will be populated at build time by getStaticProps()\r\nexport default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n// This function gets called at build time on server-side. // It won't be called on client-side, so you can even do\r\n// direct database queries. export async function getStaticProps() {\r\n  // Call an external API endpoint to get posts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ec60fa7c-5b99-42f0-9413-d7ca28928357":{"id_":"ec60fa7c-5b99-42f0-9413-d7ca28928357","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZW7Cam0/NOSncYzzTI3ljb0Jn7MAIpfAmRhUqt/jXIs=","metadata":{},"hash":"mjZ+Qii9e4kiDU+AyWUuPGqzHsLuO4GxWBBWR7LED+E="},"PREVIOUS":{"nodeId":"3fa394e7-f1ff-4e3d-9871-3db6d6673aa9","metadata":{},"hash":"ODfS9R0PsURE7WPvXzZp1ceKy7M47sLhDUvYQVKGW/k="}},"hash":"RITEXZN2pdmHaAl05SC+pp8FTso8WxnvnRtrc+EvvV8=","text":"export async function getStaticProps() {\r\n  // Call an external API endpoint to get posts. // You can use any data fetching library\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}\r\nThe getStaticProps API reference covers all parameters and props that can be used with getStaticProps. Write server-side code directly","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"677d47f9-5ca2-4b19-9121-84462b733eed":{"id_":"677d47f9-5ca2-4b19-9121-84462b733eed","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YXZfJMunhts0J3/8C8jGNNMnCOG8Rn/CV6A9o85tHP8=","metadata":{},"hash":"Gch7q4KxTepDmSlUhgloJvgJsn6uRwH1+GMsazdOhCU="},"NEXT":{"nodeId":"4b5dd1d9-7942-4233-8346-afd2b753da33","metadata":{},"hash":"gcdU2FC8jpneBDs/ant2eJ3qfsCwdRBjkp20TypecD4="}},"hash":"bdel7FvKUkWQrPKZnC9g1guNjcYeciREyGD4hiJZPw4=","text":"As getStaticProps runs only on the server-side, it will never run on the client-side. It won’t even be included in the JS bundle for the\r\nbrowser, so you can write direct database queries without them being sent to browsers. This means that instead of fetching an API route from getStaticProps (that itself fetches data from an external source), you can\r\nwrite the server-side code directly in getStaticProps. Take the following example. An API route is used to fetch some data from a CMS. That API route is then called directly fromgetStaticProps\r\n. This produces an additional call, reducing performance. Instead, the logic for fetching the data from the CMS can be\r\nshared by using a lib/ directory. Then it can be shared with getStaticProps. lib/load-posts.js (js)// The following function is shared\r\n// with getStaticProps and API routes\r\n// from a `lib/` directory\r\nexport async function loadPosts() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts/')\r\n  const data = await res.json()\r\n  return data\r\n}\r\npages/blog.js (jsx)// pages/blog.js\r\nimport { loadPosts } from '../lib/load-posts'\r\n// This function runs only on the server side\r\nexport async function getStaticProps() {\r\n  // Instead of fetching your `/api` route you can call the same\r\n  // function directly in `getStaticProps`\r\n  const posts = await loadPosts()\r\n  // Props returned will be passed to the page component\r\n  return { props: { posts } }\r\n}\r\nAlternatively, if you are not using API routes to fetch data, then the fetch() API can be used directly in getStaticProps to fetch\r\ndata. To verify what Next.js eliminates from the client-side bundle, you can use the next-code-elimination tool. Statically generates both HTML and JSON\r\nWhen a page with getStaticProps is pre-rendered at build time, in addition to the page HTML file, Next.js generates a JSON file\r\nholding the result of running getStaticProps. This JSON file will be used in client-side routing through next/link or next/router. When you navigate to a page that’s pre-rendered\r\nusing getStaticProps, Next.js fetches this JSON file (pre-computed at build time) and uses it as the props for the page component.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4b5dd1d9-7942-4233-8346-afd2b753da33":{"id_":"4b5dd1d9-7942-4233-8346-afd2b753da33","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"YXZfJMunhts0J3/8C8jGNNMnCOG8Rn/CV6A9o85tHP8=","metadata":{},"hash":"Gch7q4KxTepDmSlUhgloJvgJsn6uRwH1+GMsazdOhCU="},"PREVIOUS":{"nodeId":"677d47f9-5ca2-4b19-9121-84462b733eed","metadata":{},"hash":"bdel7FvKUkWQrPKZnC9g1guNjcYeciREyGD4hiJZPw4="}},"hash":"gcdU2FC8jpneBDs/ant2eJ3qfsCwdRBjkp20TypecD4=","text":"This means that client-side page transitions will not call getStaticProps as only the exported JSON is used. When using Incremental Static Generation, getStaticProps will be executed in the background to generate the JSON needed for\r\nclient-side navigation. You may see this in the form of multiple requests being made for the same page, however, this is intended and\r\nhas no impact on end-user performance. Where can I use getStaticProps\r\ngetStaticProps can only be exported from a page. You cannot export it from non-page files, _app, _document, or _error. One of the reasons for this restriction is that React needs to have all the required data before the page is rendered. Also, you must use export getStaticProps as a standalone function — it will not work if you add getStaticProps as a property of\r\nthe page component. Good to know: if you have created a custom app, ensure you are passing the pageProps to the page component as shown in\r\nthe linked document, otherwise the props will be empty. Runs on every request in development\r\nIn development (next dev), getStaticProps will be called on every request. Preview Mode","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4740c2f1-8f06-460e-b9d7-fe3f8c4cfb67":{"id_":"4740c2f1-8f06-460e-b9d7-fe3f8c4cfb67","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4L47StnPIHdwa8KW6fzOX7QoCuRexL2N25w9lxxYhLY=","metadata":{},"hash":"qHHMibQE/5ZZ+ug/RyvC8lues1aAtrAnxneORvdc+K8="}},"hash":"hGesmsr4JMiQRg0420BjV+GfvO51waV6N020dkFW/nY=","text":"You can temporarily bypass static generation and render the page at request time instead of build time using Preview Mode. For\r\nexample, you might be using a headless CMS and want to preview drafts before they’re published.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1bbc758d-fb23-4d79-a06c-6d3a907ecd20":{"id_":"1bbc758d-fb23-4d79-a06c-6d3a907ecd20","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"GS86o/fdfENJApG68jrBDN5sczf53zgAGGLlTiibUgs=","metadata":{},"hash":"RMLLeKZROFOn6KRbEN0NdJyuKYu/tCAJ3UTQ4ckqquk="}},"hash":"604k6QGImEQQ5QdFemBgzLAf8sETW31NuT25nXodeCY=","text":"4.1.3.2 - getStaticPaths\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/02-get-static-paths\r\nDescription: Fetch data and generate static pages with `getStaticPaths`. Learn more about this API for data fetching in Next.js. If a page has Dynamic Routes and uses getStaticProps, it needs to define a list of paths to be statically generated. When you export a function called getStaticPaths (Static Site Generation) from a page that uses dynamic routes, Next.js will\r\nstatically pre-render all the paths specified by getStaticPaths. pages/repo/[name].tsx (tsx)import type {\r\n  InferGetStaticPropsType,\r\n  GetStaticProps,\r\n  GetStaticPaths,\r\n} from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getStaticPaths = (async () => {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}) satisfies GetStaticPaths\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}\r\npages/repo/[name].js (jsx)export async function getStaticPaths() {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"07ca3a57-2812-4b32-a6f2-3c8139c9aaec":{"id_":"07ca3a57-2812-4b32-a6f2-3c8139c9aaec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vTO9cJPPC72k5bCoTcd7Pv89XTq8foGJYub8xY7EvLs=","metadata":{},"hash":"ZgeuXlFT4vZy6SoQ8jn24caMOfbN9RaIWXKDFh3F9qA="},"NEXT":{"nodeId":"25107351-a610-4d99-8353-00fe2fb19502","metadata":{},"hash":"Ury3lseTAdMaELX8Z6KxYI4eEpW2T37yww+jTZZoRDg="}},"hash":"SqmJtsqI7K7oqm1LWRj9hcLsHexzYlHKz8Bm8QjsCV4=","text":"The getStaticPaths API reference covers all parameters and props that can be used with getStaticPaths. When should I use getStaticPaths? You should use getStaticPaths if you’re statically pre-rendering pages that use dynamic routes and:\r\nThe data comes from a headless CMS\r\nThe data comes from a database\r\nThe data comes from the filesystem\r\nThe data can be publicly cached (not user-specific)\r\nThe page must be pre-rendered (for SEO) and be very fast — getStaticProps generates HTML and JSON files, both of which can be\r\ncached by a CDN for performance\r\nWhen does getStaticPaths run\r\ngetStaticPaths will only run during build in production, it will not be called during runtime. You can validate code written inside\r\ngetStaticPaths is removed from the client-side bundle with this tool. How does getStaticProps run with regards to getStaticPaths\r\ngetStaticProps runs during next build for any paths returned during build\r\ngetStaticProps runs in the background when using fallback: true\r\ngetStaticProps is called before initial render when using fallback: blocking\r\nWhere can I use getStaticPaths\r\ngetStaticPaths must be used with getStaticProps\r\nYou cannot use getStaticPaths with getServerSideProps\r\nYou can export getStaticPaths from a Dynamic Route that also uses getStaticProps\r\nYou cannot export getStaticPaths from non-page file (e.g. your components folder)\r\nYou must export getStaticPaths as a standalone function, and not a property of the page component\r\nRuns on every request in development\r\nIn development (next dev), getStaticPaths will be called on every request. Generating paths on-demand\r\ngetStaticPaths allows you to control which pages are generated during the build instead of on-demand with fallback. Generating\r\nmore pages during a build will cause slower builds. You can defer generating all pages on-demand by returning an empty array for paths. This can be especially helpful when deploying\r\nyour Next.js application to multiple environments. For example, you can have faster builds by generating all pages on-demand for\r\npreviews (but not production builds). This is helpful for sites with hundreds/thousands of static pages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"25107351-a610-4d99-8353-00fe2fb19502":{"id_":"25107351-a610-4d99-8353-00fe2fb19502","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vTO9cJPPC72k5bCoTcd7Pv89XTq8foGJYub8xY7EvLs=","metadata":{},"hash":"ZgeuXlFT4vZy6SoQ8jn24caMOfbN9RaIWXKDFh3F9qA="},"PREVIOUS":{"nodeId":"07ca3a57-2812-4b32-a6f2-3c8139c9aaec","metadata":{},"hash":"SqmJtsqI7K7oqm1LWRj9hcLsHexzYlHKz8Bm8QjsCV4="}},"hash":"Ury3lseTAdMaELX8Z6KxYI4eEpW2T37yww+jTZZoRDg=","text":"This is helpful for sites with hundreds/thousands of static pages. pages/posts/[id].js (jsx)export async function getStaticPaths() {\r\n  // When this is true (in preview environments) don't\r\n  // prerender any static pages\r\n  // (faster builds, but slower initial page load)\r\n  if (process.env.SKIP_BUILD_STATIC_GENERATION) {\r\n    return {\r\n      paths: [],\r\n      fallback: 'blocking',\r\n    }\r\n  }\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // Get the paths we want to prerender based on posts\r\n  // In production environments, prerender all pages\r\n  // (slower builds, but faster initial page load)\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d6a727e2-8fa4-4b98-a71c-a92ea0fe55b0":{"id_":"d6a727e2-8fa4-4b98-a71c-a92ea0fe55b0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3gFxTRo9A2QgrvWKcwH3eZ/PIjTm5kwKH10LyrQYN08=","metadata":{},"hash":"xR3Q5S+Fz6od/YUN3F6Pkt1SPOph0ODjtGRI0KUHx1Y="}},"hash":"TbHlMMcb5fCmwvBblorHb3sdp7+RB3wULND7sMF1zqU=","text":"}))\r\n  // { fallback: false } means other routes should 404\r\n  return { paths, fallback: false }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a823dfbe-f053-44f6-a384-a70347e36f64":{"id_":"a823dfbe-f053-44f6-a384-a70347e36f64","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1S5zIfbR8TgJ9zKokIpQqDqNZt+bbLOmHK9y4fZU7pU=","metadata":{},"hash":"nVguMFuoPdhhQMqvFjQQMgQ2mxDR7uVs/u/9rAdlUHg="}},"hash":"cHopeRtAVzLLIkMY771YqkIqtJpNfbZJgK0xLRUSEt4=","text":"4.1.3.3 - Forms and Mutations\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/03-forms-and-mutations\r\nDescription: Learn how to handle form submissions and data mutations with Next.js. Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle form submissions and data\r\nmutations using API Routes. Good to know:\r\nWe will soon recommend incrementally adopting the App Router and using Server Actions for handling form submissions\r\nand data mutations. Server Actions allow you to define asynchronous server functions that can be called directly from your\r\ncomponents, without needing to manually create an API Route. API Routes do not specify CORS headers, meaning they are same-origin only by default. Since API Routes run on the server, we’re able to use sensitive values (like API keys) through Environment Variables without\r\nexposing them to the client. This is critical for the security of your application. Examples\r\nServer-only form\r\nWith the Pages Router, you need to manually create API endpoints to handle securely mutating data on the server. pages/api/submit.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const data = req.body\r\n  const id = await createItem(data)\r\n  res.status(200).json({ id })\r\n}\r\npages/api/submit.js (js)export default function handler(req, res) {\r\n  const data = req.body\r\n  const id = await createItem(data)\r\n  res.status(200).json({ id })\r\n}\r\nThen, call the API Route from the client with an event handler:\r\npages/index.tsx (tsx)import { FormEvent } from 'react'\r\nexport default function Page() {\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n    const formData = new FormData(event.currentTarget)\r\n    const response = await fetch('/api/submit', {\r\n      method: 'POST',\r\n      body: formData,\r\n    })\r\n    // Handle response if necessary\r\n    const data = await response.json()\r\n    // ... }\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  )\r\n}\r\npages/index.jsx (jsx)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"baf7c04c-5c35-4b75-89a6-16ce1c0515c8":{"id_":"baf7c04c-5c35-4b75-89a6-16ce1c0515c8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ql0OYZPfWhD04sgo7ziCRFDDD4y+HZHy44TZkIqedSQ=","metadata":{},"hash":"C3Aow+IQ/caaKkhjm7uxR7Vifn1aUwfT981CV0z2s4Y="}},"hash":"zovapqCO/r0v6RT0xcauCUw+2lzRFHISGFhqrkAu+hw=","text":"export default function Page() {\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n    const formData = new FormData(event.target)\r\n    const response = await fetch('/api/submit', {\r\n      method: 'POST',\r\n      body: formData,\r\n    })\r\n    // Handle response if necessary\r\n    const data = await response.json()\r\n    // ... }\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  )\r\n}\r\nForm validation\r\nWe recommend using HTML validation like required and type=\"email\" for basic client-side form validation. For more advanced server-side validation, you can use a schema validation library like zod to validate the form fields before mutating\r\nthe data:\r\npages/api/submit.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nimport { z } from 'zod'\r\nconst schema = z.object({\r\n  // ... })\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const parsed = schema.parse(req.body)\r\n  // ... }\r\npages/api/submit.js (js)import { z } from 'zod'\r\nconst schema = z.object({\r\n  // ... })\r\nexport default async function handler(req, res) {\r\n  const parsed = schema.parse(req.body)\r\n  // ... }\r\nError handling\r\nYou can use React state to show an error message when a form submission fails:\r\npages/index.tsx (tsx)import React, { useState, FormEvent } from 'react'\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false)\r\n  const [error, setError] = useState<string | null>(null)\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n    setIsLoading(true)\r\n    setError(null) // Clear previous errors when a new request starts","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"67dcb1ed-e051-4e69-8d6b-fb393dbc53c1":{"id_":"67dcb1ed-e051-4e69-8d6b-fb393dbc53c1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"krCZpVhyNUnOOiBlAhc0FRZt6p55KLgit7MTrqgiGqs=","metadata":{},"hash":"kb/xQvJXq+fJDf/bomHwbLPj1AceEcYaBjo0tsWatnw="}},"hash":"i7m6eY2svFN1g478lOvdN+a+q5gRXH2GGt1WPLULO0k=","text":"try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n      if (!response.ok) {\r\n        throw new Error('Failed to submit the data. Please try again. ')\r\n      }\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ... } catch (error) {\r\n      // Capture the error message to display to the user\r\n      setError(error.message)\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false)\r\n    }\r\n  }\r\n  return (\r\n    <div>\r\n      {error && <div style={{ color: 'red' }}>{error}</div>}\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"text\" name=\"name\" />\r\n        <button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? 'Loading... ' : 'Submit'}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  )\r\n}\r\npages/index.jsx (jsx)import React, { useState } from 'react'\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState(false)\r\n  const [error, setError] = useState(null)\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n    setIsLoading(true)\r\n    setError(null) // Clear previous errors when a new request starts\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n      if (!response.ok) {\r\n        throw new Error('Failed to submit the data. Please try again. ')\r\n      }\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ... } catch (error) {\r\n      // Capture the error message to display to the user\r\n      setError(error.message)\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false)\r\n    }\r\n  }\r\n  return (\r\n    <div>\r\n      {error && <div style={{ color: 'red' }}>{error}</div>}\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"text\" name=\"name\" />","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"204046eb-90af-4412-8124-66d6f88d497d":{"id_":"204046eb-90af-4412-8124-66d6f88d497d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/CNUWT651hwn2aDTnFJjenBXkL+AuOg6RXF+IoWZUjc=","metadata":{},"hash":"2roQIHqnhl8SS8sgnaAGig7IlIZwFGiVa8ClL0aqjyM="}},"hash":"9BApqciv/lTuHXREti/4dkLzzSNb6s+a700PqQgFxDM=","text":"<button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? 'Loading... ' : 'Submit'}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  )\r\n}\r\nDisplaying loading state\r\nYou can use React state to show a loading state when a form is submitting on the server:\r\npages/index.tsx (tsx)import React, { useState, FormEvent } from 'react'\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false)\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n    setIsLoading(true) // Set loading to true when the request starts\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ... } catch (error) {\r\n      // Handle error if necessary\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false) // Set loading to false when the request completes\r\n    }\r\n  }\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\" disabled={isLoading}>\r\n        {isLoading ? 'Loading... ' : 'Submit'}\r\n      </button>\r\n    </form>\r\n  )\r\n}\r\npages/index.jsx (jsx)import React, { useState } from 'react'\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState(false)\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n    setIsLoading(true) // Set loading to true when the request starts\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ... } catch (error) {\r\n      // Handle error if necessary\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false) // Set loading to false when the request completes","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"250a0fe8-ad1d-462a-9e2e-061735852e5a":{"id_":"250a0fe8-ad1d-462a-9e2e-061735852e5a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lZbL30ftgaYf8wjmYrxk0YS5VPJhmaDsyRSszSBh0Sw=","metadata":{},"hash":"OfnEbf5QCgLFb0g836cHSKBw0PHejA4Ld1JlFEw+9jM="}},"hash":"TeARtISjY31lR5rk5C72QPvobaBn4ThLUUiFE+YHHy0=","text":"}\r\n  }\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\" disabled={isLoading}>\r\n        {isLoading ? 'Loading... ' : 'Submit'}\r\n      </button>\r\n    </form>\r\n  )\r\n}\r\nRedirecting\r\nIf you would like to redirect the user to a different route after a mutation, you can redirect to any absolute or relative URL:\r\npages/api/submit.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}\r\npages/api/submit.js (js)export default async function handler(req, res) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}\r\nSetting cookies\r\nYou can set cookies inside an API Route using the setHeader method on the response:\r\npages/api/cookie.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')\r\n  res.status(200).send('Cookie has been set. ')\r\n}\r\npages/api/cookie.js (js)export default async function handler(req, res) {\r\n  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')\r\n  res.status(200).send('Cookie has been set. ')\r\n}\r\nReading cookies\r\nYou can read cookies inside an API Route using the cookies request helper:\r\npages/api/cookie.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const auth = req.cookies.authorization\r\n  // ... }\r\npages/api/cookie.js (js)export default async function handler(req, res) {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9f641cc2-851a-4f4d-84e3-88ce45321bd8":{"id_":"9f641cc2-851a-4f4d-84e3-88ce45321bd8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ievGkGFHYzk9us/DoWtJxaq58+iuFhR7m1nPT5ejcP8=","metadata":{},"hash":"vJNUMfyxOGnEyU7LjZYkTz2mNvsqmUvqkXmqscbXZlQ="}},"hash":"Vv5nOtUEVs3GQJ+G5Le0KA5AP312XnutNDRRx7dDQGY=","text":"const auth = req.cookies.authorization\r\n  // ... }\r\nDeleting cookies\r\nYou can delete cookies inside an API Route using the setHeader method on the response:\r\npages/api/cookie.ts (ts)import type { NextApiRequest, NextApiResponse } from 'next'\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')\r\n  res.status(200).send('Cookie has been deleted. ')\r\n}\r\npages/api/cookie.js (js)export default async function handler(req, res) {\r\n  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')\r\n  res.status(200).send('Cookie has been deleted. ')\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f2ef84ce-6eb3-4935-9fa4-99fa5505ba60":{"id_":"f2ef84ce-6eb3-4935-9fa4-99fa5505ba60","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R3oICfq6Af1fY8ayuLLPUd/w/+aOuixb/8ITJjWEcGw=","metadata":{},"hash":"0m4i33WiPs8nx9rRJEbHzeb4Nn+mBiiWLJL/7VdWCGY="},"NEXT":{"nodeId":"57e79ae7-2bc2-4fac-8f31-52e8c8ac41f2","metadata":{},"hash":"SbcjVdrA4vFvNC582zKfl4ky7KIY1Pk65s1pdl81bpM="}},"hash":"unzQCN11t/4UN3Gs2HrXaPrJmPZ28jYWqvJPZmyQX9g=","text":"4.1.3.4 - getServerSideProps\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/03-get-server-side-props\r\nDescription: Fetch data on each request with `getServerSideProps`. getServerSideProps is a Next.js function that can be used to fetch data and render the contents of a page at request time. Example\r\nYou can use getServerSideProps by exporting it from a Page Component. The example below shows how you can fetch data from a\r\n3rd party API in getServerSideProps, and pass the data to the page as props:\r\npages/index.tsx (tsx)import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getServerSideProps = (async () => {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo: Repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}) satisfies GetServerSideProps<{ repo: Repo }>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}\r\npages/index.js (jsx)export async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}\r\nWhen should I use getServerSidePropsgetServerSideProps? You should use getServerSideProps if you need to render a page that relies on personalized user data, or information that can only\r\nbe known at request time. For example, authorization headers or a geolocation. If you do not need to fetch the data at request time, or would prefer to cache the data and pre-rendered HTML, we recommend usinggetStaticProps\r\n.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"57e79ae7-2bc2-4fac-8f31-52e8c8ac41f2":{"id_":"57e79ae7-2bc2-4fac-8f31-52e8c8ac41f2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R3oICfq6Af1fY8ayuLLPUd/w/+aOuixb/8ITJjWEcGw=","metadata":{},"hash":"0m4i33WiPs8nx9rRJEbHzeb4Nn+mBiiWLJL/7VdWCGY="},"PREVIOUS":{"nodeId":"f2ef84ce-6eb3-4935-9fa4-99fa5505ba60","metadata":{},"hash":"unzQCN11t/4UN3Gs2HrXaPrJmPZ28jYWqvJPZmyQX9g="}},"hash":"SbcjVdrA4vFvNC582zKfl4ky7KIY1Pk65s1pdl81bpM=","text":"Behavior\r\ngetServerSideProps runs on the server. getServerSideProps can only be exported from a page. getServerSideProps returns JSON.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bcfc1e21-6727-443a-827c-e39add1e0f53":{"id_":"bcfc1e21-6727-443a-827c-e39add1e0f53","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cgqLyGbsNlClR8UFPOlaQZ/1pV0LVzrkBLTN2TK3yks=","metadata":{},"hash":"o+OIAqmW0SYec5DjpMcNbqtE3G3QHMs3dpWWcVyAen8="},"NEXT":{"nodeId":"25ad729b-6c20-4d85-ae1e-2a95391764b8","metadata":{},"hash":"O5piWp98ETlvZ9gUavnqzJwvsWyibQfXhAPyi3kFJFo="}},"hash":"ZGA7m9GuOHPdCI24mHLZneuTIuhCUgnQkaz0TRkyiW4=","text":"When a user visits a page, getServerSideProps will be used to fetch data at request time, and the data is used to render the\r\ninitial HTML of the page.props\r\n passed to the page component can be viewed on the client as part of the initial HTML. This is to allow the page to be\r\nhydrated correctly. Make sure that you don’t pass any sensitive information that shouldn’t be available on the client in props. When a user visits the page through next/link or next/router, Next.js sends an API request to the server, which runs\r\ngetServerSideProps. You do not have to call a Next.js API Route to fetch data when using getServerSideProps since the function runs on the server. Instead, you can call a CMS, database, or other third-party APIs directly from inside getServerSideProps. Good to know:\r\nSee getServerSideProps API reference for parameters and props that can be used with getServerSideProps. You can use the next-code-elimination tool to verify what Next.js eliminates from the client-side bundle. Error Handling\r\nIf an error is thrown inside getServerSideProps, it will show the pages/500.js file. Check out the documentation for 500 page to\r\nlearn more on how to create it. During development, this file will not be used and the development error overlay will be shown instead. Edge Cases\r\nEdge Runtime\r\ngetServerSideProps can be used with both Serverless and Edge Runtimes, and you can set props in both. However, currently in the Edge Runtime, you do not have access to the response object. This means that you cannot — for example —\r\nadd cookies in getServerSideProps. To have access to the response object, you should continue to use the Node.js runtime,\r\nwhich is the default runtime. You can explicitly set the runtime on a per-page basis by modifying the config, for example:\r\npages/index.js (jsx)export const config = {\r\n  runtime: 'nodejs', // or \"edge\"\r\n}\r\nexport const getServerSideProps = async () => {}\r\nCaching with Server-Side Rendering (SSR)\r\nYou can use caching headers (Cache-Control) inside getServerSideProps to cache dynamic responses. For example, using stale-\r\nwhile-revalidate. // This value is considered fresh for ten seconds (s-maxage=10).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"25ad729b-6c20-4d85-ae1e-2a95391764b8":{"id_":"25ad729b-6c20-4d85-ae1e-2a95391764b8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cgqLyGbsNlClR8UFPOlaQZ/1pV0LVzrkBLTN2TK3yks=","metadata":{},"hash":"o+OIAqmW0SYec5DjpMcNbqtE3G3QHMs3dpWWcVyAen8="},"PREVIOUS":{"nodeId":"bcfc1e21-6727-443a-827c-e39add1e0f53","metadata":{},"hash":"ZGA7m9GuOHPdCI24mHLZneuTIuhCUgnQkaz0TRkyiW4="}},"hash":"O5piWp98ETlvZ9gUavnqzJwvsWyibQfXhAPyi3kFJFo=","text":"// This value is considered fresh for ten seconds (s-maxage=10). // If a request is repeated within the next 10 seconds, the previously\r\n// cached value will still be fresh. If the request is repeated before 59 seconds,\r\n// the cached value will be stale but still render (stale-while-revalidate=59). //\r\n// In the background, a revalidation request will be made to populate the cache\r\n// with a fresh value. If you refresh the page, you will see the new value. export async function getServerSideProps({ req, res }) {\r\n  res.setHeader(\r\n    'Cache-Control',\r\n    'public, s-maxage=10, stale-while-revalidate=59'\r\n  )\r\n  return {\r\n    props: {},\r\n  }\r\n}\r\nHowever, before reaching for cache-control, we recommend seeing if getStaticProps with ISR is a better fit for your use case.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1e45d093-dcad-43e3-9bf5-e72e0df5adb3":{"id_":"1e45d093-dcad-43e3-9bf5-e72e0df5adb3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4XQuJCsLEiCcjci01Q13mmGmui4KbVP+uZGl9joFXxk=","metadata":{},"hash":"LH3J9psVySWpZ2A6BXW8EN3DbEv9V9S9UII5xiikklo="},"NEXT":{"nodeId":"3dc94f86-0440-442b-be86-08fbdd76ff84","metadata":{},"hash":"9Z0kc631xG+o5rosOqllVi7Vjnvu+psiExOsnRewjLk="}},"hash":"Qg6+4uHv9xhYKbOIyZ+lwkNqb+lyMbq2stsCGBfRytA=","text":"4.1.3.5 - Incremental Static Regeneration\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/04-incremental-static-regeneration\r\nDescription: Learn how to create or update static pages at runtime with Incremental Static Regeneration. Examples\r\nNext.js allows you to create or update static pages after you’ve built your site. Incremental Static Regeneration (ISR) enables you to use\r\nstatic-generation on a per-page basis, without needing to rebuild the entire site. With ISR, you can retain the benefits of static while\r\nscaling to millions of pages. Good to know: The edge runtime is currently not compatible with ISR, although you can leverage stale-while-revalidate\r\nby setting the cache-control header manually. To use ISR, add the revalidate prop to getStaticProps:\r\nfunction Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n// This function gets called at build time on server-side. // It may be called again, on a serverless function, if\r\n// revalidation is enabled and a new request comes in\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n    // Next.js will attempt to re-generate the page:\r\n    // - When a request comes in\r\n    // - At most once every 10 seconds\r\n    revalidate: 10, // In seconds\r\n  }\r\n}\r\n// This function gets called at build time on server-side. // It may be called again, on a serverless function, if\r\n// the path has not been generated. export async function getStaticPaths() {\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // Get the paths we want to pre-render based on posts\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n  // We'll pre-render only these paths at build time. // { fallback: 'blocking' } will server-render pages\r\n  // on-demand if the path doesn't exist.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3dc94f86-0440-442b-be86-08fbdd76ff84":{"id_":"3dc94f86-0440-442b-be86-08fbdd76ff84","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4XQuJCsLEiCcjci01Q13mmGmui4KbVP+uZGl9joFXxk=","metadata":{},"hash":"LH3J9psVySWpZ2A6BXW8EN3DbEv9V9S9UII5xiikklo="},"PREVIOUS":{"nodeId":"1e45d093-dcad-43e3-9bf5-e72e0df5adb3","metadata":{},"hash":"Qg6+4uHv9xhYKbOIyZ+lwkNqb+lyMbq2stsCGBfRytA="}},"hash":"9Z0kc631xG+o5rosOqllVi7Vjnvu+psiExOsnRewjLk=","text":"return { paths, fallback: 'blocking' }\r\n}\r\nexport default Blog\r\nWhen a request is made to a page that was pre-rendered at build time, it will initially show the cached page. Any requests to the page after the initial request and before 10 seconds are also cached and instantaneous. After the 10-second window, the next request will still show the cached (stale) page\r\nNext.js triggers a regeneration of the page in the background. Once the page generates successfully, Next.js will invalidate the cache and show the updated page. If the background regeneration\r\nfails, the old page would still be unaltered. When a request is made to a path that hasn’t been generated, Next.js will server-render the page on the first request. Future requests","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6402d95d-3b08-4b52-8d00-993834b39785":{"id_":"6402d95d-3b08-4b52-8d00-993834b39785","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cajsjSIol/juHAdPhgomjn2ao4A7MNbCeyVzi4Mm8jQ=","metadata":{},"hash":"Dcj+O7fHvAJ+21n/UR/KRpNfKzDrJGJ1nqEMEBsSVNY="},"NEXT":{"nodeId":"9c1b5667-e7fd-4498-a146-aa27ed9b9e07","metadata":{},"hash":"ftLwEe1oWFc0m8XH74t48SuuXmnb1J8KFbxoHgoTBwc="}},"hash":"so2AdaJG4yWT3pQ2Ug2lLXkLXMeV2dAmvj4j2CxQkk8=","text":"will serve the static file from the cache. ISR on Vercel persists the cache globally and handles rollbacks. Good to know: Check if your upstream data provider has caching enabled by default. You might need to disable (e.g. useCdn:false\r\n), otherwise a revalidation won’t be able to pull fresh data to update the ISR cache. Caching can occur at a CDN (for an\r\nendpoint being requested) when it returns the Cache-Control header. On-Demand Revalidation\r\nIf you set a revalidate time of 60, all visitors will see the same generated version of your site for one minute. The only way to\r\ninvalidate the cache is from someone visiting that page after the minute has passed. Starting with v12.2.0, Next.js supports On-Demand Incremental Static Regeneration to manually purge the Next.js cache for a specific\r\npage. This makes it easier to update your site when:\r\nContent from your headless CMS is created or updated\r\nEcommerce metadata changes (price, description, category, reviews, etc. )\r\nInside getStaticProps, you do not need to specify revalidate to use on-demand revalidation. If revalidate is omitted, Next.js will\r\nuse the default value of false (no revalidation) and only revalidate the page on-demand when revalidate() is called. Good to know: Middleware won’t be executed for On-Demand ISR requests. Instead, call revalidate() on the exact path that\r\nyou want revalidated. For example, if you have pages/blog/[slug].js and a rewrite from /post-1 -> /blog/post-1, you\r\nwould need to call res.revalidate('/blog/post-1'). Using On-Demand Revalidation\r\nFirst, create a secret token only known by your Next.js app. This secret will be used to prevent unauthorized access to the revalidation\r\nAPI Route. You can access the route (either manually or with a webhook) with the following URL structure:\r\nTerminal (bash)https://<your-site.com>/api/revalidate?secret=<token>\r\nNext, add the secret as an Environment Variable to your application.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9c1b5667-e7fd-4498-a146-aa27ed9b9e07":{"id_":"9c1b5667-e7fd-4498-a146-aa27ed9b9e07","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cajsjSIol/juHAdPhgomjn2ao4A7MNbCeyVzi4Mm8jQ=","metadata":{},"hash":"Dcj+O7fHvAJ+21n/UR/KRpNfKzDrJGJ1nqEMEBsSVNY="},"PREVIOUS":{"nodeId":"6402d95d-3b08-4b52-8d00-993834b39785","metadata":{},"hash":"so2AdaJG4yWT3pQ2Ug2lLXkLXMeV2dAmvj4j2CxQkk8="}},"hash":"ftLwEe1oWFc0m8XH74t48SuuXmnb1J8KFbxoHgoTBwc=","text":"Finally, create the revalidation API Route:\r\npages/api/revalidate.js (js)export default async function handler(req, res) {\r\n  // Check for secret to confirm this is a valid request\r\n  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n  try {\r\n    // this should be the actual path not a rewritten path\r\n    // e.g. for \"/blog/[slug]\" this should be \"/blog/post-1\"\r\n    await res.revalidate('/path-to-revalidate')\r\n    return res.json({ revalidated: true })\r\n  } catch (err) {\r\n    // If there was an error, Next.js will continue\r\n    // to show the last successfully generated page\r\n    return res.status(500).send('Error revalidating')\r\n  }\r\n}\r\nView our demo to see on-demand revalidation in action and provide feedback. Testing on-Demand ISR during development\r\nWhen running locally with next dev, getStaticProps is invoked on every request. To verify your on-demand ISR configuration is\r\ncorrect, you will need to create a production build and start the production server:\r\nTerminal (bash)$ next build\r\n$ next start\r\nThen, you can confirm that static pages have successfully revalidated. Error handling and revalidation\r\nIf there is an error inside getStaticProps when handling background regeneration, or you manually throw an error, the last\r\nsuccessfully generated page will continue to show. On the next subsequent request, Next.js will retry calling getStaticProps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"be9a7015-b04a-48b2-8a66-100cd8ab25ed":{"id_":"be9a7015-b04a-48b2-8a66-100cd8ab25ed","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hIdcC8FQuLMOtiu8pqP24deJbP3j9K5HDWLMg2V84U0=","metadata":{},"hash":"kwctY4q4Xanw5ImBBOdRWIYlBOCP1s2fDPNwsfdJajM="},"NEXT":{"nodeId":"83e099c8-c592-4ee8-91fa-cb98ef0e116b","metadata":{},"hash":"47i2Kdl6b3O7dlSltNfgADw6dEcEdbTTa5guYic/PBo="}},"hash":"W2K3BNjfk+ZCe05+d/+FPSEVE2sixn7N0kZedEzqBJg=","text":"export async function getStaticProps() {\r\n  // If this request throws an uncaught error, Next.js will\r\n  // not invalidate the currently shown page and\r\n  // retry getStaticProps on the next request. const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  if (!res.ok) {\r\n    // If there is a server error, you might want to\r\n    // throw an error instead of returning so that the cache is not updated\r\n    // until the next successful request. throw new Error(`Failed to fetch posts, received status ${res.status}`)\r\n  }\r\n  // If the request was successful, return the posts\r\n  // and revalidate every 10 seconds. return {\r\n    props: {\r\n      posts,\r\n    },\r\n    revalidate: 10,\r\n  }\r\n}\r\nSelf-hosting ISR\r\nIncremental Static Regeneration (ISR) works on self-hosted Next.js sites out of the box when you use next start. You can use this approach when deploying to container orchestrators such as Kubernetes or HashiCorp Nomad. By default, generated\r\nassets will be stored in-memory on each pod. This means that each pod will have its own copy of the static files. Stale data may be\r\nshown until that specific pod is hit by a request. To ensure consistency across all pods, you can disable in-memory caching. This will inform the Next.js server to only leverage assets\r\ngenerated by ISR in the file system. You can use a shared network mount in your Kubernetes pods (or similar setup) to reuse the same file-system cache between different\r\ncontainers. By sharing the same mount, the .next folder which contains the next/image cache will also be shared and re-used. To disable in-memory caching, set isrMemoryCacheSize to 0 in your next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  experimental: {\r\n    // Defaults to 50MB\r\n    isrMemoryCacheSize: 0, // cache size in bytes\r\n  },\r\n}\r\nGood to know: You might need to consider a race condition between multiple pods trying to update the cache at the same\r\ntime, depending on how your shared mount is configured. Version History\r\nVersionChanges\r\nv12.2.0On-Demand ISR is stable\r\nv12.1.0On-Demand ISR added (beta). v12.0.0Bot-aware ISR fallback added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"83e099c8-c592-4ee8-91fa-cb98ef0e116b":{"id_":"83e099c8-c592-4ee8-91fa-cb98ef0e116b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"hIdcC8FQuLMOtiu8pqP24deJbP3j9K5HDWLMg2V84U0=","metadata":{},"hash":"kwctY4q4Xanw5ImBBOdRWIYlBOCP1s2fDPNwsfdJajM="},"PREVIOUS":{"nodeId":"be9a7015-b04a-48b2-8a66-100cd8ab25ed","metadata":{},"hash":"W2K3BNjfk+ZCe05+d/+FPSEVE2sixn7N0kZedEzqBJg="}},"hash":"47i2Kdl6b3O7dlSltNfgADw6dEcEdbTTa5guYic/PBo=","text":"v12.0.0Bot-aware ISR fallback added. v9.5.0Base Path added.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"924ab01a-1b00-4544-b94c-48f327d5c617":{"id_":"924ab01a-1b00-4544-b94c-48f327d5c617","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nCWY85ukXqL7S027FO+Pmn+EHNes4gvzN9gdotU+IC0=","metadata":{},"hash":"NyqZWhKwShl25DrGe3JVolJRa2tPmM2ebuMDFVmkz0M="},"NEXT":{"nodeId":"97e3ba38-8c14-49ff-917c-48e736f139ea","metadata":{},"hash":"/c/WUrKDWnFQASDTVRBoOLVVh9BNazNEoWFM/77x2oQ="}},"hash":"zvCi6gJmLJFs/FLhqoeYatni1b4z6DYT4+Kn3DBNJds=","text":"4.1.3.6 - Client-side Fetching\r\nDocumentation path: /03-pages/01-building-your-application/03-data-fetching/05-client-side\r\nDescription: Learn about client-side data fetching, and how to use SWR, a data fetching React hook library that handles caching,\r\nrevalidation, focus tracking, refetching on interval and more. Client-side data fetching is useful when your page doesn’t require SEO indexing, when you don’t need to pre-render your data, or when\r\nthe content of your pages needs to update frequently. Unlike the server-side rendering APIs, you can use client-side data fetching at the\r\ncomponent level. If done at the page level, the data is fetched at runtime, and the content of the page is updated as the data changes. When used at the\r\ncomponent level, the data is fetched at the time of the component mount, and the content of the component is updated as the data\r\nchanges. It’s important to note that using client-side data fetching can affect the performance of your application and the load speed of your\r\npages. This is because the data fetching is done at the time of the component or pages mount, and the data is not cached. Client-side data fetching with useEffect\r\nThe following example shows how you can fetch data on the client side using the useEffect hook. import { useState, useEffect } from 'react'\r\nfunction Profile() {\r\n  const [data, setData] = useState(null)\r\n  const [isLoading, setLoading] = useState(true)\r\n  useEffect(() => {\r\n    fetch('/api/profile-data')\r\n      .then((res) => res.json())\r\n      .then((data) => {\r\n        setData(data)\r\n        setLoading(false)\r\n      })\r\n  }, [])\r\n  if (isLoading) return <p>Loading...</p>\r\n  if (!data) return <p>No profile data</p>\r\n  return (\r\n    <div>\r\n      <h1>{data.name}</h1>\r\n      <p>{data.bio}</p>\r\n    </div>\r\n  )\r\n}\r\nClient-side data fetching with SWR\r\nThe team behind Next.js has created a React hook library for data fetching called SWR. It is highly recommended if you are fetching\r\ndata on the client-side. It handles caching, revalidation, focus tracking, refetching on intervals, and more. Using the same example as above, we can now use SWR to fetch the profile data.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"97e3ba38-8c14-49ff-917c-48e736f139ea":{"id_":"97e3ba38-8c14-49ff-917c-48e736f139ea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nCWY85ukXqL7S027FO+Pmn+EHNes4gvzN9gdotU+IC0=","metadata":{},"hash":"NyqZWhKwShl25DrGe3JVolJRa2tPmM2ebuMDFVmkz0M="},"PREVIOUS":{"nodeId":"924ab01a-1b00-4544-b94c-48f327d5c617","metadata":{},"hash":"zvCi6gJmLJFs/FLhqoeYatni1b4z6DYT4+Kn3DBNJds="}},"hash":"/c/WUrKDWnFQASDTVRBoOLVVh9BNazNEoWFM/77x2oQ=","text":"Using the same example as above, we can now use SWR to fetch the profile data. SWR will automatically cache the data for us and will\r\nrevalidate the data if it becomes stale. For more information on using SWR, check out the SWR docs. import useSWR from 'swr'\r\nconst fetcher = (...args) => fetch(...args).then((res) => res.json())\r\nfunction Profile() {\r\n  const { data, error } = useSWR('/api/profile-data', fetcher)\r\n  if (error) return <div>Failed to load</div>\r\n  if (!data) return <div>Loading...</div>\r\n  return (\r\n    <div>\r\n      <h1>{data.name}</h1>\r\n      <p>{data.bio}</p>\r\n    </div>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e4ecb167-fe22-463b-9dd1-4853269d65d1":{"id_":"e4ecb167-fe22-463b-9dd1-4853269d65d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"RDzNy+7YyyMf8rUJKPRhGv4esee6nVnUUI7gVdG+m6k=","metadata":{},"hash":"s6t3ypQwWNWPITvQ52ym2JsCxY6FiY8LTouKOSrHceo="}},"hash":"n76GSxvaU3NgTHNNaKG6gY/wq87NDLX1CaX8BZ52+IQ=","text":")\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a1d8219-b9b0-405c-88de-38f961b5e94d":{"id_":"2a1d8219-b9b0-405c-88de-38f961b5e94d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ac/KOmMhDvALUPQjOP2GWtJDMpnij8WXNU2Xb5oDRco=","metadata":{},"hash":"BheLpnvgt99AG/zVWx+upioGjvg26Oy8edxQQb+nxcg="}},"hash":"yqFdjAlW4rulIuYnDLyATBsOXe44dCYaQLHYjDVS03U=","text":"4.1.4 - Styling\r\nDocumentation path: /03-pages/01-building-your-application/04-styling/index\r\nDescription: Learn the different ways you can style your Next.js application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"232a1e86-22e5-4085-8e71-3874cccb1583":{"id_":"232a1e86-22e5-4085-8e71-3874cccb1583","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"H0xmISlybSxC2wmEckh5w4oDQulX0ycmtH9I1g9RiuQ=","metadata":{},"hash":"zO2vk6/xWaddN7ifowlMYU8X8d6eKnh4Fn63IMnTpOE="}},"hash":"IX8ZwHN4flp2TFHV28QtDKanUz2MPD0a6NTRLczz5s8=","text":"4.1.4.1 - CSS Modules\r\nDocumentation path: /03-pages/01-building-your-application/04-styling/01-css-modules\r\nDescription: Style your Next.js Application using CSS Modules. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f72580c8-3dbe-4ded-babc-95ff848f4065":{"id_":"f72580c8-3dbe-4ded-babc-95ff848f4065","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"niTxxMD+Bv9Ccj8NlqVXPktuO4srzHqc7uvapmYMq8g=","metadata":{},"hash":"FTtT5fJTekcQtOH3TgWoX0LzgX7JoCh8SnX7yQiRzf8="}},"hash":"vd5kQcX6aDQwYCPvHF0vvVsWP68vIzpPR0rXVwe2i/4=","text":"4.1.4.2 - Tailwind CSS\r\nDocumentation path: /03-pages/01-building-your-application/04-styling/02-tailwind-css\r\nDescription: Style your Next.js Application using Tailwind CSS. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1e32c6ef-966c-43f8-81af-2d1d64728cba":{"id_":"1e32c6ef-966c-43f8-81af-2d1d64728cba","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/xfXX04+UCWbFO3hKvuGFh42tvsfrherMpb7JOEayK8=","metadata":{},"hash":"IMkorz5VAnUQviuRJkHm39bAxvGuYC+0YNGvW1Ce/vw="}},"hash":"qSlb+fIDyV7paNIKAc6gsC/ZreLGpyq1LTvcKTXqDJ4=","text":"4.1.4.3 - CSS-in-JS\r\nDocumentation path: /03-pages/01-building-your-application/04-styling/03-css-in-js\r\nDescription: Use CSS-in-JS libraries with Next.js\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0218b194-1630-41f6-83a3-b017daa15960":{"id_":"0218b194-1630-41f6-83a3-b017daa15960","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3RWwLs2ODH20aIzXnKr2F3AVx557nAeEFvVGrBQ3gVI=","metadata":{},"hash":"3FZwnZKuSxovGpTH21JVAv2HUQpYrxx7oItyRjaDdc0="}},"hash":"yLnwYTUvBilNCpJ1AmpqNkzrVA617FToiJsmp6Nr8r0=","text":"4.1.4.4 - Sass\r\nDocumentation path: /03-pages/01-building-your-application/04-styling/04-sass\r\nDescription: Learn how to use Sass in your Next.js application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"046035ef-c465-4b0b-9eb3-0517704e5aae":{"id_":"046035ef-c465-4b0b-9eb3-0517704e5aae","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"egyeLjbh2cipvlleFiO3/lv4Dgvw1lcDH7rp0/4mB48=","metadata":{},"hash":"bmK6VjyCRyVpS7Nj9vvZbl9gIYz0z+oQzk3UtdwUpNM="}},"hash":"Piy1Yzq1za6EFqb6d2m38LLXUEEolwJJ7nTlngt+uIU=","text":"4.1.5 - Optimizations\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/index\r\nDescription: Optimize your Next.js application for best performance and user experience. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7a56e20f-fe7c-4c27-a18a-254a00a2397e":{"id_":"7a56e20f-fe7c-4c27-a18a-254a00a2397e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cXN/E7XhnOy/I5FvJBqH46jAQRfnTeiVoAVFq9Sa8SY=","metadata":{},"hash":"okxxop46VvFNuIebd41MdOIRRlhRqLV/7mHU9cxRkBQ="}},"hash":"6fdbDY4l3gOG51Al6aZ3TMU6xwBZeDUgIpspAhY93C0=","text":"4.1.5.1 - Image Optimization\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/01-images\r\nDescription: Optimize your images with the built-in `next/image` component. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5479fcd3-6f2e-4d07-adf7-69ebe85c49a5":{"id_":"5479fcd3-6f2e-4d07-adf7-69ebe85c49a5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rllMtS/VQOBwdKmKW2du2E9qSBL1bECk3lgrSM2NRhw=","metadata":{},"hash":"5tVScvwiD0kVJVncUektAKC1stTeRbC/fQKNDv+80bs="}},"hash":"bfFFZtuFs8H5zn4FCBn7OWppl57R8YDi4mCeoEFLG4k=","text":"4.1.5.2 - Font Optimization\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/02-fonts\r\nDescription: Optimize your application's web fonts with the built-in `next/font` loaders. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a7304f3-2104-4788-b544-e60b95b5e038":{"id_":"2a7304f3-2104-4788-b544-e60b95b5e038","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PLTlXtyTDgdt3/hbg1BMLZ99qCBr/t+FDuuRHKgeRCc=","metadata":{},"hash":"d+k9I0vh/hpf7VdRMVfqMt8P2rejV8ZpRTxJ2B9obuo="}},"hash":"SJpM+t4W4i1NERmPVB+lLmcvc27sKxbphzyPuxy5BPU=","text":"4.1.5.3 - Script Optimization\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/03-scripts\r\nDescription: Optimize 3rd party scripts with the built-in Script component. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e905112c-5beb-4137-bbaf-55cb785c2411":{"id_":"e905112c-5beb-4137-bbaf-55cb785c2411","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zbjykILFDKMiLD6Qx6g6Qc2Fh5GRWHTpbCCj6sEtqa0=","metadata":{},"hash":"aubEgbSuPFHPdJiQ1e5cI4AKBihG7DxIv2e8uRH/gSY="}},"hash":"q0+G9zBDOBZHBXm2VgWv5HQcv3RGBhWXkfH/XvOtrHQ=","text":"4.1.5.4 - Static Assets\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/05-static-assets\r\nDescription: Next.js allows you to serve static files, like images, in the public directory. You can learn how it works here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d54084d0-3100-472b-904d-9a6ab31517fa":{"id_":"d54084d0-3100-472b-904d-9a6ab31517fa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HDm7t4utU0t4xvUu51/bypM1Yefm1h9zxRXFUvPuZCA=","metadata":{},"hash":"zKsQtnQCEHiS7MeZKtXB2+2R9opcEFgtDnmXyBTuFPI="}},"hash":"tNQD1BIJgj7jB0Nm/AEUPc3mcQE2SzL/L0fUOQy7INc=","text":"4.1.5.5 - Lazy Loading\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/06-lazy-loading\r\nDescription: Lazy load imported libraries and React Components to improve your application's loading performance. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2122221a-8b6b-4b4b-8eea-36c7ce25d8da":{"id_":"2122221a-8b6b-4b4b-8eea-36c7ce25d8da","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+ytcymG5ua+rNJk3QxPB+dEUPtc5E9JQfJID9QH6jQU=","metadata":{},"hash":"LNvyFvMvCFKIdM0M5OYW3HQhHNsJHrTshGme8o0bX+E="}},"hash":"VFdUWF3JdO68pT4WZgvssyhZNi2KxVKsK3gK1vr/nkk=","text":"4.1.5.6 - Analytics\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/07-analytics\r\nDescription: Measure and track page performance using Next.js Speed Insights\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9dfec995-a3a3-4f1d-9815-275fe19835d7":{"id_":"9dfec995-a3a3-4f1d-9815-275fe19835d7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fD/wXGixSc/XA3rNjhD1Gqx/zqmNe+//JOv4ujF1LBg=","metadata":{},"hash":"GRvAgHHRK4S5AVqSRTl4WLcDSQFxtEDdPRknwxU7NY4="}},"hash":"lzZ8pPSGOSsfpuU4PBfJDrp1apiARaUPnOFFOS9HD18=","text":"4.1.5.7 - OpenTelemetry\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/08-open-telemetry\r\nDescription: Learn how to instrument your Next.js app with OpenTelemetry. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d938d1bb-a2c1-4ecd-84a7-303eb74c8504":{"id_":"d938d1bb-a2c1-4ecd-84a7-303eb74c8504","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"f0eUdVBwag2wsGJJFX/tHDzfaOTDdSEB97ojT0/DdBo=","metadata":{},"hash":"ZjPPIQjQUNnZPwCoFk9RdA4n5IXWzX8azs9QPY0pd/8="}},"hash":"gn+dv/BOqhI9er5O0BfVmzvFvWwneUq/HrcqFd2ldPs=","text":"4.1.5.8 - Instrumentation\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/09-instrumentation\r\nDescription: Learn how to use instrumentation to run code at server startup in your Next.js app\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e49e0d90-a6c7-4c98-b2e6-46e713e19842":{"id_":"e49e0d90-a6c7-4c98-b2e6-46e713e19842","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CQ+j+g+D3/7AagEKjucALngNCBX8/Lclby/04tkb16Y=","metadata":{},"hash":"XroJW4mjAUlhH+mDxrUwHGo58k6Ds9NEzUjwDWHr+Uk="}},"hash":"hSe5DZQsPIAUxBI8eHmQl1HgOJ0eR/pjgKDdrUpUE04=","text":"4.1.5.9 - Third Party Libraries\r\nDocumentation path: /03-pages/01-building-your-application/05-optimizing/11-third-party-libraries\r\nDescription: Optimize the performance of third-party libraries in your application with the `@next/third-parties` package. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"80ab3a1f-4142-444f-8faf-4daad11d2e0c":{"id_":"80ab3a1f-4142-444f-8faf-4daad11d2e0c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"CDKTXlUWqxl3tqZocK9Wnr2i+7V7HV2yrNLFSglSw7o=","metadata":{},"hash":"IvGKmyKpe9mbcsAN7DCwP6rRcmqP+acXhrGcl6wiLDs="}},"hash":"y/yhZekiWIkaeUks6NadiffJjRuEIKCUypwyqum1U1o=","text":"4.1.6 - Configuring\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/index\r\nDescription: Learn how to configure your Next.js application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4bd18f0d-be93-4354-8bdc-1232b59d4941":{"id_":"4bd18f0d-be93-4354-8bdc-1232b59d4941","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9n0wv79irJcEk9xE99xYPdaIHbz0pTuK/jax9CtXtTw=","metadata":{},"hash":"L/CiLLHIxCwPCFmro4882wRgPeYbE8zi6QlAyYL1pvM="}},"hash":"JvvO+PbGvIp6dwokqXz/azpcQosFUA9l9fcWisG3MyM=","text":"4.1.6.1 - TypeScript\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/01-typescript\r\nDescription: Next.js provides a TypeScript-first development experience for building your React application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c9b95c90-0753-4b66-a836-f918f1e69bc4":{"id_":"c9b95c90-0753-4b66-a836-f918f1e69bc4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"k76FWCDKVR9d3rqjw+lpf13UjnaN7g8AtHq9D+9uhfI=","metadata":{},"hash":"Ysc2vqADQxImw0RcEwly//WeCZod+HKCKZ7QpPkv8ns="}},"hash":"chv2rs5PuOJh+CjsSJ+AIQU9evzePtPTxWiMY/9lgY4=","text":"4.1.6.2 - ESLint\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/02-eslint\r\nDescription: Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"99a630f4-4f94-4236-aa66-f91d8a132669":{"id_":"99a630f4-4f94-4236-aa66-f91d8a132669","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ISuJFM8KBBvB165igEx3ZD6aYlUo4lmRBKA76NV1XDo=","metadata":{},"hash":"EFTMS4XXrJW01edas7f4/I8BgfWvtfQraI3bt8rDxrM="}},"hash":"tYauBQgqX3Jmmo8QX/mEHs/9fEoGMfVIzJP0n0OfJMo=","text":"4.1.6.3 - Environment Variables\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/03-environment-variables\r\nDescription: Learn to add and access environment variables in your Next.js application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"24773585-dd2d-44de-b157-abfb4bb42265":{"id_":"24773585-dd2d-44de-b157-abfb4bb42265","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3F3w6qgJRTgseEpUKxzPSCV/oa1D9fvW2cWkE25eyHo=","metadata":{},"hash":"TOwsdoogDF/poftM36SyG2QPSsXK0rfnJ3bVt8tDtfU="}},"hash":"toM/jhWBnLhou7BJYyYvbfzD2He/brJp7lNkW7z3g/4=","text":"4.1.6.4 - Absolute Imports and Module Path Aliases\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/04-absolute-imports-and-module-aliases\r\nDescription: Configure module path aliases that allow you to remap certain import paths. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"69b1b9dc-8e6d-470d-840d-9ae4166b4bd8":{"id_":"69b1b9dc-8e6d-470d-840d-9ae4166b4bd8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JlXCXJH87Tk58f3oBTrg8tohvjohLgJxhjVPgwtgeoM=","metadata":{},"hash":"JAfvmiqsbvusQVMG3HT3K37oXFx/N7IGWi2v/BcXVAo="}},"hash":"heKsxaL18iF2jdFK+qgnK8FDI22OCrOr5/GmJgsLlgg=","text":"4.1.6.5 - src Directory\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/05-src-directory\r\nDescription: Save pages under the `src` directory as an alternative to the root `pages` directory. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9bdd4cc0-18a2-4d51-896f-c1067ddfc12a":{"id_":"9bdd4cc0-18a2-4d51-896f-c1067ddfc12a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uiE7+5TugafnXlI9Fsj0dWOzTsMMOsSAvJfrQIfqr7s=","metadata":{},"hash":"BnsLN/MaIGhEd4/Mt1fx35C8np003Ev/kc6dbCzPEds="}},"hash":"Iwevp73FGXCyyuKTGUc4SuKSkQYlKzNW7xj52JbDOCY=","text":"4.1.6.6 - Markdown and MDX\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/06-mdx\r\nDescription: Learn how to configure MDX to write JSX in your markdown files. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"738a9d95-2db3-44eb-b56c-85ff28be1ce8":{"id_":"738a9d95-2db3-44eb-b56c-85ff28be1ce8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"VPTnr7yyHEMCu+6aAHTYtQnZFh+nBewtv2OfEjqaLyE=","metadata":{},"hash":"oy3IX1xgVmkOwCQh2+bFTADL2YZBoCWNtROMjcttSvY="}},"hash":"pSdmeKTVWJQBeQALwT2bZNA8wj9yxwTr497Jy2lK2MI=","text":"4.1.6.7 - AMP\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/07-amp\r\nDescription: With minimal config, and without leaving React, you can start adding AMP and improve the performance and speed of\r\nyour pages. Examples\r\nWith Next.js you can turn any React page into an AMP page, with minimal config, and without leaving React. You can read more about AMP in the official amp.dev site. Enabling AMP\r\nTo enable AMP support for a page, and to learn more about the different AMP configs, read the API documentation for next/amp. Caveats\r\nOnly CSS-in-JS is supported. CSS Modules aren’t supported by AMP pages at the moment. You can contribute CSS Modules support\r\nto Next.js. Adding AMP Components\r\nThe AMP community provides many components to make AMP pages more interactive. Next.js will automatically import all\r\ncomponents used on a page and there is no need to manually import AMP component scripts:\r\nexport const config = { amp: true }\r\nfunction MyAmpPage() {\r\n  const date = new Date()\r\n  return (\r\n    <div>\r\n      <p>Some time: {date.toJSON()}</p>\r\n      <amp-timeago\r\n        width=\"0\"\r\n        height=\"15\"\r\n        datetime={date.toJSON()}\r\n        layout=\"responsive\"\r\n      >\r\n        . </amp-timeago>\r\n    </div>\r\n  )\r\n}\r\nexport default MyAmpPage\r\nThe above example uses the amp-timeago component. By default, the latest version of a component is always imported. If you want to customize the version, you can use next/head, as in\r\nthe following example:\r\nimport Head from 'next/head'\r\nexport const config = { amp: true }\r\nfunction MyAmpPage() {\r\n  const date = new Date()\r\n  return (\r\n    <div>\r\n      <Head>\r\n        <script\r\n          async\r\n          key=\"amp-timeago\"\r\n          custom-element=\"amp-timeago\"\r\n          src=\"https://cdn.ampproject.org/v0/amp-timeago-0.1.js\"\r\n        />\r\n      </Head>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c1d3883c-61a7-47c3-b733-4d432abe6d38":{"id_":"c1d3883c-61a7-47c3-b733-4d432abe6d38","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9vkdqiJNShX8Bq3k76wZlMsr1sTz++3VpLnbovwi5Wg=","metadata":{},"hash":"Q8CAc+0aryepNGELcQfHUDrZ4QN/CHAKbcyzhSg6y4Q="}},"hash":"ZU/2u/0Fy8SEyFzYr6Xe0DoplFfCPF4n4fxR1Frk9Uw=","text":"<p>Some time: {date.toJSON()}</p>\r\n      <amp-timeago\r\n        width=\"0\"\r\n        height=\"15\"\r\n        datetime={date.toJSON()}\r\n        layout=\"responsive\"\r\n      >\r\n        . </amp-timeago>\r\n    </div>\r\n  )\r\n}\r\nexport default MyAmpPage\r\nAMP Validation\r\nAMP pages are automatically validated with amphtml-validator during development. Errors and warnings will appear in the terminal\r\nwhere you started Next.js. Pages are also validated during Static HTML export and any warnings / errors will be printed to the terminal. Any AMP errors will cause\r\nthe export to exit with status code 1 because the export is not valid AMP. Custom Validators\r\nYou can set up custom AMP validator in next.config.js as shown below:\r\nmodule.exports = {\r\n  amp: {\r\n    validator: './custom_validator.js',\r\n  },\r\n}\r\nSkip AMP Validation\r\nTo turn off AMP validation add the following code to next.config.js\r\nexperimental: {\r\n  amp: {\r\n    skipValidation: true\r\n  }\r\n}\r\nAMP in Static HTML Export\r\nWhen using Static HTML export statically prerender pages, Next.js will detect if the page supports AMP and change the exporting\r\nbehavior based on that. For example, the hybrid AMP page pages/about.js would output:\r\nout/about.html - HTML page with client-side React runtime\r\nout/about.amp.html - AMP page\r\nAnd if pages/about.js is an AMP-only page, then it would output:\r\nout/about.html - Optimized AMP page\r\nNext.js will automatically insert a link to the AMP version of your page in the HTML version, so you don’t have to, like so:\r\n<link rel=\"amphtml\" href=\"/about.amp.html\" />\r\nAnd the AMP version of your page will include a link to the HTML page:\r\n<link rel=\"canonical\" href=\"/about\" />\r\nWhen trailingSlash is enabled the exported pages for pages/about.js would be:\r\nout/about/index.html - HTML page\r\nout/about.amp/index.html - AMP page\r\nTypeScript","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"36688e29-1b56-4e2e-a97b-66730cca0e5b":{"id_":"36688e29-1b56-4e2e-a97b-66730cca0e5b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sx4azPKPItCHqVbJ+RL4g0BkS0VTQghsew+L14dE/JE=","metadata":{},"hash":"gLNaQ4IKL4uW8CbmB/Wj5UBgjXszTMceBG7okthJySs="}},"hash":"dHBJsNb84OarTaqGdQPLA8eWj2/vVQbEFTBUEaWZlys=","text":"AMP currently doesn’t have built-in types for TypeScript, but it’s in their roadmap (#13791). As a workaround you can manually create a file called amp.d.ts inside your project and add these custom types.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bee1944a-a0ba-4580-9454-77152c0b4810":{"id_":"bee1944a-a0ba-4580-9454-77152c0b4810","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pqIIfRpJtnvoVsikGQhmY2ZtNYeqxNN+N1bKCBrAd38=","metadata":{},"hash":"BNum4ByG3p99VCbJI1lDweravN/VncPV3rkYyIxyi0E="}},"hash":"Cpl+HFarfhERzeJ2SAMWAZhTsz8erIOFIAKVDe2YGZ4=","text":"4.1.6.8 - Babel\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/08-babel\r\nDescription: Extend the babel preset added by Next.js with your own configs. Examples\r\nNext.js includes the next/babel preset to your app, which includes everything needed to compile React applications and server-side\r\ncode. But if you want to extend the default Babel configs, it’s also possible. Adding Presets and Plugins\r\nTo start, you only need to define a .babelrc file (or babel.config.js) in the root directory of your project. If such a file is found, it\r\nwill be considered as the source of truth, and therefore it needs to define what Next.js needs as well, which is the next/babel preset. Here’s an example .babelrc file:\r\n.babelrc (json){\r\n  \"presets\": [\"next/babel\"],\r\n  \"plugins\": []\r\n}\r\nYou can take a look at this file to learn about the presets included by next/babel. To add presets/plugins without configuring them, you can do it this way:\r\n.babelrc (json){\r\n  \"presets\": [\"next/babel\"],\r\n  \"plugins\": [\"@babel/plugin-proposal-do-expressions\"]\r\n}\r\nCustomizing Presets and Plugins\r\nTo add presets/plugins with custom configuration, do it on the next/babel preset like so:\r\n.babelrc (json){\r\n  \"presets\": [\r\n    [\r\n      \"next/babel\",\r\n      {\r\n        \"preset-env\": {},\r\n        \"transform-runtime\": {},\r\n        \"styled-jsx\": {},\r\n        \"class-properties\": {}\r\n      }\r\n    ]\r\n  ],\r\n  \"plugins\": []\r\n}\r\nTo learn more about the available options for each config, visit babel’s documentation site. Good to know:\r\nNext.js uses the current Node.js version for server-side compilations. The modules option on \"preset-env\" should be kept to false, otherwise webpack code splitting is turned off.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f5664a14-8726-42f4-979c-6ebb9740975b":{"id_":"f5664a14-8726-42f4-979c-6ebb9740975b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DXHaM3w+XNetD/4JRMoZ3/b0TG1cE7XKwxn4XfiUClU=","metadata":{},"hash":"8eQzuR372+V19ibUs92za0Tzrs+nOvNpBGRLZbtCC6A="},"NEXT":{"nodeId":"e6ac1351-6243-44e2-a05d-66154422b599","metadata":{},"hash":"tXCLa+as1AKpCB31w6Kn2SRGHSnQbBzs9B8JvxfD5kY="}},"hash":"4b2ObnVen+NqMqObst168OGiBRRHD6WYIBInePITopU=","text":"4.1.6.9 - PostCSS\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/09-post-css\r\nDescription: Extend the PostCSS config and plugins added by Next.js with your own. Examples\r\n- [Tailwind CSS Example](https://github.com/vercel/next.js/tree/canary/examples/with-tailwindcss)\r\nDefault Behavior\r\nNext.js compiles CSS for its built-in CSS support using PostCSS. Out of the box, with no configuration, Next.js compiles CSS with the following transformations:\r\nAutoprefixer automatically adds vendor prefixes to CSS rules (back to IE11). Cross-browser Flexbox bugs are corrected to behave like the spec. New CSS features are automatically compiled for Internet Explorer 11 compatibility:all\r\n Property\r\nBreak Propertiesfont-variant\r\n Property\r\nGap Properties\r\nMedia Query Ranges\r\nBy default, CSS Grid and Custom Properties (CSS variables) are not compiled for IE11 support. To compile CSS Grid Layout for IE11, you can place the following comment at the top of your CSS file:\r\n/* autoprefixer grid: autoplace */\r\nYou can also enable IE11 support for CSS Grid Layout in your entire project by configuring autoprefixer with the configuration shown\r\nbelow (collapsed). See “Customizing Plugins” below for more information. Click to view the configuration to enable CSS Grid Layout\r\nCSS variables are not compiled because it is not possible to safely do so. If you must use variables, consider using something like Sass\r\nvariables which are compiled away by Sass. Customizing Target Browsers\r\nNext.js allows you to configure the target browsers (for Autoprefixer and compiled css features) through Browserslist. To customize browserslist, create a browserslist key in your package.json like so:\r\npackage.json (json){\r\n  \"browserslist\": [\">0.3%\", \"not dead\", \"not op_mini all\"]\r\n}\r\nYou can use the browsersl.ist tool to visualize what browsers you are targeting. CSS Modules\r\nNo configuration is needed to support CSS Modules. To enable CSS Modules for a file, rename the file to have the extension.module.css\r\n. You can learn more about Next.js’ CSS Module support here. Customizing Plugins\r\nWarning: When you define a custom PostCSS configuration file, Next.js completely disables the default behavior. Be sure to\r\nmanually configure all the features you need compiled, including Autoprefixer.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e6ac1351-6243-44e2-a05d-66154422b599":{"id_":"e6ac1351-6243-44e2-a05d-66154422b599","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DXHaM3w+XNetD/4JRMoZ3/b0TG1cE7XKwxn4XfiUClU=","metadata":{},"hash":"8eQzuR372+V19ibUs92za0Tzrs+nOvNpBGRLZbtCC6A="},"PREVIOUS":{"nodeId":"f5664a14-8726-42f4-979c-6ebb9740975b","metadata":{},"hash":"4b2ObnVen+NqMqObst168OGiBRRHD6WYIBInePITopU="}},"hash":"tXCLa+as1AKpCB31w6Kn2SRGHSnQbBzs9B8JvxfD5kY=","text":"Be sure to\r\nmanually configure all the features you need compiled, including Autoprefixer. You also need to install any plugins included in\r\nyour custom configuration manually, i.e. npm install postcss-flexbugs-fixes postcss-preset-env. To customize the PostCSS configuration, create a postcss.config.json file in the root of your project. This is the default configuration used by Next.js:\r\npostcss.config.json (json){\r\n  \"plugins\": [","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"04793010-cba7-4bba-8abf-a5cfc7bbc808":{"id_":"04793010-cba7-4bba-8abf-a5cfc7bbc808","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1xTyauseiGvu1OIZnzcqm97NWtqYcSABDpHuLgpq2EE=","metadata":{},"hash":"h8+X1R0Vj8OXpaY4CewRIQ/cLHMF/i0/NVdhGyDuRGs="}},"hash":"3yx1F2MveVggnfZdISuwKsP1TF6u9VtMzC1SFyowSwU=","text":"\"postcss-flexbugs-fixes\",\r\n    [\r\n      \"postcss-preset-env\",\r\n      {\r\n        \"autoprefixer\": {\r\n          \"flexbox\": \"no-2009\"\r\n        },\r\n        \"stage\": 3,\r\n        \"features\": {\r\n          \"custom-properties\": false\r\n        }\r\n      }\r\n    ]\r\n  ]\r\n}\r\nGood to know: Next.js also allows the file to be named .postcssrc.json, or, to be read from the postcss key inpackage.json\r\n. It is also possible to configure PostCSS with a postcss.config.js file, which is useful when you want to conditionally include plugins\r\nbased on environment:\r\npostcss.config.js (js)module.exports = {\r\n  plugins:\r\n    process.env.NODE_ENV === 'production'\r\n      ? [\r\n          'postcss-flexbugs-fixes',\r\n          [\r\n            'postcss-preset-env',\r\n            {\r\n              autoprefixer: {\r\n                flexbox: 'no-2009',\r\n              },\r\n              stage: 3,\r\n              features: {\r\n                'custom-properties': false,\r\n              },\r\n            },\r\n          ],\r\n        ]\r\n      : [\r\n          // No transformations in development\r\n        ],\r\n}\r\nGood to know: Next.js also allows the file to be named .postcssrc.js. Do not use require()require() to import the PostCSS Plugins. Plugins must be provided as strings. Good to know: If your postcss.config.js needs to support other non-Next.js tools in the same project, you must use the\r\ninteroperable object-based format instead:\r\njs module.exports = { plugins: { 'postcss-flexbugs-fixes': {}, 'postcss-preset-env': {\r\nautoprefixer: { flexbox: 'no-2009', }, stage: 3, features: { 'custom-properties': false, }, }, }, }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"70ec6599-cbe1-43a4-8c64-3428c2f65c7c":{"id_":"70ec6599-cbe1-43a4-8c64-3428c2f65c7c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+bN3ZcSoUrMzVl7LugPqr75y9ER4VlE5rNNG5F9jDB8=","metadata":{},"hash":"8e14e4lwmggmbeBFrwzA67WxfryjYXnfB/T/SSsYVas="},"NEXT":{"nodeId":"e18d016b-805a-471a-9034-0a4e27f93059","metadata":{},"hash":"x6OxV6jBs5r099KMyqW5nY+x8OSsEiGrJs54m+csMIA="}},"hash":"zrheIVzFNleUtjMVzH/6H9D7li0dcSY+lyWAZzqsV4Y=","text":"4.1.6.10 - Custom Server\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/10-custom-server\r\nDescription: Start a Next.js app programmatically using a custom server. Examples\r\nBy default, Next.js includes its own server with next start. If you have an existing backend, you can still use it with Next.js (this is not\r\na custom server). A custom Next.js server allows you to start a server 100% programmatically in order to use custom server patterns. Most of the time, you will not need this - but it’s available for complete customization. Good to know:\r\nBefore deciding to use a custom server, please keep in mind that it should only be used when the integrated router of\r\nNext.js can’t meet your app requirements. A custom server will remove important performance optimizations, like\r\nserverless functions and Automatic Static Optimization. A custom server cannot be deployed on Vercel. Take a look at the following example of a custom server:\r\nserver.js (js)const { createServer } = require('http')\r\nconst { parse } = require('url')\r\nconst next = require('next')\r\nconst dev = process.env.NODE_ENV !== 'production'\r\nconst hostname = 'localhost'\r\nconst port = 3000\r\n// when using middleware `hostname` and `port` must be provided below\r\nconst app = next({ dev, hostname, port })\r\nconst handle = app.getRequestHandler()\r\napp.prepare().then(() => {\r\n  createServer(async (req, res) => {\r\n    try {\r\n      // Be sure to pass `true` as the second argument to `url.parse`. // This tells it to parse the query portion of the URL.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e18d016b-805a-471a-9034-0a4e27f93059":{"id_":"e18d016b-805a-471a-9034-0a4e27f93059","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"+bN3ZcSoUrMzVl7LugPqr75y9ER4VlE5rNNG5F9jDB8=","metadata":{},"hash":"8e14e4lwmggmbeBFrwzA67WxfryjYXnfB/T/SSsYVas="},"PREVIOUS":{"nodeId":"70ec6599-cbe1-43a4-8c64-3428c2f65c7c","metadata":{},"hash":"zrheIVzFNleUtjMVzH/6H9D7li0dcSY+lyWAZzqsV4Y="}},"hash":"x6OxV6jBs5r099KMyqW5nY+x8OSsEiGrJs54m+csMIA=","text":"// This tells it to parse the query portion of the URL. const parsedUrl = parse(req.url, true)\r\n      const { pathname, query } = parsedUrl\r\n      if (pathname === '/a') {\r\n        await app.render(req, res, '/a', query)\r\n      } else if (pathname === '/b') {\r\n        await app.render(req, res, '/b', query)\r\n      } else {\r\n        await handle(req, res, parsedUrl)\r\n      }\r\n    } catch (err) {\r\n      console.error('Error occurred handling', req.url, err)\r\n      res.statusCode = 500\r\n      res.end('internal server error')\r\n    }\r\n  })\r\n    .once('error', (err) => {\r\n      console.error(err)\r\n      process.exit(1)\r\n    })\r\n    .listen(port, () => {\r\n      console.log(`> Ready on http://${hostname}:${port}`)\r\n    })\r\n})\r\nserver.js doesn’t go through babel or webpack. Make sure the syntax and sources this file requires are compatible with the\r\ncurrent node version you are running. To run the custom server you’ll need to update the scripts in package.json like so:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"node server.js\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"NODE_ENV=production node server.js\"","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cec62968-824d-489f-b6f7-8c180a9523d8":{"id_":"cec62968-824d-489f-b6f7-8c180a9523d8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"29OTASO5mdnDhBLvWVl7hA0M6k+n4xQ5jPzO5N8rETc=","metadata":{},"hash":"uN4q2zolcWxDREEVbdKnbagl40QcyuP+qFa43SpfMlY="}},"hash":"ezI1k/se30oIruwl5eS0pUGETvMWwkR3C/AKZBzdvY8=","text":"}\r\n}\r\nThe custom server uses the following import to connect the server with the Next.js application:\r\nconst next = require('next')\r\nconst app = next({})\r\nThe above next import is a function that receives an object with the following options:\r\nOptionTypeDescription\r\nconfObjectThe same object you would use in next.config.js. Defaults to {}\r\ncustomServerBoolean(Optional) Set to false when the server was created by Next.js\r\ndevBoolean(Optional) Whether or not to launch Next.js in dev mode. Defaults to false\r\ndirString(Optional) Location of the Next.js project. Defaults to '. '\r\nquietBoolean(Optional) Hide error messages containing server information. Defaults to false\r\nhostnameString(Optional) The hostname the server is running behind\r\nportNumber(Optional) The port the server is running behind\r\nhttpServernode:http#Server(Optional) The HTTP Server that Next.js is running behind\r\nThe returned app can then be used to let Next.js handle requests as required. Disabling file-system routing\r\nBy default, Next will serve each file in the pages folder under a pathname matching the filename. If your project uses a custom server,\r\nthis behavior may result in the same content being served from multiple paths, which can present problems with SEO and UX. To disable this behavior and prevent routing based on files in pages, open next.config.js and disable the\r\nuseFileSystemPublicRoutes config:\r\nnext.config.js (js)module.exports = {\r\n  useFileSystemPublicRoutes: false,\r\n}\r\nNote that useFileSystemPublicRoutes disables filename routes from SSR; client-side routing may still access those paths. When using this option, you should guard against navigation to routes you do not want programmatically. You may also wish to configure the client-side router to disallow client-side redirects to filename routes; for that refer torouter.beforePopState\r\n.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bb7908db-2849-491f-afd9-8ff6459604c8":{"id_":"bb7908db-2849-491f-afd9-8ff6459604c8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NrsrVYXBZGnkihM2dO7uqOJZuuuuTEE75+NooEidxvY=","metadata":{},"hash":"CgLm1mtVKWk6okc8HSWCRcGuivireXQqlcm1CNb2YwQ="},"NEXT":{"nodeId":"660a69a0-f681-4379-9808-52d1088e031a","metadata":{},"hash":"mb2EfaA6Y46DkrNvj7Y5jQIqZ8UxnO/eOh0bXbmRIDQ="}},"hash":"b1dYh0k2VQnkZLTQ+v9qNrNgAv6r1c49s77U+JLaTkI=","text":"4.1.6.11 - Draft Mode\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/11-draft-mode\r\nDescription: Next.js has draft mode to toggle between static and dynamic pages. You can learn how it works with Pages Router. In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static\r\nGeneration) using getStaticProps and getStaticPaths. Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your\r\nheadless CMS and want to view the draft immediately on your page. You’d want Next.js to render these pages at request time instead\r\nof build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only for this\r\nspecific case. Next.js has a feature called Draft Mode which solves this problem. Here are instructions on how to use it. Step 1: Create and access the API route\r\nTake a look at the API Routes documentation first if you’re not familiar with Next.js API Routes. First, create the API route. It can have any name - e.g. pages/api/draft.ts\r\nIn this API route, you need to call setDraftMode on the response object. export default function handler(req, res) {\r\n  // ... res.setDraftMode({ enable: true })\r\n  // ... }\r\nThis will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger Draft Mode changing the behavior\r\nfor statically generated pages (more on this later). You can test this manually by creating an API route like below and accessing it from your browser manually:\r\npages/api/draft.ts (ts)// simple example for testing it manually from your browser. export default function handler(req, res) {\r\n  res.setDraftMode({ enable: true })\r\n  res.end('Draft mode is enabled')\r\n}\r\nIf you open your browser’s developer tools and visit /api/draft, you’ll notice a Set-Cookie response header with a cookie named\r\n__prerender_bypass. Securely accessing it from your Headless CMS\r\nIn practice, you’d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless\r\nCMS you’re using, but here are some common steps you could take.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"660a69a0-f681-4379-9808-52d1088e031a":{"id_":"660a69a0-f681-4379-9808-52d1088e031a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NrsrVYXBZGnkihM2dO7uqOJZuuuuTEE75+NooEidxvY=","metadata":{},"hash":"CgLm1mtVKWk6okc8HSWCRcGuivireXQqlcm1CNb2YwQ="},"PREVIOUS":{"nodeId":"bb7908db-2849-491f-afd9-8ff6459604c8","metadata":{},"hash":"b1dYh0k2VQnkZLTQ+v9qNrNgAv6r1c49s77U+JLaTkI="}},"hash":"mb2EfaA6Y46DkrNvj7Y5jQIqZ8UxnO/eOh0bXbmRIDQ=","text":"These steps assume that the headless CMS you’re using supports setting custom draft URLs. If it doesn’t, you can still use this method\r\nto secure your draft URLs, but you’ll need to construct and access the draft URL manually. First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js\r\napp and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing draft URLs. Second, if your headless CMS supports setting custom draft URLs, specify the following as the draft URL. This assumes that your draft\r\nAPI route is located at pages/api/draft.ts. Terminal (bash)https://<your-site>/api/draft?secret=<token>&slug=<path>\r\n<your-site> should be your deployment domain. <token> should be replaced with the secret token you generated. <path> should be the path for the page that you want to view. If you want to view /posts/foo, then you should use\r\n&slug=/posts/foo. Your headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMS’s\r\ndata like so: &slug=/posts/{entry.fields.slug}\r\nFinally, in the draft API route:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a3f42b50-677d-4473-8a8b-7f8ddcfb9944":{"id_":"a3f42b50-677d-4473-8a8b-7f8ddcfb9944","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7yNNTlp100H99q+B9Vrhv3026JYByb6KjqnL1ZZMLY8=","metadata":{},"hash":"ce79e2T9LumbxUSW84E+0YdI7yBpz3RVCQDMeIAolzw="},"NEXT":{"nodeId":"97ef1ebf-1306-459b-9a1e-e25d8ab7eb75","metadata":{},"hash":"1u0RrlZeIxMmzTqP2NshEXPk/qpOI8sF7qC2UBMFgxw="}},"hash":"xgBKyPQhfMYcqxkrJnzX4tXszvcYagvPFk4SzDbzvCk=","text":"- Check that the secret matches and that the slugslug parameter exists (if not, the\r\nrequest should fail). Call res.setDraftMode. Then redirect the browser to the path specified by slug. (The following example uses a 307 redirect). export default async (req, res) => {\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this API route and the CMS\r\n  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(req.query.slug)\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return res.status(401).json({ message: 'Invalid slug' })\r\n  }\r\n  // Enable Draft Mode by setting the cookie\r\n  res.setDraftMode({ enable: true })\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities\r\n  res.redirect(post.slug)\r\n}\r\nIf it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie. Step 2: Update getStaticPropsgetStaticProps\r\nThe next step is to update getStaticProps to support draft mode. If you request a page which has getStaticProps with the cookie set (via res.setDraftMode), then getStaticProps will be called at\r\nrequest time (instead of at build time). Furthermore, it will be called with a context object where context.draftMode will be true. export async function getStaticProps(context) {\r\n  if (context.draftMode) {\r\n    // dynamic data\r\n  }\r\n}\r\nWe used res.setDraftMode in the draft API route, so context.draftMode will be true. If you’re also using getStaticPaths, then context.params will also be available. Fetch draft data\r\nYou can update getStaticProps to fetch different data based on context.draftMode. For example, your headless CMS might have a different API endpoint for draft posts.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"97ef1ebf-1306-459b-9a1e-e25d8ab7eb75":{"id_":"97ef1ebf-1306-459b-9a1e-e25d8ab7eb75","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7yNNTlp100H99q+B9Vrhv3026JYByb6KjqnL1ZZMLY8=","metadata":{},"hash":"ce79e2T9LumbxUSW84E+0YdI7yBpz3RVCQDMeIAolzw="},"PREVIOUS":{"nodeId":"a3f42b50-677d-4473-8a8b-7f8ddcfb9944","metadata":{},"hash":"xgBKyPQhfMYcqxkrJnzX4tXszvcYagvPFk4SzDbzvCk="}},"hash":"1u0RrlZeIxMmzTqP2NshEXPk/qpOI8sF7qC2UBMFgxw=","text":"For example, your headless CMS might have a different API endpoint for draft posts. If so, you can modify the API endpoint URL like\r\nbelow:\r\nexport async function getStaticProps(context) {\r\n  const url = context.draftMode\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n  const res = await fetch(url)\r\n  // ... }\r\nThat’s it! If you access the draft API route (with secret and slug) from your headless CMS or manually, you should now be able to see\r\nthe draft content. And if you update your draft without publishing, you should be able to view the draft. Set this as the draft URL on your headless CMS or access manually, and you should be able to see the draft. Terminal (bash)https://<your-site>/api/draft?secret=<token>&slug=<path>","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"06437e8e-1e04-4038-9297-8a089e301577":{"id_":"06437e8e-1e04-4038-9297-8a089e301577","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ilLc5bfcJBHaLlEqQQWCKfhAIGbjJWeHQrzrdwm4cHE=","metadata":{},"hash":"+4g92Q8FwStWNwhWk8HCmz2QZZLJiQWqHnch1f+Qmj0="}},"hash":"xXsbtQhsuUy1bOI+I4oQpqyli33CiCPoed6jLkYOaKo=","text":"More Details\r\nClear the Draft Mode cookie\r\nBy default, the Draft Mode session ends when the browser is closed. To clear the Draft Mode cookie manually, create an API route that calls setDraftMode({ enable: false }):\r\npages/api/disable-draft.ts (ts)export default function handler(req, res) {\r\n  res.setDraftMode({ enable: false })\r\n}\r\nThen, send a request to /api/disable-draft to invoke the API Route. If calling this route using next/link, you must pass\r\nprefetch={false} to prevent accidentally deleting the cookie on prefetch. Works with getServerSidePropsgetServerSideProps\r\nDraft Mode works with getServerSideProps, and is available as a draftMode key in the context object. Good to know: You shouldn’t set the Cache-Control header when using Draft Mode because it cannot be bypassed. Instead,\r\nwe recommend using ISR. Works with API Routes\r\nAPI Routes will have access to draftMode on the request object. For example:\r\nexport default function myApiRoute(req, res) {\r\n  if (req.draftMode) {\r\n    // get draft data\r\n  }\r\n}\r\nUnique per next buildnext build\r\nA new bypass cookie value will be generated each time you run next build. This ensures that the bypass cookie can’t be guessed. Good to know: To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage\r\naccess.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d3f75f00-b3ed-45dc-9ff8-3b3e4bc7be36":{"id_":"d3f75f00-b3ed-45dc-9ff8-3b3e4bc7be36","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QRMXhZc4twSU15RDwMIsN5HCFKxjXB7v99xHX8oTGlA=","metadata":{},"hash":"qp/ebfTWx0gI/v+NEjO54avkuVgzOMIDe2lbPQRaVTo="}},"hash":"oYJ3h+pjUzptQlBQjFUrnj3reoyOilUcbD4Ez63N4hE=","text":"4.1.6.12 - Error Handling\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/12-error-handling\r\nDescription: Handle errors in your Next.js app. This documentation explains how you can handle development, server-side, and client-side errors. Handling Errors in Development\r\nWhen there is a runtime error during the development phase of your Next.js application, you will encounter an overlay. It is a modal\r\nthat covers the webpage. It is only visible when the development server runs using next dev via pnpm dev, npm run dev, yarn dev,\r\nor bun dev and will not be shown in production. Fixing the error will automatically dismiss the overlay. Here is an example of an overlay:\r\n{/ TODO UPDATE SCREENSHOT /} \r\nHandling Server Errors\r\nNext.js provides a static 500 page by default to handle server-side errors that occur in your application. You can also customize this\r\npage by creating a pages/500.js file. Having a 500 page in your application does not show specific errors to the app user. You can also use 404 page to handle specific runtime error like file not found. Handling Client Errors\r\nReact Error Boundaries is a graceful way to handle a JavaScript error on the client so that the other parts of the application continue\r\nworking. In addition to preventing the page from crashing, it allows you to provide a custom fallback component and even log error\r\ninformation. To use Error Boundaries for your Next.js application, you must create a class component ErrorBoundary and wrap the Component\r\nprop in the pages/_app.js file. This component will be responsible to:\r\nRender a fallback UI after an error is thrown\r\nProvide a way to reset the Application’s state\r\nLog error information\r\nYou can create an ErrorBoundary class component by extending React.Component. For example:\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    // Define a state variable to track whether is an error or not\r\n    this.state = { hasError: false }\r\n  }\r\n  static getDerivedStateFromError(error) {\r\n    // Update state so the next render will show the fallback UI","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"046b52ef-362c-48e4-9513-1cd95c5fce77":{"id_":"046b52ef-362c-48e4-9513-1cd95c5fce77","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"y9BTpH+1Vjmw/FjZfMh/RTj9QMETtWdiCRhl54MRoTo=","metadata":{},"hash":"Wxx3INEHEp4V58Q7CVcMKaiUT9RA+ixImclLedgIjwE="}},"hash":"OkQB2F0A6tO8GGPWIGmxU6V43SGl956cexEH1t0Rt7A=","text":"return { hasError: true }\r\n  }\r\n  componentDidCatch(error, errorInfo) {\r\n    // You can use your own error logging service here\r\n    console.log({ error, errorInfo })\r\n  }\r\n  render() {\r\n    // Check if the error is thrown\r\n    if (this.state.hasError) {\r\n      // You can render any custom fallback UI\r\n      return (\r\n        <div>\r\n          <h2>Oops, there is an error!</h2>\r\n          <button\r\n            type=\"button\"\r\n            onClick={() => this.setState({ hasError: false })}\r\n          >\r\n            Try again? </button>\r\n        </div>\r\n      )\r\n    }\r\n    // Return children components in case of no error\r\n    return this.props.children\r\n  }\r\n}\r\nexport default ErrorBoundary\r\nThe ErrorBoundary component keeps track of an hasError state. The value of this state variable is a boolean. When the value of\r\nhasError is true, then the ErrorBoundary component will render a fallback UI. Otherwise, it will render the children components. After creating an ErrorBoundary component, import it in the pages/_app.js file to wrap the Component prop in your Next.js\r\napplication. // Import the ErrorBoundary component\r\nimport ErrorBoundary from '../components/ErrorBoundary'\r\nfunction MyApp({ Component, pageProps }) {\r\n  return (\r\n    // Wrap the Component prop with ErrorBoundary component\r\n    <ErrorBoundary>\r\n      <Component {...pageProps} />\r\n    </ErrorBoundary>\r\n  )\r\n}\r\nexport default MyApp\r\nYou can learn more about Error Boundaries in React’s documentation. Reporting Errors\r\nTo monitor client errors, use a service like Sentry, Bugsnag or Datadog.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bd859fd5-fe9f-427a-bd31-1c9e21440eb2":{"id_":"bd859fd5-fe9f-427a-bd31-1c9e21440eb2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"g0VoA5qqjv4oqexPdmVHPWWJZVNH7H6OIXmr9APbKF4=","metadata":{},"hash":"XXAk7MFvx6f0seSChieiMFefvZuXhvr5VeHbg0u0ezo="},"NEXT":{"nodeId":"c4641a64-9c4a-4249-ac59-cf1fc30bbe78","metadata":{},"hash":"FjI+ngobVFgIbJ33Q+oydx4P8bZQgRObo6vWwrZ5cH8="}},"hash":"vyaKczb+ai9z7tLIFEMelb1Bdxd86DtMHf6m14TmSjA=","text":"4.1.6.13 - Debugging\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/13-debugging\r\nDescription: Learn how to debug your Next.js application with VS Code or Chrome DevTools. This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using either\r\nthe VS Code debugger or Chrome DevTools. Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js\r\nDebugging Guide. Debugging with VS Code\r\nCreate a file named .vscode/launch.json at the root of your project with the following content:\r\nlaunch.json (json){\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"Next.js: debug server-side\",\r\n      \"type\": \"node-terminal\",\r\n      \"request\": \"launch\",\r\n      \"command\": \"npm run dev\"\r\n    },\r\n    {\r\n      \"name\": \"Next.js: debug client-side\",\r\n      \"type\": \"chrome\",\r\n      \"request\": \"launch\",\r\n      \"url\": \"http://localhost:3000\"\r\n    },\r\n    {\r\n      \"name\": \"Next.js: debug full stack\",\r\n      \"type\": \"node-terminal\",\r\n      \"request\": \"launch\",\r\n      \"command\": \"npm run dev\",\r\n      \"serverReadyAction\": {\r\n        \"pattern\": \"- Local:.+(https?://.+)\",\r\n        \"uriFormat\": \"%s\",\r\n        \"action\": \"debugWithChrome\"\r\n      }\r\n    }\r\n  ]\r\n}\r\nnpm run dev can be replaced with yarn dev if you’re using Yarn or pnpm dev if you’re using pnpm. If you’re changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you’re using\r\ninstead. If you’re running Next.js from a directory other than root (for example, if you’re using Turborepo) then you need to add cwd to the\r\nserver-side and full stack debugging tasks. For example, \"cwd\": \"${workspaceFolder}/apps/web\". Now go to the Debug panel (Ctrl+Shift+D on Windows/Linux, ⇧+⌘+D on macOS), select a launch configuration, then press F5 or\r\nselect Debug: Start Debugging from the Command Palette to start your debugging session.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c4641a64-9c4a-4249-ac59-cf1fc30bbe78":{"id_":"c4641a64-9c4a-4249-ac59-cf1fc30bbe78","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"g0VoA5qqjv4oqexPdmVHPWWJZVNH7H6OIXmr9APbKF4=","metadata":{},"hash":"XXAk7MFvx6f0seSChieiMFefvZuXhvr5VeHbg0u0ezo="},"PREVIOUS":{"nodeId":"bd859fd5-fe9f-427a-bd31-1c9e21440eb2","metadata":{},"hash":"vyaKczb+ai9z7tLIFEMelb1Bdxd86DtMHf6m14TmSjA="}},"hash":"FjI+ngobVFgIbJ33Q+oydx4P8bZQgRObo6vWwrZ5cH8=","text":"Using the Debugger in Jetbrains WebStorm\r\nClick the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a Javascript Debug debug\r\nconfiguration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file),\r\nand click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2\r\napplications in debug mode: the NextJS node application, and the client/ browser application. Debugging with Chrome DevTools\r\nClient-side code\r\nStart your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open\r\nhttp://localhost:3000 (or your alternate URL) in Chrome. Next, open Chrome’s Developer Tools (Ctrl+Shift+J on","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6be5359a-c6ad-484d-b04f-4ea95160efe8":{"id_":"6be5359a-c6ad-484d-b04f-4ea95160efe8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rfwJBYjmfPH7FQtjCvVuaZvXPc3bXbnsRWYX6xyogAk=","metadata":{},"hash":"/Nh5UV+spI0YHJ8RYOVdXRaPz/KBZ3pEms52724Fj8E="},"NEXT":{"nodeId":"c0d52fde-e3d3-4865-ac92-fffc27c2396a","metadata":{},"hash":"x0aL8tsouZF+SiXsQZwv45sdSgXzGAJO0d4mFKUMlwc="}},"hash":"kN4AwXNMx/4R4l9vnnAjmBgPuoed1f+bAf7FUmnDosk=","text":"Windows/Linux, ⌥+⌘+I on macOS), then go to the Sources tab. Now, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug\r\narea. You can also press Ctrl+P on Windows/Linux or ⌘+P on macOS to search for a file and set breakpoints manually. Note that when\r\nsearching here, your source files will have paths starting with webpack://_N_E/./. Server-side code\r\nTo debug server-side Next.js code with Chrome DevTools, you need to pass the --inspect flag to the underlying Node.js process:\r\nTerminal (bash)NODE_OPTIONS='--inspect' next dev\r\nIf you’re using npm run dev or yarn dev then you should update the dev script on your package.json:\r\npackage.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"NODE_OPTIONS='--inspect' next dev\"\r\n  }\r\n}\r\nLaunching the Next.js dev server with the --inspect flag will look something like this:\r\nTerminal (bash)Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95\r\nFor help, see: https://nodejs.org/en/docs/inspector\r\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\r\nBe aware that running NODE_OPTIONS='--inspect' npm run dev or NODE_OPTIONS='--inspect' yarn dev won’t work. This would try to start multiple debuggers on the same port: one for the npm/yarn process and one for Next.js. You would then\r\nget an error like Starting inspector on 127.0.0.1:9229 failed: address already in use in your console. Once the server starts, open a new tab in Chrome and visit chrome://inspect, where you should see your Next.js application inside\r\nthe Remote Target section. Click inspect under your application to open a separate DevTools window, then go to the Sources tab.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c0d52fde-e3d3-4865-ac92-fffc27c2396a":{"id_":"c0d52fde-e3d3-4865-ac92-fffc27c2396a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rfwJBYjmfPH7FQtjCvVuaZvXPc3bXbnsRWYX6xyogAk=","metadata":{},"hash":"/Nh5UV+spI0YHJ8RYOVdXRaPz/KBZ3pEms52724Fj8E="},"PREVIOUS":{"nodeId":"6be5359a-c6ad-484d-b04f-4ea95160efe8","metadata":{},"hash":"kN4AwXNMx/4R4l9vnnAjmBgPuoed1f+bAf7FUmnDosk="}},"hash":"x0aL8tsouZF+SiXsQZwv45sdSgXzGAJO0d4mFKUMlwc=","text":"Click inspect under your application to open a separate DevTools window, then go to the Sources tab. Debugging server-side code here works much like debugging client-side code with Chrome DevTools, except that when you search for\r\nfiles here with Ctrl+P or ⌘+P, your source files will have paths starting with webpack://{application-name}/./ (where\r\n{application-name} will be replaced with the name of your application according to your package.json file). Debugging on Windows\r\nWindows users may run into an issue when using NODE_OPTIONS='--inspect' as that syntax is not supported on Windows platforms. To get around this, install the cross-env package as a development dependency (-D with npm and yarn) and replace the dev script\r\nwith the following. package.json (json){\r\n  \"scripts\": {\r\n    \"dev\": \"cross-env NODE_OPTIONS='--inspect' next dev\"\r\n  }\r\n}\r\ncross-env will set the NODE_OPTIONS environment variable regardless of which platform you are on (including Mac, Linux, and\r\nWindows) and allow you to debug consistently across devices and operating systems. Good to know: Ensure Windows Defender is disabled on your machine. This external service will check every file read, which\r\nhas been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does\r\naffect Next.js development. More information\r\nTo learn more about how to use a JavaScript debugger, take a look at the following documentation:\r\nNode.js debugging in VS Code: Breakpoints\r\nChrome DevTools: Debug JavaScript","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"81e3d0d9-d889-4de2-8896-c16728bec5aa":{"id_":"81e3d0d9-d889-4de2-8896-c16728bec5aa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uyBOFmmnScRv8t81BIgPzpMGRRv8GdfUKhdrgEghwL4=","metadata":{},"hash":"Uh76SfclOWq0gqPT5RWLf/5aTlPQ6y3S2qvZrOTqoSw="},"NEXT":{"nodeId":"06b4c176-e808-4c72-ad1e-ec9844b83bf7","metadata":{},"hash":"/nIBjhlwK6kw9AFYqArFqRktlgbujpFOtnLq4o6PyLg="}},"hash":"jZjzXse5QCcjLuZ/6V6LPSN8Dkx+HCf0H0ApiaMfIcM=","text":"4.1.6.14 - Preview Mode\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/14-preview-mode\r\nDescription: Next.js has the preview mode for statically generated pages. You can learn how it works here. Note: This feature is superseded by Draft Mode. Examples\r\nIn the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static\r\nGeneration) using getStaticProps and getStaticPaths. Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your\r\nheadless CMS and want to preview the draft immediately on your page. You’d want Next.js to render these pages at request time\r\ninstead of build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only\r\nfor this specific case. Next.js has a feature called Preview Mode which solves this problem. Here are instructions on how to use it. Step 1: Create and access a preview API route\r\nTake a look at the API Routes documentation first if you’re not familiar with Next.js API Routes. First, create a preview API route. It can have any name - e.g. pages/api/preview.js (or .ts if using TypeScript). In this API route, you need to call setPreviewData on the response object. The argument for setPreviewData should be an object,\r\nand this can be used by getStaticProps (more on this later). For now, we’ll use {}. export default function handler(req, res) {\r\n  // ... res.setPreviewData({})\r\n  // ... }\r\nres.setPreviewData sets some cookies on the browser which turns on the preview mode. Any requests to Next.js containing these\r\ncookies will be considered as the preview mode, and the behavior for statically generated pages will change (more on this later). You can test this manually by creating an API route like below and accessing it from your browser manually:\r\npages/api/preview.js (js)// simple example for testing it manually from your browser.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"06b4c176-e808-4c72-ad1e-ec9844b83bf7":{"id_":"06b4c176-e808-4c72-ad1e-ec9844b83bf7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uyBOFmmnScRv8t81BIgPzpMGRRv8GdfUKhdrgEghwL4=","metadata":{},"hash":"Uh76SfclOWq0gqPT5RWLf/5aTlPQ6y3S2qvZrOTqoSw="},"PREVIOUS":{"nodeId":"81e3d0d9-d889-4de2-8896-c16728bec5aa","metadata":{},"hash":"jZjzXse5QCcjLuZ/6V6LPSN8Dkx+HCf0H0ApiaMfIcM="}},"hash":"/nIBjhlwK6kw9AFYqArFqRktlgbujpFOtnLq4o6PyLg=","text":"export default function handler(req, res) {\r\n  res.setPreviewData({})\r\n  res.end('Preview mode enabled')\r\n}\r\nIf you open your browser’s developer tools and visit /api/preview, you’ll notice that the __prerender_bypass and\r\n__next_preview_data cookies will be set on this request. Securely accessing it from your Headless CMS\r\nIn practice, you’d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless\r\nCMS you’re using, but here are some common steps you could take. These steps assume that the headless CMS you’re using supports setting custom preview URLs. If it doesn’t, you can still use this\r\nmethod to secure your preview URLs, but you’ll need to construct and access the preview URL manually. First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js\r\napp and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing preview URLs. Second, if your headless CMS supports setting custom preview URLs, specify the following as the preview URL. This assumes that your\r\npreview API route is located at pages/api/preview.js. Terminal (bash)https://<your-site>/api/preview?secret=<token>&slug=<path>\r\n<your-site> should be your deployment domain. <token> should be replaced with the secret token you generated. <path> should be the path for the page that you want to preview. If you want to preview /posts/foo, then you should use\r\n&slug=/posts/foo.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0c40d27c-32a4-41ac-82a6-e5418eae7605":{"id_":"0c40d27c-32a4-41ac-82a6-e5418eae7605","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vGS3LgHBhiIRaIi5+ruhSPAqJEtChsp7UGZR/X1BqRs=","metadata":{},"hash":"X/v/Tr0v8AoFEHdcB53tUS3u81zHhUfQb+iIIyMq3Bg="},"NEXT":{"nodeId":"3ee5e904-f42f-4046-b020-5c0c21820866","metadata":{},"hash":"wUwTraA1k4hqJlS8V4pjELLkxrAgQUyAy2aMQAlyqRU="}},"hash":"nH1qghT2Zz0biK4+EEom9zutXFSy35IZumyEvIfdpPY=","text":"Your headless CMS might allow you to include a variable in the preview URL so that <path> can be set dynamically based on the CMS’s\r\ndata like so: &slug=/posts/{entry.fields.slug}\r\nFinally, in the preview API route:\r\n- Check that the secret matches and that the slugslug parameter exists (if not, the\r\nrequest should fail). Call res.setPreviewData. Then redirect the browser to the path specified by slug. (The following example uses a 307 redirect). export default async (req, res) => {\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this API route and the CMS\r\n  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(req.query.slug)\r\n  // If the slug doesn't exist prevent preview mode from being enabled\r\n  if (!post) {\r\n    return res.status(401).json({ message: 'Invalid slug' })\r\n  }\r\n  // Enable Preview Mode by setting the cookies\r\n  res.setPreviewData({})\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities\r\n  res.redirect(post.slug)\r\n}\r\nIf it succeeds, then the browser will be redirected to the path you want to preview with the preview mode cookies being set. Step 2: Update getStaticPropsgetStaticProps\r\nThe next step is to update getStaticProps to support the preview mode. If you request a page which has getStaticProps with the preview mode cookies set (via res.setPreviewData), then\r\ngetStaticProps will be called at request time (instead of at build time). Furthermore, it will be called with a context object where:\r\ncontext.preview will be true. context.previewData will be the same as the argument used for setPreviewData. export async function getStaticProps(context) {\r\n  // If you request this page with the preview mode cookies set:\r\n  //\r\n  // - context.preview will be true\r\n  // - context.previewData will be the same as\r\n  //   the argument used for `setPreviewData`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3ee5e904-f42f-4046-b020-5c0c21820866":{"id_":"3ee5e904-f42f-4046-b020-5c0c21820866","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vGS3LgHBhiIRaIi5+ruhSPAqJEtChsp7UGZR/X1BqRs=","metadata":{},"hash":"X/v/Tr0v8AoFEHdcB53tUS3u81zHhUfQb+iIIyMq3Bg="},"PREVIOUS":{"nodeId":"0c40d27c-32a4-41ac-82a6-e5418eae7605","metadata":{},"hash":"nH1qghT2Zz0biK4+EEom9zutXFSy35IZumyEvIfdpPY="}},"hash":"wUwTraA1k4hqJlS8V4pjELLkxrAgQUyAy2aMQAlyqRU=","text":"}\r\nWe used res.setPreviewData({}) in the preview API route, so context.previewData will be {}. You can use this to pass session\r\ninformation from the preview API route to getStaticProps if necessary. If you’re also using getStaticPaths, then context.params will also be available. Fetch preview data\r\nYou can update getStaticProps to fetch different data based on context.preview and/or context.previewData. For example, your headless CMS might have a different API endpoint for draft posts. If so, you can use context.preview to modify the\r\nAPI endpoint URL like below:\r\nexport async function getStaticProps(context) {\r\n  // If context.preview is true, append \"/preview\" to the API endpoint","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4b28bf40-d6a0-46d7-847c-32f6ca4ba2d3":{"id_":"4b28bf40-d6a0-46d7-847c-32f6ca4ba2d3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"r61ZoDqdDojV1pMEiWnCHZvnu905MHqiK/Kfu4XIQ7Q=","metadata":{},"hash":"b0miKFjub7rQtOn77khPmIYvo/Cu34/BrcSpHUlOnPw="},"NEXT":{"nodeId":"15674bda-5df6-42d2-8dd5-755249b57fe0","metadata":{},"hash":"VMWPBBsrZrDtuGXOE1LFsIztOzxGtJJhCDcHnmPu6ak="}},"hash":"HnDzV25wDDX30eTYGur2iICUTzSnJogoWxpa/bfJ5cM=","text":"// to request draft data instead of published data. This will vary\r\n  // based on which headless CMS you're using. const res = await fetch(`https://.../${context.preview ? 'preview' : ''}`)\r\n  // ... }\r\nThat’s it! If you access the preview API route (with secret and slug) from your headless CMS or manually, you should now be able to\r\nsee the preview content. And if you update your draft without publishing, you should be able to preview the draft. Set this as the preview URL on your headless CMS or access manually, and you should be able to see the preview. Terminal (bash)https://<your-site>/api/preview?secret=<token>&slug=<path>\r\nMore Details\r\nGood to know: during rendering next/router exposes an isPreview flag, see the router object docs for more info. Specify the Preview Mode duration\r\nsetPreviewData takes an optional second parameter which should be an options object. It accepts the following keys:\r\nmaxAge: Specifies the number (in seconds) for the preview session to last for. path: Specifies the path the cookie should be applied under. Defaults to / enabling preview mode for all paths. setPreviewData(data, {\r\n  maxAge: 60 * 60, // The preview mode cookies expire in 1 hour\r\n  path: '/about', // The preview mode cookies apply to paths with /about\r\n})\r\nClear the Preview Mode cookies\r\nBy default, no expiration date is set for Preview Mode cookies, so the preview session ends when the browser is closed. To clear the Preview Mode cookies manually, create an API route that calls clearPreviewData():\r\npages/api/clear-preview-mode-cookies.js (js)export default function handler(req, res) {\r\n  res.clearPreviewData({})\r\n}\r\nThen, send a request to /api/clear-preview-mode-cookies to invoke the API Route. If calling this route using next/link, you\r\nmust pass prefetch={false} to prevent calling clearPreviewData during link prefetching.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"15674bda-5df6-42d2-8dd5-755249b57fe0":{"id_":"15674bda-5df6-42d2-8dd5-755249b57fe0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"r61ZoDqdDojV1pMEiWnCHZvnu905MHqiK/Kfu4XIQ7Q=","metadata":{},"hash":"b0miKFjub7rQtOn77khPmIYvo/Cu34/BrcSpHUlOnPw="},"PREVIOUS":{"nodeId":"4b28bf40-d6a0-46d7-847c-32f6ca4ba2d3","metadata":{},"hash":"HnDzV25wDDX30eTYGur2iICUTzSnJogoWxpa/bfJ5cM="}},"hash":"VMWPBBsrZrDtuGXOE1LFsIztOzxGtJJhCDcHnmPu6ak=","text":"If a path was specified in the setPreviewData call, you must pass the same path to clearPreviewData:\r\npages/api/clear-preview-mode-cookies.js (js)export default function handler(req, res) {\r\n  const { path } = req.query\r\n  res.clearPreviewData({ path })\r\n}\r\npreviewDatapreviewData size limits\r\nYou can pass an object to setPreviewData and have it be available in getStaticProps. However, because the data will be stored in a\r\ncookie, there’s a size limitation. Currently, preview data is limited to 2KB. Works with getServerSidePropsgetServerSideProps\r\nThe preview mode works on getServerSideProps as well. It will also be available on the context object containing preview and\r\npreviewData. Good to know: You shouldn’t set the Cache-Control header when using Preview Mode because it cannot be bypassed. Instead, we recommend using ISR. Works with API Routes\r\nAPI Routes will have access to preview and previewData under the request object. For example:","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6b082d25-07a1-47ff-9561-22357bf88dc8":{"id_":"6b082d25-07a1-47ff-9561-22357bf88dc8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Y3rkAbSLLzn8Uqd12hdtaxOjHvLI+pfhDpaSx/tsUGI=","metadata":{},"hash":"PpSyEb2xM8XyT81gmnEXYQ2oawQTCR4o27EUVIcUksg="}},"hash":"rUzA6uLKnnXUrbDCNlU6XQhP8heOO8n8tW+Uvy2cnIU=","text":"export default function myApiRoute(req, res) {\r\n  const isPreview = req.preview\r\n  const previewData = req.previewData\r\n  // ... }\r\nUnique per next buildnext build\r\nBoth the bypass cookie value and the private key for encrypting the previewData change when next build is completed. This\r\nensures that the bypass cookie can’t be guessed. Good to know: To test Preview Mode locally over HTTP your browser will need to allow third-party cookies and local storage\r\naccess.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cdfeb4da-64b0-4319-b14a-32bacaa7a51d":{"id_":"cdfeb4da-64b0-4319-b14a-32bacaa7a51d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"x89eQqbEGSPZYLwcemjOhP+JNdjnfUmTsApb0lp2/m8=","metadata":{},"hash":"U9aICWgBCgCGbLkUWlRh1NbB+5Bg848Mz+dKWiGCBxc="}},"hash":"8YT52Nwkf7/OhU1fSCBhb2DCXzP9zOxc9jfdYGDVkuM=","text":"4.1.6.15 - Content Security Policy\r\nDocumentation path: /03-pages/01-building-your-application/06-configuring/15-content-security-policy\r\nDescription: Learn how to set a Content Security Policy (CSP) for your Next.js application. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"47bbc133-8302-4383-a36b-2b8f24d914fa":{"id_":"47bbc133-8302-4383-a36b-2b8f24d914fa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sPkZnoou8VVOKXtAwn+EGbOGWsNSb0cSWW9SPbRHY8Y=","metadata":{},"hash":"2kdVvIWPALUQuOdg3ae/dnN7X+58IukZ+Qrsy20OYlM="}},"hash":"FtKqKgAAQLVKH0tepRE11Cm6hPlqwNzXIDZACeXWIxM=","text":"4.1.7 - Testing\r\nDocumentation path: /03-pages/01-building-your-application/07-testing/index\r\nDescription: Learn how to set up Next.js with three commonly used testing tools — Cypress, Playwright, Vitest, and Jest. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"47417055-4f6b-47c1-a864-905ac01769ab":{"id_":"47417055-4f6b-47c1-a864-905ac01769ab","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HmLnVIqQjNgjPpMyrHIvRTIP0tn8FkfIMzFBUZksXac=","metadata":{},"hash":"iJc3FilsvDZbJG2GzC4tX2cDMyW6kQk0WLKggnGpphc="}},"hash":"aPR6iNyKokZJSufgGCC/Xqj0Y8Qn0XUGmMu/bciOrt8=","text":"4.1.7.1 - Setting up Vitest with Next.js\r\nDocumentation path: /03-pages/01-building-your-application/07-testing/01-vitest\r\nDescription: Learn how to set up Next.js with Vitest and React Testing Library - two popular unit testing libraries. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"15e798eb-9550-49ad-9817-14c29e795846":{"id_":"15e798eb-9550-49ad-9817-14c29e795846","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"080zlvoudstR72VAzXdGQ9hptm0uoCHY8Q2urc+pI90=","metadata":{},"hash":"hfXEzFFypeFLCaUv75B7A+9euw572G8B98tWPvCh24Q="}},"hash":"SQ2W1S+3LgTEfhAqv23SNZFAx+cWs524Sy90FJbnqV8=","text":"4.1.7.2 - Setting up Jest with Next.js\r\nDocumentation path: /03-pages/01-building-your-application/07-testing/02-jest\r\nDescription: Learn how to set up Next.js with Jest for Unit Testing. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2d03bea3-13ac-4da2-94e9-0104d356d636":{"id_":"2d03bea3-13ac-4da2-94e9-0104d356d636","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J7sefgcbJc2bINjHqPOfrYIpgraFCM8H9Pgl6tz1jaI=","metadata":{},"hash":"LP5rAtwsWSL0rIPROcYN7+NpMxL7xpx5qkVC25PrR44="}},"hash":"fxchtZuGNLCMaaDQcFJ6ora6X5ufnYeiZdVqX2xtP1U=","text":"4.1.7.3 - Setting up Playwright with Next.js\r\nDocumentation path: /03-pages/01-building-your-application/07-testing/03-playwright\r\nDescription: Learn how to set up Next.js with Playwright for End-to-End (E2E) and Integration testing. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4a6e44d0-86e5-4ace-b724-26d066c00a37":{"id_":"4a6e44d0-86e5-4ace-b724-26d066c00a37","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"f4Z9pqSZfSKi4/FUeZpZ9f27r8Xqg2wA1C+ZHupSdzU=","metadata":{},"hash":"crtaal7r+3gzkv858wD8zWki8eljpCDXkjWXWxb1EWo="}},"hash":"Ug+qkl0WlitmSFAScO+OCh6BmPrL8eKpHCyQAx7lGic=","text":"4.1.7.4 - Setting up Cypress with Next.js\r\nDocumentation path: /03-pages/01-building-your-application/07-testing/04-cypress\r\nDescription: Learn how to set up Next.js with Cypress for End-to-End (E2E) and Component Testing. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e061aa91-7f68-414c-8f0f-d9ee5e7359d1":{"id_":"e061aa91-7f68-414c-8f0f-d9ee5e7359d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"B0l7i8OiDi3QUV7s6gphlCiaut6MxqXYojEx3N4zo3c=","metadata":{},"hash":"wRADufGDcMlTViN7244liVcb7debDsdMFhbpZ88anzI="}},"hash":"Um29afQIO8feTTCPThDF6IAZ/tPe5gftaWB6u701ojM=","text":"4.1.8 - Deploying\r\nDocumentation path: /03-pages/01-building-your-application/08-deploying/index\r\nDescription: Learn how to deploy your Next.js app to production, either managed or self-hosted. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d5879558-a90d-425f-8ea2-1aac98f7c9c7":{"id_":"d5879558-a90d-425f-8ea2-1aac98f7c9c7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yAQlSR1LvJ0x1O7Xcg/NlJNSTbxeWJ6PZZNei29+R6o=","metadata":{},"hash":"d/r7iPYza5dqWs2uQJJtEgoy9D7I+qPXF2w1NEoiY88="},"NEXT":{"nodeId":"6bb68b91-52a0-4eb6-8565-26f02c36b8a0","metadata":{},"hash":"rQh5MQMRF6IIZrP0WdbNvZoV4HCadj+apxj/rc/ZIuY="}},"hash":"TwkvOXYPz6IbfJUwEl4T8dPsJwrGaxygk3ilHGZ7FMI=","text":"4.1.8.1 - Going to Production\r\nDocumentation path: /03-pages/01-building-your-application/08-deploying/01-production-checklist\r\nDescription: Before taking your Next.js application to production, here are some recommendations to ensure the best user\r\nexperience. Before taking your Next.js application to production, here are some recommendations to ensure the best user experience. In General\r\nUse caching wherever possible. Ensure your database and backend are deployed in the same region. Aim to ship the least amount of JavaScript possible. Defer loading heavy JavaScript bundles until needed. Ensure logging is set up. Ensure error handling is set up. Configure the 404 (Not Found) and 500 (Error) pages. Ensure you are measuring performance. Run Lighthouse to check for performance, best practices, accessibility, and SEO. For best results, use a production build of Next.js\r\nand use incognito in your browser so results aren’t affected by extensions. Review Supported Browsers and Features. Improve performance using:next/image\r\n and Automatic Image Optimization\r\nAutomatic Font Optimization\r\nScript Optimization\r\nImprove loading performance\r\nConsider adding a Content Security Policy\r\nCaching\r\nExamples\r\n- [ssr-caching](https://github.com/vercel/next.js/tree/canary/examples/ssr-caching)\r\nCaching improves response times and reduces the number of requests to external services. Next.js automatically adds caching headers\r\nto immutable assets served from /_next/static including JavaScript, CSS, static images, and other media. Cache-Control: public, max-age=31536000, immutable\r\nCache-Control headers set in next.config.js will be overwritten in production to ensure that static assets can be cached\r\neffectively. If you need to revalidate the cache of a page that has been statically generated, you can do so by setting revalidate in the\r\npage’s getStaticProps function. If you’re using next/image, you can configure the minimumCacheTTL for the default Image\r\nOptimization loader. Good to know: When running your application locally with next dev, your headers are overwritten to prevent caching locally. Cache-Control: no-cache, no-store, max-age=0, must-revalidate\r\nYou can also use caching headers inside getServerSideProps and API Routes for dynamic responses. For example, using stale-\r\nwhile-revalidate. // This value is considered fresh for ten seconds (s-maxage=10).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6bb68b91-52a0-4eb6-8565-26f02c36b8a0":{"id_":"6bb68b91-52a0-4eb6-8565-26f02c36b8a0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yAQlSR1LvJ0x1O7Xcg/NlJNSTbxeWJ6PZZNei29+R6o=","metadata":{},"hash":"d/r7iPYza5dqWs2uQJJtEgoy9D7I+qPXF2w1NEoiY88="},"PREVIOUS":{"nodeId":"d5879558-a90d-425f-8ea2-1aac98f7c9c7","metadata":{},"hash":"TwkvOXYPz6IbfJUwEl4T8dPsJwrGaxygk3ilHGZ7FMI="}},"hash":"rQh5MQMRF6IIZrP0WdbNvZoV4HCadj+apxj/rc/ZIuY=","text":"// This value is considered fresh for ten seconds (s-maxage=10). // If a request is repeated within the next 10 seconds, the previously\r\n// cached value will still be fresh. If the request is repeated before 59 seconds,\r\n// the cached value will be stale but still render (stale-while-revalidate=59). //\r\n// In the background, a revalidation request will be made to populate the cache\r\n// with a fresh value. If you refresh the page, you will see the new value. export async function getServerSideProps({ req, res }) {\r\n  res.setHeader(\r\n    'Cache-Control',\r\n    'public, s-maxage=10, stale-while-revalidate=59'\r\n  )\r\n  return {\r\n    props: {},\r\n  }","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"789537f3-8a92-45bf-8d1f-9ea1d38ac1c2":{"id_":"789537f3-8a92-45bf-8d1f-9ea1d38ac1c2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9GWHTVNJsJiYfi8JZDLaBj9M+vqu2DJYgMXtJIE9VWo=","metadata":{},"hash":"JndrHAWG0TbbNVTv3gJB79IGB8qTkr3Buh4zIL83j3o="},"NEXT":{"nodeId":"705c292d-7aee-4cbe-8507-8b4873a426c7","metadata":{},"hash":"2q56xsvj4j+DX7rGG+JIryIJj1+Q3Xe8IeLjguhnd3E="}},"hash":"AGr9LFZM2LbFlT75zF7BiUyPZdX0945ZI4KplR7W0LQ=","text":"}\r\nBy default, Cache-Control headers will be set differently depending on how your page fetches data. If the page uses getServerSideProps or getInitialProps, it will use the default Cache-Control header set by next start in\r\norder to prevent accidental caching of responses that cannot be cached. If you want a different cache behavior while usinggetServerSideProps\r\n, use res.setHeader('Cache-Control', 'value_you_prefer') inside of the function as shown above. If the page is using getStaticProps, it will have a Cache-Control header of s-maxage=REVALIDATE_SECONDS, stale-while-\r\nrevalidate, or if revalidate is not used, s-maxage=31536000, stale-while-revalidate to cache for the maximum age\r\npossible. Good to know: Your deployment provider must support caching for dynamic responses. If you are self-hosting, you will need to\r\nadd this logic yourself using a key/value store like Redis. If you are using Vercel, Edge Caching works without configuration. Reducing JavaScript Size\r\nExamples\r\n- [with-dynamic-import](https://github.com/vercel/next.js/tree/canary/examples/with-dynamic-import)\r\nTo reduce the amount of JavaScript sent to the browser, you can use the following tools to understand what is included inside each\r\nJavaScript bundle:\r\nImport Cost – Display the size of the imported package inside VSCode. Package Phobia – Find the cost of adding a new dev dependency to your project. Bundle Phobia - Analyze how much a dependency can increase bundle sizes. Webpack Bundle Analyzer – Visualize the size of webpack output files with an interactive, zoomable treemap. bundlejs - An online tool to quickly bundle & minify your projects, while viewing the compressed gzip/brotli bundle size, all running\r\nlocally on your browser. Each file inside your pages/ directory will automatically be code split into its own JavaScript bundle during next build. You can also\r\nuse Dynamic Imports to lazy-load components and libraries. For example, you might want to defer loading your modal code until a user\r\nclicks the open button.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"705c292d-7aee-4cbe-8507-8b4873a426c7":{"id_":"705c292d-7aee-4cbe-8507-8b4873a426c7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"9GWHTVNJsJiYfi8JZDLaBj9M+vqu2DJYgMXtJIE9VWo=","metadata":{},"hash":"JndrHAWG0TbbNVTv3gJB79IGB8qTkr3Buh4zIL83j3o="},"PREVIOUS":{"nodeId":"789537f3-8a92-45bf-8d1f-9ea1d38ac1c2","metadata":{},"hash":"AGr9LFZM2LbFlT75zF7BiUyPZdX0945ZI4KplR7W0LQ="}},"hash":"2q56xsvj4j+DX7rGG+JIryIJj1+Q3Xe8IeLjguhnd3E=","text":"Logging\r\nExamples\r\n- [Pino and Logflare Example](https://github.com/Logflare/next-pino-logflare-logging-example)\r\nSince Next.js runs on both the client and server, there are multiple forms of logging supported:\r\nconsole.log in the browser\r\nstdout on the server\r\nIf you want a structured logging package, we recommend Pino. If you’re using Vercel, there are pre-built logging integrations\r\ncompatible with Next.js. Error Handling\r\nExamples\r\n- [with-sentry](https://github.com/vercel/next.js/tree/canary/examples/with-sentry)\r\nWhen an unhandled exception occurs, you can control the experience for your users with the 500 page. We recommend customizing\r\nthis to your brand instead of the default Next.js theme. You can also log and track exceptions with a tool like Sentry. This example shows how to catch & report errors on both the client and\r\nserver-side, using the Sentry SDK for Next.js. There’s also a Sentry integration for Vercel. Loading Performance\r\nTo improve loading performance, you first need to determine what to measure and how to measure it. Core Web Vitals is a good\r\nindustry standard that is measured using your own web browser. If you are not familiar with the metrics of Core Web Vitals, review this\r\nblog post and determine which specific metric/s will be your drivers for loading performance. Ideally, you would want to measure the\r\nloading performance in the following environments:\r\nIn the lab, using your own computer or a simulator. In the field, using real-world data from actual visitors. Local, using a test that runs on your device. Remote, using a test that runs in the cloud.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dbfe495d-7661-4525-a9c8-863bf12dc581":{"id_":"dbfe495d-7661-4525-a9c8-863bf12dc581","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"C8LlxYmYlHU4RcG+0TvLAfpgYRE8HdC/AUEgfrKAKcE=","metadata":{},"hash":"g3etTKaY+OnSuYY3mj2wCgbps+dXVa71/58VyorzY8c="}},"hash":"NaTRc6ADolCHH+K2ffWlOYvkPdKNmo+m1bWWLqBbedQ=","text":"Once you are able to measure the loading performance, use the following strategies to improve it iteratively so that you apply one\r\nstrategy, measure the new performance and continue tweaking until you do not see much improvement. Then, you can move on to the\r\nnext strategy. Use caching regions that are close to the regions where your database or API is deployed. As described in the caching section, use a stale-while-revalidate value that will not overload your backend. Use Incremental Static Regeneration to reduce the number of requests to your backend. Remove unused JavaScript. Review this blog post to understand what Core Web Vitals metrics bundle size affects and what\r\nstrategies you can use to reduce it, such as:\r\nSetting up your Code Editor to view import costs and sizes\r\nFinding alternative smaller packages\r\nDynamically loading components and dependencies","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ffd24132-ae4a-4874-9679-569e0a71dd4b":{"id_":"ffd24132-ae4a-4874-9679-569e0a71dd4b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"KCOWbLHefyMIYkEEwSspHGmoroRJ/nOE5+SqqEXvv2w=","metadata":{},"hash":"5861ivufWXNbpUC8TFEvtg1VV14LUzXcQ6QmP7aT87Q="}},"hash":"0BuwwxLCiptpUGLwIcbYVQafDHkkKp5meHp5atnrwnM=","text":"4.1.8.2 - Static Exports\r\nDocumentation path: /03-pages/01-building-your-application/08-deploying/02-static-exports\r\nDescription: Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features\r\nthat require a server. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"58a4fd38-0312-46e8-8cdb-3c3bf123e12d":{"id_":"58a4fd38-0312-46e8-8cdb-3c3bf123e12d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sGXMRwa7vCA7CVvFMD/Xw/FwQJNgwey+e8/5ORvivVA=","metadata":{},"hash":"27U+or5uHTtcjn6ZvFeEUyY+3tZKDh0KhxCjBD27bRE="}},"hash":"nFQe6t5pwiuRv+Wt/ivAeyfxEwAJBrdetnFcY5T7tOc=","text":"4.1.8.3 - Multi Zones\r\nDocumentation path: /03-pages/01-building-your-application/08-deploying/03-multi-zones\r\nDescription: Learn how to use multi zones to deploy multiple Next.js apps as a single app. Examples\r\n- [With Zones](https://github.com/vercel/next.js/tree/canary/examples/with-zones)\r\nA zone is a single deployment of a Next.js app. You can have multiple zones and merge them as a single app. For example, let’s say you have the following apps:\r\nAn app for serving /blog/**\r\nAnother app for serving all other pages\r\nWith multi zones support, you can merge both these apps into a single one allowing your customers to browse it using a single URL, but\r\nyou can develop and deploy both apps independently. How to define a zone\r\nThere are no zone related APIs. You only need to do the following:\r\nMake sure to keep only the pages you need in your app, meaning that an app can’t have pages from another app, if app A has\r\n/blog then app B shouldn’t have it too. Make sure to configure a basePath to avoid conflicts with pages and static files. How to merge zones\r\nYou can merge zones using rewrites in one of the apps or any HTTP proxy. For Next.js on Vercel applications, you can use a monorepo to deploy both apps with a single git push.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a4c380c1-411d-4a57-81cd-c41d51b85b52":{"id_":"a4c380c1-411d-4a57-81cd-c41d51b85b52","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NZam4jfSAgE1mI2GddlDgr1QclWVxHnAW2sGEzaN20E=","metadata":{},"hash":"KrftBCFFaR2q/iOgcwz/gFi/k5MQpO3PDzPGLT/utGE="}},"hash":"dguALJDz6a6cx553sveePFS4dfCDN6hEm05Z6XYMi+g=","text":"4.1.8.4 - Continuous Integration (CI) Build Caching\r\nDocumentation path: /03-pages/01-building-your-application/08-deploying/04-ci-build-caching\r\nDescription: Learn how to configure CI to cache Next.js builds\r\nTo improve build performance, Next.js saves a cache to .next/cache that is shared between builds. To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly\r\npersist the cache between builds. If your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error. Here are some example cache configurations for common CI providers:\r\nVercel\r\nNext.js caching is automatically configured for you. There’s no action required on your part. CircleCI\r\nEdit your save_cache step in .circleci/config.yml to include .next/cache:\r\nsteps:\r\n  - save_cache:\r\n      key: dependency-cache-{{ checksum \"yarn.lock\" }}\r\n      paths:\r\n        - ./node_modules\r\n        - ./.next/cache\r\nIf you do not have a save_cache key, please follow CircleCI’s documentation on setting up build caching. Travis CI\r\nAdd or merge the following into your .travis.yml:\r\ncache:\r\n  directories:\r\n    - $HOME/.cache/yarn\r\n    - node_modules\r\n    - .next/cache\r\nGitLab CI\r\nAdd or merge the following into your .gitlab-ci.yml:\r\ncache:\r\n  key: ${CI_COMMIT_REF_SLUG}\r\n  paths:\r\n    - node_modules/\r\n    - .next/cache/\r\nNetlify CI\r\nUse Netlify Plugins with @netlify/plugin-nextjs. AWS CodeBuild\r\nAdd (or merge in) the following to your buildspec.yml:\r\ncache:\r\n  paths:\r\n    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`\r\n    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds\r\nGitHub Actions","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6c44c961-e5bc-45b8-ac79-9b7806f15b1d":{"id_":"6c44c961-e5bc-45b8-ac79-9b7806f15b1d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zxmWIvBnMXZiUXaJIaMZl7/fbf4uyb9D8nZxHjMexBQ=","metadata":{},"hash":"x5XxkWHWgUj6YEhm5IfyaUK/6iln4Rgp67BBPPQUlNw="},"NEXT":{"nodeId":"78339fde-355a-4017-8f99-a5b8a85ffbfc","metadata":{},"hash":"SyaAnSOa3i3Rd8xB9H2ccjMvvCC17Uh3pEss2Nl6Dc4="}},"hash":"aLI3Q3uXQxP45kU8upLvSlCxK4Li5E/pUGDDdx3t90w=","text":"Using GitHub’s actions/cache, add the following step in your workflow file:\r\nuses: actions/cache@v3\r\nwith:\r\n  # See here for caching with `yarn` https://github.com/actions/cache/blob/main/examples.md#node---yarn or you can leverage caching with actions/setup-node https://github.com/actions/setup-node\r\n  path: |\r\n    ~/.npm\r\n    ${{ github.workspace }}/.next/cache\r\n  # Generate a new cache whenever packages or source files change. key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}\r\n  # If source files changed but packages didn't, rebuild from a prior cache.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"78339fde-355a-4017-8f99-a5b8a85ffbfc":{"id_":"78339fde-355a-4017-8f99-a5b8a85ffbfc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zxmWIvBnMXZiUXaJIaMZl7/fbf4uyb9D8nZxHjMexBQ=","metadata":{},"hash":"x5XxkWHWgUj6YEhm5IfyaUK/6iln4Rgp67BBPPQUlNw="},"PREVIOUS":{"nodeId":"6c44c961-e5bc-45b8-ac79-9b7806f15b1d","metadata":{},"hash":"aLI3Q3uXQxP45kU8upLvSlCxK4Li5E/pUGDDdx3t90w="}},"hash":"SyaAnSOa3i3Rd8xB9H2ccjMvvCC17Uh3pEss2Nl6Dc4=","text":"restore-keys: |\r\n    ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-\r\nBitbucket Pipelines\r\nAdd or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines):\r\ndefinitions:\r\n  caches:\r\n    nextcache: .next/cache\r\nThen reference it in the caches section of your pipeline’s step:\r\n- step:\r\n    name: your_step_name\r\n    caches:\r\n      - node\r\n      - nextcache\r\nHeroku\r\nUsing Heroku’s custom cache, add a cacheDirectories array in your top-level package.json:\r\n\"cacheDirectories\": [\".next/cache\"]\r\nAzure Pipelines\r\nUsing Azure Pipelines’ Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next\r\nbuild:\r\n- task: Cache@2\r\n  displayName: 'Cache .next/cache'\r\n  inputs:\r\n    key: next | $(Agent.OS) | yarn.lock\r\n    path: '$(System.DefaultWorkingDirectory)/.next/cache'\r\nJenkins (Pipeline)\r\nUsing Jenkins’ Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm\r\ninstall:\r\nstage(\"Restore npm packages\") {\r\n    steps {\r\n        // Writes lock-file to cache based on the GIT_COMMIT hash\r\n        writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\r\n        cache(caches: [\r\n            arbitraryFileCache(\r\n                path: \"node_modules\",\r\n                includes: \"**/*\",\r\n                cacheValidityDecidingFile: \"package-lock.json\"\r\n            )\r\n        ]) {\r\n            sh \"npm install\"\r\n        }\r\n    }\r\n}\r\nstage(\"Build\") {\r\n    steps {\r\n        // Writes lock-file to cache based on the GIT_COMMIT hash","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"60a0cbdb-442d-44c6-b580-6d6c6f642bd9":{"id_":"60a0cbdb-442d-44c6-b580-6d6c6f642bd9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"k4iubZbg6KiSQeVGlfVMe5Y9tzTt9o2SXzQ2z2ONVfw=","metadata":{},"hash":"ZV+kaLYrs6yduWoE99b9M4NTgoRn7UUqZqZfpGbt5o4="}},"hash":"Loo0j1K/HJS5T2kFO7l3ZG5fpbAPtdDU0O6cBIFxOLU=","text":"writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\r\n        cache(caches: [\r\n            arbitraryFileCache(\r\n                path: \".next/cache\",\r\n                includes: \"**/*\",\r\n                cacheValidityDecidingFile: \"next-lock.cache\"\r\n            )\r\n        ]) {\r\n            // aka `next build`\r\n            sh \"npm run build\"\r\n        }\r\n    }\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e5377e61-6616-48c6-8a90-d0f23e8ff763":{"id_":"e5377e61-6616-48c6-8a90-d0f23e8ff763","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ra8qXIu+Gh+BurM4MnnhS/uvBLayidIW35FSIax5hFI=","metadata":{},"hash":"M3An2w56BJZwx8gvC4Q+xJaFeNNYwYqrziZ7rq0W8Hw="}},"hash":"oDY+efvYq+CAKE9sYFef0d/vUqDeZCuuashF6Hu1PQs=","text":"4.1.9 - Upgrading\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/index\r\nDescription: Learn how to upgrade to the latest versions of Next.js. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e0d2284c-5f70-488c-94b6-865e0309ee3d":{"id_":"e0d2284c-5f70-488c-94b6-865e0309ee3d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nkgA3rtGuhZK1t8XjxCO18682uSXMnOU1n62SL8qFnw=","metadata":{},"hash":"y3tz52W2vP1JNW2F6vvZSKmgo7HtmVM1HwZCIdllUng="}},"hash":"wJs2lxZmtakjlhLJ635/I4dNpkbaAcjXgzfxSXX1b8k=","text":"4.1.9.1 - Codemods\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/01-codemods\r\nDescription: Use codemods to upgrade your Next.js codebase when new features are released. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d4d54e84-1a37-4975-ab6e-9bc0dfcd6688":{"id_":"d4d54e84-1a37-4975-ab6e-9bc0dfcd6688","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"X8RudIx1QoL9x6X9oZYUNfeo7VOFlVvFciqtg25CtG8=","metadata":{},"hash":"AUChlQXtn4nWSRwmOGu407U9dY1gaoI4jbFDPiD2In8="}},"hash":"6M41fZQ9X3vBb9+TY3tkdTiEn1TkmN0tiaM2mWGrPyc=","text":"4.1.9.2 - From Pages to App\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/02-app-router-migration\r\nDescription: Learn how to upgrade your existing Next.js application from the Pages Router to the App Router. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"27578b8d-7a31-4cf6-825f-66bbf44447bf":{"id_":"27578b8d-7a31-4cf6-825f-66bbf44447bf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZIzAu+J/xAMU3tta+5jtherv+fggtmmIae96gULM9pI=","metadata":{},"hash":"vDdC8Xz6QjbRKSkZGtN8FwDIEM5S+1g0+Ra66VtgPCw="}},"hash":"Zmgiece4e2Z/bvF8sWYuXlXE90KWOitBcPjYmMZYYRY=","text":"4.1.9.3 - Version 14\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/03-version-14\r\nDescription: Upgrade your Next.js Application from Version 13 to 14. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fa8cda42-b321-4b12-97d5-34a47c8e0906":{"id_":"fa8cda42-b321-4b12-97d5-34a47c8e0906","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"01EhIlQZeKPaowOCegSu1RWaEUBwj39GZX2A97+fq/U=","metadata":{},"hash":"Vkcv7kwOX03H5KrBnUxRH09DWMqub6X/CXGUq8bwylg="},"NEXT":{"nodeId":"24f3d107-9622-4e50-93f1-2ce78990d429","metadata":{},"hash":"6nSA0LfDoveaM2X+nqFVRHcPPxFXE5ch9MgQBH5A7ok="}},"hash":"+2MbyMAn3Tza1l8fR1wch8A1tQ2UEgZqUCjlRrduPgQ=","text":"4.1.9.4 - Version 13\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/04-version-13\r\nDescription: Upgrade your Next.js Application from Version 12 to 13. Upgrading from 12 to 13\r\nTo update to Next.js version 13, run the following command using your preferred package manager:\r\nTerminal (bash)npm i next@13 react@latest react-dom@latest eslint-config-next@13\r\nTerminal (bash)yarn add next@13 react@latest react-dom@latest eslint-config-next@13\r\nTerminal (bash)pnpm i next@13 react@latest react-dom@latest eslint-config-next@13\r\nTerminal (bash)bun add next@13 react@latest react-dom@latest eslint-config-next@13\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest\r\nversions. v13 Summary\r\nThe Supported Browsers have been changed to drop Internet Explorer and target modern browsers. The minimum Node.js version has been bumped from 12.22.0 to 16.14.0, since 12.x and 14.x have reached end-of-life. The minimum React version has been bumped from 17.0.2 to 18.2.0. The swcMinify configuration property was changed from false to true. See Next.js Compiler for more info. The next/image import was renamed to next/legacy/image. The next/future/image import was renamed to next/image. A\r\ncodemod is available to safely and automatically rename your imports. The next/link child can no longer be <a>. Add the legacyBehavior prop to use the legacy behavior or remove the <a> to\r\nupgrade. A codemod is available to automatically upgrade your code. The target configuration property has been removed and superseded by Output File Tracing. Migrating shared features\r\nNext.js 13 introduces a new app directory with new features and conventions. However, upgrading to Next.js 13 does not require using\r\nthe new app directory. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component,\r\nScript component, and Font optimization. <Image/><Image/> Component\r\nNext.js 12 introduced many improvements to the Image Component with a temporary import: next/future/image.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"24f3d107-9622-4e50-93f1-2ce78990d429":{"id_":"24f3d107-9622-4e50-93f1-2ce78990d429","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"01EhIlQZeKPaowOCegSu1RWaEUBwj39GZX2A97+fq/U=","metadata":{},"hash":"Vkcv7kwOX03H5KrBnUxRH09DWMqub6X/CXGUq8bwylg="},"PREVIOUS":{"nodeId":"fa8cda42-b321-4b12-97d5-34a47c8e0906","metadata":{},"hash":"+2MbyMAn3Tza1l8fR1wch8A1tQ2UEgZqUCjlRrduPgQ="}},"hash":"6nSA0LfDoveaM2X+nqFVRHcPPxFXE5ch9MgQBH5A7ok=","text":"These\r\nimprovements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy\r\nloading. Starting in Next.js 13, this new behavior is now the default for next/image. There are two codemods to help you migrate to the new Image Component:\r\nnext-image-to-legacy-image: This codemod will safely and automatically rename next/image imports to next/legacy/image to\r\nmaintain the same behavior as Next.js 12. We recommend running this codemod to quickly update to Next.js 13 automatically. next-image-experimental: After running the previous codemod, you can optionally run this experimental codemod to upgradenext/legacy/image\r\n to the new next/image, which will remove unused props and add inline styles. Please note this codemod is\r\nexperimental and only covers static usage (such as <Image src={img} layout=\"responsive\" />) but not dynamic usage (such\r\nas <Image {...props} />). Alternatively, you can manually update by following the migration guide and also see the legacy comparison.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b94e7535-a6af-4e29-9bbd-c1590d414afa":{"id_":"b94e7535-a6af-4e29-9bbd-c1590d414afa","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wJnzhq5ofz3jEWEnWneIjXinLC8kGsWZvTGxR9Y4n6A=","metadata":{},"hash":"z5PlMo3HWJhHSgTGvKrwQYolh4ME1ODGMbV+7vUZipQ="}},"hash":"T+pK+fuDwRiZE8kmjU9I2nqgZO15Sb6ppA1fwwxreRg=","text":"<Link><Link> Component\r\nThe <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option\r\nin version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag. For example:\r\nimport Link from 'next/link'\r\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\r\n<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n// Next.js 13: `<Link>` always renders `<a>` under the hood\r\n<Link href=\"/about\">\r\n  About\r\n</Link>\r\nTo upgrade your links to Next.js 13, you can use the new-link codemod. <Script><Script> Component\r\nThe behavior of next/script has been updated to support both pages and app. If incrementally adopting app, read the upgrade\r\nguide. Font Optimization\r\nPreviously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you\r\nthe ability to customize your font loading experience while still ensuring great performance and privacy. See Optimizing Fonts to learn how to use next/font.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"72cbb775-af82-41cd-aca5-3ebb11f81c76":{"id_":"72cbb775-af82-41cd-aca5-3ebb11f81c76","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NE8g3Qnt5WVY5nNi6FZJYBoBqkPJjLSL1/0lQY3R4ns=","metadata":{},"hash":"zRkdxRxMbxuc/6VyWpdG5U2b5b3xIC/G2gzYXKqfXL4="},"NEXT":{"nodeId":"0911031e-6118-4d95-8418-87f44944af69","metadata":{},"hash":"tMtHljUMC7mJXZUNnA2IdUax6knAwuD5OdS7dEi18Us="}},"hash":"BrYmEvNd7l0oxK7ef6mdsHoMLvfTyoCN15Y0AMy748o=","text":"4.1.9.5 - Version 12\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/05-version-12\r\nDescription: Upgrade your Next.js Application from Version 11 to Version 12. To upgrade to version 12, run the following command:\r\nTerminal (bash)npm i next@12 react@17 react-dom@17 eslint-config-next@12\r\nTerminal (bash)yarn add next@12 react@17 react-dom@17 eslint-config-next@12\r\nTerminal (bash)pnpm up next@12 react@17 react-dom@17 eslint-config-next@12\r\nTerminal (bash)bun add next@12 react@17 react-dom@17 eslint-config-next@12\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their\r\ncorresponding versions. Upgrading to 12.2\r\nMiddleware - If you were using Middleware prior to 12.2, please see the upgrade guide for more information. Upgrading to 12.0\r\nMinimum Node.js Version - The minimum Node.js version has been bumped from 12.0.0 to 12.22.0 which is the first version of\r\nNode.js with native ES Modules support. Minimum React Version - The minimum required React version is 17.0.2. To upgrade you can run the following command in the\r\nterminal:\r\nTerminal (bash)npm install react@latest react-dom@latest\r\nyarn add react@latest react-dom@latest\r\npnpm update react@latest react-dom@latest\r\nbun add react@latest react-dom@latest\r\nSWC replacing Babel\r\nNext.js now uses the Rust-based compiler SWC to compile JavaScript/TypeScript. This new compiler is up to 17x faster than Babel when\r\ncompiling individual files and up to 5x faster Fast Refresh. Next.js provides full backward compatibility with applications that have custom Babel configuration. All transformations that Next.js\r\nhandles by default like styled-jsx and tree-shaking of getStaticProps / getStaticPaths / getServerSideProps have been ported\r\nto Rust. When an application has a custom Babel configuration, Next.js will automatically opt-out of using SWC for compiling\r\nJavaScript/Typescript and will fall back to using Babel in the same way that it was used in Next.js 11.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0911031e-6118-4d95-8418-87f44944af69":{"id_":"0911031e-6118-4d95-8418-87f44944af69","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NE8g3Qnt5WVY5nNi6FZJYBoBqkPJjLSL1/0lQY3R4ns=","metadata":{},"hash":"zRkdxRxMbxuc/6VyWpdG5U2b5b3xIC/G2gzYXKqfXL4="},"PREVIOUS":{"nodeId":"72cbb775-af82-41cd-aca5-3ebb11f81c76","metadata":{},"hash":"BrYmEvNd7l0oxK7ef6mdsHoMLvfTyoCN15Y0AMy748o="}},"hash":"tMtHljUMC7mJXZUNnA2IdUax6knAwuD5OdS7dEi18Us=","text":"Many of the integrations with external libraries that currently require custom Babel transformations will be ported to Rust-based SWC\r\ntransforms in the near future. These include but are not limited to:\r\nStyled Components\r\nEmotion\r\nRelay\r\nIn order to prioritize transforms that will help you adopt SWC, please provide your .babelrc on this feedback thread. SWC replacing Terser for minification\r\nYou can opt-in to replacing Terser with SWC for minifying JavaScript up to 7x faster using a flag in next.config.js:\r\nnext.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e73135dc-40e9-4c4b-aa2c-463b2955cd2e":{"id_":"e73135dc-40e9-4c4b-aa2c-463b2955cd2e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sjG1xWwvvaepJicatF871c5ysxHJY3Di1N8NJVG1ld0=","metadata":{},"hash":"hdS+ZXP/Ijikme3kc9Pd5L+YEuh+ieBvdy/lznPq0qg="},"NEXT":{"nodeId":"685d552d-7c01-48b2-a9d4-d370c0938fa3","metadata":{},"hash":"0loqcOdjFNBinTH7vBlFzVI25n+EHg/PzN3/KhFa8+g="}},"hash":"FElDkGBpxP+vAR0mVzZz8LgOVmm+18kvSLoAT/esdbA=","text":"module.exports = {\r\n  swcMinify: true,\r\n}\r\nMinification using SWC is an opt-in flag to ensure it can be tested against more real-world Next.js applications before it becomes the\r\ndefault in Next.js 12.1. If you have feedback about minification, please leave it on this feedback thread. Improvements to styled-jsx CSS parsing\r\nOn top of the Rust-based compiler we’ve implemented a new CSS parser based on the one used for the styled-jsx Babel transform. This\r\nnew parser has improved handling of CSS and now errors when invalid CSS is used that would previously slip through and cause\r\nunexpected behavior. Because of this change invalid CSS will throw an error during development and next build. This change only affects styled-jsx usage. next/imagenext/image changed wrapping element\r\nnext/image now renders the <img> inside a <span> instead of <div>. If your application has specific CSS targeting span such as .container span, upgrading to Next.js 12 might incorrectly match the\r\nwrapping element inside the <Image> component. You can avoid this by restricting the selector to a specific class such as .container\r\nspan.item and updating the relevant component with that className, such as <span className=\"item\" />. If your application has specific CSS targeting the next/image <div> tag, for example .container div, it may not match anymore. You can update the selector .container span, or preferably, add a new <div className=\"wrapper\"> wrapping the <Image>\r\ncomponent and target that instead such as .container .wrapper. The className prop is unchanged and will still be passed to the underlying <img> element. See the documentation for more info. HMR connection now uses a WebSocket\r\nPreviously, Next.js used a server-sent events connection to receive HMR events. Next.js 12 now uses a WebSocket connection. In some cases when proxying requests to the Next.js dev server, you will need to ensure the upgrade request is handled correctly.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"685d552d-7c01-48b2-a9d4-d370c0938fa3":{"id_":"685d552d-7c01-48b2-a9d4-d370c0938fa3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sjG1xWwvvaepJicatF871c5ysxHJY3Di1N8NJVG1ld0=","metadata":{},"hash":"hdS+ZXP/Ijikme3kc9Pd5L+YEuh+ieBvdy/lznPq0qg="},"PREVIOUS":{"nodeId":"e73135dc-40e9-4c4b-aa2c-463b2955cd2e","metadata":{},"hash":"FElDkGBpxP+vAR0mVzZz8LgOVmm+18kvSLoAT/esdbA="}},"hash":"0loqcOdjFNBinTH7vBlFzVI25n+EHg/PzN3/KhFa8+g=","text":"For\r\nexample, in nginx you would need to add the following configuration:\r\nlocation /_next/webpack-hmr {\r\n    proxy_pass http://localhost:3000/_next/webpack-hmr;\r\n    proxy_http_version 1.1;\r\n    proxy_set_header Upgrade $http_upgrade;\r\n    proxy_set_header Connection \"upgrade\";\r\n}\r\nIf you are using Apache (2.x), you can add the following configuration to enable web sockets to the server. Review the port, host name\r\nand server names. <VirtualHost *:443>\r\n # ServerName yourwebsite.local\r\n ServerName \"${WEBSITE_SERVER_NAME}\"\r\n ProxyPass / http://localhost:3000/\r\n ProxyPassReverse / http://localhost:3000/\r\n # Next.js 12 uses websocket\r\n <Location /_next/webpack-hmr>\r\n    RewriteEngine On\r\n    RewriteCond %{QUERY_STRING} transport=websocket [NC]\r\n    RewriteCond %{HTTP:Upgrade} websocket [NC]\r\n    RewriteCond %{HTTP:Connection} upgrade [NC]\r\n    RewriteRule /(.*) ws://localhost:3000/_next/webpack-hmr/$1 [P,L]\r\n    ProxyPass ws://localhost:3000/_next/webpack-hmr retry=0 timeout=30\r\n    ProxyPassReverse ws://localhost:3000/_next/webpack-hmr\r\n </Location>\r\n</VirtualHost>\r\nFor custom servers, such as express, you may need to use app.all to ensure the request is passed correctly, for example:\r\napp.all('/_next/webpack-hmr', (req, res) => {\r\n  nextjsRequestHandler(req, res)\r\n})\r\nWebpack 4 support has been removed\r\nIf you are already using webpack 5 you can skip this section.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dabbbe91-e423-460b-843b-23dd4f593341":{"id_":"dabbbe91-e423-460b-843b-23dd4f593341","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fpTOkSSq0aXmri8S+BTl2dTfcgtT6cxZBhiA7NLnLPk=","metadata":{},"hash":"8Y2+nh544T8EJe1yO8+4ZC/KxAFxWxL8XCFNE8aEMZs="}},"hash":"qpVZnlic+94twZoZ+gbydfufYR1aoQHgTiJATpECAY8=","text":"Next.js has adopted webpack 5 as the default for compilation in Next.js 11. As communicated in the webpack 5 upgrading\r\ndocumentation Next.js 12 removes support for webpack 4. If your application is still using webpack 4 using the opt-out flag, you will now see an error linking to the webpack 5 upgrading\r\ndocumentation. targettarget option deprecated\r\nIf you do not have target in next.config.js you can skip this section. The target option has been deprecated in favor of built-in support for tracing what dependencies are needed to run a page. During next build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for\r\ndeploying a production version of your application. If you are currently using the target option set to serverless, please read the documentation on how to leverage the new output.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"37985afe-02c9-431a-b522-9a91189e0eb8":{"id_":"37985afe-02c9-431a-b522-9a91189e0eb8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/TUi260nlE81lSZw+UZUCoK3h7Sr9Ev69UDYwjlFtvc=","metadata":{},"hash":"SUN3S5kfk/VU7rJ0hrbw9oa0/nFZ2w4qrtbXalblxhA="},"NEXT":{"nodeId":"8073f408-4c2f-45d6-b20c-76d8cfc162eb","metadata":{},"hash":"asFiGHpDcgDcHmktW1noxNkoXfP4f0XR4T92oQPU5Ck="}},"hash":"aYeorElxvHYd62X2ViHVLVV9N5FPYw452c9RFPSGx38=","text":"4.1.9.6 - Version 11\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/06-version-11\r\nDescription: Upgrade your Next.js Application from Version 10 to Version 11. To upgrade to version 11, run the following command:\r\nTerminal (bash)npm i next@11 react@17 react-dom@17\r\nTerminal (bash)yarn add next@11 react@17 react-dom@17\r\nTerminal (bash)pnpm up next@11 react@17 react-dom@17\r\nTerminal (bash)bun add next@11 react@17 react-dom@17\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their\r\ncorresponding versions. Webpack 5\r\nWebpack 5 is now the default for all Next.js applications. If you did not have a custom webpack configuration, your application is\r\nalready using webpack 5. If you do have a custom webpack configuration, you can refer to the Next.js webpack 5 documentation for\r\nupgrade guidance. Cleaning the distDirdistDir is now a default\r\nThe build output directory (defaults to .next) is now cleared by default except for the Next.js caches. You can refer to the cleaning\r\ndistDir RFC for more information. If your application was relying on this behavior previously you can disable the new default behavior by adding the cleanDistDir:\r\nfalse flag in next.config.js. PORTPORT is now supported for next devnext dev and next startnext start\r\nNext.js 11 supports the PORT environment variable to set the port the application runs on. Using -p/--port is still recommended but if\r\nyou were prohibited from using -p in any way you can now use PORT as an alternative:\r\nExample:\r\nPORT=4000 next start\r\nnext.config.jsnext.config.js customization to import images\r\nNext.js 11 supports static image imports with next/image. This new feature relies on being able to process image imports.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8073f408-4c2f-45d6-b20c-76d8cfc162eb":{"id_":"8073f408-4c2f-45d6-b20c-76d8cfc162eb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/TUi260nlE81lSZw+UZUCoK3h7Sr9Ev69UDYwjlFtvc=","metadata":{},"hash":"SUN3S5kfk/VU7rJ0hrbw9oa0/nFZ2w4qrtbXalblxhA="},"PREVIOUS":{"nodeId":"37985afe-02c9-431a-b522-9a91189e0eb8","metadata":{},"hash":"aYeorElxvHYd62X2ViHVLVV9N5FPYw452c9RFPSGx38="}},"hash":"asFiGHpDcgDcHmktW1noxNkoXfP4f0XR4T92oQPU5Ck=","text":"This new feature relies on being able to process image imports. If you\r\npreviously added the next-images or next-optimized-images packages you can either move to the new built-in support using\r\nnext/image or disable the feature:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}\r\nRemove super.componentDidCatch()super.componentDidCatch() from pages/_app.jspages/_app.js\r\nThe next/app component’s componentDidCatch was deprecated in Next.js 9 as it’s no longer needed and has since been a no-op. In\r\nNext.js 11, it was removed. If your pages/_app.js has a custom componentDidCatch method you can remove super.componentDidCatch as it is no longer\r\nneeded.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2f463381-fb68-43db-9bfd-1a2ef8115a94":{"id_":"2f463381-fb68-43db-9bfd-1a2ef8115a94","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"++Cpv0JCKzL2E2Ge7fqigozzruO3vu3AJfhBbpLkTXE=","metadata":{},"hash":"GivnVNZznnmE2tJ5oy5l6FwDE6MhL3YuwmDVFaMJMCo="},"NEXT":{"nodeId":"3d8a5d95-ad52-4283-a2ae-a9577abec2ae","metadata":{},"hash":"/T4SW72arub7Zi0mpyeGg8B9fda2P1a95K+9j+bES48="}},"hash":"i+76p2PzYK1w55x2Jg6TisOQX6GA6SEyVnUgIStRQ5s=","text":"Remove ContainerContainer from pages/_app.jspages/_app.js\r\nThis export was deprecated in Next.js 9 as it’s no longer needed and has since been a no-op with a warning during development. In\r\nNext.js 11 it was removed. If your pages/_app.js imports Container from next/app you can remove Container as it was removed. Learn more in the\r\ndocumentation. Remove props.urlprops.url usage from page components\r\nThis property was deprecated in Next.js 4 and has since shown a warning during development. With the introduction ofgetStaticProps\r\n / getServerSideProps these methods already disallowed the usage of props.url. In Next.js 11, it was removed\r\ncompletely. You can learn more in the documentation. Remove unsizedunsized property on next/imagenext/image\r\nThe unsized property on next/image was deprecated in Next.js 10.0.1. You can use layout=\"fill\" instead. In Next.js 11 unsized\r\nwas removed. Remove modulesmodules property on next/dynamicnext/dynamic\r\nThe modules and render option for next/dynamic were deprecated in Next.js 9.5. This was done in order to make the\r\nnext/dynamic API closer to React.lazy. In Next.js 11, the modules and render options were removed. This option hasn’t been mentioned in the documentation since Next.js 8 so it’s less likely that your application is using it. If your application does use modules and render you can refer to the documentation. Remove Head.rewindHead.rewind\r\nHead.rewind has been a no-op since Next.js 9.5, in Next.js 11 it was removed. You can safely remove your usage of Head.rewind. Moment.js locales excluded by default\r\nMoment.js includes translations for a lot of locales by default. Next.js now automatically excludes these locales by default to optimize\r\nbundle size for applications using Moment.js. To load a specific locale use this snippet:\r\nimport moment from 'moment'\r\nimport 'moment/locale/ja'\r\nmoment.locale('ja')\r\nYou can opt-out of this new default by adding excludeDefaultMomentLocales: false to next.config.js if you do not want the\r\nnew behavior, do note it’s highly recommended to not disable this new optimization as it significantly reduces the size of Moment.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3d8a5d95-ad52-4283-a2ae-a9577abec2ae":{"id_":"3d8a5d95-ad52-4283-a2ae-a9577abec2ae","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"++Cpv0JCKzL2E2Ge7fqigozzruO3vu3AJfhBbpLkTXE=","metadata":{},"hash":"GivnVNZznnmE2tJ5oy5l6FwDE6MhL3YuwmDVFaMJMCo="},"PREVIOUS":{"nodeId":"2f463381-fb68-43db-9bfd-1a2ef8115a94","metadata":{},"hash":"i+76p2PzYK1w55x2Jg6TisOQX6GA6SEyVnUgIStRQ5s="}},"hash":"/T4SW72arub7Zi0mpyeGg8B9fda2P1a95K+9j+bES48=","text":"Update usage of router.eventsrouter.events\r\nIn case you’re accessing router.events during rendering, in Next.js 11 router.events is no longer provided during pre-rendering. Ensure you’re accessing router.events in useEffect:\r\nuseEffect(() => {\r\n  const handleRouteChange = (url, { shallow }) => {\r\n    console.log(\r\n      `App is changing to ${url} ${\r\n        shallow ? 'with' : 'without'\r\n      } shallow routing`\r\n    )\r\n  }\r\n  router.events.on('routeChangeStart', handleRouteChange)\r\n  // If the component is unmounted, unsubscribe\r\n  // from the event with the `off` method:\r\n  return () => {\r\n    router.events.off('routeChangeStart', handleRouteChange)\r\n  }\r\n}, [router])","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b8dce2c9-560a-4c8c-9657-c607a3395162":{"id_":"b8dce2c9-560a-4c8c-9657-c607a3395162","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uUdxvpb5Fnd6xfiAgwITVplSvPuXOUxuW+eiqD/le2A=","metadata":{},"hash":"0pkDbi6exGB+OTcC6vg3/AfGHzg6hCq6ApUYWeY/hIs="}},"hash":"yBcM4441d/dqpMDc6YzX30lvRVElTo23dmufbKyqzRE=","text":"If your application uses router.router.events which was an internal property that was not public please make sure to use\r\nrouter.events as well. React 16 to 17\r\nReact 17 introduced a new JSX Transform that brings a long-time Next.js feature to the wider React ecosystem: Not having to import\r\nReact from 'react' when using JSX. When using React 17 Next.js will automatically use the new transform. This transform does not\r\nmake the React variable global, which was an unintended side-effect of the previous Next.js implementation. A codemod is available to\r\nautomatically fix cases where you accidentally used React without importing it. Most applications already use the latest version of React, with Next.js 11 the minimum React version has been updated to 17.0.2. To upgrade you can run the following command:\r\nnpm install react@latest react-dom@latest\r\nOr using yarn:\r\nyarn add react@latest react-dom@latest","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cd2027eb-dddb-46a6-a834-66e670b5f0d8":{"id_":"cd2027eb-dddb-46a6-a834-66e670b5f0d8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"pTrVdSwao7Vc22bIhFJIanNRdl4AImxwUtaUZVj4SJg=","metadata":{},"hash":"pw7W70ca/W2CQ1SBR74+vYrpkHPd1lT8oaJtQAH1llQ="}},"hash":"motebt5h8x7A6TbPZ4rfg3fYbOneSY5XXDlbaisGKtg=","text":"4.1.9.7 - Version 10\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/07-version-10\r\nDescription: Upgrade your Next.js Application from Version 9 to Version 10. There were no breaking changes between versions 9 and 10. To upgrade to version 10, run the following command:\r\nTerminal (bash)npm i next@10\r\nTerminal (bash)yarn add next@10\r\nTerminal (bash)pnpm up next@10\r\nTerminal (bash)bun add next@10\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their\r\ncorresponding versions.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"988454c5-d9cf-4509-b39d-1ae20c8898b6":{"id_":"988454c5-d9cf-4509-b39d-1ae20c8898b6","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"R2ryqWRsX6enmPCIQqzNnQ7xjTCenObu9zGw/MCl7zw=","metadata":{},"hash":"Fl9tWItGXQHFV2a6joDnsjEr3c3fPyhVD29xTE0M2RM="}},"hash":"bAg4QMh51kbiXmzKf1dusQXJEbdh/ns2fXd2b5VH5sM=","text":"4.1.9.8 - Upgrading to Version 9\r\nDocumentation path: /03-pages/01-building-your-application/09-upgrading/08-version-9\r\nDescription: Upgrade your Next.js Application from Version 8 to Version 9. To upgrade to version 9, run the following command:\r\nTerminal (bash)npm i next@9\r\nTerminal (bash)yarn add next@9\r\nTerminal (bash)pnpm up next@9\r\nTerminal (bash)bun add next@9\r\nGood to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their\r\ncorresponding versions. Production Deployment on Vercel\r\nIf you previously configured routes in your vercel.json file for dynamic routes, these rules can be removed when leveraging Next.js\r\n9’s new Dynamic Routing feature. Next.js 9’s dynamic routes are automatically configured on Vercel and do not require any vercel.json customization. You can read more about Dynamic Routing here. Check your Custom App File (pages/_app.jspages/_app.js)\r\nIf you previously copied the Custom <App> example, you may be able to remove your getInitialProps. Removing getInitialProps from pages/_app.js (when possible) is important to leverage new Next.js features! The following getInitialProps does nothing and may be removed:\r\nclass MyApp extends App {\r\n  // Remove me, I do nothing! static async getInitialProps({ Component, ctx }) {\r\n    let pageProps = {}\r\n    if (Component.getInitialProps) {\r\n      pageProps = await Component.getInitialProps(ctx)\r\n    }\r\n    return { pageProps }\r\n  }\r\n  render() {\r\n    // ... etc\r\n  }\r\n}\r\nBreaking Changes\r\n@zeit/next-typescript@zeit/next-typescript is no longer necessary\r\nNext.js will now ignore usage @zeit/next-typescript and warn you to remove it. Please remove this plugin from your\r\nnext.config.js. Remove references to @zeit/next-typescript/babel from your custom .babelrc (if present). The usage of fork-ts-checker-webpack-plugin should also be removed from your next.config.js. TypeScript Definitions are published with the next package, so you need to uninstall @types/next as they would conflict.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1f3223ac-a83c-4dc7-92ac-7e25772f2f87":{"id_":"1f3223ac-a83c-4dc7-92ac-7e25772f2f87","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2iXAZKduHzagq7DdkiIaxXr/POqAJdOy5NmgytKEoaE=","metadata":{},"hash":"MeWzLDUZ1Edg6EJksmuTsR/8hniNoFKDMQqt4ELsmxg="},"NEXT":{"nodeId":"d250d6ec-4500-4182-9927-7e464894106a","metadata":{},"hash":"lM94ehOTaONRXDcP/T9UKWOsLdL0ygd3ev1iJ0lOkZI="}},"hash":"1rQFO4grR6l9vUYSfoZy1Cz2cucLHMuNGZmygq6soZM=","text":"The following types are different:\r\nThis list was created by the community to help you upgrade, if you find other differences please send a pull-request to this list\r\nto help other users. From:\r\nimport { NextContext } from 'next'\r\nimport { NextAppContext, DefaultAppIProps } from 'next/app'\r\nimport { NextDocumentContext, DefaultDocumentIProps } from 'next/document'\r\nto\r\nimport { NextPageContext } from 'next'\r\nimport { AppContext, AppInitialProps } from 'next/app'\r\nimport { DocumentContext, DocumentInitialProps } from 'next/document'\r\nThe configconfig key is now an export on a page\r\nYou may no longer export a custom variable named config from a page (i.e. export { config } / export const config ...). This exported variable is now used to specify page-level Next.js configuration like Opt-in AMP and API Route features. You must rename a non-Next.js-purposed config export to something different. next/dynamicnext/dynamic no longer renders “loading... ” by default while loading\r\nDynamic components will not render anything by default while loading. You can still customize this behavior by setting the loading\r\nproperty:\r\nimport dynamic from 'next/dynamic'\r\nconst DynamicComponentWithCustomLoading = dynamic(\r\n  () => import('../components/hello2'),\r\n  {\r\n    loading: () => <p>Loading</p>,\r\n  }\r\n)\r\nwithAmpwithAmp has been removed in favor of an exported configuration object\r\nNext.js now has the concept of page-level configuration, so the withAmp higher-order component has been removed for consistency.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d250d6ec-4500-4182-9927-7e464894106a":{"id_":"d250d6ec-4500-4182-9927-7e464894106a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2iXAZKduHzagq7DdkiIaxXr/POqAJdOy5NmgytKEoaE=","metadata":{},"hash":"MeWzLDUZ1Edg6EJksmuTsR/8hniNoFKDMQqt4ELsmxg="},"PREVIOUS":{"nodeId":"1f3223ac-a83c-4dc7-92ac-7e25772f2f87","metadata":{},"hash":"1rQFO4grR6l9vUYSfoZy1Cz2cucLHMuNGZmygq6soZM="}},"hash":"lM94ehOTaONRXDcP/T9UKWOsLdL0ygd3ev1iJ0lOkZI=","text":"This change can be automatically migrated by running the following commands in the root of your Next.js project:\r\nTerminal (bash)curl -L https://github.com/vercel/next-codemod/archive/master.tar.gz | tar -xz --strip=2 next-codemod-master/transforms/withamp-to-config.js\r\nTo perform this migration by hand, or view what the codemod will produce, see below:\r\nBefore\r\nimport { withAmp } from 'next/amp'\r\nfunction Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\nexport default withAmp(Home)\r\n// or\r\nexport default withAmp(Home, { hybrid: true })\r\nAfter\r\nexport default function Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\nexport const config = {\r\n  amp: true,\r\n  // or\r\n  amp: 'hybrid',\r\n}\r\nnext exportnext export no longer exports pages as index.htmlindex.html","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"03194170-c0c9-4bfd-90df-e1fe52dfefc8":{"id_":"03194170-c0c9-4bfd-90df-e1fe52dfefc8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"uE4PIPn2NSMKXIO6dKc90aPinJ0TPj9I8DcEhg1z5mI=","metadata":{},"hash":"DW0HGwW+bcSbW63NNUrrnA/otUYVU2u/4a3Vpb15ffg="}},"hash":"u3snld4Idz3ncCkiD1WMfHYNntcdh73x6MwVmiFqkqw=","text":"Previously, exporting pages/about.js would result in out/about/index.html. This behavior has been changed to result in\r\nout/about.html. You can revert to the previous behavior by creating a next.config.js with the following content:\r\nnext.config.js (js)module.exports = {\r\n  trailingSlash: true,\r\n}\r\npages/api/pages/api/ is treated differently\r\nPages in pages/api/ are now considered API Routes. Pages in this directory will no longer contain a client-side bundle. Deprecated Features\r\nnext/dynamicnext/dynamic has deprecated loading multiple modules at once\r\nThe ability to load multiple modules at once has been deprecated in next/dynamic to be closer to React’s implementation\r\n(React.lazy and Suspense). Updating code that relies on this behavior is relatively straightforward! We’ve provided an example of a before/after to help you\r\nmigrate your application:\r\nBefore\r\nimport dynamic from 'next/dynamic'\r\nconst HelloBundle = dynamic({\r\n  modules: () => {\r\n    const components = {\r\n      Hello1: () => import('../components/hello1').then((m) => m.default),\r\n      Hello2: () => import('../components/hello2').then((m) => m.default),\r\n    }\r\n    return components\r\n  },\r\n  render: (props, { Hello1, Hello2 }) => (\r\n    <div>\r\n      <h1>{props.title}</h1>\r\n      <Hello1 />\r\n      <Hello2 />\r\n    </div>\r\n  ),\r\n})\r\nfunction DynamicBundle() {\r\n  return <HelloBundle title=\"Dynamic Bundle\" />\r\n}\r\nexport default DynamicBundle\r\nAfter\r\nimport dynamic from 'next/dynamic'\r\nconst Hello1 = dynamic(() => import('../components/hello1'))\r\nconst Hello2 = dynamic(() => import('../components/hello2'))\r\nfunction HelloBundle({ title }) {\r\n  return (\r\n    <div>\r\n      <h1>{title}</h1>\r\n      <Hello1 />\r\n      <Hello2 />\r\n    </div>\r\n  )\r\n}\r\nfunction DynamicBundle() {\r\n  return <HelloBundle title=\"Dynamic Bundle\" />\r\n}\r\nexport default DynamicBundle","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"343f7092-fd7f-4748-948a-5615bb1ffd02":{"id_":"343f7092-fd7f-4748-948a-5615bb1ffd02","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XO0qDo2ppH01sVBRjh7lFVKvKplApAjYsKBiCTQ2tPw=","metadata":{},"hash":"xk10YPF//ucDkdx8GC/lfJAHtuxenXJTzB1eyI3BIKA="}},"hash":"K42VxyXWdmOukLrOYBCwPbvP2cNuISrE5CszxX6zmik=","text":"4.2 - API Reference\r\nDocumentation path: /03-pages/02-api-reference/index\r\nDescription: Next.js API Reference for the Pages Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a7eb14c1-7db8-4c3e-bb9d-38ddc4bf84e2":{"id_":"a7eb14c1-7db8-4c3e-bb9d-38ddc4bf84e2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EBZF0+lDytxQo32TPwgkvdekkA2zu0nbrKJxtgPL+ko=","metadata":{},"hash":"FxlEhI8hYIJKRlxdfppwuGA02P4v9bgGn4+TPRL7/Jg="}},"hash":"TK5pWBW6plvk78M7n6d8qN4gp5BUJwkR/j06a25PyeA=","text":"4.2.1 - Components\r\nDocumentation path: /03-pages/02-api-reference/01-components/index\r\nDescription: API Reference for Next.js built-in components in the Pages Router. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3cff6771-ed01-4635-95d4-5e09b6ce76df":{"id_":"3cff6771-ed01-4635-95d4-5e09b6ce76df","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BVzvO05uDQr1vEle3S45CW6BHGnBZY2R1umcgr4eJmo=","metadata":{},"hash":"K69nxGSZfCuJUaIH7QQLULVTyHsAsQ9Vg53n77xZRX8="}},"hash":"7w9/gPO8yf1PX6scK4Ccd53zfzx6BQsUzo4eJWrT724=","text":"4.2.1.1 - Font Module\r\nDocumentation path: /03-pages/02-api-reference/01-components/font\r\nDescription: API Reference for the Font Module\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"eaba6bd2-7a23-44ee-926d-b9707f733923":{"id_":"eaba6bd2-7a23-44ee-926d-b9707f733923","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"xFMVnn8ZagbDUltzUVQ+JsNWJtVdGRg2zjNeJKBa4oo=","metadata":{},"hash":"K6HhA0gjt+IRyvuzEZVSg38e0FeqwU8W5cdSSWDA/bc="}},"hash":"BaITrkG2fATYXd1IiqYRJy3ZOEXiRYL6/iMlveJxSMo=","text":"4.2.1.2 - <Head>\r\nDocumentation path: /03-pages/02-api-reference/01-components/head\r\nDescription: Add custom elements to the `head` of your page with the built-in Head component. Examples\r\nWe expose a built-in component for appending elements to the head of the page:\r\nimport Head from 'next/head'\r\nfunction IndexPage() {\r\n  return (\r\n    <div>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n      <p>Hello world!</p>\r\n    </div>\r\n  )\r\n}\r\nexport default IndexPage\r\nTo avoid duplicate tags in your head you can use the key property, which will make sure the tag is only rendered once, as in the\r\nfollowing example:\r\nimport Head from 'next/head'\r\nfunction IndexPage() {\r\n  return (\r\n    <div>\r\n      <Head>\r\n        <title>My page title</title>\r\n        <meta property=\"og:title\" content=\"My page title\" key=\"title\" />\r\n      </Head>\r\n      <Head>\r\n        <meta property=\"og:title\" content=\"My new title\" key=\"title\" />\r\n      </Head>\r\n      <p>Hello world!</p>\r\n    </div>\r\n  )\r\n}\r\nexport default IndexPage\r\nIn this case only the second <meta property=\"og:title\" /> is rendered. meta tags with duplicate key attributes are automatically\r\nhandled. The contents of head get cleared upon unmounting the component, so make sure each page completely defines what it needs\r\nin head, without making assumptions about what other pages added. title, meta or any other elements (e.g. script) need to be contained as direct children of the Head element, or wrapped into\r\nmaximum one level of <React.Fragment> or arrays—otherwise the tags won’t be correctly picked up on client-side navigations. We recommend using next/script in your component instead of manually creating a <script> in next/head.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"15816aa8-11c5-486a-87c1-47c8cd1032cd":{"id_":"15816aa8-11c5-486a-87c1-47c8cd1032cd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cpSmMqs5YyuTKJUegX501g4psMWkpyxnQviY9uxUrAo=","metadata":{},"hash":"4cFCyDGH38zl8DhMqKsz0V8dzNzuc4doQqihEf+OOLs="},"NEXT":{"nodeId":"0f30ee03-3bfa-44bd-bb8d-7d30120b6465","metadata":{},"hash":"5r1CRQUBhVteJwYN004bPUkeFJcDxt9vLjp69jGpyQU="}},"hash":"PMFOXcv47O6YZFSI69K8ZsZA7Y3WICOSTUDUp3P6Z2o=","text":"4.2.1.3 - <Image> (Legacy)\r\nDocumentation path: /03-pages/02-api-reference/01-components/image-legacy\r\nDescription: Backwards compatible Image Optimization with the Legacy Image component. Examples\r\nStarting with Next.js 13, the next/image component was rewritten to improve both the performance and developer experience. In\r\norder to provide a backwards compatible upgrade solution, the old next/image was renamed to next/legacy/image. View the new next/image API Reference\r\nComparison\r\nCompared to next/legacy/image, the new next/image component has the following changes:\r\nRemoves <span> wrapper around <img> in favor of native computed aspect ratio\r\nAdds support for canonical style prop\r\nRemoves layout prop in favor of style or className\r\nRemoves objectFit prop in favor of style or className\r\nRemoves objectPosition prop in favor of style or className\r\nRemoves IntersectionObserver implementation in favor of native lazy loading\r\nRemoves lazyBoundary prop since there is no native equivalent\r\nRemoves lazyRoot prop since there is no native equivalent\r\nRemoves loader config in favor of loader prop\r\nChanged alt prop from optional to required\r\nChanged onLoadingComplete callback to receive reference to <img> element\r\nRequired Props\r\nThe <Image /> component requires the following properties. src\r\nMust be one of the following:\r\nA statically imported image file\r\nA path string. This can be either an absolute external URL, or an internal path depending on the loader prop or loader\r\nconfiguration. When using an external URL, you must add it to remotePatterns in next.config.js. width\r\nThe width property can represent either the rendered width or original width in pixels, depending on the layout and sizes\r\nproperties. When using layout=\"intrinsic\" or layout=\"fixed\" the width property represents the rendered width in pixels, so it will affect\r\nhow large the image appears. When using layout=\"responsive\", layout=\"fill\", the width property represents the original width in pixels, so it will only affect\r\nthe aspect ratio. The width property is required, except for statically imported images, or those with layout=\"fill\". height\r\nThe height property can represent either the rendered height or original height in pixels, depending on the layout and sizes\r\nproperties. When using layout=\"intrinsic\" or layout=\"fixed\" the height property represents the rendered height in pixels, so it will affect\r\nhow large the image appears.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0f30ee03-3bfa-44bd-bb8d-7d30120b6465":{"id_":"0f30ee03-3bfa-44bd-bb8d-7d30120b6465","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cpSmMqs5YyuTKJUegX501g4psMWkpyxnQviY9uxUrAo=","metadata":{},"hash":"4cFCyDGH38zl8DhMqKsz0V8dzNzuc4doQqihEf+OOLs="},"PREVIOUS":{"nodeId":"15816aa8-11c5-486a-87c1-47c8cd1032cd","metadata":{},"hash":"PMFOXcv47O6YZFSI69K8ZsZA7Y3WICOSTUDUp3P6Z2o="}},"hash":"5r1CRQUBhVteJwYN004bPUkeFJcDxt9vLjp69jGpyQU=","text":"When using layout=\"responsive\", layout=\"fill\", the height property represents the original height in pixels, so it will only affect\r\nthe aspect ratio. The height property is required, except for statically imported images, or those with layout=\"fill\".","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bc6b57c7-0fb6-4573-a02e-cd54fa4a26d1":{"id_":"bc6b57c7-0fb6-4573-a02e-cd54fa4a26d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iXfpqFrn2cLzs34BTiE8JgxLxfZ1Wy4pdlaCjFPxSLI=","metadata":{},"hash":"5dLbcKQ6cIUfBWPKC+408DH8hfndCsrnrhU2IqtiLf8="},"NEXT":{"nodeId":"5ae5f4f6-755f-407a-b0dd-805f151ba4cf","metadata":{},"hash":"zKjDNo811M38d60/RzwePMd5T4Z89Q7G3SBBavVh4eI="}},"hash":"x1Qn+2zy0kM5g2feoorzGvZMY9GCgV6AEoBYGfsBS7Q=","text":"Optional Props\r\nThe <Image /> component accepts a number of additional properties beyond those which are required. This section describes the\r\nmost commonly-used properties of the Image component. Find details about more rarely-used properties in the Advanced Props\r\nsection. layout\r\nThe layout behavior of the image as the viewport changes size. layoutlayoutBehaviorsrcSetsrcSetsizessizesHas wrapper\r\nand sizer\r\nintrinsic\r\n(default)\r\nScale down to fit width of container, up\r\nto image size\r\n1x, 2x (based on imageSizes)N/Ayes\r\nfixedSized to width and height exactly1x, 2x (based on imageSizes)N/Ayes\r\nresponsiveScale to fit width of container640w, 750w, ... 2048w, 3840w (based on\r\nimageSizes and deviceSizes)\r\n100vwyes\r\nfillGrow in both X and Y axes to fill\r\ncontainer\r\n640w, 750w, ... 2048w, 3840w (based on\r\nimageSizes and deviceSizes)\r\n100vwyes\r\nDemo the intrinsic layout (default)\r\nWhen intrinsic, the image will scale the dimensions down for smaller viewports, but maintain the original dimensions for larger\r\nviewports. Demo the fixed layout\r\nWhen fixed, the image dimensions will not change as the viewport changes (no responsiveness) similar to the native img element. Demo the responsive layout\r\nWhen responsive, the image will scale the dimensions down for smaller viewports and scale up for larger viewports. Ensure the parent element uses display: block in their stylesheet. Demo the fill layout\r\nWhen fill, the image will stretch both width and height to the dimensions of the parent element, provided the parent element is\r\nrelative. This is usually paired with the objectFit property. Ensure the parent element has position: relative in their stylesheet. Demo background image\r\nloader\r\nA custom function used to resolve URLs. Setting the loader as a prop on the Image component overrides the default loader defined in\r\nthe images section of next.config.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5ae5f4f6-755f-407a-b0dd-805f151ba4cf":{"id_":"5ae5f4f6-755f-407a-b0dd-805f151ba4cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"iXfpqFrn2cLzs34BTiE8JgxLxfZ1Wy4pdlaCjFPxSLI=","metadata":{},"hash":"5dLbcKQ6cIUfBWPKC+408DH8hfndCsrnrhU2IqtiLf8="},"PREVIOUS":{"nodeId":"bc6b57c7-0fb6-4573-a02e-cd54fa4a26d1","metadata":{},"hash":"x1Qn+2zy0kM5g2feoorzGvZMY9GCgV6AEoBYGfsBS7Q="}},"hash":"zKjDNo811M38d60/RzwePMd5T4Z89Q7G3SBBavVh4eI=","text":"A loader is a function returning a URL string for the image, given the following parameters:\r\nsrc\r\nwidth\r\nquality\r\nHere is an example of using a custom loader:\r\nimport Image from 'next/legacy/image'\r\nconst myLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\nconst MyImage = (props) => {\r\n  return (\r\n    <Image\r\n      loader={myLoader}\r\n      src=\"me.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"64ae3287-d44f-4376-9b72-99e0862602d2":{"id_":"64ae3287-d44f-4376-9b72-99e0862602d2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ruoGGigAB/0J2Yr33T5s1iJzitCpuSxROu4w1E9wLoE=","metadata":{},"hash":"Z7lXEmPnHPyDWUrnc+h2BnESVpz3DhNcJ/C0b1sukFw="},"NEXT":{"nodeId":"2def8b01-c79c-4c20-a89b-750b19c510d4","metadata":{},"hash":"QE4b1Q0rIiHM7GQ3jO5i2KBbo9Rok84SQBCNrQKwyWs="}},"hash":"DlOCrEptSJ2FlkWI7Z1MFA8tZRhiuVjtmjk3d5RBJh8=","text":"}\r\nsizes\r\nA string that provides information about how wide the image will be at different breakpoints. The value of sizes will greatly affect\r\nperformance for images using layout=\"responsive\" or layout=\"fill\". It will be ignored for images using layout=\"intrinsic\"\r\nor layout=\"fixed\". The sizes property serves two important purposes related to image performance:\r\nFirst, the value of sizes is used by the browser to determine which size of the image to download, from next/legacy/image’s\r\nautomatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an\r\nimage that is the same size or larger than the viewport. The sizes property allows you to tell the browser that the image will actually\r\nbe smaller than full screen. If you don’t specify a sizes value, a default value of 100vw (full screen width) is used. Second, the sizes value is parsed and used to trim the values in the automatically-created source set. If the sizes property includes\r\nsizes such as 50vw, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which\r\nare too small to ever be necessary. For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-\r\ncolumn layout on desktop displays, you should include a sizes property such as the following:\r\nimport Image from 'next/legacy/image'\r\nconst Example = () => (\r\n  <div className=\"grid-element\">\r\n    <Image\r\n      src=\"/example.png\"\r\n      layout=\"fill\"\r\n      sizes=\"(max-width: 768px) 100vw,\r\n              (max-width: 1200px) 50vw,\r\n              33vw\"\r\n    />\r\n  </div>\r\n)\r\nThis example sizes could have a dramatic effect on performance metrics. Without the 33vw sizes, the image selected from the server\r\nwould be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, without sizes the user would\r\ndownload an image that’s 9 times larger than necessary. Learn more about srcset and sizes:\r\nweb.dev\r\nmdn\r\nquality\r\nThe quality of the optimized image, an integer between 1 and 100 where 100 is the best quality. Defaults to 75.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2def8b01-c79c-4c20-a89b-750b19c510d4":{"id_":"2def8b01-c79c-4c20-a89b-750b19c510d4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ruoGGigAB/0J2Yr33T5s1iJzitCpuSxROu4w1E9wLoE=","metadata":{},"hash":"Z7lXEmPnHPyDWUrnc+h2BnESVpz3DhNcJ/C0b1sukFw="},"PREVIOUS":{"nodeId":"64ae3287-d44f-4376-9b72-99e0862602d2","metadata":{},"hash":"DlOCrEptSJ2FlkWI7Z1MFA8tZRhiuVjtmjk3d5RBJh8="}},"hash":"QE4b1Q0rIiHM7GQ3jO5i2KBbo9Rok84SQBCNrQKwyWs=","text":"Defaults to 75. priority\r\nWhen true, the image will be considered high priority and preload. Lazy loading is automatically disabled for images using priority. You should use the priority property on any image detected as the Largest Contentful Paint (LCP) element. It may be appropriate to\r\nhave multiple priority images, as different images may be the LCP element for different viewport sizes. Should only be used when the image is visible above the fold. Defaults to false. placeholder\r\nA placeholder to use while the image is loading. Possible values are blur or empty. Defaults to empty. When blur, the blurDataURL property will be used as the placeholder. If src is an object from a static import and the imported image\r\nis .jpg, .png, .webp, or .avif, then blurDataURL will be automatically populated. For dynamic images, you must provide the blurDataURL property. Solutions such as Plaiceholder can help with base64 generation. When empty, there will be no placeholder while the image is loading, only empty space. Try it out:\r\nDemo the blur placeholder\r\nDemo the shimmer effect with blurDataURL prop\r\nDemo the color effect with blurDataURL prop","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f962ec59-780c-4ab8-9a16-6e5515c13f3d":{"id_":"f962ec59-780c-4ab8-9a16-6e5515c13f3d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lgq5yRBeDdB+OnR+IFOvPneTkS1DpTGtWXCj/gi54dA=","metadata":{},"hash":"ypisZiaJ9O08oxmidCyjbEhRZRuze879tUDeaeEa/q4="},"NEXT":{"nodeId":"9ffc64e1-11fb-4904-af19-8bdc3a59b84a","metadata":{},"hash":"UwzV50p4t9Nz8xe5tzBM9IWbLlYUCu2JmWcAv8ONojo="}},"hash":"ohBurL+gIJ/3jHfDdzRWJAtTpvZ+PClpvdNldgedsEU=","text":"Advanced Props\r\nIn some cases, you may need more advanced usage. The <Image /> component optionally accepts the following advanced properties. style\r\nAllows passing CSS styles to the underlying image element. Note that all layout modes apply their own styles to the image element, and these automatic styles take precedence over the style\r\nprop. Also keep in mind that the required width and height props can interact with your styling. If you use styling to modify an image’s\r\nwidth, you must set the height=\"auto\" style as well, or your image will be distorted. objectFit\r\nDefines how the image will fit into its parent container when using layout=\"fill\". This value is passed to the object-fit CSS property for the src image. objectPosition\r\nDefines how the image is positioned within its parent element when using layout=\"fill\". This value is passed to the object-position CSS property applied to the image. onLoadingComplete\r\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed. The onLoadingComplete function accepts one parameter, an object with the following properties:\r\nnaturalWidth\r\nnaturalHeight\r\nloading\r\nAttention: This property is only meant for advanced usage. Switching an image to load with eager will normally hurt\r\nperformance. We recommend using the priority property instead, which properly loads the image eagerly for nearly all use cases. The loading behavior of the image. Defaults to lazy. When lazy, defer loading the image until it reaches a calculated distance from the viewport. When eager, load the image immediately. Learn more\r\nblurDataURL\r\nA Data URL to be used as a placeholder image before the src image successfully loads. Only takes effect when combined with\r\nplaceholder=\"blur\". Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or less) is recommended. Including larger\r\nimages as placeholders may harm your application performance. Try it out:\r\nDemo the default blurDataURL prop\r\nDemo the shimmer effect with blurDataURL prop\r\nDemo the color effect with blurDataURL prop\r\nYou can also generate a solid color Data URL to match the image. lazyBoundary\r\nA string (with similar syntax to the margin property) that acts as the bounding box used to detect the intersection of the viewport with\r\nthe image and trigger lazy loading. Defaults to \"200px\".","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9ffc64e1-11fb-4904-af19-8bdc3a59b84a":{"id_":"9ffc64e1-11fb-4904-af19-8bdc3a59b84a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"lgq5yRBeDdB+OnR+IFOvPneTkS1DpTGtWXCj/gi54dA=","metadata":{},"hash":"ypisZiaJ9O08oxmidCyjbEhRZRuze879tUDeaeEa/q4="},"PREVIOUS":{"nodeId":"f962ec59-780c-4ab8-9a16-6e5515c13f3d","metadata":{},"hash":"ohBurL+gIJ/3jHfDdzRWJAtTpvZ+PClpvdNldgedsEU="}},"hash":"UwzV50p4t9Nz8xe5tzBM9IWbLlYUCu2JmWcAv8ONojo=","text":"Defaults to \"200px\". If the image is nested in a scrollable parent element other than the root document, you will also need to assign the lazyRoot prop. Learn more","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6cf37648-3054-40b3-9e1f-996690e464a4":{"id_":"6cf37648-3054-40b3-9e1f-996690e464a4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sEMFpte9ZDYE8egl0Afp2RJMESZwgn6gwIX0pugMYCE=","metadata":{},"hash":"rvtXzRjXUDtsoRrjyvqJ5Nj2r+NKzyJ72OZESvbjgqc="}},"hash":"LvOfr/VpCj+hNYUFg34CRb+orYAX82EcYeKmBYSBO8E=","text":"lazyRoot\r\nA React Ref pointing to the scrollable parent element. Defaults to null (the document viewport). The Ref must point to a DOM element or a React component that forwards the Ref to the underlying DOM element. Example pointing to a DOM element\r\nimport Image from 'next/legacy/image'\r\nimport React from 'react'\r\nconst Example = () => {\r\n  const lazyRoot = React.useRef(null)\r\n  return (\r\n    <div ref={lazyRoot} style={{ overflowX: 'scroll', width: '500px' }}>\r\n      <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n      <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n    </div>\r\n  )\r\n}\r\nExample pointing to a React component\r\nimport Image from 'next/legacy/image'\r\nimport React from 'react'\r\nconst Container = React.forwardRef((props, ref) => {\r\n  return (\r\n    <div ref={ref} style={{ overflowX: 'scroll', width: '500px' }}>\r\n      {props.children}\r\n    </div>\r\n  )\r\n})\r\nconst Example = () => {\r\n  const lazyRoot = React.useRef(null)\r\n  return (\r\n    <Container ref={lazyRoot}>\r\n      <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n      <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n    </Container>\r\n  )\r\n}\r\nLearn more\r\nunoptimized\r\nWhen true, the source image will be served as-is instead of changing quality, size, or format. Defaults to false. import Image from 'next/image'\r\nconst UnoptimizedImage = (props) => {\r\n  return <Image {...props} unoptimized />\r\n}\r\nSince Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    unoptimized: true,\r\n  },\r\n}\r\nOther Props\r\nOther properties on the <Image /> component will be passed to the underlying img element with the exception of the following:\r\nsrcSet. Use Device Sizes instead. ref. Use onLoadingComplete instead. decoding. It is always \"async\".","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"bfdc480c-e104-4479-a36a-71fe2125f775":{"id_":"bfdc480c-e104-4479-a36a-71fe2125f775","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XtbOBNNyipWkPlX0xEEwHut7/vyotZfHjkbxGyQQQ9g=","metadata":{},"hash":"GNx91ACSYokb8E6MprftNwpb8CEdxgWGTcYtODW4Xqo="}},"hash":"e67QLBgizQWap6mCuGXlCN3Lrd4h7JZAdtypGPhtJuQ=","text":"Configuration Options\r\nRemote Patterns\r\nTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only\r\nexternal images from your account can be served from the Next.js Image Optimization API. These external images can be configured\r\nwith the remotePatterns property in your next.config.js file, as shown below:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'example.com',\r\n        port: '',\r\n        pathname: '/account123/**',\r\n      },\r\n    ],\r\n  },\r\n}\r\nGood to know: The example above will ensure the src property of next/legacy/image must start withhttps://example.com/account123/\r\n. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad\r\nRequest. Below is another example of the remotePatterns property in the next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: '**.example.com',\r\n      },\r\n    ],\r\n  },\r\n}\r\nGood to know: The example above will ensure the src property of next/legacy/image must start withhttps://img1.example.com\r\n or https://me.avatar.example.com or any number of subdomains. Any other protocol or\r\nunmatched hostname will respond with 400 Bad Request. Wildcard patterns can be used for both pathname and hostname and have the following syntax:\r\n* match a single path segment or subdomain\r\n** match any number of path segments at the end or subdomains at the beginning\r\nThe ** syntax does not work in the middle of the pattern. Domains\r\nWarning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious\r\nusers. Only use domains if you own all the content served from the domain. Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname. Below is an example of the domains property in the next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    domains: ['assets.acme.com'],\r\n  },\r\n}\r\nLoader Configuration\r\nIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2dcb1a6e-7736-424d-8c74-f23cea4f19ef":{"id_":"2dcb1a6e-7736-424d-8c74-f23cea4f19ef","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"m65WosY4m1UoY5QgqBHVXOuup14SKznGbxLHeOjUlko=","metadata":{},"hash":"UgFRlhdOPHAmSeRao2AhSbxEgcYHSKLulFJRy0Y7EDE="},"NEXT":{"nodeId":"9cef77d2-d346-413a-8c8f-a049198a268a","metadata":{},"hash":"Jv4OBf73fi5+N9D8pfkavdeKuJN4/3YGsRnFmAbseM8="}},"hash":"9237PCkumK4ks1hMqp1FKTLwkfrFBnq0ZTtAk+iZ5Vw=","text":"the loader and path prefix in your next.config.js file. This allows you to use relative URLs for the Image src and automatically\r\ngenerate the correct absolute URL for your provider. next.config.js (js)module.exports = {\r\n  images: {\r\n    loader: 'imgix',\r\n    path: 'https://example.com/myaccount/',\r\n  },\r\n}\r\nBuilt-in Loaders\r\nThe following Image Optimization cloud providers are included:\r\nDefault: Works automatically with next dev, next start, or a custom server\r\nVercel: Works automatically when you deploy on Vercel, no configuration necessary. Learn more\r\nImgix: loader: 'imgix'\r\nCloudinary: loader: 'cloudinary'\r\nAkamai: loader: 'akamai'\r\nCustom: loader: 'custom' use a custom cloud provider by implementing the loader prop on the next/legacy/image\r\ncomponent\r\nIf you need a different provider, you can use the loader prop with next/legacy/image. Images can not be optimized at build time using output: 'export', only on-demand. To use next/legacy/image with\r\noutput: 'export', you will need to use a different loader than the default. Read more in the discussion. The next/legacy/image component’s default loader uses squoosh because it is quick to install and suitable for a\r\ndevelopment environment. When using next start in your production environment, it is strongly recommended that you\r\ninstall sharp by running npm i sharp in your project directory. This is not necessary for Vercel deployments, as sharp is\r\ninstalled automatically. Advanced\r\nThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you\r\nwill override any changes to the Next.js defaults in future updates. Device Sizes\r\nIf you know the expected device widths of your users, you can specify a list of device width breakpoints using the deviceSizes\r\nproperty in next.config.js. These widths are used when the next/legacy/image component uses layout=\"responsive\" or\r\nlayout=\"fill\" to ensure the correct image is served for user’s device. If no configuration is provided, the default below is used.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9cef77d2-d346-413a-8c8f-a049198a268a":{"id_":"9cef77d2-d346-413a-8c8f-a049198a268a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"m65WosY4m1UoY5QgqBHVXOuup14SKznGbxLHeOjUlko=","metadata":{},"hash":"UgFRlhdOPHAmSeRao2AhSbxEgcYHSKLulFJRy0Y7EDE="},"PREVIOUS":{"nodeId":"2dcb1a6e-7736-424d-8c74-f23cea4f19ef","metadata":{},"hash":"9237PCkumK4ks1hMqp1FKTLwkfrFBnq0ZTtAk+iZ5Vw="}},"hash":"Jv4OBf73fi5+N9D8pfkavdeKuJN4/3YGsRnFmAbseM8=","text":"If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\r\n  },\r\n}\r\nImage Sizes\r\nYou can specify a list of image widths using the images.imageSizes property in your next.config.js file. These widths are\r\nconcatenated with the array of device sizes to form the full array of sizes used to generate image srcsets. The reason there are two separate lists is that imageSizes is only used for images which provide a sizes prop, which indicates that the\r\nimage is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in\r\ndeviceSizes. If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"54229d81-bd98-4d81-ba5d-3170de546051":{"id_":"54229d81-bd98-4d81-ba5d-3170de546051","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QV3GzyBceQeNYJCR5TeeBQ+PXgKzc2alqmne+WEiyhs=","metadata":{},"hash":"Z5NffNY1kiZWZCKdtOwP3oa5SBIyznja3vRApIACf14="},"NEXT":{"nodeId":"ff8ce190-fb5b-4135-9174-532293931b1f","metadata":{},"hash":"voNVnB0ytDtPjVRfv8IvqxPgeAgnfMbUig2VsL47gjs="}},"hash":"6iZ7UDglvjCzhXIgU9ihg+MsLcFCs1G9XoTo/4NONno=","text":"Acceptable Formats\r\nThe default Image Optimization API will automatically detect the browser’s supported image formats via the request’s Accept header. If the Accept head matches more than one of the configured formats, the first match in the array is used. Therefore, the array order\r\nmatters. If there is no match (or the source image is animated), the Image Optimization API will fallback to the original image’s format. If no configuration is provided, the default below is used. next.config.js (js)module.exports = {\r\n  images: {\r\n    formats: ['image/webp'],\r\n  },\r\n}\r\nYou can enable AVIF support with the following configuration. next.config.js (js)module.exports = {\r\n  images: {\r\n    formats: ['image/avif', 'image/webp'],\r\n  },\r\n}\r\nGood to know: AVIF generally takes 20% longer to encode but it compresses 20% smaller compared to WebP. This means that\r\nthe first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster. Caching Behavior\r\nThe following describes the caching algorithm for the default loader. For all other loaders, please refer to your cloud provider’s\r\ndocumentation. Images are optimized dynamically upon request and stored in the <distDir>/cache/images directory. The optimized image file will\r\nbe served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the\r\nexpired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to\r\nthe cache with the new expiration date. The cache status of an image can be determined by reading the value of the x-nextjs-cache (x-vercel-cache when deployed on\r\nVercel) response header. The possible values are the following:\r\nMISS - the path is not in the cache (occurs at most once, on the first visit)\r\nSTALE - the path is in the cache but exceeded the revalidate time so it will be updated in the background\r\nHIT - the path is in the cache and has not exceeded the revalidate time\r\nThe expiration (or rather Max Age) is defined by either the minimumCacheTTL configuration or the upstream image Cache-Control\r\nheader, whichever is larger. Specifically, the max-age value of the Cache-Control header is used.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ff8ce190-fb5b-4135-9174-532293931b1f":{"id_":"ff8ce190-fb5b-4135-9174-532293931b1f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QV3GzyBceQeNYJCR5TeeBQ+PXgKzc2alqmne+WEiyhs=","metadata":{},"hash":"Z5NffNY1kiZWZCKdtOwP3oa5SBIyznja3vRApIACf14="},"PREVIOUS":{"nodeId":"54229d81-bd98-4d81-ba5d-3170de546051","metadata":{},"hash":"6iZ7UDglvjCzhXIgU9ihg+MsLcFCs1G9XoTo/4NONno="}},"hash":"voNVnB0ytDtPjVRfv8IvqxPgeAgnfMbUig2VsL47gjs=","text":"Specifically, the max-age value of the Cache-Control header is used. If both s-maxage and max-age are\r\nfound, then s-maxage is preferred. The max-age is also passed-through to any downstream clients including CDNs and browsers. You can configure minimumCacheTTL to increase the cache duration when the upstream image does not include Cache-Control\r\nheader or the value is very low. You can configure deviceSizes and imageSizes to reduce the total number of possible generated images. You can configure formats to disable multiple formats in favor of a single image format. Minimum Cache TTL\r\nYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it’s better to use a Static Image Import\r\nwhich will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable. next.config.js (js)module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 60,\r\n  },\r\n}\r\nThe expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-\r\nControl header, whichever is larger. If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream\r\nimage (e.g. /some-asset.jpg, not /_next/image itself).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"edec4bcf-d6d0-4623-8c26-194ad7bbc88a":{"id_":"edec4bcf-d6d0-4623-8c26-194ad7bbc88a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"teqn+rN7PFROaz2+DtVytVbJkZaQUeKfqwiHlX6ibXg=","metadata":{},"hash":"q1deHMDwL/DQc93U4oW+6ZplxQafKTazMLuE8evram0="}},"hash":"5XKTTf2NDeqhI6fOIEzOdalTu/oCCmfaYbrygAmyemU=","text":"There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to\r\nmanually change the src prop or delete <distDir>/cache/images. Disable Static Imports\r\nThe default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src\r\nproperty. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently. You can disable static image imports inside your next.config.js:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}\r\nDangerously Allow SVG\r\nThe default loader does not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy\r\n(CSP) headers. If you need to serve SVG images with the default Image Optimization API, you can set dangerouslyAllowSVG inside your\r\nnext.config.js:\r\nnext.config.js (js)module.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n    contentDispositionType: 'attachment',\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n}\r\nIn addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as\r\ncontentSecurityPolicy to prevent scripts embedded in the image from executing. Animated Images\r\nThe default loader will automatically bypass Image Optimization for animated images and serve the image as-is. Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization\r\nfor a given animated image, use the unoptimized prop. Version History\r\nVersionChanges\r\nv13.0.0next/image renamed to next/legacy/image","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6a6ed38f-c85d-467a-84fb-40cb5f4ed04e":{"id_":"6a6ed38f-c85d-467a-84fb-40cb5f4ed04e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"SVfK0fA8A4fU/LbQsvyzi9BxD6Fj2PrSyMY3gev7JKs=","metadata":{},"hash":"gaqC9W56IaETj82dHS5fubqmM0x5sIIXr+Pi95QUULM="}},"hash":"3Y8Ca8SgFvY7VJANZaPxODICZh12Z9emy0hmasoO4i4=","text":"4.2.1.4 - <Image>\r\nDocumentation path: /03-pages/02-api-reference/01-components/image\r\nDescription: Optimize Images in your Next.js Application using the built-in `next/image` Component. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"368b6b46-ff78-498b-9db0-8e00a045ea49":{"id_":"368b6b46-ff78-498b-9db0-8e00a045ea49","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zLcfRDq8YBdybIjI2JBPWug64tut9CRD+1P9qjvgFQo=","metadata":{},"hash":"T62hNLXrTDP+/up2YFGblSqh444vb4HNPBvRIiDiLNU="}},"hash":"D5L4LM74ltEYFxUhxwhdzFxwQcv/EWVxx8hOVUlSSpI=","text":"4.2.1.5 - <Link>\r\nDocumentation path: /03-pages/02-api-reference/01-components/link\r\nDescription: API reference for the <Link> component. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b8ce4191-302a-4b56-96d3-af8686e6b72b":{"id_":"b8ce4191-302a-4b56-96d3-af8686e6b72b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XfUNno+uztANx0Qd86AWhfeeFYcMx4HRKx1vdNoVkns=","metadata":{},"hash":"HzLt+LyNtGqXmy/3fqNCg84FtCddVeYJ5Fo1gPnM8rs="}},"hash":"VoupoWt4hm4KUEQp3o7+pF+o2tZquz3EpeVYD+NSiq8=","text":"4.2.1.6 - <Script>\r\nDocumentation path: /03-pages/02-api-reference/01-components/script\r\nDescription: Optimize third-party scripts in your Next.js application using the built-in `next/script` Component. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c5af0826-109c-492a-a800-0dc57c1edcc0":{"id_":"c5af0826-109c-492a-a800-0dc57c1edcc0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"x9gWXx72wONaeeyXOTs1aQhJQv7yCZE6yMKKcoqDAkw=","metadata":{},"hash":"A4F3uOLcLWJ3M8cUP/aQOmxhk0c5gbE+30kMclA3f1w="}},"hash":"Mqvq8TYs5P7cqOcpJVtjMVb6niqkFW+De/naA9FCQVI=","text":"4.2.2 - Functions\r\nDocumentation path: /03-pages/02-api-reference/02-functions/index\r\nDescription: API Reference for Functions and Hooks in Pages Router. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"de419e5e-7ddd-481d-87d9-28fadeb8d73f":{"id_":"de419e5e-7ddd-481d-87d9-28fadeb8d73f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"oVmfgUbvVGkBgJOcMU7s5WaGu7I08INPz8TILAPHF1A=","metadata":{},"hash":"VU3vNMMXIR1ylFK+5IIfPIK7zSp06y+t8kN0NBh0QkI="},"NEXT":{"nodeId":"e0e78e3c-9ade-4a99-85b1-a8315168d325","metadata":{},"hash":"UrAF2t66kYLyCzZtWk6nchkc20L4dcMQYmKeDAarneA="}},"hash":"lVjizwYOskhHFoLWz9UVQaQUGNlsAzNGEQEI+uv9Vp8=","text":"4.2.2.1 - getInitialProps\r\nDocumentation path: /03-pages/02-api-reference/02-functions/get-initial-props\r\nDescription: Fetch dynamic data on the server for your React component with getInitialProps. Good to know: getInitialProps is a legacy API. We recommend using getStaticProps or getServerSideProps instead. getInitialProps is an async function that can be added to the default exported React component for the page. It will run on both\r\nthe server-side and again on the client-side during page transitions. The result of the function will be forwarded to the React\r\ncomponent as props. pages/index.tsx (tsx)import { NextPageContext } from 'next'\r\nPage.getInitialProps = async (ctx: NextPageContext) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const json = await res.json()\r\n  return { stars: json.stargazers_count }\r\n}\r\nexport default function Page({ stars }: { stars: number }) {\r\n  return stars\r\n}\r\npages/index.js (jsx)Page.getInitialProps = async (ctx) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const json = await res.json()\r\n  return { stars: json.stargazers_count }\r\n}\r\nexport default function Page({ stars }) {\r\n  return stars\r\n}\r\nGood to know:\r\nData returned from getInitialProps is serialized when server rendering. Ensure the returned object from\r\ngetInitialProps is a plain Object, and not using Date, Map or Set. For the initial page load, getInitialProps will run on the server only. getInitialProps will then also run on the client\r\nwhen navigating to a different route with the next/link component or by using next/router. If getInitialProps is used in a custom _app.js, and the page being navigated to is using getServerSideProps, then\r\ngetInitialProps will also run on the server.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e0e78e3c-9ade-4a99-85b1-a8315168d325":{"id_":"e0e78e3c-9ade-4a99-85b1-a8315168d325","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"oVmfgUbvVGkBgJOcMU7s5WaGu7I08INPz8TILAPHF1A=","metadata":{},"hash":"VU3vNMMXIR1ylFK+5IIfPIK7zSp06y+t8kN0NBh0QkI="},"PREVIOUS":{"nodeId":"de419e5e-7ddd-481d-87d9-28fadeb8d73f","metadata":{},"hash":"lVjizwYOskhHFoLWz9UVQaQUGNlsAzNGEQEI+uv9Vp8="}},"hash":"UrAF2t66kYLyCzZtWk6nchkc20L4dcMQYmKeDAarneA=","text":"Context Object\r\ngetInitialProps receives a single argument called context, which is an object with the following properties:\r\nNameDescription\r\npathnameCurrent route, the path of the page in /pages\r\nqueryQuery string of the URL, parsed as an object\r\nasPathString of the actual path (including the query) shown in the browser\r\nreqHTTP request object (server only)\r\nresHTTP response object (server only)\r\nerrError object if any error is encountered during the rendering\r\nCaveats\r\ngetInitialProps can only be used in pages/ top level files, and not in nested components. To have nested data fetching at the\r\ncomponent level, consider exploring the App Router.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5e75dc10-60a6-4637-8085-4b3ef6ed7b8d":{"id_":"5e75dc10-60a6-4637-8085-4b3ef6ed7b8d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EhZ8/uKFNDku7TTNuEeyymodvTSe+vzt61LgQA/0u/A=","metadata":{},"hash":"cIelaSN/BN1hS24a0cH/c7M8yf10EKmy6Qs0B2a/Dxo="}},"hash":"ia/ry3cKanyU/WRFfZbGxvaoTXbLw+bjcclh7Cz8mZI=","text":"Regardless of whether your route is static or dynamic, any data returned from getInitialProps as props will be able to be\r\nexamined on the client-side in the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don’t pass any\r\nsensitive information that shouldn’t be available on the client in props.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f7a01925-8b8f-4df7-a1e3-26262d023bf0":{"id_":"f7a01925-8b8f-4df7-a1e3-26262d023bf0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NDsfuj6YJ4T5NwmbbE+iCktdzVIhssktz2rDCSOYt0w=","metadata":{},"hash":"7hG0mM2c1tUM03A9DdrPo4sG04mXrdY/04nPdK3/sGs="},"NEXT":{"nodeId":"d19b3590-4394-4481-943f-9388c592dbf0","metadata":{},"hash":"nPLVAMYI5lD7htN2x6opvMLoL+B9MVl8yBeM+N07Ygs="}},"hash":"fvwnq75KXUCFpljmnhjazNR1xY0j/T3+U35RQ/qNhTE=","text":"4.2.2.2 - getServerSideProps\r\nDocumentation path: /03-pages/02-api-reference/02-functions/get-server-side-props\r\nDescription: API reference for `getServerSideProps`. Learn how to fetch data on each request with Next.js. When exporting a function called getServerSideProps (Server-Side Rendering) from a page, Next.js will pre-render this page on each\r\nrequest using the data returned by getServerSideProps. This is useful if you want to fetch data that changes often, and have the\r\npage update to show the most current data. pages/index.tsx (tsx)import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getServerSideProps = (async () => {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo: Repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}) satisfies GetServerSideProps<{ repo: Repo }>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}\r\npages/index.js (jsx)export async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}\r\nYou can import modules in top-level scope for use in getServerSideProps. Imports used will not be bundled for the client-side. This means you can write server-side code directly in getServerSidePropsgetServerSideProps, including fetching data from your database. Context parameter\r\nThe context parameter is an object containing the following keys:\r\nNameDescription\r\nparamsIf this page uses a dynamic route, params contains the route parameters. If the page name is [id].js, thenparams\r\n will look like { id: ...","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d19b3590-4394-4481-943f-9388c592dbf0":{"id_":"d19b3590-4394-4481-943f-9388c592dbf0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NDsfuj6YJ4T5NwmbbE+iCktdzVIhssktz2rDCSOYt0w=","metadata":{},"hash":"7hG0mM2c1tUM03A9DdrPo4sG04mXrdY/04nPdK3/sGs="},"PREVIOUS":{"nodeId":"f7a01925-8b8f-4df7-a1e3-26262d023bf0","metadata":{},"hash":"fvwnq75KXUCFpljmnhjazNR1xY0j/T3+U35RQ/qNhTE="}},"hash":"nPLVAMYI5lD7htN2x6opvMLoL+B9MVl8yBeM+N07Ygs=","text":"If the page name is [id].js, thenparams\r\n will look like { id: ... }. reqThe HTTP IncomingMessage object, with an additional cookies prop, which is an object with string keys mapping\r\nto string values of cookies. resThe HTTP response object.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dba1540d-38dd-4c40-97f2-89d15283f9bd":{"id_":"dba1540d-38dd-4c40-97f2-89d15283f9bd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4YLU5oBTkss4qlXb5tJOwpyf9y0AIG4PPeKJvAn+G3w=","metadata":{},"hash":"O7YWrph+6XVjqaVBAAiUiPdfnJtgX6GI2pNZJF27CvA="},"NEXT":{"nodeId":"76976069-4a97-4447-bd08-acf6c1b54010","metadata":{},"hash":"/SdcaMPM1NUuWJX/kE+G6xz9vKAjkr7Na+0l/cFllZI="}},"hash":"e3vOUapdIa4ntLt2cNwdkBK0hSA3dmxy6queieVzCGs=","text":"queryAn object representing the query string, including dynamic route parameters. preview(Deprecated for draftMode) preview is true if the page is in the Preview Mode and false otherwise. previewData(Deprecated for draftMode) The preview data set by setPreviewData. draftModedraftMode is true if the page is in the Draft Mode and false otherwise. resolvedUrlA normalized version of the request URL that strips the _next/data prefix for client transitions and includes\r\noriginal query values. localeContains the active locale (if enabled). localesContains all supported locales (if enabled). defaultLocaleContains the configured default locale (if enabled). NameDescription\r\ngetServerSideProps return values\r\nThe getServerSideProps function should return an object with any one of the following properties:\r\npropsprops\r\nThe props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any\r\nprops passed, could be serialized with JSON.stringify. export async function getServerSideProps(context) {\r\n  return {\r\n    props: { message: `Next.js is awesome` }, // will be passed to the page component as props\r\n  }\r\n}\r\nnotFoundnotFound\r\nThe notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if\r\nthere was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its\r\nauthor. export async function getServerSideProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n  if (!data) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}\r\nredirectredirect\r\nThe redirect object allows redirecting to internal and external resources. It should match the shape of { destination: string,\r\npermanent: boolean }. In some rare cases, you might need to assign a custom status code for older HTTP clients to properly\r\nredirect. In these cases, you can use the statusCode property instead of the permanent property, but not both.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"76976069-4a97-4447-bd08-acf6c1b54010":{"id_":"76976069-4a97-4447-bd08-acf6c1b54010","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4YLU5oBTkss4qlXb5tJOwpyf9y0AIG4PPeKJvAn+G3w=","metadata":{},"hash":"O7YWrph+6XVjqaVBAAiUiPdfnJtgX6GI2pNZJF27CvA="},"PREVIOUS":{"nodeId":"dba1540d-38dd-4c40-97f2-89d15283f9bd","metadata":{},"hash":"e3vOUapdIa4ntLt2cNwdkBK0hSA3dmxy6queieVzCGs="}},"hash":"/SdcaMPM1NUuWJX/kE+G6xz9vKAjkr7Na+0l/cFllZI=","text":"In these cases, you can use the statusCode property instead of the permanent property, but not both. export async function getServerSideProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n  if (!data) {\r\n    return {\r\n      redirect: {\r\n        destination: '/',\r\n        permanent: false,\r\n      },","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a4f2f343-8ed0-4c29-9ddb-19c2de4c4eec":{"id_":"a4f2f343-8ed0-4c29-9ddb-19c2de4c4eec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"c6gebg/ZZJ4FAnc7lv184t/yaiCcAegFr7Er4uWZfKg=","metadata":{},"hash":"fs9s7igdpn3J2BYE6blZ1dK6qAVkIYOWlF502ixXUIc="}},"hash":"35BJzvfSDiLxVAazrt9Q/Ey75/Gu/dndO+SIOx4q96A=","text":"}\r\n  }\r\n  return {\r\n    props: {}, // will be passed to the page component as props\r\n  }\r\n}\r\nVersion History\r\nVersionChanges\r\nv13.4.0App Router is now stable with simplifed data fetching\r\nv10.0.0locale, locales, defaultLocale, and notFound options added. v9.3.0getServerSideProps introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"795507a8-bc7b-4110-ad5d-d9e1c7d70b02":{"id_":"795507a8-bc7b-4110-ad5d-d9e1c7d70b02","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"duaAWvmO2gaf3YpXbQDb5mqy7bOfbaGZptRudCvEyJs=","metadata":{},"hash":"F9RDlmbps3xBinIVmz+/vrEiu+gh7F1NpaLbORuNeaA="}},"hash":"DgJ2WenWmpxbpti8Q8GuS1+Z6ZJYThppZC8lbj7ZMjo=","text":"4.2.2.3 - getStaticPaths\r\nDocumentation path: /03-pages/02-api-reference/02-functions/get-static-paths\r\nDescription: API reference for `getStaticPaths`. Learn how to fetch data and generate static pages with `getStaticPaths`. When exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the\r\npaths specified by getStaticPaths. pages/repo/[name].tsx (tsx)import type {\r\n  InferGetStaticPropsType,\r\n  GetStaticProps,\r\n  GetStaticPaths,\r\n} from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getStaticPaths = (async () => {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}) satisfies GetStaticPaths\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}\r\npages/repo/[name].js (jsx)export async function getStaticPaths() {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}\r\ngetStaticPaths return values","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a0c45be-3226-4528-bdd2-fb19c4430abd":{"id_":"2a0c45be-3226-4528-bdd2-fb19c4430abd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"C0FCq4OeGopJNNZ8iE8Wr60gF7hMM7xMvh4flH8ZF0s=","metadata":{},"hash":"CSDY1CFiiv365iCuuMFFJRqGLrgZpo29xn7A9JKYOkQ="},"NEXT":{"nodeId":"1b47bd6f-5b87-4640-998f-0d33c75d1416","metadata":{},"hash":"lbmYfJVMYxTLJS6/tQmonSdl45kUUlKlIi6oZXQHZYU="}},"hash":"aZ45bA5fWTyU0VD3Y+GTkOTdr6Hr2elq27yhSMQThSU=","text":"The getStaticPaths function should return an object with the following required properties:\r\npathspaths\r\nThe paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes\r\nnamed pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths:\r\nreturn {\r\n  paths: [\r\n    { params: { id: '1' }},\r\n    {\r\n      params: { id: '2' },\r\n      // with i18n configured the locale for the path can be returned as well\r\n      locale: \"en\",\r\n    },\r\n  ],\r\n  fallback: ... }\r\nThen, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in\r\npages/posts/[id].js. The value for each params object must match the parameters used in the page name:\r\nIf the page name is pages/posts/[postId]/[commentId], then params should contain postId and commentId. If the page name uses catch-all routes like pages/[...slug], then params should contain slug (which is an array). If this array is\r\n['hello', 'world'], then Next.js will statically generate the page at /hello/world. If the page uses an optional catch-all route, use null, [], undefined or false to render the root-most route. For example, if you\r\nsupply slug: false for pages/[[...slug]], Next.js will statically generate the page /. The params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if\r\nWoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World. Separate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being\r\ngenerated. fallback: falsefallback: false\r\nIf fallback is false, then any paths not returned by getStaticPaths will result in a 404 page. When next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned\r\nby getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1b47bd6f-5b87-4640-998f-0d33c75d1416":{"id_":"1b47bd6f-5b87-4640-998f-0d33c75d1416","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"C0FCq4OeGopJNNZ8iE8Wr60gF7hMM7xMvh4flH8ZF0s=","metadata":{},"hash":"CSDY1CFiiv365iCuuMFFJRqGLrgZpo29xn7A9JKYOkQ="},"PREVIOUS":{"nodeId":"2a0c45be-3226-4528-bdd2-fb19c4430abd","metadata":{},"hash":"aZ45bA5fWTyU0VD3Y+GTkOTdr6Hr2elq27yhSMQThSU="}},"hash":"lbmYfJVMYxTLJS6/tQmonSdl45kUUlKlIi6oZXQHZYU=","text":"If you\r\nfind that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths\r\ncan be generated. The following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a\r\nCMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps. pages/posts/[id].js (jsx)function Post({ post }) {\r\n  // Render post... }\r\n// This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  // Get the paths we want to pre-render based on posts\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n  // We'll pre-render only these paths at build time. // { fallback: false } means other routes should 404. return { paths, fallback: false }\r\n}\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"135c0b05-6dd8-4659-9a3e-3e839c997cc1":{"id_":"135c0b05-6dd8-4659-9a3e-3e839c997cc1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Z08mvqg9ZSSX0ay+ZsJq4rIAICRxiNkl00wEbwR+Yko=","metadata":{},"hash":"0jzq33GttgmGlN8Gm+b6Ub8pdZ8uRLMi5+pWi1RbSd8="},"NEXT":{"nodeId":"9ceda81c-dfeb-4dbe-be3c-908389c7e6d0","metadata":{},"hash":"wybS7LUXim5WX9szS3rWESgdI0j4zoUNIoim3LR1d1s="}},"hash":"GIjzW9d1VzFnprwx9vmMtsLUojvZqYxVALVcAFjOC8o=","text":"// If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n  // Pass post data to the page via props\r\n  return { props: { post } }\r\n}\r\nexport default Post\r\nfallback: truefallback: true\r\nExamples\r\nIf fallback is true, then the behavior of getStaticProps changes in the following ways:\r\nThe paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of\r\nthe page on the first request to such a path. Web crawlers, such as Google, won’t be served a fallback and instead the path will\r\nbehave as in fallback: 'blocking'. When a page with fallback: true is navigated to through next/link or next/router (client-side) Next.js will not serve a\r\nfallback and instead the page will behave as fallback: 'blocking'. In the background, Next.js will statically generate the requested path HTML and JSON. This includes running getStaticProps. When complete, the browser receives the JSON for the generated path. This will be used to automatically render the page with the\r\nrequired props. From the user’s perspective, the page will be swapped from the fallback page to the full page. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the\r\ngenerated page, like other pages pre-rendered at build time. Good to know: fallback: true is not supported when using output: 'export'. When is fallback: truefallback: true useful? fallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce\r\nsite). If you want to pre-render all product pages, the builds would take a very long time. Instead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page\r\nthat is not generated yet, the user will see the page with a loading indicator or skeleton component. Shortly after, getStaticProps finishes and the page will be rendered with the requested data.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9ceda81c-dfeb-4dbe-be3c-908389c7e6d0":{"id_":"9ceda81c-dfeb-4dbe-be3c-908389c7e6d0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Z08mvqg9ZSSX0ay+ZsJq4rIAICRxiNkl00wEbwR+Yko=","metadata":{},"hash":"0jzq33GttgmGlN8Gm+b6Ub8pdZ8uRLMi5+pWi1RbSd8="},"PREVIOUS":{"nodeId":"135c0b05-6dd8-4659-9a3e-3e839c997cc1","metadata":{},"hash":"GIjzW9d1VzFnprwx9vmMtsLUojvZqYxVALVcAFjOC8o="}},"hash":"wybS7LUXim5WX9szS3rWESgdI0j4zoUNIoim3LR1d1s=","text":"Shortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests\r\nthe same page will get the statically pre-rendered page. This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation. fallback: true will not update generated pages, for that take a look at Incremental Static Regeneration. fallback: 'blocking'fallback: 'blocking'\r\nIf fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR\r\n(hence why blocking), and then be cached for future requests so it only happens once per path. getStaticProps will behave as follows:\r\nThe paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will SSR on the first request and\r\nreturn the generated HTML. When complete, the browser receives the HTML for the generated path. From the user’s perspective, it will transition from “the\r\nbrowser is requesting the page” to “the full page is loaded”. There is no flash of loading/fallback state. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the\r\ngenerated page, like other pages pre-rendered at build time. fallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration\r\nin conjunction with fallback: 'blocking'. Good to know: fallback: 'blocking' is not supported when using output: 'export'. Fallback pages\r\nIn the “fallback” version of a page:\r\nThe page’s props will be empty.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"99917ccf-da4a-43cf-b6e2-90a6d1a24ea3":{"id_":"99917ccf-da4a-43cf-b6e2-90a6d1a24ea3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"J7VIdnLq08vkuWIByIklTQ8xUroy13T7mvZkvrf1wmc=","metadata":{},"hash":"iJOB8KnaLB0LV5JvTCv66Jm8PgF/qx24p3BEGzRAbuA="}},"hash":"YXyTCqsv+0XPr0ggs2WUh14iNxXQsHJm1wEDNT4KR4E=","text":"Using the router, you can detect if the fallback is being rendered, router.isFallback will be true. The following example showcases using isFallback:\r\npages/posts/[id].js (jsx)import { useRouter } from 'next/router'\r\nfunction Post({ post }) {\r\n  const router = useRouter()\r\n  // If the page is not yet generated, this will be displayed\r\n  // initially until getStaticProps() finishes running\r\n  if (router.isFallback) {\r\n    return <div>Loading...</div>\r\n  }\r\n  // Render post... }\r\n// This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  return {\r\n    // Only `/posts/1` and `/posts/2` are generated at build time\r\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\r\n    // Enable statically generating additional pages\r\n    // For example: `/posts/3`\r\n    fallback: true,\r\n  }\r\n}\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`. // If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n  // Pass post data to the page via props\r\n  return {\r\n    props: { post },\r\n    // Re-generate the post at most once per second\r\n    // if a request comes in\r\n    revalidate: 1,\r\n  }\r\n}\r\nexport default Post\r\nVersion History\r\nVersionChanges\r\nv13.4.0App Router is now stable with simplifed data fetching, including generateStaticParams()\r\nv12.2.0On-Demand Incremental Static Regeneration is stable. v12.1.0On-Demand Incremental Static Regeneration added (beta). v9.5.0Stable Incremental Static Regeneration\r\nv9.3.0getStaticPaths introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"563d8e4d-1eec-41a4-8eb2-149310c7545b":{"id_":"563d8e4d-1eec-41a4-8eb2-149310c7545b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AB/YLrAsJzFL1WWILmolRj50KW4b7Y54Pv+BPcnwILg=","metadata":{},"hash":"BkFQWr3EWUensxoz04EujJKo9OS9vGQbRCFZVcFB4jc="},"NEXT":{"nodeId":"2acaaca4-d63d-4c63-a953-75f1c3191fe1","metadata":{},"hash":"1HlvWGhHEQnkBqPmpnsmvvsPhTJ5sjXRTREnb1rBV4M="}},"hash":"wgXK5DDXucH6ekgZUbWlDpMF9oZbf1b2ujHb5aUpOVA=","text":"4.2.2.4 - getStaticProps\r\nDocumentation path: /03-pages/02-api-reference/02-functions/get-static-props\r\nDescription: API reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js. Exporting a function called getStaticProps will pre-render a page at build time using the props returned from the function:\r\npages/index.tsx (tsx)import type { InferGetStaticPropsType, GetStaticProps } from 'next'\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}\r\npages/index.js (jsx)export async function getStaticPaths() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}\r\nYou can import modules in top-level scope for use in getStaticProps. Imports used will not be bundled for the client-side. This\r\nmeans you can write server-side code directly in getStaticPropsgetStaticProps, including fetching data from your database. Context parameter\r\nThe context parameter is an object containing the following keys:\r\nNameDescription\r\nparamsContains the route parameters for pages using dynamic routes. For example, if the page name is [id].js, thenparams\r\n will look like { id: ... }. You should use this together with getStaticPaths, which we’ll explain later. preview(Deprecated for draftMode) preview is true if the page is in the Preview Mode and false otherwise. previewData(Deprecated for draftMode) The preview data set by setPreviewData. draftModedraftMode is true if the page is in the Draft Mode and false otherwise. localeContains the active locale (if enabled). localesContains all supported locales (if enabled). defaultLocaleContains the configured default locale (if enabled).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2acaaca4-d63d-4c63-a953-75f1c3191fe1":{"id_":"2acaaca4-d63d-4c63-a953-75f1c3191fe1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"AB/YLrAsJzFL1WWILmolRj50KW4b7Y54Pv+BPcnwILg=","metadata":{},"hash":"BkFQWr3EWUensxoz04EujJKo9OS9vGQbRCFZVcFB4jc="},"PREVIOUS":{"nodeId":"563d8e4d-1eec-41a4-8eb2-149310c7545b","metadata":{},"hash":"wgXK5DDXucH6ekgZUbWlDpMF9oZbf1b2ujHb5aUpOVA="}},"hash":"1HlvWGhHEQnkBqPmpnsmvvsPhTJ5sjXRTREnb1rBV4M=","text":"defaultLocaleContains the configured default locale (if enabled). getStaticProps return values\r\nThe getStaticProps function should return an object containing either props, redirect, or notFound followed by an optional\r\nrevalidate property.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f4074875-9757-47d8-9185-648653149cdc":{"id_":"f4074875-9757-47d8-9185-648653149cdc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kSTbNA3prVXwDteyDQ6IjVJXOS8VcztTnoA9zDY+kuQ=","metadata":{},"hash":"sm0XMT3DoelymsNwDT1hLqeZ7YePHXKVaOBQrwbfr9c="},"NEXT":{"nodeId":"c4506146-240f-491d-b36e-e7c74e0247e4","metadata":{},"hash":"GM8+eRSiAh1TfaoQcopPFTeRdKj9NBON3aRIzmqU0/o="}},"hash":"Pn3BsPTBivXMBXfEozV53XTp+UEBfM6EEoP0JHrIjEw=","text":"propsprops\r\nThe props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any\r\nprops passed, could be serialized with JSON.stringify. export async function getStaticProps(context) {\r\n  return {\r\n    props: { message: `Next.js is awesome` }, // will be passed to the page component as props\r\n  }\r\n}\r\nrevalidaterevalidate\r\nThe revalidate property is the amount in seconds after which a page re-generation can occur (defaults to false or no revalidation). // This function gets called at build time on server-side. // It may be called again, on a serverless function, if\r\n// revalidation is enabled and a new request comes in\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n    // Next.js will attempt to re-generate the page:\r\n    // - When a request comes in\r\n    // - At most once every 10 seconds\r\n    revalidate: 10, // In seconds\r\n  }\r\n}\r\nLearn more about Incremental Static Regeneration. The cache status of a page leveraging ISR can be determined by reading the value of the x-nextjs-cache response header. The\r\npossible values are the following:\r\nMISS - the path is not in the cache (occurs at most once, on the first visit)\r\nSTALE - the path is in the cache but exceeded the revalidate time so it will be updated in the background\r\nHIT - the path is in the cache and has not exceeded the revalidate time\r\nnotFoundnotFound\r\nThe notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if\r\nthere was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its\r\nauthor. Note, notFound follows the same revalidate behavior described here.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c4506146-240f-491d-b36e-e7c74e0247e4":{"id_":"c4506146-240f-491d-b36e-e7c74e0247e4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"kSTbNA3prVXwDteyDQ6IjVJXOS8VcztTnoA9zDY+kuQ=","metadata":{},"hash":"sm0XMT3DoelymsNwDT1hLqeZ7YePHXKVaOBQrwbfr9c="},"PREVIOUS":{"nodeId":"f4074875-9757-47d8-9185-648653149cdc","metadata":{},"hash":"Pn3BsPTBivXMBXfEozV53XTp+UEBfM6EEoP0JHrIjEw="}},"hash":"GM8+eRSiAh1TfaoQcopPFTeRdKj9NBON3aRIzmqU0/o=","text":"Note, notFound follows the same revalidate behavior described here. export async function getStaticProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n  if (!data) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}\r\nGood to know: notFound is not needed for fallback: false mode as only paths returned from getStaticPaths will be\r\npre-rendered. redirectredirect\r\nThe redirect object allows redirecting to internal or external resources. It should match the shape of { destination: string,\r\npermanent: boolean }.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e41a320e-753e-4ece-bd44-3bfa256cede0":{"id_":"e41a320e-753e-4ece-bd44-3bfa256cede0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fMQAh3l8wX1JorrIuU5Hm5zOzCYw6Pd7F7/WRulUtIk=","metadata":{},"hash":"eGNxMOIVFdWd8qE0SgQecjsgMO4ObuJEp8xJN56jMko="},"NEXT":{"nodeId":"39446776-ce59-45b0-b4ae-bd4c7e0796c0","metadata":{},"hash":"c70p8cCKftUheDFBPyV92qC0Y6JCWW6/8+xVlYVpa7c="}},"hash":"MxA7LIlQg1PUAjhILsrijiz0r3BjDCNdRFs2488NT28=","text":"In some rare cases, you might need to assign a custom status code for older HTTP clients to properly redirect. In these cases, you can\r\nuse the statusCode property instead of the permanent property, but not both. You can also set basePath: false similar to\r\nredirects in next.config.js. export async function getStaticProps(context) {\r\n  const res = await fetch(`https://... `)\r\n  const data = await res.json()\r\n  if (!data) {\r\n    return {\r\n      redirect: {\r\n        destination: '/',\r\n        permanent: false,\r\n        // statusCode: 301\r\n      },\r\n    }\r\n  }\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}\r\nIf the redirects are known at build-time, they should be added in next.config.js instead. Reading files: Use process.cwd()process.cwd()\r\nFiles can be read directly from the filesystem in getStaticProps. In order to do so you have to get the full path to a file. Since Next.js compiles your code into a separate directory you can’t use __dirname as the path it returns will be different from the\r\nPages Router. Instead you can use process.cwd() which gives you the directory where Next.js is being executed. import { promises as fs } from 'fs'\r\nimport path from 'path'\r\n// posts will be populated at build time by getStaticProps()\r\nfunction Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>\r\n          <h3>{post.filename}</h3>\r\n          <p>{post.content}</p>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n// This function gets called at build time on server-side. // It won't be called on client-side, so you can even do\r\n// direct database queries.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"39446776-ce59-45b0-b4ae-bd4c7e0796c0":{"id_":"39446776-ce59-45b0-b4ae-bd4c7e0796c0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fMQAh3l8wX1JorrIuU5Hm5zOzCYw6Pd7F7/WRulUtIk=","metadata":{},"hash":"eGNxMOIVFdWd8qE0SgQecjsgMO4ObuJEp8xJN56jMko="},"PREVIOUS":{"nodeId":"e41a320e-753e-4ece-bd44-3bfa256cede0","metadata":{},"hash":"MxA7LIlQg1PUAjhILsrijiz0r3BjDCNdRFs2488NT28="}},"hash":"c70p8cCKftUheDFBPyV92qC0Y6JCWW6/8+xVlYVpa7c=","text":"export async function getStaticProps() {\r\n  const postsDirectory = path.join(process.cwd(), 'posts')\r\n  const filenames = await fs.readdir(postsDirectory)\r\n  const posts = filenames.map(async (filename) => {\r\n    const filePath = path.join(postsDirectory, filename)\r\n    const fileContents = await fs.readFile(filePath, 'utf8')\r\n    // Generally you would parse/transform the contents\r\n    // For example you can transform markdown to HTML here\r\n    return {\r\n      filename,\r\n      content: fileContents,\r\n    }\r\n  })\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2a1a98f0-575a-44c3-b106-3aecd178a5b9":{"id_":"2a1a98f0-575a-44c3-b106-3aecd178a5b9","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BarlFy8By2yeJh5PrRTYB8A0W2RH7pskJGsgCKErRzU=","metadata":{},"hash":"mdRinha7uW11IXJ4O4f8QOK90b2fRjDClnikLgbh2ew="}},"hash":"t9ox7uDdiaWjHF94R1hueijr20gV23ly1+1hSjOA0GE=","text":"props: {\r\n      posts: await Promise.all(posts),\r\n    },\r\n  }\r\n}\r\nexport default Blog\r\nVersion History\r\nVersionChanges\r\nv13.4.0App Router is now stable with simplifed data fetching\r\nv12.2.0On-Demand Incremental Static Regeneration is stable. v12.1.0On-Demand Incremental Static Regeneration added (beta). v10.0.0locale, locales, defaultLocale, and notFound options added. v10.0.0fallback: 'blocking' return option added. v9.5.0Stable Incremental Static Regeneration\r\nv9.3.0getStaticProps introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a3e079c1-7cd8-4e3b-8028-2e19e960db5a":{"id_":"a3e079c1-7cd8-4e3b-8028-2e19e960db5a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"HEq3w6P6pzEiX8e/4sjc10f2LivIIfPV7Oopg56PN1c=","metadata":{},"hash":"1K2p4p4oESE3PIbeJM1BWGciqqw/6/ZRlAQ5OHE3rGY="}},"hash":"uMRnGWJBGjGxP5JSxPbp/2mCxa3KI4FiAT1H6BGsKJA=","text":"4.2.2.5 - NextRequest\r\nDocumentation path: /03-pages/02-api-reference/02-functions/next-request\r\nDescription: API Reference for NextRequest. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ad8d6aee-8a4f-4e47-92a1-5bb06ecaddb7":{"id_":"ad8d6aee-8a4f-4e47-92a1-5bb06ecaddb7","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"QDvHjCg2xLk5Lcm65I30fLGL/B8skd/w1JbikezyHbQ=","metadata":{},"hash":"bRNQ5fG4ILn+R/zCW5JJoTE+ndRi9FFgz54ub/VehYk="}},"hash":"UCxFVBgxBkPILBAudJrNP3+02k9kzM36Sdn46yolk9I=","text":"4.2.2.6 - NextResponse\r\nDocumentation path: /03-pages/02-api-reference/02-functions/next-response\r\nDescription: API Reference for NextResponse. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"56b468dd-17a9-4435-89ba-76cc3faa95d1":{"id_":"56b468dd-17a9-4435-89ba-76cc3faa95d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"nitLjilFkxUNr8i0dn+ghrM2QAj5aJUhexYU7OqwwAg=","metadata":{},"hash":"EEgEaq/jj5QfELDEEMnjfr5mP1YeKid/u7ZT+BQlzEg="}},"hash":"iH0GWzGGdF/Rb3Cv8wg7PeWyyZWF0ep1UhjLFDmy0Ko=","text":"4.2.2.7 - useAmp\r\nDocumentation path: /03-pages/02-api-reference/02-functions/use-amp\r\nDescription: Enable AMP in a page, and control the way Next.js adds AMP to the page with the AMP config. Examples\r\nAMP support is one of our advanced features, you can read more about AMP here. To enable AMP, add the following config to your page:\r\npages/index.js (jsx)export const config = { amp: true }\r\nThe amp config accepts the following values:\r\ntrue - The page will be AMP-only\r\n'hybrid' - The page will have two versions, one with AMP and another one with HTML\r\nTo learn more about the amp config, read the sections below. AMP First Page\r\nTake a look at the following example:\r\npages/about.js (jsx)export const config = { amp: true }\r\nfunction About(props) {\r\n  return <h3>My AMP About Page!</h3>\r\n}\r\nexport default About\r\nThe page above is an AMP-only page, which means:\r\nThe page has no Next.js or React client-side runtime\r\nThe page is automatically optimized with AMP Optimizer, an optimizer that applies the same transformations as AMP caches\r\n(improves performance by up to 42%)\r\nThe page has a user-accessible (optimized) version of the page and a search-engine indexable (unoptimized) version of the page\r\nHybrid AMP Page\r\nTake a look at the following example:\r\npages/about.js (jsx)import { useAmp } from 'next/amp'\r\nexport const config = { amp: 'hybrid' }\r\nfunction About(props) {\r\n  const isAmp = useAmp()\r\n  return (\r\n    <div>\r\n      <h3>My AMP About Page!</h3>\r\n      {isAmp ? (\r\n        <amp-img\r\n          width=\"300\"\r\n          height=\"300\"\r\n          src=\"/my-img.jpg\"\r\n          alt=\"a cool image\"\r\n          layout=\"responsive\"\r\n        />\r\n      ) : (\r\n        <img width=\"300\" height=\"300\" src=\"/my-img.jpg\" alt=\"a cool image\" />\r\n      )}\r\n    </div>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fc20541a-9997-4ec7-be7e-c9e4dcf795b1":{"id_":"fc20541a-9997-4ec7-be7e-c9e4dcf795b1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"18gIcUrxHwuzlLcgVqdUDJ1uHPU03lDfnqEaer8Oz5w=","metadata":{},"hash":"KYkXI65uxvDNE0bP0wdtR9F8u2qOLnCz0fkGs4xyurg="}},"hash":"kzocMoipW+UwIlQq4/nx7HH1TvJVUJ/xIe7MImvu+PI=","text":"export default About\r\nThe page above is a hybrid AMP page, which means:\r\nThe page is rendered as traditional HTML (default) and AMP HTML (by adding ?amp=1 to the URL)\r\nThe AMP version of the page only has valid optimizations applied with AMP Optimizer so that it is indexable by search-engines\r\nThe page uses useAmp to differentiate between modes, it’s a React Hook that returns true if the page is using AMP, and false\r\notherwise.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"71fef65f-c721-4261-93e1-b33869bf5324":{"id_":"71fef65f-c721-4261-93e1-b33869bf5324","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"1C8ZUJtg+mvWlM7t5axqru0tNopOSk1kLnJ4RAZRzxo=","metadata":{},"hash":"0aUrZ07TzN6LT7wk4sTd4FrfOKmHNHLG2BKrNN+ixU8="}},"hash":"OzWyRMK1+aPmJv38Qgp0O7wAAWZ9YM3rLFHULFAUgn4=","text":"4.2.2.8 - useReportWebVitals\r\nDocumentation path: /03-pages/02-api-reference/02-functions/use-report-web-vitals\r\nDescription: useReportWebVitals\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8b90be1b-32a9-4fa6-82d0-634edf53a80f":{"id_":"8b90be1b-32a9-4fa6-82d0-634edf53a80f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"q/0J/latW0DqQCysQkhy5AdqwVbLLId9ojK+3THdY/g=","metadata":{},"hash":"jTkiiYHRF1e0SLEVEq7GHpxJGr7Y4SPX8aTE7gUI52I="},"NEXT":{"nodeId":"5ae8cfec-1192-4497-9624-fd76bde369fc","metadata":{},"hash":"eqk6zmCs93R2Ph/AaSmpHvWfUFKbq9HWwKYBaqWLg7c="}},"hash":"Q0SZrScnb1Z1iaTeikdpC2J6vh0kUnKFUxUeCpylxOw=","text":"4.2.2.9 - useRouter\r\nDocumentation path: /03-pages/02-api-reference/02-functions/use-router\r\nDescription: Learn more about the API of the Next.js Router, and access the router instance in your page with the useRouter hook. If you want to access the router object inside any function component in your app, you can use the useRouter hook, take a look at\r\nthe following example:\r\nimport { useRouter } from 'next/router'\r\nfunction ActiveLink({ children, href }) {\r\n  const router = useRouter()\r\n  const style = {\r\n    marginRight: 10,\r\n    color: router.asPath === href ? 'red' : 'black',\r\n  }\r\n  const handleClick = (e) => {\r\n    e.preventDefault()\r\n    router.push(href)\r\n  }\r\n  return (\r\n    <a href={href} onClick={handleClick} style={style}>\r\n      {children}\r\n    </a>\r\n  )\r\n}\r\nexport default ActiveLink\r\nuseRouter is a React Hook, meaning it cannot be used with classes. You can either use withRouter or wrap your class in a\r\nfunction component.routerrouter\r\n object\r\nThe following is the definition of the router object returned by both useRouter and withRouter:\r\npathname: String - The path for current route file that comes after /pages. Therefore, basePath, locale and trailing slash\r\n(trailingSlash: true) are not included. query: Object - The query string parsed to an object, including dynamic route parameters. It will be an empty object during\r\nprerendering if the page doesn’t use Server-side Rendering. Defaults to {}\r\nasPath: String - The path as shown in the browser including the search params and respecting the trailingSlash\r\nconfiguration. basePath and locale are not included. isFallback: boolean - Whether the current page is in fallback mode. basePath: String - The active basePath (if enabled). locale: String - The active locale (if enabled). locales: String[] - All supported locales (if enabled). defaultLocale: String - The current default locale (if enabled). domainLocales: Array<{domain, defaultLocale, locales}> - Any configured domain locales. isReady: boolean - Whether the router fields are updated client-side and ready for use. Should only be used inside of useEffect\r\nmethods and not for conditionally rendering on the server.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5ae8cfec-1192-4497-9624-fd76bde369fc":{"id_":"5ae8cfec-1192-4497-9624-fd76bde369fc","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"q/0J/latW0DqQCysQkhy5AdqwVbLLId9ojK+3THdY/g=","metadata":{},"hash":"jTkiiYHRF1e0SLEVEq7GHpxJGr7Y4SPX8aTE7gUI52I="},"PREVIOUS":{"nodeId":"8b90be1b-32a9-4fa6-82d0-634edf53a80f","metadata":{},"hash":"Q0SZrScnb1Z1iaTeikdpC2J6vh0kUnKFUxUeCpylxOw="}},"hash":"eqk6zmCs93R2Ph/AaSmpHvWfUFKbq9HWwKYBaqWLg7c=","text":"Should only be used inside of useEffect\r\nmethods and not for conditionally rendering on the server. See related docs for use case with automatically statically optimized\r\npagesisPreview\r\n: boolean - Whether the application is currently in preview mode. Using the asPath field may lead to a mismatch between client and server if the page is rendered using server-side rendering or\r\nautomatic static optimization. Avoid using asPath until the isReady field is true. The following methods are included inside router:\r\nrouter.push\r\nHandles client-side transitions, this method is useful for cases where next/link is not enough. router.push(url, as, options)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a38c7fa5-2fd3-48d1-b4f4-8e7feb34ad4a":{"id_":"a38c7fa5-2fd3-48d1-b4f4-8e7feb34ad4a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NSHPeCqfa8sHhXinpB9oIbzSOl1fQt9mFuuzezDFCSQ=","metadata":{},"hash":"oiTN8iwJGEiSxF5FmKiS5pHl3orMaMz4lKvFeO+I6iU="},"NEXT":{"nodeId":"cc250d47-f0d5-470b-8fcf-ec9089fb5216","metadata":{},"hash":"vMwMjoFnDL8WSnPJQhhvvcTRzKWGQOQaF8bDlmZug2M="}},"hash":"U0cj0smsZUlS/wn/rC+ygefcU/cgOulXw5yfaae+Yhk=","text":"url: UrlObject | String - The URL to navigate to (see Node.JS URL module documentation for UrlObject properties). as: UrlObject | String - Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this\r\nwas used for dynamic routes.options\r\n - Optional object with the following configuration options:\r\nscroll - Optional boolean, controls scrolling to the top of the page after navigation. Defaults to true\r\nshallow: Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false\r\nlocale - Optional string, indicates locale of the new page\r\nYou don’t need to use router.push for external URLs. window.location is better suited for those cases. Navigating to pages/about.js, which is a predefined route:\r\nimport { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/about')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}\r\nNavigating pages/post/[pid].js, which is a dynamic route:\r\nimport { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/post/abc')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}\r\nRedirecting the user to pages/login.js, useful for pages behind authentication:\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n// Here you would fetch and return the user\r\nconst useUser = () => ({ user: null, loading: false })\r\nexport default function Page() {\r\n  const { user, loading } = useUser()\r\n  const router = useRouter()\r\n  useEffect(() => {\r\n    if (!(user || loading)) {\r\n      router.push('/login')\r\n    }\r\n  }, [user, loading])\r\n  return <p>Redirecting...</p>\r\n}\r\nResetting state after navigation\r\nWhen navigating to the same page in Next.js, the page’s state will not be reset by default as React does not unmount unless the parent\r\ncomponent has changed.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"cc250d47-f0d5-470b-8fcf-ec9089fb5216":{"id_":"cc250d47-f0d5-470b-8fcf-ec9089fb5216","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"NSHPeCqfa8sHhXinpB9oIbzSOl1fQt9mFuuzezDFCSQ=","metadata":{},"hash":"oiTN8iwJGEiSxF5FmKiS5pHl3orMaMz4lKvFeO+I6iU="},"PREVIOUS":{"nodeId":"a38c7fa5-2fd3-48d1-b4f4-8e7feb34ad4a","metadata":{},"hash":"U0cj0smsZUlS/wn/rC+ygefcU/cgOulXw5yfaae+Yhk="}},"hash":"vMwMjoFnDL8WSnPJQhhvvcTRzKWGQOQaF8bDlmZug2M=","text":"pages/[slug].js (jsx)import Link from 'next/link'\r\nimport { useState } from 'react'\r\nimport { useRouter } from 'next/router'\r\nexport default function Page(props) {\r\n  const router = useRouter()\r\n  const [count, setCount] = useState(0)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6e7351ed-af82-4bba-97c0-100ee224b3f3":{"id_":"6e7351ed-af82-4bba-97c0-100ee224b3f3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/wmcEm7fhWeDaFWf2xmDc/gvKHtedRfjF//shEZeVJg=","metadata":{},"hash":"Skv5tIpsL2sJmoDgt7zgZT2+IJO1Yf/WZU1/r5XwGZ8="}},"hash":"zKwujy/3AUtOX3FIosDmal23D86fz4DUymTMCk/AMFk=","text":"return (\r\n    <div>\r\n      <h1>Page: {router.query.slug}</h1>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increase count</button>\r\n      <Link href=\"/one\">one</Link> <Link href=\"/two\">two</Link>\r\n    </div>\r\n  )\r\n}\r\nIn the above example, navigating between /one and /two will not reset the count . The useState is maintained between renders\r\nbecause the top-level React component, Page, is the same. If you do not want this behavior, you have a couple of options:\r\nManually ensure each state is updated using useEffect. In the above example, that could look like:\r\njsx useEffect(() => { setCount(0) }, [router.query.slug])\r\nUse a React key to tell React to remount the component. To do this for all pages, you can use a custom app:\r\npages/_app.js (jsx)  import { useRouter } from 'next/router'\r\n  export default function MyApp({ Component, pageProps }) {\r\n    const router = useRouter()\r\n    return <Component key={router.asPath} {...pageProps} />\r\n  }\r\nWith URL object\r\nYou can use a URL object in the same way you can use it for next/link. Works for both the url and as parameters:\r\nimport { useRouter } from 'next/router'\r\nexport default function ReadMore({ post }) {\r\n  const router = useRouter()\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => {\r\n        router.push({\r\n          pathname: '/post/[pid]',\r\n          query: { pid: post.id },\r\n        })\r\n      }}\r\n    >\r\n      Click here to read more\r\n    </button>\r\n  )\r\n}\r\nrouter.replace\r\nSimilar to the replace prop in next/link, router.replace will prevent adding a new URL entry into the history stack. router.replace(url, as, options)\r\nThe API for router.replace is exactly the same as the API for router.push. Take a look at the following example:\r\nimport { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.replace('/home')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"dea0a266-0ad5-4ab5-8a86-8eee2b156672":{"id_":"dea0a266-0ad5-4ab5-8a86-8eee2b156672","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JUIUKJotYbQiO+vg3K0ZdBMUSWG0OxNpHzn0OiOPfTM=","metadata":{},"hash":"MPI2p7kKnqFisjhynycwmnkwX82PGCn+2/OD3hNEvwA="},"NEXT":{"nodeId":"87ad0da5-3bbf-4f7e-9937-7d16fe9882ff","metadata":{},"hash":"IfxJJ7mBeremfB5/Hf0ptGhNA61puPNNPRXaZ4AK87E="}},"hash":"IJxvpp8+G/RxRyob40Uz8vjA3XicIeoBgPrzj4EiKxM=","text":"router.prefetch\r\nPrefetch pages for faster client-side transitions. This method is only useful for navigations without next/link, as next/link takes\r\ncare of prefetching pages automatically. This is a production only feature. Next.js doesn’t prefetch pages in development. router.prefetch(url, as, options)\r\nurl - The URL to prefetch, including explicit routes (e.g. /dashboard) and dynamic routes (e.g. /product/[id])\r\nas - Optional decorator for url. Before Next.js 9.5.3 this was used to prefetch dynamic routes. options - Optional object with the following allowed fields:\r\nlocale - allows providing a different locale from the active one. If false, url has to include the locale as the active locale won’t be\r\nused. Let’s say you have a login page, and after a login, you redirect the user to the dashboard. For that case, we can prefetch the dashboard\r\nto make a faster transition, like in the following example:\r\nimport { useCallback, useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\nexport default function Login() {\r\n  const router = useRouter()\r\n  const handleSubmit = useCallback((e) => {\r\n    e.preventDefault()\r\n    fetch('/api/login', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        /* Form data */\r\n      }),\r\n    }).then((res) => {\r\n      // Do a fast client-side transition to the already prefetched dashboard page\r\n      if (res.ok) router.push('/dashboard')\r\n    })\r\n  }, [])\r\n  useEffect(() => {\r\n    // Prefetch the dashboard page\r\n    router.prefetch('/dashboard')\r\n  }, [router])\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      {/* Form fields */}\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  )\r\n}\r\nrouter.beforePopState\r\nIn some cases (for example, if using a Custom Server), you may wish to listen to popstate and do something before the router acts on it. router.beforePopState(cb)\r\ncb - The function to run on incoming popstate events. The function receives the state of the event as an object with the following\r\nprops:url\r\n: String - the route for the new state.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"87ad0da5-3bbf-4f7e-9937-7d16fe9882ff":{"id_":"87ad0da5-3bbf-4f7e-9937-7d16fe9882ff","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JUIUKJotYbQiO+vg3K0ZdBMUSWG0OxNpHzn0OiOPfTM=","metadata":{},"hash":"MPI2p7kKnqFisjhynycwmnkwX82PGCn+2/OD3hNEvwA="},"PREVIOUS":{"nodeId":"dea0a266-0ad5-4ab5-8a86-8eee2b156672","metadata":{},"hash":"IJxvpp8+G/RxRyob40Uz8vjA3XicIeoBgPrzj4EiKxM="}},"hash":"IfxJJ7mBeremfB5/Hf0ptGhNA61puPNNPRXaZ4AK87E=","text":"This is usually the name of a page\r\nas: String - the url that will be shown in the browser\r\noptions: Object - Additional options sent by router.push\r\nIf cb returns false, the Next.js router will not handle popstate, and you’ll be responsible for handling it in that case. See Disabling\r\nfile-system routing. You could use beforePopState to manipulate the request, or force a SSR refresh, as in the following example:\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\nexport default function Page() {","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7c49eb77-5487-4bba-9c90-6e43bd60f05c":{"id_":"7c49eb77-5487-4bba-9c90-6e43bd60f05c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"etjSL82UIoLwOMqkwtlDiDjvFalzLl41bT9NL3di9Uc=","metadata":{},"hash":"K+RULrbG7M4AodlDpaf71UjG8wcmD11JRK9FZ6WHHQc="}},"hash":"sIKTOa7LLV+oeVth9vI6fPEOoxxgFoTbjMO1YG15KTc=","text":"const router = useRouter()\r\n  useEffect(() => {\r\n    router.beforePopState(({ url, as, options }) => {\r\n      // I only want to allow these two routes! if (as !== '/' && as !== '/other') {\r\n        // Have SSR render bad routes as a 404. window.location.href = as\r\n        return false\r\n      }\r\n      return true\r\n    })\r\n  }, [router])\r\n  return <p>Welcome to the page</p>\r\n}\r\nrouter.back\r\nNavigate back in history. Equivalent to clicking the browser’s back button. It executes window.history.back(). import { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.back()}>\r\n      Click here to go back\r\n    </button>\r\n  )\r\n}\r\nrouter.reload\r\nReload the current URL. Equivalent to clicking the browser’s refresh button. It executes window.location.reload(). import { useRouter } from 'next/router'\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return (\r\n    <button type=\"button\" onClick={() => router.reload()}>\r\n      Click here to reload\r\n    </button>\r\n  )\r\n}\r\nrouter.events\r\nYou can listen to different events happening inside the Next.js Router. Here’s a list of supported events:\r\nrouteChangeStart(url, { shallow }) - Fires when a route starts to change\r\nrouteChangeComplete(url, { shallow }) - Fires when a route changed completely\r\nrouteChangeError(err, url, { shallow }) - Fires when there’s an error when changing routes, or a route load is cancelled\r\nerr.cancelled - Indicates if the navigation was cancelled\r\nbeforeHistoryChange(url, { shallow }) - Fires before changing the browser’s history\r\nhashChangeStart(url, { shallow }) - Fires when the hash will change but not the page\r\nhashChangeComplete(url, { shallow }) - Fires when the hash has changed but not the page\r\nGood to know: Here url is the URL shown in the browser, including the basePath. For example, to listen to the router event routeChangeStart, open or create pages/_app.js and subscribe to the event, like so:\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  const router = useRouter()","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4839882b-c01f-49e6-80e9-0f5d13d980ec":{"id_":"4839882b-c01f-49e6-80e9-0f5d13d980ec","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rsVsMyfZlo6ilVuVH4Gi4Sm/jHtSDVv+dopEjToRmWc=","metadata":{},"hash":"c8TQVhB7mEBk+kf6N49QEO4Up7fh8Rlj78cU0yixRus="},"NEXT":{"nodeId":"7fcf1dda-e09e-4dc3-b8b7-876081f0f88c","metadata":{},"hash":"62t8AHgaePzDcvGUZwwUYeNtLMRFS3auvK/bO3j/Ud4="}},"hash":"rkkgB/hwfuM6dCJ8/3neVoNVkGfI84zaV28eGXsz4WU=","text":"useEffect(() => {\r\n    const handleRouteChange = (url, { shallow }) => {\r\n      console.log(\r\n        `App is changing to ${url} ${\r\n          shallow ? 'with' : 'without'\r\n        } shallow routing`\r\n      )\r\n    }\r\n    router.events.on('routeChangeStart', handleRouteChange)\r\n    // If the component is unmounted, unsubscribe\r\n    // from the event with the `off` method:\r\n    return () => {\r\n      router.events.off('routeChangeStart', handleRouteChange)\r\n    }\r\n  }, [router])\r\n  return <Component {...pageProps} />\r\n}\r\nWe use a Custom App (pages/_app.js) for this example to subscribe to the event because it’s not unmounted on page\r\nnavigations, but you can subscribe to router events on any component in your application. Router events should be registered when a component mounts (useEffect or componentDidMount / componentWillUnmount) or\r\nimperatively when an event happens. If a route load is cancelled (for example, by clicking two links rapidly in succession), routeChangeError will fire. And the passed err\r\nwill contain a cancelled property set to true, as in the following example:\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\nexport default function MyApp({ Component, pageProps }) {\r\n  const router = useRouter()\r\n  useEffect(() => {\r\n    const handleRouteChangeError = (err, url) => {\r\n      if (err.cancelled) {\r\n        console.log(`Route to ${url} was cancelled! `)\r\n      }\r\n    }\r\n    router.events.on('routeChangeError', handleRouteChangeError)\r\n    // If the component is unmounted, unsubscribe\r\n    // from the event with the `off` method:\r\n    return () => {\r\n      router.events.off('routeChangeError', handleRouteChangeError)\r\n    }\r\n  }, [router])\r\n  return <Component {...pageProps} />\r\n}\r\nPotential ESLint errors\r\nCertain methods accessible on the router object return a Promise. If you have the ESLint rule, no-floating-promises enabled, consider\r\ndisabling it either globally, or for the affected line. If your application needs this rule, you should either void the promise – or use an async function, await the Promise, then void the\r\nfunction call. This is not applicable when the method is called from inside an onClickonClick handler.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7fcf1dda-e09e-4dc3-b8b7-876081f0f88c":{"id_":"7fcf1dda-e09e-4dc3-b8b7-876081f0f88c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rsVsMyfZlo6ilVuVH4Gi4Sm/jHtSDVv+dopEjToRmWc=","metadata":{},"hash":"c8TQVhB7mEBk+kf6N49QEO4Up7fh8Rlj78cU0yixRus="},"PREVIOUS":{"nodeId":"4839882b-c01f-49e6-80e9-0f5d13d980ec","metadata":{},"hash":"rkkgB/hwfuM6dCJ8/3neVoNVkGfI84zaV28eGXsz4WU="}},"hash":"62t8AHgaePzDcvGUZwwUYeNtLMRFS3auvK/bO3j/Ud4=","text":"This is not applicable when the method is called from inside an onClickonClick handler. The affected methods are:\r\nrouter.push\r\nrouter.replace\r\nrouter.prefetch\r\nPotential solutions\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d1e2120c-83a9-4a52-8e4d-14e2f8ba5d9d":{"id_":"d1e2120c-83a9-4a52-8e4d-14e2f8ba5d9d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"k1YDmlyxBNxu3FExAi8yuNN14/spB0Ku5P/cU8nHK2s=","metadata":{},"hash":"CSGKJz3p6ythMaqyfC51ay14vsaaUruqN69wDopgvGg="}},"hash":"+gnhvO/YI/9LfO1i/i2t8Fgk5dJlWLALpYZGS322/zQ=","text":"// Here you would fetch and return the user\r\nconst useUser = () => ({ user: null, loading: false })\r\nexport default function Page() {\r\n  const { user, loading } = useUser()\r\n  const router = useRouter()\r\n  useEffect(() => {\r\n    // disable the linting on the next line - This is the cleanest solution\r\n    // eslint-disable-next-line no-floating-promises\r\n    router.push('/login')\r\n    // void the Promise returned by router.push\r\n    if (!(user || loading)) {\r\n      void router.push('/login')\r\n    }\r\n    // or use an async function, await the Promise, then void the function call\r\n    async function handleRouteChange() {\r\n      if (!(user || loading)) {\r\n        await router.push('/login')\r\n      }\r\n    }\r\n    void handleRouteChange()\r\n  }, [user, loading])\r\n  return <p>Redirecting...</p>\r\n}\r\nwithRouter\r\nIf useRouter is not the best fit for you, withRouter can also add the same router object to any component. Usage\r\nimport { withRouter } from 'next/router'\r\nfunction Page({ router }) {\r\n  return <p>{router.pathname}</p>\r\n}\r\nexport default withRouter(Page)\r\nTypeScript\r\nTo use class components with withRouter, the component needs to accept a router prop:\r\nimport React from 'react'\r\nimport { withRouter, NextRouter } from 'next/router'\r\ninterface WithRouterProps {\r\n  router: NextRouter\r\n}\r\ninterface MyComponentProps extends WithRouterProps {}\r\nclass MyComponent extends React.Component<MyComponentProps> {\r\n  render() {\r\n    return <p>{this.props.router.pathname}</p>\r\n  }\r\n}\r\nexport default withRouter(MyComponent)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b81e112b-6858-42b4-9083-1c2844eb455e":{"id_":"b81e112b-6858-42b4-9083-1c2844eb455e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"cmY7tLnKpBxn57+FGGG0mSScHvQEl94uItZ00LVZahE=","metadata":{},"hash":"5jjBM4qtp9TDN05uFzEZo/PlgG9vEDcR3vdx3yxAlTc="}},"hash":"HhhJa9pRW1mcDIeyJtTwR2PyP7wR2s0PvZ4rY13UIHw=","text":"4.2.2.10 - userAgent\r\nDocumentation path: /03-pages/02-api-reference/02-functions/userAgent\r\nDescription: The userAgent helper extends the Web Request API with additional properties and methods to interact with the user\r\nagent object from the request. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5cfc4d14-9aac-4dad-af0e-6fa7a42fc688":{"id_":"5cfc4d14-9aac-4dad-af0e-6fa7a42fc688","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Y9OvHkfviaSKmkeel7pxQMTVXS++J0FanCz8yNtffEg=","metadata":{},"hash":"Z9CWhGEriMFBo5uEoeQENeRIyenRujYDXQfyKapZ8yQ="}},"hash":"xPC8AWfzgg5WKaC2CSXxrDwqzm0gjs/NMiYAaa4F3YI=","text":"4.2.3 - next.config.js Options\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/index\r\nDescription: Learn about the options available in next.config.js for the Pages Router. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"83d86295-863a-4d9f-839d-e335608fc477":{"id_":"83d86295-863a-4d9f-839d-e335608fc477","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"u6zJcNbVNQlaQ9lj0QdxEenpQ8b77u0iY57uY6uY4mg=","metadata":{},"hash":"QWdvrXXATGzcxpOyUH0nKIP3Sa/2XkrkBrTvtSegTxc="}},"hash":"dRrnMHER6JXooPWKu1DRgtsgcCmAhlji0XGXgq0BiSs=","text":"4.2.3.1 - assetPrefix\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/assetPrefix\r\nDescription: Learn how to use the assetPrefix config option to configure your CDN. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"aac2fa51-65fb-4194-84ee-8fe6fcff700c":{"id_":"aac2fa51-65fb-4194-84ee-8fe6fcff700c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"BU41FqK9VOiKwFPZdQT9CXEQxxigYXpwJuVlFdgftWA=","metadata":{},"hash":"Clc2CXWj1rjzmWj9rvAa7ynAWgbvyHcSD7+DwIJ/OHU="}},"hash":"5V8QHz/pZHx39aldN2Ex50+/gfFhxSk4SIZjlcdnQ6U=","text":"4.2.3.2 - basePath\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/basePath\r\nDescription: Use `basePath` to deploy a Next.js application under a sub-path of a domain. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0f93bc66-6cda-4051-be2b-0914d60572d1":{"id_":"0f93bc66-6cda-4051-be2b-0914d60572d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fWkwa8NLHEUrQR/+hycbeMuwKE/lxPqHPymbHccO7Rg=","metadata":{},"hash":"Lvot4/ZnnL2evjBquU2IX5o2KzLbhuHmwlIDmXhJiVg="}},"hash":"mMrwUAEsfkznmvfMLuf48L00NbNSRAO0OUPQdyUTqoY=","text":"4.2.3.3 - compress\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/compress\r\nDescription: Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"48675fe0-a735-4f26-a0b5-b1dd4f54ce87":{"id_":"48675fe0-a735-4f26-a0b5-b1dd4f54ce87","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"X/I5jswIrvzqOCSS/pfnNtXb5hfeQHwz7YE+ravPHks=","metadata":{},"hash":"KyAiIZMRhXc877iOnRcnrmHDEUKlyRhGGlzk5eUFcMo="}},"hash":"sPHZs52QOOh9Kr1i+Um4H1IfRT3XSkfMf2Dx2vHx0C0=","text":"4.2.3.4 - devIndicators\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/devIndicators\r\nDescription: Optimized pages include an indicator to let you know if it's being statically optimized. You can opt-out of it here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"35c3ce53-803d-4fba-b4ee-ba20a9403402":{"id_":"35c3ce53-803d-4fba-b4ee-ba20a9403402","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"tPv9gow038hBShR2PNPbd96moyzeTogebd4YCmDzQMI=","metadata":{},"hash":"ZVP1jbfJr1K/uDTzuwmon53qssYfoRARM0po6NcQCRY="}},"hash":"TK3oN94PAdw36J0J/nfRBvq9WxBtyAhZFhy8cYxSnyo=","text":"4.2.3.5 - distDir\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/distDir\r\nDescription: Set a custom build directory to use instead of the default .next directory. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"45ed2956-2df1-4029-8291-af3ca1f648ce":{"id_":"45ed2956-2df1-4029-8291-af3ca1f648ce","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PDQhNJioyx/AI1qk9/0PxsVvHWTJSIZsgssNp85n6xY=","metadata":{},"hash":"kHPdWjdhLagCVi71W/r51ARdwALGYC0QU7rhZ+kdkb0="}},"hash":"fHXKR3Y7RW8J8+EeV4c2CFTDBWqB5IRLYuGlW/DV8zI=","text":"4.2.3.6 - env\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/env\r\nDescription: Learn to add and access environment variables in your Next.js application at build time. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"37a7c5f4-3edb-48f6-b1f0-295de85320c3":{"id_":"37a7c5f4-3edb-48f6-b1f0-295de85320c3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"n9elDy4n4NOXQAfTa2mOTOXIL5LmzZoXeV/vXJ2nMTc=","metadata":{},"hash":"A/2PhJAXBy4CTBbxfoRBZGSdinZRkqEyki614Dwxy4U="}},"hash":"q5nGpJKMeOKy76C0mK4ZiPx6M07WrelT7bSWAjPuc8A=","text":"4.2.3.7 - eslint\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/eslint\r\nDescription: Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"de86c63f-6622-45b8-b817-3a193e0b25cf":{"id_":"de86c63f-6622-45b8-b817-3a193e0b25cf","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Wem3h37ddjn+lEicjK7kzzL7nWbIatpXbLxG/YrNC0s=","metadata":{},"hash":"+DNNMUtyPArHg93TYi2vSp8Ou/+3+GbpVtlhNDcIJQQ="}},"hash":"0vnXFeCbgSvXmRvWoyZg3uSbA42xc8vxhSwGiWoKUCY=","text":"4.2.3.8 - exportPathMap\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/exportPathMap\r\nDescription: Customize the pages that will be exported as HTML files when using `next export`. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"911b1870-84fe-4ec9-aa37-4ae79854b1b3":{"id_":"911b1870-84fe-4ec9-aa37-4ae79854b1b3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"vjhVgnVCepDuR/TCme5wcDsKdvcLGJI0zcXkSrlLO3E=","metadata":{},"hash":"QLO+QmkcTrwiWCHNm0KgiiH4TviAvn+CN28uI++QgPM="}},"hash":"kWouFlKAglW68Tla9u0pcuWbufQGBfxW2K7hgPqgvoM=","text":"4.2.3.9 - generateBuildId\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/generateBuildId\r\nDescription: Configure the build id, which is used to identify the current build in which your application is being served. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"aa67f5ee-8999-4820-a97f-9075ac928039":{"id_":"aa67f5ee-8999-4820-a97f-9075ac928039","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ZRotYfYqH1hsXSIyMpagn5ZuceEKy07OEi9VWMYV2ek=","metadata":{},"hash":"i8ie1t8DvYxxRav2JGlHJnWAhxeJnTiJpb8rAFl27ig="}},"hash":"d1imV7aMuuXXlzYs3XwZjxw8mbP9vVTW+wGoCMtyKK0=","text":"4.2.3.10 - generateEtags\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/generateEtags\r\nDescription: Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a93194ab-5d63-4eee-925c-0456c6d66286":{"id_":"a93194ab-5d63-4eee-925c-0456c6d66286","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7Oa9WpKK0s1gYMrzkloIZlllFedTdh0QELJHW94Zsf0=","metadata":{},"hash":"39VmPWq90A/Yi5AapkxhpCQYmvKxsanR43/ych3bKcM="}},"hash":"iXFQz9HZZHZvVTSJqJkEeee68hTnY/DGWsjSXgev4Lo=","text":"4.2.3.11 - headers\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/headers\r\nDescription: Add custom HTTP headers to your Next.js app. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"83fdee21-cf67-4e5d-a1bc-7cefbdaf4676":{"id_":"83fdee21-cf67-4e5d-a1bc-7cefbdaf4676","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"XkgUx5YpLsQA53vC5mPqMLsBoe4zul9skBQefeYqWqY=","metadata":{},"hash":"hkaStIhEDmzYwm94TpiczyFQDuRBqKyYdFb24NZYNWQ="}},"hash":"15orb5YL9YMsrVIAD1VxaaPeJzQgY0QTH7fLHztC4eo=","text":"4.2.3.12 - httpAgentOptions\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/httpAgentOptions\r\nDescription: Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"9b8e8ab6-bf3f-4f96-a085-25ed76df25dd":{"id_":"9b8e8ab6-bf3f-4f96-a085-25ed76df25dd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"sbKOiCl8zhLPrzPVKFBRDiNInE54eV7d05Xs+wlN7w8=","metadata":{},"hash":"Nn/WfhxmjwC1nIlE/QzIE/ZwGJ4LVW5QPKvdoctOViQ="}},"hash":"Y+2rKGK9oYkUIXquy1sQ6ADvsAwJHIiBuB7MgV5I7l4=","text":"4.2.3.13 - images\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/images\r\nDescription: Custom configuration for the next/image loader\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"78c97854-cf6b-4632-bde9-c76fa71d0c9f":{"id_":"78c97854-cf6b-4632-bde9-c76fa71d0c9f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"DXVVIycnvxtigFA4c6jCVSOJQuM4+ADBjb1uaXjJKLI=","metadata":{},"hash":"0uEDA7TPDkkXOvCP/URHpQdaXAGxX3vvKXpOfx7Nj7E="}},"hash":"06SD0kTH/oXRua1WFlafqxwmY4GrYw0Aewb0OiylNms=","text":"4.2.3.14 - onDemandEntries\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/onDemandEntries\r\nDescription: Configure how Next.js will dispose and keep in memory pages created in development. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7ce47d74-938b-4bcc-8f1f-e20df6c43208":{"id_":"7ce47d74-938b-4bcc-8f1f-e20df6c43208","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4yK7hpWBqctgFz+BfWOnu8+g+0MkoyEJ2+eNVz7jbAU=","metadata":{},"hash":"og8lHsuUmOXgKVLntL2fXLbfrpJumv46CeVnq/ryt1w="}},"hash":"Gb0pDbEKbt2WKJoD441B88MLakoigU5iRaVBcBTedQE=","text":"4.2.3.15 - output\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/output\r\nDescription: Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn\r\nhow it works here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"810bdfbd-d172-475d-a04d-1621e4232dbe":{"id_":"810bdfbd-d172-475d-a04d-1621e4232dbe","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"F1H/XK8uQfwRfC4nlZCmhLm8Rb3C8Nr3zTklvPILbIU=","metadata":{},"hash":"9uvqRKm5+Sdy+Xwovsa7yTOI8QLF3zJ1neAP7uZ+/6Q="}},"hash":"AC6bMeT54+516VsglAESaVBYZIhpCmJN+OrV1Xd8ApM=","text":"4.2.3.16 - pageExtensions\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/pageExtensions\r\nDescription: Extend the default page extensions used by Next.js when resolving pages in the Pages Router. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"a24af0b4-22f6-4781-8694-65279ee2d414":{"id_":"a24af0b4-22f6-4781-8694-65279ee2d414","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6M1OLsJoswO+vR/uHNJCVvegiCdMfY1JftDcDnKbVC8=","metadata":{},"hash":"oFJsIc4MqgV7yUxXBw9pOpO5HVh9AyTsSVOUnZAkn7c="}},"hash":"GwuSIiUbab4zwSeCVcCKG0PRFeihXDA6M/tsKnICr+M=","text":"4.2.3.17 - poweredByHeader\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/poweredByHeader\r\nDescription: Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0b50541c-2984-437f-81af-6ae6564b1449":{"id_":"0b50541c-2984-437f-81af-6ae6564b1449","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"6MrUJgzT4X8b6h5fm7eATKcth/NBdl/QsB3wo80ZggU=","metadata":{},"hash":"y87jOegubXCCLviMfQHbkMxGph7oL7/FGTHKIz1PSJw="}},"hash":"13cAet5AmoSsCE087KbDjPzTZhMYzI74yu8aW86yNZI=","text":"4.2.3.18 - productionBrowserSourceMaps\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/productionBrowserSourceMaps\r\nDescription: Enables browser source map generation during the production build. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8db478e6-d802-48e5-b324-5b76203358bd":{"id_":"8db478e6-d802-48e5-b324-5b76203358bd","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"x8rkCXO79PlQhlsWy8x8C0Xt3JrTTqteWtdeJjdpfFk=","metadata":{},"hash":"T8rUUryCppYuCqpKl2muY6W0/AA9rRY3zZAm+Ifru84="}},"hash":"4i4DcvI1YxgqO49/i4uOP4x/5gNi0Bh+G/DKjtvKR1s=","text":"4.2.3.19 - reactStrictMode\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/reactStrictMode\r\nDescription: The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7d8d3937-174c-4c62-8dba-e9d5c0792c0b":{"id_":"7d8d3937-174c-4c62-8dba-e9d5c0792c0b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PgOwJbvL7jOt2shQZnYeXEYKbn2AAO8D1JXQXabrKqg=","metadata":{},"hash":"wtqyHCEXqZAdgZIn3LQUXRswFyoAZ1jxKgy4mV1Lu/U="}},"hash":"tfU6U0v6+/GKzEkNRo5gwwhmm93qJzPeki3hMXSdMPY=","text":"4.2.3.20 - redirects\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/redirects\r\nDescription: Add redirects to your Next.js app. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c6aa067c-a9fe-4954-947d-722140e37421":{"id_":"c6aa067c-a9fe-4954-947d-722140e37421","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UAm/ssITaqTl/RfaAbtrKoQi3eY1jQFwBL4P4wGPg7Y=","metadata":{},"hash":"Johsngg9RzTV331cPNjzT4NCuXBKODgfqEjQyNwB+1w="}},"hash":"RPD18QYWjmbz9ysZN0XwhQ0nnZu76TT7hMXBpLD9p90=","text":"4.2.3.21 - rewrites\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/rewrites\r\nDescription: Add rewrites to your Next.js app. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1836cf3d-03c0-42b9-9783-81166cded796":{"id_":"1836cf3d-03c0-42b9-9783-81166cded796","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"fRM3UdbVqf80q7b7XwOzjmvmDc7Fn4WZCIGgWC1XbAk=","metadata":{},"hash":"OfNw9n/ikokZdtf/XFiQJ27fj/4xScjx6fU3kyn9Ct0="}},"hash":"p84RzTmOSOQ1hHPsYe1aBMPFyl1hMWOUIkiIECwuoWg=","text":"4.2.3.22 - Runtime Config\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/runtime-configuration\r\nDescription: Add client and server runtime configuration to your Next.js app. Warning:\r\nThis feature is deprecated. We recommend using environment variables instead, which also can support reading runtime\r\nvalues. You can run code on server startup using the register function. This feature does not work with Automatic Static Optimization, Output File Tracing, or React Server Components. To add runtime configuration to your app, open next.config.js and add the publicRuntimeConfig and serverRuntimeConfig\r\nconfigs:\r\nnext.config.js (js)module.exports = {\r\n  serverRuntimeConfig: {\r\n    // Will only be available on the server side\r\n    mySecret: 'secret',\r\n    secondSecret: process.env.SECOND_SECRET, // Pass through env variables\r\n  },\r\n  publicRuntimeConfig: {\r\n    // Will be available on both server and client\r\n    staticFolder: '/static',\r\n  },\r\n}\r\nPlace any server-only runtime config under serverRuntimeConfig. Anything accessible to both client and server-side code should be under publicRuntimeConfig. A page that relies on publicRuntimeConfig must use getInitialProps or getServerSideProps or your application must\r\nhave a Custom App with getInitialProps to opt-out of Automatic Static Optimization. Runtime configuration won’t be\r\navailable to any page (or component in a page) without being server-side rendered. To get access to the runtime configs in your app use next/config, like so:\r\nimport getConfig from 'next/config'\r\nimport Image from 'next/image'\r\n// Only holds serverRuntimeConfig and publicRuntimeConfig\r\nconst { serverRuntimeConfig, publicRuntimeConfig } = getConfig()\r\n// Will only be available on the server-side\r\nconsole.log(serverRuntimeConfig.mySecret)\r\n// Will be available on both server-side and client-side\r\nconsole.log(publicRuntimeConfig.staticFolder)\r\nfunction MyImage() {\r\n  return (\r\n    <div>\r\n      <Image\r\n        src={`${publicRuntimeConfig.staticFolder}/logo.png`}\r\n        alt=\"logo\"\r\n        layout=\"fill\"\r\n      />\r\n    </div>\r\n  )\r\n}\r\nexport default MyImage","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f6a2e02d-690a-4db0-a222-674ce2e1d678":{"id_":"f6a2e02d-690a-4db0-a222-674ce2e1d678","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"j9Qd9+EpUWhL21INeRhqQeVdTND61zd6tDOLK6YEAJE=","metadata":{},"hash":"ofuD/HVvfyyJCuvj2uKL0JfXxzIzf2kOEapnpWoorUg="}},"hash":"3hzH8gwD4zOnV0C2SrXFyzAq0NM2nUTWp4sBcUIXHtc=","text":"4.2.3.23 - trailingSlash\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/trailingSlash\r\nDescription: Configure Next.js pages to resolve with or without a trailing slash. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e027eb23-75b5-4271-86a6-f7ba70a1060f":{"id_":"e027eb23-75b5-4271-86a6-f7ba70a1060f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"/C+YH9ThLT0a+L/YLwPubbpd4vqGSG/1mP7MYd4VPG8=","metadata":{},"hash":"b73rGQOnsslUYjMltgLaQ8Nz2qpxbkQ0WGeyoHawFQg="}},"hash":"lpg6q9xWl7uqPsIGxxHxDMEnG+oMInuAr7pOYc5di/0=","text":"4.2.3.24 - transpilePackages\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/transpilePackages\r\nDescription: Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies\r\n(`node_modules`). {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"082b46ed-21aa-4907-b308-937861c421ea":{"id_":"082b46ed-21aa-4907-b308-937861c421ea","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"UNFyPOXyHrwUxh2C20zaHrLE4RyK944opGWkJc5gWEE=","metadata":{},"hash":"+D3H5ThZJQC93I/Q3nVnjcIRXiATQtyazWmji/wH0sQ="}},"hash":"QN/TN9opqZtunGZ5cSD6O4BJVMrkM0303inr7WbnorQ=","text":"4.2.3.25 - turbo (experimental)\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/turbo\r\nDescription: Configure Next.js with Turbopack-specific options\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e47050a8-7930-418b-a49a-518f39f7f9d1":{"id_":"e47050a8-7930-418b-a49a-518f39f7f9d1","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qdTIjTUyh6r4sPXM7w0Ojh9FbebaGPndmUAlNLB74ng=","metadata":{},"hash":"obJc70r1Zli3xudqhT7U8Rhkp6SKV9O8OfCngD2GdDU="}},"hash":"i7lgAUcJH0Y9KtM1dDewPyYwM5G1jwy7heVdkshk2oQ=","text":"4.2.3.26 - typescript\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/typescript\r\nDescription: Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"1ec2e7de-2e4b-4753-a1a6-f2a63cba5668":{"id_":"1ec2e7de-2e4b-4753-a1a6-f2a63cba5668","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"zPjfgJcH10F3MYmZconM/ehRhsEzjakpCLRr69AkE2A=","metadata":{},"hash":"NT/PUYV39vYDQ0wabfTH3AQo2+nC3RmMX7SUczF2eak="}},"hash":"Z9um73A5diGJ/5VCMdMDMfWacAvdt2fwmFqeFidck/8=","text":"4.2.3.27 - urlImports\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/urlImports\r\nDescription: Configure Next.js to allow importing modules from external URLs (experimental). {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"aabb07c4-c1da-4b44-aa7e-3c4592218449":{"id_":"aabb07c4-c1da-4b44-aa7e-3c4592218449","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"q7q14Rcw1DH7U2kXltr34uqHnaYtbvmh3ulpmJ7s4EM=","metadata":{},"hash":"mAUZ1fND8v5ohkd2/Ku1R69260gJyUOdoQ/KT7WteiQ="}},"hash":"9c2Z6QWsCtI04Dgt7yCJXk7pEN4bMYARqJOCaVYZGkY=","text":"4.2.3.28 - webVitalsAttribution\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/webVitalsAttribution\r\nDescription: Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c2cb8ec5-352e-4ad8-90ed-9544f1555e9b":{"id_":"c2cb8ec5-352e-4ad8-90ed-9544f1555e9b","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Ya8aaJWFQYdcQvJEZFeKt56ErEgOrevJyXpHvmb3oWw=","metadata":{},"hash":"M/brXMHabo7z1NGGbpgP9IHAXLq2DBncgV0NWRFywfQ="}},"hash":"zWSSnyofcXPdBQxL9Uv2iLILT+oG30UzFivXg5KGN8o=","text":"4.2.3.29 - Custom Webpack Config\r\nDocumentation path: /03-pages/02-api-reference/03-next-config-js/webpack\r\nDescription: Learn how to customize the webpack config used by Next.js\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6a9167d4-cbf3-4d88-ada1-0cc6237588ed":{"id_":"6a9167d4-cbf3-4d88-ada1-0cc6237588ed","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"z0gF/mWhz4pjnT0ya3WUKZ+meq4PelTft/70j0UztQc=","metadata":{},"hash":"B7mchrHR4tY4DU4N7dMDrZIBpbCXXfRWEexYpXDgfvk="}},"hash":"Cpft5ZGhGTAVi3i2JusZcAqt5ESTURXAdQdRS5/VHI0=","text":"4.2.4 - create-next-app\r\nDocumentation path: /03-pages/02-api-reference/04-create-next-app\r\nDescription: create-next-app\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"08074c86-f4ee-4938-ac7f-7e3f3cef3bb8":{"id_":"08074c86-f4ee-4938-ac7f-7e3f3cef3bb8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"qMxQZpT8zIgHbvEaeva3IqnD40QWYZFBRcqDuYuAO3o=","metadata":{},"hash":"ZWlZAwRrFYqvdXdI7DCBHkCdMrB5TBDeQIYT6Sy0QxE="}},"hash":"fF+JX5DPErqplxwsI5pF1DvBlgH/UcuFPVgWd7tmp9E=","text":"4.2.5 - Next.js CLI\r\nDocumentation path: /03-pages/02-api-reference/05-next-cli\r\nDescription: Next.js CLI\r\n{/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0620dace-20bc-429b-9f14-f62981d196e3":{"id_":"0620dace-20bc-429b-9f14-f62981d196e3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"IdUfqcpklxD+RDAEugmojNjVD/GY53v3x4yY+I6rlzs=","metadata":{},"hash":"4RB6r529qeU8BmjlFrtzVatLNt3jk8MyVmxHH9P79Co="}},"hash":"2NQhcvf/xXSSIujybCzvzeFdxY8TT8UjCpuxxnmrBwI=","text":"4.2.6 - Edge Runtime\r\nDocumentation path: /03-pages/02-api-reference/06-edge\r\nDescription: API Reference for the Edge Runtime. {/ DO NOT EDIT. The content of this doc is generated from the source above. To edit the content of this page, navigate to the source page in\r\nyour editor. You can use the <PagesOnly>Content</PagesOnly> component to add content that is specific to the Pages Router. Any\r\nshared content should not be wrapped in a component. /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b7cd4c65-bb7b-449a-ad72-6ad21515138d":{"id_":"b7cd4c65-bb7b-449a-ad72-6ad21515138d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"EvShmalaMEAhnAYRtQDknwQ/8cjoqFzh3K/m7UvVGuI=","metadata":{},"hash":"JvcFafk379ZBNTixMZUPRZtjBzfH9ka044Nomlf8JOg="}},"hash":"JzoCNdhDoinLTvIMZ/KOiM8suuoWQH2YeHw40ZiOT/4=","text":"5 - Architecture\r\nDocumentation path: /04-architecture/index\r\nDescription: How Next.js Works\r\nLearn about the Next.js architecture and how it works under the hood.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4cc027fc-68c1-4c7e-838e-4badcafb7c83":{"id_":"4cc027fc-68c1-4c7e-838e-4badcafb7c83","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bjS8lRQMpzwFDu6uen2fziTOnfmnp/VXmDD8LnAftTA=","metadata":{},"hash":"l28drZgQGb0CsRdTP7sEy6/BNhFAzCLDCWcVdM1+/mc="}},"hash":"U48CGA5SAY38ijxMAbojCMzGrNmycRPwzMC/i0oEtYE=","text":"5.1 - Accessibility\r\nDocumentation path: /04-architecture/accessibility\r\nDescription: The built-in accessibility features of Next.js. The Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to\r\nNext.js by default, we aim to make the Web more inclusive for everyone. Route Announcements\r\nWhen transitioning between pages rendered on the server (e.g. using the <a href> tag) screen readers and other assistive technology\r\nannounce the page title when the page loads so that users understand that the page has changed. In addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (using next/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default. The Next.js route announcer looks for the page name to announce by first inspecting document.title, then the <h1> element, and\r\nfinally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and\r\ndescriptive title. Linting\r\nNext.js provides an integrated ESLint experience out of the box, including custom rules for Next.js. By default, Next.js includeseslint-plugin-jsx-a11y\r\n to help catch accessibility issues early, including warning on:\r\naria-props\r\naria-proptypes\r\naria-unsupported-elements\r\nrole-has-required-aria-props\r\nrole-supports-aria-props\r\nFor example, this plugin helps ensure you add alt text to img tags, use correct aria-* attributes, use correct role attributes, and\r\nmore. Accessibility Resources\r\nWebAIM WCAG checklist\r\nWCAG 2.2 Guidelines\r\nThe A11y Project\r\nCheck color contrast ratios between foreground and background elements\r\nUse prefers-reduced-motion when working with animations","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"0ee25f6b-cc22-4613-820d-b6431392198f":{"id_":"0ee25f6b-cc22-4613-820d-b6431392198f","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4w4rVQb1poANjG8QIC4FNXJbySE6kLwTA3AxZfs3Jmo=","metadata":{},"hash":"6bdCSNhF4HrAdp2608NlW6pHQnBQubJ6QujSmRG5m6o="},"NEXT":{"nodeId":"5ad3bb3c-f95b-430e-8baf-b40d4d3eb02a","metadata":{},"hash":"nTN7MBmvbuZgSgZAe7hXzSg9iNFz3NP25lLLZVVc6m4="}},"hash":"qgvNUhTYKU/LH3/EoTBg+iXXuS+Uwp5mg4elA3sH+MU=","text":"5.2 - Fast Refresh\r\nDocumentation path: /04-architecture/fast-refresh\r\nDescription: Fast Refresh is a hot module reloading experience that gives you instantaneous feedback on edits made to your React\r\ncomponents. Fast Refresh is a Next.js feature that gives you instantaneous feedback on edits made to your React components. Fast Refresh is\r\nenabled by default in all Next.js applications on 9.4 or newer. With Next.js Fast Refresh enabled, most edits should be visible within a\r\nsecond, without losing component state. How It Works\r\nIf you edit a file that only exports React component(s), Fast Refresh will update the code only for that file, and re-render your\r\ncomponent. You can edit anything in that file, including styles, rendering logic, event handlers, or effects. If you edit a file with exports that aren’t React components, Fast Refresh will re-run both that file, and the other files importing it. So\r\nif both Button.js and Modal.js import theme.js, editing theme.js will update both components. Finally, if you edit a file that’s imported by files outside of the React tree, Fast Refresh will fall back to doing a full reload. You might have a file which renders a React component but also exports a value that is imported by a non-React component. For\r\nexample, maybe your component also exports a constant, and a non-React utility file imports it. In that case, consider migrating the\r\nconstant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be\r\nsolved in a similar way. Error Resilience\r\nSyntax Errors\r\nIf you make a syntax error during development, you can fix it and save the file again. The error will disappear automatically, so you\r\nwon’t need to reload the app. You will not lose component state. Runtime Errors\r\nIf you make a mistake that leads to a runtime error inside your component, you’ll be greeted with a contextual overlay. Fixing the error\r\nwill automatically dismiss the overlay, without reloading the app. Component state will be retained if the error did not occur during rendering. If the error did occur during rendering, React will remount\r\nyour application using the updated code. If you have error boundaries in your app (which is a good idea for graceful failures in production), they will retry rendering on the next\r\nedit after a rendering error.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"5ad3bb3c-f95b-430e-8baf-b40d4d3eb02a":{"id_":"5ad3bb3c-f95b-430e-8baf-b40d4d3eb02a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"4w4rVQb1poANjG8QIC4FNXJbySE6kLwTA3AxZfs3Jmo=","metadata":{},"hash":"6bdCSNhF4HrAdp2608NlW6pHQnBQubJ6QujSmRG5m6o="},"PREVIOUS":{"nodeId":"0ee25f6b-cc22-4613-820d-b6431392198f","metadata":{},"hash":"qgvNUhTYKU/LH3/EoTBg+iXXuS+Uwp5mg4elA3sH+MU="}},"hash":"nTN7MBmvbuZgSgZAe7hXzSg9iNFz3NP25lLLZVVc6m4=","text":"This means having an error boundary can prevent you from always getting reset to the root app state. However, keep in mind that error boundaries shouldn’t be too granular. They are used by React in production, and should always be\r\ndesigned intentionally. Limitations\r\nFast Refresh tries to preserve local React state in the component you’re editing, but only if it’s safe to do so. Here’s a few reasons why\r\nyou might see local state being reset on every edit to a file:\r\nLocal state is not preserved for class components (only function components and Hooks preserve state). The file you’re editing might have other exports in addition to a React component. Sometimes, a file would export the result of calling a higher-order component like HOC(WrappedComponent). If the returned\r\ncomponent is a class, its state will be reset. Anonymous arrow functions like export default () => <div />; cause Fast Refresh to not preserve local component state. For large codebases you can use our name-default-component codemod. As more of your codebase moves to function components and Hooks, you can expect state to be preserved in more cases. Tips\r\nFast Refresh preserves React local state in function components (and Hooks) by default. Sometimes you might want to force the state to be reset, and a component to be remounted. For example, this can be handy if\r\nyou’re tweaking an animation that only happens on mount. To do this, you can add // @refresh reset anywhere in the file\r\nyou’re editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit. You can put console.log or debugger; into the components you edit during development. Remember that imports are case sensitive. Both fast and full refresh can fail, when your import doesn’t match the actual filename.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"01c30c2f-ad1a-4781-9d4b-e1e6031eee54":{"id_":"01c30c2f-ad1a-4781-9d4b-e1e6031eee54","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"jrITFoZ+sNfiiLROqTb5xHOt8YL+9gxFJlQn8/iq6zA=","metadata":{},"hash":"O5I3rthGjaGnrUQmIocGSR0gsW8VMGbm2p+eI9j5FGA="}},"hash":"MNf8HdlQ2Xa5MbE6+wGjV30TW+wgjhxZMMwyrZaEkLE=","text":"For example, './header' vs './Header'. Fast Refresh and Hooks\r\nWhen possible, Fast Refresh attempts to preserve the state of your component between edits. In particular, useState and useRef\r\npreserve their previous values as long as you don’t change their arguments or the order of the Hook calls. Hooks with dependencies—such as useEffect, useMemo, and useCallback—will always update during Fast Refresh. Their list of\r\ndependencies will be ignored while Fast Refresh is happening. For example, when you edit useMemo(() => x * 2, [x]) to useMemo(() => x * 10, [x]), it will re-run even though x (the\r\ndependency) has not changed. If React didn’t do that, your edit wouldn’t reflect on the screen! Sometimes, this can lead to unexpected results. For example, even a useEffect with an empty array of dependencies would still re-\r\nrun once during Fast Refresh. However, writing code resilient to occasional re-running of useEffect is a good practice even without Fast Refresh. It will make it\r\neasier for you to introduce new dependencies to it later on and it’s enforced by React Strict Mode, which we highly recommend\r\nenabling.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"6b47b475-5ff6-4d27-8320-c93fe9570414":{"id_":"6b47b475-5ff6-4d27-8320-c93fe9570414","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ExrT0hyX8xoK4/+Ki/u90/otVnI9ot8SEm/UA34jLVE=","metadata":{},"hash":"bt//IFmiY93PH44jUafdjnJvuAVg9BYmtm9HmIeZF9c="},"NEXT":{"nodeId":"d900a8c4-94c7-458b-8d9f-b465f42d584c","metadata":{},"hash":"Xk69qVbN+vPUw0m87fQEpSL1k1jCeMBiCg7c2d9qtLg="}},"hash":"WCQC3L0K86HDp2Rf3fWaHTWU/sw2aOqz+c5isFPm3k8=","text":"5.3 - Next.js Compiler\r\nDocumentation path: /04-architecture/nextjs-compiler\r\nDescription: Next.js Compiler, written in Rust, which transforms and minifies your Next.js application. The Next.js Compiler, written in Rust using SWC, allows Next.js to transform and minify your JavaScript code for production. This\r\nreplaces Babel for individual files and Terser for minifying output bundles. Compilation using the Next.js Compiler is 17x faster than Babel and enabled by default since Next.js version 12. If you have an existing\r\nBabel configuration or are using unsupported features, your application will opt-out of the Next.js Compiler and continue using Babel. Why SWC? SWC is an extensible Rust-based platform for the next generation of fast developer tools. SWC can be used for compilation, minification, bundling, and more – and is designed to be extended. It’s something you can call to\r\nperform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like\r\nNext.js. We chose to build on SWC for a few reasons:\r\nExtensibility: SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints. Performance: We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more\r\nroom for optimization still in progress. WebAssembly: Rust’s support for WASM is essential for supporting all possible platforms and taking Next.js development\r\neverywhere. Community: The Rust community and ecosystem are amazing and still growing. Supported Features\r\nStyled Components\r\nWe’re working to port babel-plugin-styled-components to the Next.js Compiler. First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    styledComponents: true,\r\n    },\r\n  },\r\n}\r\nFor advanced use cases, you can configure individual properties for styled-components compilation. Note: minify, transpileTemplateLiterals and pure are not yet implemented. You can follow the progress here. ssr and\r\ndisplayName transforms are the main requirement for using styled-components in Next.js.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"d900a8c4-94c7-458b-8d9f-b465f42d584c":{"id_":"d900a8c4-94c7-458b-8d9f-b465f42d584c","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ExrT0hyX8xoK4/+Ki/u90/otVnI9ot8SEm/UA34jLVE=","metadata":{},"hash":"bt//IFmiY93PH44jUafdjnJvuAVg9BYmtm9HmIeZF9c="},"PREVIOUS":{"nodeId":"6b47b475-5ff6-4d27-8320-c93fe9570414","metadata":{},"hash":"WCQC3L0K86HDp2Rf3fWaHTWU/sw2aOqz+c5isFPm3k8="}},"hash":"Xk69qVbN+vPUw0m87fQEpSL1k1jCeMBiCg7c2d9qtLg=","text":"ssr and\r\ndisplayName transforms are the main requirement for using styled-components in Next.js. next.config.js (js)module.exports = {\r\n  compiler: {\r\n    // see https://styled-components.com/docs/tooling#babel-plugin for more info on the options. styledComponents: {\r\n      // Enabled by default in development, disabled in production to reduce file size,\r\n      // setting this will override the default for all environments. displayName?: boolean,\r\n      // Enabled by default. ssr?: boolean,\r\n      // Enabled by default. fileName?: boolean,\r\n      // Empty by default. topLevelImportPaths?: string[],\r\n      // Defaults to [\"index\"]. meaninglessFileNames?: string[],\r\n      // Enabled by default. cssProp?: boolean,\r\n      // Empty by default. namespace?: string,\r\n      // Not supported yet.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"37c5442e-c935-4a3d-9cdf-2f3abbc12356":{"id_":"37c5442e-c935-4a3d-9cdf-2f3abbc12356","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"ypBQIYVz1quW8OCh2QB4VYyLTUfYfBaex5PkmpXvLXI=","metadata":{},"hash":"1giGgeBBh/4mx/GcNWJi/1KpX2l6Hp33LUGcWxqNqZg="}},"hash":"d7UDnAbDoNiLUMpFwH2Izwf/pB+baWX0h4CIjWWG5oo=","text":"minify?: boolean,\r\n      // Not supported yet. transpileTemplateLiterals?: boolean,\r\n      // Not supported yet. pure?: boolean,\r\n    },\r\n  },\r\n}\r\nJest\r\nThe Next.js Compiler transpiles your tests and simplifies configuring Jest together with Next.js including:\r\nAuto mocking of .css, .module.css (and their .scss variants), and image imports\r\nAutomatically sets up transform using SWC\r\nLoading .env (and all variants) into process.env\r\nIgnores node_modules from test resolving and transforms\r\nIgnoring .next from test resolving\r\nLoads next.config.js for flags that enable experimental SWC transforms\r\nFirst, update to the latest version of Next.js: npm install next@latest. Then, update your jest.config.js file:\r\njest.config.js (js)const nextJest = require('next/jest')\r\n// Providing the path to your Next.js app which will enable loading next.config.js and .env files\r\nconst createJestConfig = nextJest({ dir: './' })\r\n// Any custom config you want to pass to Jest\r\nconst customJestConfig = {\r\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\r\n}\r\n// createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is async\r\nmodule.exports = createJestConfig(customJestConfig)\r\nRelay\r\nTo enable Relay support:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    relay: {\r\n      // This should match relay.config.js\r\n      src: './',\r\n      artifactDirectory: './__generated__',\r\n      language: 'typescript',\r\n      eagerEsModules: false,\r\n    },\r\n  },\r\n}\r\nGood to know: In Next.js, all JavaScript files in pages directory are considered routes. So, for relay-compiler you’ll need to\r\nspecify artifactDirectory configuration settings outside of the pages, otherwise relay-compiler will generate files next\r\nto the source file in the __generated__ directory, and this file will be considered a route, which will break production builds. Remove React Properties\r\nAllows to remove JSX properties. This is often used for testing. Similar to babel-plugin-react-remove-properties. To remove properties matching the default regex ^data-test:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    reactRemoveProperties: true,\r\n  },\r\n}\r\nTo remove custom properties:\r\nnext.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"7b183711-52b0-454d-9443-db88ac885798":{"id_":"7b183711-52b0-454d-9443-db88ac885798","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"JgRhNyU9WgKKgOhFqWd8fS/0S7qX57ofm9SDL0Hg8RM=","metadata":{},"hash":"ZG6fkHZThkpB8nW6ML77+RWnEGa5Ne2jXdsyxsDdCLw="}},"hash":"f6KkQRZchIHFihuPNhJ2Psb52AReXdS7ADTdoim5vUk=","text":"module.exports = {\r\n  compiler: {\r\n    // The regexes defined here are processed in Rust so the syntax is different from\r\n    // JavaScript `RegExp`s. See https://docs.rs/regex. reactRemoveProperties: { properties: ['^data-custom$'] },\r\n  },\r\n}\r\nRemove Console\r\nThis transform allows for removing all console.* calls in application code (not node_modules). Similar to babel-plugin-\r\ntransform-remove-console. Remove all console.* calls:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    removeConsole: true,\r\n  },\r\n}\r\nRemove console.* output except console.error:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    removeConsole: {\r\n      exclude: ['error'],\r\n    },\r\n  },\r\n}\r\nLegacy Decorators\r\nNext.js will automatically detect experimentalDecorators in jsconfig.json or tsconfig.json. Legacy decorators are commonly\r\nused with older versions of libraries like mobx. This flag is only supported for compatibility with existing applications. We do not recommend using legacy decorators in new\r\napplications. First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file:\r\n{\r\n  \"compilerOptions\": {\r\n    \"experimentalDecorators\": true\r\n  }\r\n}\r\nimportSource\r\nNext.js will automatically detect jsxImportSource in jsconfig.json or tsconfig.json and apply that. This is commonly used with\r\nlibraries like Theme UI. First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file:\r\n{\r\n  \"compilerOptions\": {\r\n    \"jsxImportSource\": \"theme-ui\"\r\n  }\r\n}\r\nEmotion\r\nWe’re working to port @emotion/babel-plugin to the Next.js Compiler. First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file:\r\nnext.config.js (js)module.exports = {\r\n  compiler: {\r\n    emotion: boolean | {\r\n      // default is true. It will be disabled when build type is production. sourceMap?: boolean,","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"fd71a05e-639f-48c4-b2c7-68e5910fcc04":{"id_":"fd71a05e-639f-48c4-b2c7-68e5910fcc04","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2Hi54NiLfHnLb21Ud7wFFtbUoMB4AQ3Eh0XH2+yh1G0=","metadata":{},"hash":"K5MKZ7qUhzBmGuzhrGu0dIJGZVbu9PaXo7mq60X0vQs="},"NEXT":{"nodeId":"97d0a62b-2b9a-4700-aa70-a0360798c160","metadata":{},"hash":"4QOh+LNB5mz0zkmBm8y5jaD6cv9lvrqv6OrdhOgQlqc="}},"hash":"gmtmorWcB5jWly5cKvveHuhbGPofeNlQ9xeDqbj5yIA=","text":"// default is 'dev-only'. autoLabel?: 'never' | 'dev-only' | 'always',\r\n      // default is '[local]'. // Allowed values: `[local]` `[filename]` and `[dirname]`\r\n      // This option only works when autoLabel is set to 'dev-only' or 'always'. // It allows you to define the format of the resulting label. // The format is defined via string where variable parts are enclosed in square brackets []. // For example labelFormat: \"my-classname--[local]\", where [local] will be replaced with the name of the variable the result is assigned to. labelFormat?: string,\r\n      // default is undefined. // This option allows you to tell the compiler what imports it should\r\n      // look at to determine what it should transform so if you re-export\r\n      // Emotion's exports, you can still use transforms. importMap?: {\r\n        [packageName: string]: {\r\n          [exportName: string]: {\r\n            canonicalImport?: [string, string],\r\n            styledBaseImport?: [string, string],\r\n          }\r\n        }\r\n      },\r\n    },\r\n  },\r\n}\r\nMinification\r\nNext.js’ swc compiler is used for minification by default since v13. This is 7x faster than Terser. If Terser is still needed for any reason this can be configured. next.config.js (js)module.exports = {\r\n  swcMinify: false,\r\n}\r\nModule Transpilation\r\nNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies\r\n(node_modules). This replaces the next-transpile-modules package. next.config.js (js)module.exports = {\r\n  transpilePackages: ['@acme/ui', 'lodash-es'],\r\n}\r\nModularize Imports\r\nThis option has been superseded by optimizePackageImports in Next.js 13.5. We recommend upgrading to use the new option that\r\ndoes not require manual configuration of import paths. Experimental Features\r\nSWC Trace profiling\r\nYou can generate SWC’s internal transform traces as chromium’s trace event format. next.config.js (js)module.exports = {\r\n  experimental: {\r\n    swcTraceProfiling: true,\r\n  },\r\n}\r\nOnce enabled, swc will generate trace named as swc-trace-profile-${timestamp}.json under .next/.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"97d0a62b-2b9a-4700-aa70-a0360798c160":{"id_":"97d0a62b-2b9a-4700-aa70-a0360798c160","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"2Hi54NiLfHnLb21Ud7wFFtbUoMB4AQ3Eh0XH2+yh1G0=","metadata":{},"hash":"K5MKZ7qUhzBmGuzhrGu0dIJGZVbu9PaXo7mq60X0vQs="},"PREVIOUS":{"nodeId":"fd71a05e-639f-48c4-b2c7-68e5910fcc04","metadata":{},"hash":"gmtmorWcB5jWly5cKvveHuhbGPofeNlQ9xeDqbj5yIA="}},"hash":"4QOh+LNB5mz0zkmBm8y5jaD6cv9lvrqv6OrdhOgQlqc=","text":"Chromium’s trace viewer\r\n(chrome://tracing/, https://ui.perfetto.dev/), or compatible flamegraph viewer (https://www.speedscope.app/) can load & visualize\r\ngenerated traces. SWC Plugins (Experimental)\r\nYou can configure swc’s transform to use SWC’s experimental plugin support written in wasm to customize transformation behavior. next.config.js (js)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"801812af-f6e4-4893-bbf5-25028f4653bb":{"id_":"801812af-f6e4-4893-bbf5-25028f4653bb","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"wDc033H7kgGIM8FUQhbanSb24p+9MegjuI45glkcc38=","metadata":{},"hash":"FCCdvWMFP0ZTvuww/Y+DNbm0kDtWDSOP4PlAiaAoMVs="}},"hash":"rSbywED/WXv0xz4tASGcObqm5/wAJWKPEgpiJ1oHCUw=","text":"module.exports = {\r\n  experimental: {\r\n    swcPlugins: [\r\n      [\r\n        'plugin',\r\n        {\r\n          ...pluginOptions,\r\n        },\r\n      ],\r\n    ],\r\n  },\r\n}\r\nswcPlugins accepts an array of tuples for configuring plugins. A tuple for the plugin contains the path to the plugin and an object for\r\nplugin configuration. The path to the plugin can be an npm module package name or an absolute path to the .wasm binary itself. Unsupported Features\r\nWhen your application has a .babelrc file, Next.js will automatically fall back to using Babel for transforming individual files. This\r\nensures backwards compatibility with existing applications that leverage custom Babel plugins. If you’re using a custom Babel setup, please share your configuration. We’re working to port as many commonly used Babel\r\ntransformations as possible, as well as supporting plugins in the future. Version History\r\nVersionChanges\r\nv13.1.0Module Transpilation and Modularize Imports stable. v13.0.0SWC Minifier enabled by default. v12.3.0SWC Minifier stable. v12.2.0SWC Plugins experimental support added. v12.1.0Added support for Styled Components, Jest, Relay, Remove React Properties, Legacy Decorators, Remove Console, and\r\njsxImportSource. v12.0.0Next.js Compiler introduced.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"c2b7d048-6bf5-4340-83f6-a92d85b8276d":{"id_":"c2b7d048-6bf5-4340-83f6-a92d85b8276d","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"l0e00ic8aEvuJnPROMHE20/stEecbRa5P+72E4z/PcQ=","metadata":{},"hash":"GaORfNK/IsqFd75BARak4r/7gq6fknIfwbKg8oXe/2c="}},"hash":"puL9G14ngOpN58uR2D/xEIu0N00H1XPTOQgT3D/6ay0=","text":"5.4 - Supported Browsers\r\nDocumentation path: /04-architecture/supported-browsers\r\nDescription: Browser support and which JavaScript features are supported by Next.js. Next.js supports modern browsers with zero configuration. Chrome 64+\r\nEdge 79+\r\nFirefox 67+\r\nOpera 51+\r\nSafari 12+\r\nBrowserslist\r\nIf you would like to target specific browsers or features, Next.js supports Browserslist configuration in your package.json file. Next.js\r\nuses the following Browserslist configuration by default:\r\npackage.json (json){\r\n  \"browserslist\": [\r\n    \"chrome 64\",\r\n    \"edge 79\",\r\n    \"firefox 67\",\r\n    \"opera 51\",\r\n    \"safari 12\"\r\n  ]\r\n}\r\nPolyfills\r\nWe inject widely used polyfills, including:\r\nfetch() — Replacing: whatwg-fetch and unfetch. URL — Replacing: the url package (Node.js API). Object.assign() — Replacing: object-assign, object.assign, and core-js/object/assign. If any of your dependencies include these polyfills, they’ll be eliminated automatically from the production build to avoid duplication. In addition, to reduce bundle size, Next.js will only load these polyfills for browsers that require them. The majority of the web traffic\r\nglobally will not download these polyfills. Custom Polyfills\r\nIf your own code or any external npm dependencies require features not supported by your target browsers (such as IE 11), you need to\r\nadd polyfills yourself. In this case, you should add a top-level import for the specific polyfill you need in your Custom <App> or the individual component. JavaScript Language Features\r\nNext.js allows you to use the latest JavaScript features out of the box. In addition to ES6 features, Next.js also supports:\r\nAsync/await (ES2017)\r\nObject Rest/Spread Properties (ES2018)\r\nDynamic import() (ES2020)\r\nOptional Chaining (ES2020)\r\nNullish Coalescing (ES2020)\r\nClass Fields and Static Properties (part of stage 3 proposal)\r\nand more! TypeScript Features\r\nNext.js has built-in TypeScript support. Learn more here. Customizing Babel Config (Advanced)","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f2767c37-6ddf-49bc-adf4-76a5f05e5322":{"id_":"f2767c37-6ddf-49bc-adf4-76a5f05e5322","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Be7JrRdpCkzd2Lh2QalU1kJ8t+otwkte+2JrkKFLKNw=","metadata":{},"hash":"0N3Xh7B6Hp+l907BuqMILylkqZMSaRKGDzb9G3a8l6Y="}},"hash":"Qdu7cP9ERHySZ4zdDfZxqx39rvoN0dLnWWd20+ylpko=","text":"You can customize babel configuration. Learn more here.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"54d94da9-b4c2-4d01-9345-95a070e8e2de":{"id_":"54d94da9-b4c2-4d01-9345-95a070e8e2de","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"WzLZWf+ptTIMIYf2dqH2KzpKVuPWhTESGUi5Lnpp6d8=","metadata":{},"hash":"qDX+NplnacC+Aa3mwmm41X5jx7VzARsF2pXhOfZqgys="}},"hash":"k7wdIkjFubetRuN8VhxvfRLNK1tkvhxy76wDXS8L7Dg=","text":"5.5 - Turbopack\r\nDocumentation path: /04-architecture/turbopack\r\nDescription: Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack (beta) is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Usage\r\nTurbopack can be used in Next.js in both the pages and app directories for faster local development. To enable Turbopack, use the --\r\nturbo flag when running the Next.js development server. json filename=\"package.json\" highlight={3} { \"scripts\": { \"dev\": \"next dev --turbo\", \"build\": \"next\r\nbuild\", \"start\": \"next start\", \"lint\": \"next lint\" } }\r\nSupported Features\r\nTo learn more about the currently supported features for Turbopack, view the documentation. Unsupported Features\r\nTurbopack currently only supports next dev and does not support next build. We are currently working on support for builds as we\r\nmove closer towards stability.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"ea7920c5-c3fd-4d84-a5cf-87feff4fea17":{"id_":"ea7920c5-c3fd-4d84-a5cf-87feff4fea17","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"7Nd3ri5NTzatJ0K8xwnz9jXWepLUggpk7sJri0MXCsg=","metadata":{},"hash":"Vo9vV0w9in1C2OXNkMcG4StNTsZGO5xLXiAp7GYMxuY="}},"hash":"43i9oDK8c14kmQo0s9S0YCrxxvHH9f1+/z4mM/AJz44=","text":"6 - Next.js Community\r\nDocumentation path: /05-community/index\r\nDescription: Get involved in the Next.js community. With over 4 million weekly downloads, Next.js has a large and active community of developers across the world. Here’s how you can\r\nget involved in our community:\r\nContributing\r\nThere are a couple of ways you can contribute to the development of Next.js:\r\nDocumentation: Suggest improvements or even write new sections to help our users understand how to use Next.js. Examples: Help developers integrate Next.js with other tools and services by creating a new example or improving an existing one. Codebase: Learn more about the underlying architecture, contribute to bug fixes, errors, and suggest new features. Discussions\r\nIf you have a question about Next.js, or want to help others, you’re always welcome to join the conversation:\r\nGitHub Discussions\r\nDiscord\r\nReddit\r\nSocial Media\r\nFollow Next.js on Twitter for the latest updates, and subscribe to the Vercel YouTube channel for Next.js videos. Code of Conduct\r\nWe believe in creating an inclusive, welcoming community. As such, we ask all members to adhere to our Code of Conduct. This\r\ndocument outlines our expectations for participant behavior. We invite you to read it and help us maintain a safe and respectful\r\nenvironment.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"e7aab7a2-0e76-4e96-8d1c-add5377f7404":{"id_":"e7aab7a2-0e76-4e96-8d1c-add5377f7404","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"giAivUbhsUk2+aXh4gmEnBTf3ZyJ4vmX3f9uYNAOx34=","metadata":{},"hash":"WkVIRRNn/Vqc0Oc/19sp6/612Pt9VN7Qc2cmLd302ns="},"NEXT":{"nodeId":"404e790b-1fb9-4064-a8c9-269037de11b8","metadata":{},"hash":"rGUqCHShj+gl7jYNRsIrNEQE+UGB5wltHlxXz3llngw="}},"hash":"Vlwg1IvmOhtSNQJvi7cerQbeTmU+rYcGvnz0s7u1nUI=","text":"6.1 - Docs Contribution Guide\r\nDocumentation path: /05-community/01-contribution-guide\r\nDescription: Learn how to contribute to Next.js Documentation\r\nWelcome to the Next.js Docs Contribution Guide! We’re excited to have you here. This page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the community feels\r\nempowered to contribute and improve our docs. Why Contribute? Open-source work is never done, and neither is documentation. Contributing to docs is a good way for beginners to get involved in\r\nopen-source and for experienced developers to clarify more complex topics while sharing their knowledge with the community. By contributing to the Next.js docs, you’re helping us build a more robust learning resource for all developers. Whether you’ve found a\r\ntypo, a confusing section, or you’ve realized that a particular topic is missing, your contributions are welcomed and appreciated. How to Contribute\r\nThe docs content can be found on the Next.js repo. To contribute, you can edit the files directly on GitHub or clone the repo and edit\r\nthe files locally. GitHub Workflow\r\nIf you’re new to GitHub, we recommend reading the GitHub Open Source Guide to learn how to fork a repository, create a branch, and\r\nsubmit a pull request. Good to know: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that\r\nyou can’t preview the docs locally. However, you’ll see your changes on nextjs.org after merging a pull request. Writing MDX\r\nThe docs are written in MDX, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See\r\nthe GitHub Markdown Guide for a quick overview of markdown syntax. VSCode\r\nPreviewing Changes Locally\r\nVSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you’ll need\r\nto add a configuration option to your user settings. Open the command palette (⌘ + ⇧ + P on Mac or Ctrl + Shift + P on Windows) and search from Preferences: Open User\r\nSettings (JSON).","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"404e790b-1fb9-4064-a8c9-269037de11b8":{"id_":"404e790b-1fb9-4064-a8c9-269037de11b8","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"giAivUbhsUk2+aXh4gmEnBTf3ZyJ4vmX3f9uYNAOx34=","metadata":{},"hash":"WkVIRRNn/Vqc0Oc/19sp6/612Pt9VN7Qc2cmLd302ns="},"PREVIOUS":{"nodeId":"e7aab7a2-0e76-4e96-8d1c-add5377f7404","metadata":{},"hash":"Vlwg1IvmOhtSNQJvi7cerQbeTmU+rYcGvnz0s7u1nUI="}},"hash":"rGUqCHShj+gl7jYNRsIrNEQE+UGB5wltHlxXz3llngw=","text":"Then, add the following line to your settings.json file:\r\nsettings.json (json){\r\n  \"files.associations\": {\r\n    \"*.mdx\": \"markdown\"\r\n  }\r\n}\r\nNext, open the command palette again, and search for Markdown: Preview File or Markdown: Open Preview to the Side. This\r\nwill open a preview window where you can see your formatted changes. Extensions\r\nWe also recommend the following extensions for VSCode users:\r\nMDX: Intellisense and syntax highlighting for MDX. Grammarly: Grammar and spell checker. Prettier: Format MDX files on save. Review Process\r\nOnce you’ve submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"b5e55530-10bf-49af-a167-1a2f738345a0":{"id_":"b5e55530-10bf-49af-a167-1a2f738345a0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rRsTXmsFtfb76Du7c9auVhgRpkqiCLva/8zqaktQ/sw=","metadata":{},"hash":"iAaUW/7eBtgxbvAyd1+nEiS085WHnKABDDv7H8BaoAk="},"NEXT":{"nodeId":"2284c8e2-a01b-4c43-93ee-16c4be7a38a5","metadata":{},"hash":"7ctXzCT7X6H/P+WrZvxD2hzH4eJgEEUnKK4jYiRUfAI="}},"hash":"ZuBSzXR4T7omHB1OTVX0/Tf1PG2g9J8SvDSq32l0SoU=","text":"merge the pull request when it’s ready. Please let us know if you have any questions or need further assistance in your PR’s comments. Thank you for contributing to the\r\nNext.js docs and being a part of our community! Tip: Run pnpm prettier-fix to run Prettier before submitting your PR. File Structure\r\nThe docs use file-system routing. Each folder and files inside /docs represent a route segment. These segments are used to generate\r\nthe URL paths, navigation, and breadcrumbs. The file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However,\r\nwe can change the order of the items by prepending a two-digit number (00-) to the folder or file name. For example, in the functions API Reference, the pages are sorted alphabetically because it makes it easier for developers to find a\r\nspecific function:\r\n03-functions\r\n├── cookies.mdx\r\n├── draft-mode.mdx\r\n├── fetch.mdx\r\n└── ... But, in the routing section, the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts:\r\n02-routing\r\n├── 01-defining-routes.mdx\r\n├── 02-pages-and-layouts.mdx\r\n├── 03-linking-and-navigating.mdx\r\n└── ... To quickly find a page, you can use ⌘ + P (Mac) or Ctrl + P (Windows) to open the search bar on VSCode. Then, type the slug of the\r\npage you’re looking for. E.g. defining-routes\r\nWhy not use a manifest? We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would\r\nquickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native\r\nto Next.js. Metadata\r\nEach page has a metadata block at the top of the file separated by three dashes. Required Fields\r\nThe following fields are required:\r\nFieldDescription\r\ntitleThe page’s <h1> title, used for SEO and OG Images. descriptionThe page’s description, used in the <meta name=\"description\"> tag for SEO.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"2284c8e2-a01b-4c43-93ee-16c4be7a38a5":{"id_":"2284c8e2-a01b-4c43-93ee-16c4be7a38a5","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"rRsTXmsFtfb76Du7c9auVhgRpkqiCLva/8zqaktQ/sw=","metadata":{},"hash":"iAaUW/7eBtgxbvAyd1+nEiS085WHnKABDDv7H8BaoAk="},"PREVIOUS":{"nodeId":"b5e55530-10bf-49af-a167-1a2f738345a0","metadata":{},"hash":"ZuBSzXR4T7omHB1OTVX0/Tf1PG2g9J8SvDSq32l0SoU="}},"hash":"7ctXzCT7X6H/P+WrZvxD2hzH4eJgEEUnKK4jYiRUfAI=","text":"descriptionThe page’s description, used in the <meta name=\"description\"> tag for SEO. required-fields.mdx (yaml)---\r\ntitle: Page Title\r\ndescription: Page Description\r\n---\r\nIt’s good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to\r\noptimize images in Next.js). Optional Fields\r\nThe following fields are optional:\r\nFieldDescription","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"f300e510-a55a-4cdb-8a0e-eb75045aaaf2":{"id_":"f300e510-a55a-4cdb-8a0e-eb75045aaaf2","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PhAKLRaZjn83U+DnGUVMhzZwmytJbvK/XT4nzkqT+R4=","metadata":{},"hash":"as0sTRvI7ogTB9I6nbMJebS40/l3LMtjHQ1NwPg3kV4="},"NEXT":{"nodeId":"53a93638-d7c1-4e05-8873-2aaefdd9c46a","metadata":{},"hash":"sxcDvL5EzyJKbVIcHov8Gc5yfYJPMr2wUkfnUR0S6Do="}},"hash":"UNfSdJKO3ZepC2Zvp+VsH6uymp5w0lL3yDqsoALB/08=","text":"nav_titleOverrides the page’s title in the navigation. This is useful when the page’s title is too long to fit. If not provided, thetitle field is used. sourcePulls content into a shared page. See Shared Pages. relatedA list of related pages at the bottom of the document. These will automatically be turned into cards. See Related Links. FieldDescription\r\noptional-fields.mdx (yaml)---\r\nnav_title: Nav Item Title\r\nsource: app/building-your-application/optimizing/images\r\nrelated:\r\n  description: See the image component API reference. links:\r\n    - app/api-reference/components/image\r\n---\r\nAppApp and PagesPages Docs\r\nSince most of the features in the App Router and Pages Router are completely different, their docs for each are kept in separate\r\nsections (02-app and 03-pages). However, there are a few features that are shared between them. Shared Pages\r\nTo avoid content duplication and risk the content becoming out of sync, we use the source field to pull content from one page into\r\nanother. For example, the <Link> component behaves mostly the same in App and Pages. Instead of duplicating the content, we can\r\npull the content from app/.../link.mdx into pages/.../link.mdx:\r\napp/.../link.mdx (mdx)---\r\ntitle: <Link>\r\ndescription: API reference for the <Link> component. ---\r\nThis API reference will help you understand how to use the props\r\nand configuration options available for the Link Component. pages/.../link.mdx (mdx)---\r\ntitle: <Link>\r\ndescription: API reference for the <Link> component. source: app/api-reference/components/link\r\n---\r\n{/* DO NOT EDIT THIS PAGE. */}\r\n{/* The content of this page is pulled from the source above. */}\r\nWe can therefore edit the content in one place and have it reflected in both sections. Shared Content\r\nIn shared pages, sometimes there might be content that is App Router or Pages Router specific. For example, the <Link> component\r\nhas a shallow prop that is only available in Pages but not in App. To make sure the content only shows in the correct router, we can wrap content blocks in an <AppOnly> or <PagesOnly>\r\ncomponents:\r\napp/.../link.mdx (mdx)This content is shared between App and Pages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"53a93638-d7c1-4e05-8873-2aaefdd9c46a":{"id_":"53a93638-d7c1-4e05-8873-2aaefdd9c46a","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"PhAKLRaZjn83U+DnGUVMhzZwmytJbvK/XT4nzkqT+R4=","metadata":{},"hash":"as0sTRvI7ogTB9I6nbMJebS40/l3LMtjHQ1NwPg3kV4="},"PREVIOUS":{"nodeId":"f300e510-a55a-4cdb-8a0e-eb75045aaaf2","metadata":{},"hash":"UNfSdJKO3ZepC2Zvp+VsH6uymp5w0lL3yDqsoALB/08="}},"hash":"sxcDvL5EzyJKbVIcHov8Gc5yfYJPMr2wUkfnUR0S6Do=","text":"<PagesOnly>\r\nThis content will only be shown on the Pages docs. </PagesOnly>\r\nThis content is shared between App and Pages.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4a99dadd-0296-46d1-821a-8b2350138e5e":{"id_":"4a99dadd-0296-46d1-821a-8b2350138e5e","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Hy+qfyeYhH1pRu0JQhLKoFRcc009fXIHo2wDC514s24=","metadata":{},"hash":"qCZa89cxq0+O1jNTxlfW5FMIcZz+Gz2qzxyhI1VRYuU="},"NEXT":{"nodeId":"4d587df9-f250-4bfd-ada1-27c3017bdef0","metadata":{},"hash":"BaWFyH+/5Gn1WVvvKlYi/sEniavzPQEz8NfqGYZm/qo="}},"hash":"ttySqvpHGvhQjYiAktjt/h78nb2zITHoTpoPIdbW4mg=","text":"You’ll likely use these components for examples and code blocks. Code Blocks\r\nCode blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to\r\nrun without any additional configuration. For example, if you’re showing how to use the <Link> component, you should include the import statement and the <Link>\r\ncomponent itself. app/page.tsx (tsx)import Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}\r\nAlways run examples locally before committing them. This will ensure that the code is up-to-date and working. Language and Filename\r\nCode blocks should have a header that includes the language and the filename. Add a filename prop to render a special Terminal\r\nicon that helps orientate users where to input the command. For example:\r\n`\r\ncode-example.mdx (mdx)```bash filename=\"Terminal\"\r\nnpx create-next-app\r\nMost examples in the docs are written in `tsx` and `jsx`, and a few in `bash`. However, you can use any supported\r\nWhen writing JavaScript code blocks, we use the following language and extension combinations. |                                | Language | Extension |\r\n| ------------------------------ | -------- | --------- |\r\n| JavaScript files with JSX code | ```jsx   | .js       |\r\n| JavaScript files without JSX   | ```js    | .js       |\r\n| TypeScript files with JSX      | ```tsx   | .tsx      |\r\n| TypeScript files without JSX   | ```ts    | .ts       |\r\n### TS and JS Switcher\r\nAdd a language switcher to toggle between TypeScript and JavaScript. Code blocks should be TypeScript first\r\nCurrently, we write TS and JS examples one after the other, and link them with `switcher` prop:\r\n`<div class=\"code-header\"><i>code-example.mdx (mdx)</i></div>\r\n```mdx\r\n```tsx filename=\"app/page.tsx\" switcher\r\n```\r\n<div class=\"code-header\"><i>app/page.js (jsx)</i></div>\r\n```jsx\r\n```\r\nGood to know: We plan to automatically compile TypeScript snippets to JavaScript in the future. In the meantime, you can use\r\ntransform.tools. Line Highlighting\r\nCode lines can be highlighted. This is useful when you want to draw attention to a specific part of the code. You can highlight lines by\r\npassing a number to the highlight prop.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"4d587df9-f250-4bfd-ada1-27c3017bdef0":{"id_":"4d587df9-f250-4bfd-ada1-27c3017bdef0","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"Hy+qfyeYhH1pRu0JQhLKoFRcc009fXIHo2wDC514s24=","metadata":{},"hash":"qCZa89cxq0+O1jNTxlfW5FMIcZz+Gz2qzxyhI1VRYuU="},"PREVIOUS":{"nodeId":"4a99dadd-0296-46d1-821a-8b2350138e5e","metadata":{},"hash":"ttySqvpHGvhQjYiAktjt/h78nb2zITHoTpoPIdbW4mg="}},"hash":"BaWFyH+/5Gn1WVvvKlYi/sEniavzPQEz8NfqGYZm/qo=","text":"You can highlight lines by\r\npassing a number to the highlight prop. Single Line: highlight={1}\r\n```tsx filename=”app/page.tsx” {1} import Link from ‘next/link’\r\nexport default function Page() { return About }\r\n**Multiple Lines:** `highlight={1,3}`","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"01a948d1-15bb-48cf-a4dd-d210e4a11f57":{"id_":"01a948d1-15bb-48cf-a4dd-d210e4a11f57","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"yoiJ6ZFnrUXkb6eVjh2HxoH73P4I7VLd0z+K8Bv8kqw=","metadata":{},"hash":"d/kTDTHwiqUK0hkmsNnS6CAoLmfc/N1hpIiazOe+2OU="}},"hash":"8Xm9PCZqBZkltGEbHajzDTfshxiT5c/nJhhoCI6yMZ8=","text":"```tsx filename=\"app/page.tsx\" highlight={1,3}\r\nimport Link from 'next/link'\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}\r\nRange of Lines: highlight={1-5}\r\n```tsx filename=”app/page.tsx” highlight={1-5} import Link from ‘next/link’\r\nexport default function Page() { return About }\r\n## Icons\r\nThe following icons are available for use in the docs:\r\n<div class=\"code-header\"><i>mdx-icon.mdx (mdx)</i></div>\r\n```mdx\r\n<Check size={18} />\r\n<Cross size={18} />\r\nOutput:\r\nWe do not use emojis in the docs. Notes\r\nFor information that is important but not critical, use notes. Notes are a good way to add information without distracting the user from\r\nthe main content. notes.mdx (mdx)> **Good to know**: This is a single line note. > **Good to know**:\r\n>\r\n> - We also use this format for multi-line notes. > - There are sometimes multiple items worth knowing or keeping in mind. Output:\r\nGood to know: This is a single line note. Good to know:\r\nWe also use this format for multi-line notes. There are sometimes multiple item worths knowing or keeping in mind. Related Links\r\nRelated Links guide the user’s learning journey by adding links to logical next steps. Links will be displayed in cards under the main content of the page. Links will be automatically generated for pages that have child pages. For example, the Optimizing section has links to all of its\r\nchild pages. Create related links using the related field in the page’s metadata. example.mdx (yaml)---\r\nrelated:\r\n  description: Learn how to quickly get started with your first application. links:\r\n    - app/building-your-application/routing/defining-routes\r\n    - app/building-your-application/data-fetching\r\n    - app/api-reference/file-conventions/page\r\n---\r\nNested Fields\r\nFieldRequired?Description\r\ntitleOptionalThe title of the card list. Defaults to Next Steps.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"3c4c52e0-f4d4-4111-929a-21eb3be43da3":{"id_":"3c4c52e0-f4d4-4111-929a-21eb3be43da3","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3+CfXgVDTyjeWu2uLgMsf+czuECbIIpRNfqOyAFFX3E=","metadata":{},"hash":"MWxO1AXCKa4FqYQRuCO6wbAWHtmcEaaMs4bufgr3sRM="},"NEXT":{"nodeId":"8a5453a5-fd8a-4352-98a6-42ab1b8b54f4","metadata":{},"hash":"KW1wa34d03F4fQgyAjGzYfCTeCQ0bGnLkiAJVPqxp9A="}},"hash":"VGzxK9idoiQD2wCS4vZBNsLiL/r3If8Xr3Qa0GE3JU0=","text":"descriptionOptionalThe description of the card list. linksRequiredA list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g.app/api-reference/file-conventions/page\r\nFieldRequired?Description\r\nDiagrams\r\nDiagrams are a great way to explain complex concepts. We use Figma to create diagrams, following Vercel’s design guide. The diagrams currently live in a /public folder in our private Next.js site. If you’d like to update or add a diagram, please open a\r\nGitHub issue with your ideas. Custom Components and HTML\r\nThese are the React Components available for the docs: <Image /> (next/image), <PagesOnly />, <AppOnly />, <Cross />, and\r\n<Check />. We do not allow raw HTML in the docs besides the <details> tag. If you have ideas for new components, please open a GitHub issue. Style Guide\r\nThis section contains guidelines for writing docs for those who are new to technical writing. Page Templates\r\nWhile we don’t have a strict template for pages, there are page sections you’ll see repeated across the docs:\r\nOverview: The first paragraph of a page should tell the user what the feature is and what it’s used for. Followed by a minimum\r\nworking example or its API reference. Convention: If the feature has a convention, it should be explained here. Examples: Show how the feature can be used with different use cases. API Tables: API Pages should have an overview table at the of the page with jump-to-section links (when possible). Next Steps (Related Links): Add links to related pages to guide the user’s learning journey. Feel free to add these sections as needed. Page Types\r\nDocs pages are also split into two categories: Conceptual and Reference. Conceptual pages are used to explain a concept or feature. They are usually longer and contain more information than reference\r\npages. In the Next.js docs, conceptual pages are found in the Building Your Application section. Reference pages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages\r\nare found in the API Reference section. Good to know: Depending on the page you’re contributing to, you may need to follow a different voice and style. For example,\r\nconceptual pages are more instructional and use the word you to address the user.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"8a5453a5-fd8a-4352-98a6-42ab1b8b54f4":{"id_":"8a5453a5-fd8a-4352-98a6-42ab1b8b54f4","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"3+CfXgVDTyjeWu2uLgMsf+czuECbIIpRNfqOyAFFX3E=","metadata":{},"hash":"MWxO1AXCKa4FqYQRuCO6wbAWHtmcEaaMs4bufgr3sRM="},"PREVIOUS":{"nodeId":"3c4c52e0-f4d4-4111-929a-21eb3be43da3","metadata":{},"hash":"VGzxK9idoiQD2wCS4vZBNsLiL/r3If8Xr3Qa0GE3JU0="}},"hash":"KW1wa34d03F4fQgyAjGzYfCTeCQ0bGnLkiAJVPqxp9A=","text":"For example,\r\nconceptual pages are more instructional and use the word you to address the user. Reference pages are more technical, they\r\nuse more imperative words like “create, update, accept” and tend to omit the word you. Voice\r\nHere are some guidelines to maintain a consistent style and voice across the docs:\r\nWrite clear, concise sentences. Avoid tangents. If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list. Swap out complex words for simpler ones. For example, use instead of utilize. Be mindful with the word this. It can be ambiguous and confusing, don’t be afraid to repeat the subject of the sentence if unclear. For example, Next.js uses React instead of Next.js uses this. Use an active voice instead of passive. An active sentence is easier to read. For example, Next.js uses React instead of React is used by Next.js. If you find yourself using words like was and by you may be using a\r\npassive voice. Avoid using words like easy, quick, simple, just, etc. This is subjective and can be discouraging to users. Avoid negative words like don’t, can’t, won’t, etc. This can be discouraging to readers.","textTemplate":"","metadataSeparator":"\n","type":"TEXT"},"96cbc19a-80fe-45a4-abd2-7a59b8b9fc29":{"id_":"96cbc19a-80fe-45a4-abd2-7a59b8b9fc29","metadata":{},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"bluPX8LrjaAWKpwUqlgUNi+KEEJEd+uBGfwG6jhQPHM=","metadata":{},"hash":"6FsflmOFDk2nEglGvc0zKEPTYxWp6UBxTWRknNnrOM0="}},"hash":"LxjVX8mKvaDjrpP53NIIQm1jzCW5QMU9EWFPe9hGMw4=","text":"For example, “You can use the Link component to create links between pages” instead of “Don’t use the <a> tag to create links between\r\npages”. Write in second person (you/your). This is more personal and engaging. Use gender-neutral language. Use developers, users, or readers, when referring to the audience. If adding code examples, ensure they are properly formatted and working. While these guidelines are not exhaustive, they should help you get started. If you’d like to dive deeper into technical writing, check out\r\nthe Google Technical Writing Course. Thank you for contributing to the docs and being part of the Next.js community! {/ To do: Latest Contributors Component /}","textTemplate":"","metadataSeparator":"\n","type":"TEXT"}},"type":"simple_dict"}}}